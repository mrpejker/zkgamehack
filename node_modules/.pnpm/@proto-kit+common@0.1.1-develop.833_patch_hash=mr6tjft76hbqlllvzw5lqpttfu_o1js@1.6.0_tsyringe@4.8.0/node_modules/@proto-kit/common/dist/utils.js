import { Field, Poseidon, } from "o1js";
export function requireTrue(condition, errorOrFunction) {
    if (!condition) {
        throw typeof errorOrFunction === "function"
            ? errorOrFunction()
            : errorOrFunction;
    }
}
export function range(startOrEnd, endOrNothing) {
    let end = endOrNothing;
    let start = startOrEnd;
    if (end === undefined) {
        end = startOrEnd;
        start = 0;
    }
    return Array.from({ length: end - start }, (ignored, index) => index + start);
}
export function reduceSequential(array, callbackfn, initialValue) {
    return array.reduce(async (previousPromise, current, index, arr) => {
        const previous = await previousPromise;
        return await callbackfn(previous, current, index, arr);
    }, Promise.resolve(initialValue));
}
export function mapSequential(array, f) {
    return array.reduce(async (r, element, index, a) => {
        const ret = await r;
        const next = await f(element, index, a);
        ret.push(next);
        return ret;
    }, Promise.resolve([]));
}
/**
 * Computes a dummy value for the given value type.
 *
 * @param valueType - Value type to generate the dummy value for
 * @returns Dummy value for the given value type
 */
export function dummyValue(valueType) {
    const length = valueType.sizeInFields();
    const fields = Array.from({ length }, () => Field(0));
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return valueType.fromFields(fields);
}
export function noop() { }
export async function sleep(ms) {
    await new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
export function filterNonNull(value) {
    return value !== null;
}
export function filterNonUndefined(value) {
    return value !== undefined;
}
const encoder = new TextEncoder();
// Copied from o1js binable.ts:317
export function prefixToField(prefix) {
    const fieldSize = Field.sizeInBytes;
    if (prefix.length >= fieldSize)
        throw Error("prefix too long");
    const stringBytes = [...encoder.encode(prefix)];
    return Field.fromBytes(stringBytes.concat(Array(fieldSize - stringBytes.length).fill(0)));
}
export function hashWithPrefix(prefix, input) {
    const salt = Poseidon.update([Field(0), Field(0), Field(0)], [prefixToField(prefix)]);
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return Poseidon.update(salt, input)[0];
}
// end copy
export function expectDefined(value) {
    expect(value).toBeDefined();
}
