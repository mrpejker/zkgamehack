import "reflect-metadata";
import { DependencyContainer, InjectionToken } from "tsyringe";
import { MergeObjects, StringKeyOf, TypedClass } from "../types";
import { DependencyFactory, InferDependencies } from "../dependencyFactory/DependencyFactory";
import { EventEmitterProxy } from "../events/EventEmitterProxy";
import { Configurable, ConfigurableModule, NoConfig } from "./ConfigurableModule";
import { ChildContainerProvider } from "./ChildContainerProvider";
import { ChildContainerCreatable } from "./ChildContainerCreatable";
export declare const ModuleContainerErrors: {
    configNotSetInContainer: (moduleName: string) => Error;
    onlyValidModuleNames: (moduleName: NonNullable<unknown>) => Error;
    unableToDecorateModule: (moduleName: InjectionToken<unknown>) => Error;
    nonModuleDependency: (runtimeModuleName: string) => Error;
    unknownDependency: (runtimeModuleName: string, name: string) => Error;
    dependencyContainerNotSet: (className: string) => Error;
    validModuleInstance: (moduleName: string, moduleTypeName: string) => Error;
};
export interface BaseModuleInstanceType extends ChildContainerCreatable, Configurable<unknown> {
}
export type BaseModuleType = TypedClass<BaseModuleInstanceType>;
export interface ModulesRecord<ModuleType extends BaseModuleType = BaseModuleType> {
    [name: string]: ModuleType;
}
export type ModulesConfig<Modules extends ModulesRecord> = {
    [ConfigKey in StringKeyOf<Modules>]: InstanceType<Modules[ConfigKey]> extends Configurable<infer Config> ? Config extends NoConfig ? Config | undefined : Config : never;
};
/**
 * This type make any config partial (i.e. optional) up to the first level
 * So { Module: { a: { b: string } } }
 * will become
 * { Module?: { a?: { b: string } } }
 * Note that b does not become optional, as we don't want nested objects to
 * become unreasonably partialized (for example Field).
 */
export type RecursivePartial<T> = {
    [Key in keyof T]?: Partial<T[Key]>;
};
/**
 * Parameters required when creating a module container instance
 */
export interface ModuleContainerDefinition<Modules extends ModulesRecord> {
    modules: Modules;
    /**
     * @deprecated
     */
    config?: ModulesConfig<Modules>;
}
export type FilterNeverValues<Type extends Record<string, unknown>> = {
    [Key in keyof Type as Type[Key] extends never ? never : Key]: Type[Key];
};
export type DependenciesFromModules<Modules extends ModulesRecord> = FilterNeverValues<{
    [Key in keyof Modules]: Modules[Key] extends TypedClass<DependencyFactory> ? InferDependencies<InstanceType<Modules[Key]>> : never;
}>;
export type ResolvableModules<Modules extends ModulesRecord> = MergeObjects<DependenciesFromModules<Modules>> & Modules;
/**
 * Reusable module container facilitating registration, resolution
 * configuration, decoration and validation of modules
 */
export declare class ModuleContainer<Modules extends ModulesRecord> extends ConfigurableModule<ModulesConfig<Modules>> {
    definition: ModuleContainerDefinition<Modules>;
    /**
     * Determines how often are modules decorated upon resolution
     * from the tsyringe DI container
     */
    private static readonly moduleDecorationFrequency;
    private providedContainer?;
    private eventEmitterProxy;
    constructor(definition: ModuleContainerDefinition<Modules>);
    /**
     * @returns list of module names
     */
    get moduleNames(): string[];
    /**
     * Check if the provided module satisfies the container requirements,
     * such as only injecting other known modules.
     *
     * @param moduleName
     * @param containedModule
     */
    protected validateModule(moduleName: StringKeyOf<Modules>, containedModule: ConfigurableModule<unknown>): void;
    protected get container(): DependencyContainer;
    /**
     * Assert that the iterated `moduleName` is of ModuleName type,
     * otherwise it may be just string e.g. when modules are iterated over
     * using e.g. a for loop.
     */
    assertIsValidModuleName(moduleName: string): asserts moduleName is StringKeyOf<Modules>;
    isValidModuleName(modules: Modules, moduleName: number | string | symbol): moduleName is StringKeyOf<Modules>;
    assertContainerInitialized(container: DependencyContainer | undefined): asserts container is DependencyContainer;
    /**
     * Register modules into the current container, and registers
     * a respective resolution hook in order to decorate the module
     * upon/after resolution.
     *
     * @param modules
     */
    protected registerModules(modules: Modules): void;
    get events(): EventEmitterProxy<Modules>;
    /**
     * Register a non-module value into the current container
     * @param modules
     */
    registerValue<Value>(modules: Record<string, Value>): void;
    protected registerClasses(modules: Record<string, TypedClass<unknown>>): void;
    /**
     * Provide additional configuration after the ModuleContainer was created.
     *
     * Keep in mind that modules are only decorated once after they are resolved,
     * therefore applying any configuration must happen
     * before the first resolution.
     * @param config
     */
    configure(config: ModulesConfig<Modules>): void;
    configurePartial(config: RecursivePartial<ModulesConfig<Modules>>): void;
    get config(): ModulesConfig<Modules>;
    set config(config: ModulesConfig<Modules>);
    /**
     * Resolves a module from the current module container
     *
     * We have to narrow down the `ModuleName` type here to
     * `ResolvableModuleName`, otherwise the resolved value might
     * be any module instance, not the one specifically requested as argument.
     *
     * @param moduleName
     * @returns
     */
    resolve<KeyType extends StringKeyOf<ResolvableModules<Modules>>>(moduleName: KeyType): InstanceType<ResolvableModules<Modules>[KeyType]>;
    resolveOrFail<ModuleType>(moduleName: string, moduleType: TypedClass<ModuleType>): ModuleType;
    /**
     * Override this in the child class to provide custom
     * features or module checks
     */
    protected decorateModule(moduleName: StringKeyOf<Modules>, containedModule: InstanceType<Modules[StringKeyOf<Modules>]>): void;
    private isDependencyFactory;
    /**
     * Inject a set of dependencies using the given list of DependencyFactories
     * This method should be called during startup
     */
    protected initializeDependencyFactories(factories: StringKeyOf<Modules>[]): void;
    /**
     * Retrieves all dependencies generated by a particular dependencyfactory
     * and injects them inside this modulecontainer's DI container.
     * This will be automatically called for every module, but can also be called
     * explicitly to initialize an extra factory
     * @param factory
     * @private
     */
    protected useDependencyFactory(factory: DependencyFactory): void;
    /**
     * Handle module resolution, e.g. by decorating resolved modules
     * @param moduleName
     */
    protected onAfterModuleResolution(moduleName: StringKeyOf<Modules>): void;
    /**
     * This is a placeholder for individual modules to override.
     * This method will be called whenever the underlying container fully
     * initialized
     */
    create(childContainerProvider: ChildContainerProvider): void;
}
//# sourceMappingURL=ModuleContainer.d.ts.map