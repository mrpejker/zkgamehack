import "reflect-metadata";
import { instancePerContainerCachingFactory, isClassProvider, isFactoryProvider, isTokenProvider, isValueProvider, Lifecycle, } from "tsyringe";
import log from "loglevel";
import merge from "lodash/merge";
import { EventEmitterProxy } from "../events/EventEmitterProxy";
import { ConfigurableModule, } from "./ConfigurableModule";
const errors = {
    configNotSetInContainer: (moduleName) => new Error(`Trying to get config of ${moduleName}, but it was not yet set in the module container`),
    onlyValidModuleNames: (moduleName) => new Error(
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    `Only known module names are allowed, using unknown module name: ${moduleName}`),
    unableToDecorateModule: (moduleName) => 
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    new Error(`Unable to decorate module ${moduleName.toString()}`),
    nonModuleDependency: (runtimeModuleName) => new Error(`
  Unable to register module: ${runtimeModuleName}, attempting to inject a non-module dependency`),
    unknownDependency: (runtimeModuleName, name) => new Error(`Unable to register module: ${runtimeModuleName}, 
      attempting to inject a dependency that is not registered 
      as a runtime module for this chain: ${name}`),
    dependencyContainerNotSet: (className) => new Error(`DependencyContainer not set. Be sure to only call DI-related function in create() and not inside the constructor. (${className})`),
    validModuleInstance: (moduleName, moduleTypeName) => new Error(`Incompatible module instance ("${moduleName}" not instanceof ${moduleTypeName})`),
};
export const ModuleContainerErrors = errors;
/**
 * Reusable module container facilitating registration, resolution
 * configuration, decoration and validation of modules
 */
export class ModuleContainer extends ConfigurableModule {
    constructor(definition) {
        super();
        this.definition = definition;
        // DI container holding all the registered modules
        this.providedContainer = undefined;
        this.eventEmitterProxy = undefined;
    }
    /**
     * @returns list of module names
     */
    get moduleNames() {
        return Object.keys(this.definition.modules);
    }
    /**
     * Check if the provided module satisfies the container requirements,
     * such as only injecting other known modules.
     *
     * @param moduleName
     * @param containedModule
     */
    validateModule(moduleName, containedModule) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const dependencies = Reflect.getMetadata("design:paramtypes", containedModule);
        dependencies?.forEach((dependency) => {
            const name = typeof dependency === "string" ? dependency : dependency.name;
            if (name === undefined) {
                throw errors.nonModuleDependency(moduleName);
            }
            if (!this.moduleNames.includes(name)) {
                throw errors.unknownDependency(moduleName, name);
            }
        });
    }
    get container() {
        this.assertContainerInitialized(this.providedContainer);
        return this.providedContainer;
    }
    /**
     * Assert that the iterated `moduleName` is of ModuleName type,
     * otherwise it may be just string e.g. when modules are iterated over
     * using e.g. a for loop.
     */
    assertIsValidModuleName(moduleName) {
        if (!this.isValidModuleName(this.definition.modules, moduleName)) {
            throw errors.onlyValidModuleNames(moduleName);
        }
    }
    isValidModuleName(modules, moduleName) {
        return Object.prototype.hasOwnProperty.call(modules, moduleName);
    }
    assertContainerInitialized(container) {
        if (container === undefined) {
            throw errors.dependencyContainerNotSet(this.constructor.name);
        }
    }
    /**
     * Register modules into the current container, and registers
     * a respective resolution hook in order to decorate the module
     * upon/after resolution.
     *
     * @param modules
     */
    registerModules(modules) {
        Object.keys(modules).forEach((moduleName) => {
            if (Object.prototype.hasOwnProperty.call(modules, moduleName)) {
                this.assertIsValidModuleName(moduleName);
                log.debug(`Registering module: ${moduleName}`);
                const useClass = modules[moduleName];
                this.container.register(moduleName, { useClass }, { lifecycle: Lifecycle.ContainerScoped });
                this.onAfterModuleResolution(moduleName);
            }
        });
    }
    get events() {
        if (this.eventEmitterProxy === undefined) {
            this.eventEmitterProxy = new EventEmitterProxy(this);
        }
        return this.eventEmitterProxy;
    }
    /**
     * Register a non-module value into the current container
     * @param modules
     */
    // TODO Rename to plural since object is param
    registerValue(modules) {
        Object.entries(modules).forEach(([moduleName, useValue]) => {
            this.container.register(moduleName, { useValue });
        });
    }
    registerClasses(modules) {
        Object.entries(modules).forEach(([moduleName, useClass]) => {
            this.container.register(moduleName, { useClass }, { lifecycle: Lifecycle.ContainerScoped });
        });
    }
    /**
     * Provide additional configuration after the ModuleContainer was created.
     *
     * Keep in mind that modules are only decorated once after they are resolved,
     * therefore applying any configuration must happen
     * before the first resolution.
     * @param config
     */
    configure(config) {
        this.config = config;
    }
    configurePartial(config) {
        this.config = merge(this.currentConfig ?? {}, config);
    }
    get config() {
        return super.config;
    }
    set config(config) {
        super.config = merge(this.currentConfig ?? {}, config);
    }
    /**
     * Resolves a module from the current module container
     *
     * We have to narrow down the `ModuleName` type here to
     * `ResolvableModuleName`, otherwise the resolved value might
     * be any module instance, not the one specifically requested as argument.
     *
     * @param moduleName
     * @returns
     */
    resolve(moduleName) {
        return this.container.resolve(moduleName);
    }
    resolveOrFail(moduleName, moduleType) {
        const instance = this.container.resolve(moduleName);
        const isValidModuleInstance = instance instanceof moduleType;
        if (!isValidModuleInstance) {
            throw errors.validModuleInstance(moduleName, moduleType.name);
        }
        return instance;
    }
    /**
     * Override this in the child class to provide custom
     * features or module checks
     */
    decorateModule(moduleName, containedModule) {
        const config = super.config?.[moduleName];
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (!config) {
            throw errors.configNotSetInContainer(moduleName.toString());
        }
        if (containedModule instanceof ModuleContainer) {
            containedModule.configure(config);
        }
        else {
            containedModule.config = config;
        }
    }
    isDependencyFactory(type) {
        return "dependencies" in type;
    }
    /**
     * Inject a set of dependencies using the given list of DependencyFactories
     * This method should be called during startup
     */
    initializeDependencyFactories(factories) {
        factories.forEach((factoryName) => {
            this.resolve(factoryName);
        });
    }
    /**
     * Retrieves all dependencies generated by a particular dependencyfactory
     * and injects them inside this modulecontainer's DI container.
     * This will be automatically called for every module, but can also be called
     * explicitly to initialize an extra factory
     * @param factory
     * @private
     */
    useDependencyFactory(factory) {
        const dependencies = factory.dependencies();
        Object.entries(dependencies).forEach(([rawKey, declaration]) => {
            const key = rawKey.charAt(0).toUpperCase() + rawKey.slice(1);
            if (!this.container.isRegistered(key) ||
                declaration.forceOverwrite === true) {
                // Find correct provider type and call respective register
                if (isValueProvider(declaration)) {
                    this.container.register(key, declaration);
                }
                else if (isFactoryProvider(declaration)) {
                    // this enables us to have a singletoned factory
                    // that returns the same instance for each resolve
                    this.container.register(key, {
                        useFactory: instancePerContainerCachingFactory(declaration.useFactory),
                    });
                }
                else if (isClassProvider(declaration)) {
                    this.container.register(key, declaration, {
                        lifecycle: Lifecycle.Singleton,
                    });
                    // eslint-disable-next-line sonarjs/no-duplicated-branches
                }
                else if (isTokenProvider(declaration)) {
                    this.container.register(key, declaration, {
                        lifecycle: Lifecycle.Singleton,
                    });
                }
                else {
                    // Can never be reached
                    throw new Error("Above if-statement is exhaustive");
                }
            }
            else {
                log.debug(`Dependency ${key} already registered, skipping`);
            }
        });
    }
    /**
     * Handle module resolution, e.g. by decorating resolved modules
     * @param moduleName
     */
    onAfterModuleResolution(moduleName) {
        this.container.afterResolution(moduleName, (containedModuleName, containedModule) => {
            // special case where tsyringe may return multiple known instances (?)
            if (Array.isArray(containedModule)) {
                throw errors.unableToDecorateModule(containedModuleName);
            }
            this.decorateModule(moduleName, containedModule);
            containedModule.create(() => {
                const container = this.container.createChildContainer();
                container.reset();
                return container;
            });
            if (this.isDependencyFactory(containedModule)) {
                this.useDependencyFactory(containedModule);
            }
        }, { frequency: ModuleContainer.moduleDecorationFrequency });
    }
    /**
     * This is a placeholder for individual modules to override.
     * This method will be called whenever the underlying container fully
     * initialized
     */
    create(childContainerProvider) {
        this.providedContainer = childContainerProvider();
        this.registerValue({
            ChildContainerProvider: () => this.container.createChildContainer(),
        });
        // register all provided modules when the container is created
        this.registerModules(this.definition.modules);
    }
}
/**
 * Determines how often are modules decorated upon resolution
 * from the tsyringe DI container
 */
ModuleContainer.moduleDecorationFrequency = "Once";
