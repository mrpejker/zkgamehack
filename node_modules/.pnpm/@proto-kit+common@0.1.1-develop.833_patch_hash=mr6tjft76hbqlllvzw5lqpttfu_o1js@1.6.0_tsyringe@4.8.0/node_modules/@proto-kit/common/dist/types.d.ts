import { PublicKey } from "o1js";
export type TypedClass<Class> = new (...args: any[]) => Class;
export type UnTypedClass = new (...args: any[]) => unknown;
/**
 * Using simple `keyof Target` would result into the key
 * being `string | number | symbol`, but we want just a `string`
 */
export type StringKeyOf<Target extends object> = Extract<keyof Target, string> & string;
/**
 * Utility type to infer element type from an array type
 */
export type ArrayElement<ArrayType extends readonly unknown[]> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;
/**
 * Transforms X | Y => X & Y
 */
export type UnionToIntersection<Union> = (Union extends any ? (x: Union) => void : never) extends (x: infer Intersection) => void ? Intersection : never;
export type MergeObjects<Input extends Record<string, unknown>> = UnionToIntersection<Input[keyof Input]>;
export type OmitKeys<Record, Keys> = {
    [Key in keyof Record as Key extends Keys ? never : Key]: Record[Key];
};
export declare const EMPTY_PUBLICKEY_X: import("o1js/dist/node/lib/provable/field").Field;
export declare const EMPTY_PUBLICKEY: PublicKey;
export type OverwriteObjectType<Base, New> = {
    [Key in keyof Base]: Key extends keyof New ? New[Key] : Base[Key];
} & New;
//# sourceMappingURL=types.d.ts.map