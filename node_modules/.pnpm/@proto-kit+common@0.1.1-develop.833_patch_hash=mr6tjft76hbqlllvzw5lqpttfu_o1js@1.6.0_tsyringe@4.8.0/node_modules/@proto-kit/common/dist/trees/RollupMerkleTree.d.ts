import { Bool, Field } from "o1js";
import { TypedClass } from "../types";
import { MerkleTreeStore } from "./MerkleTreeStore";
declare const StructTemplate_base: (new (value: {
    path: import("o1js/dist/node/lib/provable/field").Field[];
    isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
}) => {
    path: import("o1js/dist/node/lib/provable/field").Field[];
    isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    path: import("o1js/dist/node/lib/provable/field").Field[];
    isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
}, {
    path: bigint[];
    isLeft: boolean[];
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    };
} & {
    fromValue: (value: {
        path: import("o1js/dist/node/lib/provable/field").Field[] | bigint[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[] | boolean[];
    }) => {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    };
    toInput: (x: {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    }) => {
        path: string[];
        isLeft: boolean[];
    };
    fromJSON: (x: {
        path: string[];
        isLeft: boolean[];
    }) => {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    };
    empty: () => {
        path: import("o1js/dist/node/lib/provable/field").Field[];
        isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
    };
};
declare class StructTemplate extends StructTemplate_base {
}
export interface AbstractMerkleWitness extends StructTemplate {
    height(): number;
    /**
     * Calculates a root depending on the leaf value.
     * @param leaf Value of the leaf node that belongs to this Witness.
     * @returns The calculated root.
     */
    calculateRoot(hash: Field): Field;
    /**
     * Calculates the index of the leaf node that belongs to this Witness.
     * @returns Index of the leaf.
     */
    calculateIndex(): Field;
    checkMembership(root: Field, key: Field, value: Field): Bool;
    checkMembershipGetRoots(root: Field, key: Field, value: Field): [Bool, Field, Field];
    toShortenedEntries(): string[];
}
export interface AbstractMerkleTree {
    store: MerkleTreeStore;
    readonly leafCount: bigint;
    assertIndexRange(index: bigint): void;
    /**
     * Returns a node which lives at a given index and level.
     * @param level Level of the node.
     * @param index Index of the node.
     * @returns The data of the node.
     */
    getNode(level: number, index: bigint): Field;
    /**
     * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
     * @returns The root of the Merkle Tree.
     */
    getRoot(): Field;
    /**
     * Sets the value of a leaf node at a given index to a given value.
     * @param index Position of the leaf node.
     * @param leaf New value.
     */
    setLeaf(index: bigint, leaf: Field): void;
    /**
     * Returns the witness (also known as
     * [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof))
     * for the leaf at the given index.
     * @param index Position of the leaf node.
     * @returns The witness that belongs to the leaf.
     */
    getWitness(index: bigint): AbstractMerkleWitness;
    /**
     * Fills all leaves of the tree.
     * @param leaves Values to fill the leaves with.
     */
    fill(leaves: Field[]): void;
}
export interface AbstractMerkleTreeClass {
    new (store: MerkleTreeStore): AbstractMerkleTree;
    WITNESS: TypedClass<AbstractMerkleWitness> & typeof StructTemplate & {
        dummy: () => AbstractMerkleWitness;
    };
    HEIGHT: number;
    EMPTY_ROOT: bigint;
    get leafCount(): bigint;
}
/**
 * A [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) is a binary tree in
 * which every leaf is the cryptography hash of a piece of data,
 * and every node is the hash of the concatenation of its two child nodes.
 *
 * A Merkle Tree allows developers to easily and securely verify
 * the integrity of large amounts of data.
 *
 * Take a look at our [documentation](https://docs.minaprotocol.com/en/zkapps)
 * on how to use Merkle Trees in combination with zkApps and
 * zero knowledge programming!
 *
 * Levels are indexed from leaves (level 0) to root (level N - 1).
 *
 * This function takes a height as argument and returns a class
 * that implements a merkletree with that specified height.
 *
 * It also holds the Witness class under tree.WITNESS
 */
export declare function createMerkleTree(height: number): AbstractMerkleTreeClass;
declare const RollupMerkleTree_base: AbstractMerkleTreeClass;
export declare class RollupMerkleTree extends RollupMerkleTree_base {
}
export declare class RollupMerkleTreeWitness extends RollupMerkleTree.WITNESS {
}
export {};
//# sourceMappingURL=RollupMerkleTree.d.ts.map