import { Field, FlexibleProvablePure, DynamicProof, Proof } from "o1js";
export declare function requireTrue(condition: boolean, errorOrFunction: Error | (() => Error)): void;
export declare function range(startOrEnd: number, endOrNothing: number | undefined): number[];
export declare function reduceSequential<T, U>(array: T[], callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => Promise<U>, initialValue: U): Promise<U>;
export declare function mapSequential<T, R>(array: T[], f: (element: T, index: number, array: T[]) => Promise<R>): Promise<R[]>;
/**
 * Computes a dummy value for the given value type.
 *
 * @param valueType - Value type to generate the dummy value for
 * @returns Dummy value for the given value type
 */
export declare function dummyValue<Value>(valueType: FlexibleProvablePure<Value>): Value;
export declare function noop(): void;
export interface ToFieldable {
    toFields: () => Field[];
}
export interface ToFieldableStatic {
    toFields: (value: unknown) => Field[];
}
export interface ToJSONableStatic {
    toJSON: (value: unknown) => any;
}
export type ProofTypes = typeof Proof<unknown, unknown> | typeof DynamicProof<unknown, unknown>;
export declare function sleep(ms: number): Promise<void>;
export declare function filterNonNull<Type>(value: Type | null): value is Type;
export declare function filterNonUndefined<Type>(value: Type | undefined): value is Type;
export declare function prefixToField(prefix: string): Field;
export declare function hashWithPrefix(prefix: string, input: Field[]): import("o1js/dist/node/lib/provable/field").Field;
export declare function expectDefined<T>(value: T | undefined): asserts value is T;
type NonMethodKeys<Type> = {
    [Key in keyof Type]: Type[Key] extends Function ? never : Key;
}[keyof Type];
export type NonMethods<Type> = Pick<Type, NonMethodKeys<Type>>;
export {};
//# sourceMappingURL=utils.d.ts.map