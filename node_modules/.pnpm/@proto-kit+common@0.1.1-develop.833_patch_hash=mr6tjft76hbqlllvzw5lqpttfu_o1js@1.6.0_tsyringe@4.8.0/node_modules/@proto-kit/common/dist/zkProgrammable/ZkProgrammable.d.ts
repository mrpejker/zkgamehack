import { ZkProgram, FlexibleProvablePure, Proof, Field, Provable } from "o1js";
export interface CompileArtifact {
    verificationKey: {
        data: string;
        hash: Field;
    };
}
export interface AreProofsEnabled {
    areProofsEnabled: boolean;
    setProofsEnabled: (areProofsEnabled: boolean) => void;
}
export interface Verify<PublicInput, PublicOutput> {
    (proof: Proof<PublicInput, PublicOutput>): Promise<boolean>;
}
export interface Compile {
    (): Promise<CompileArtifact>;
}
export interface PlainZkProgram<PublicInput = undefined, PublicOutput = void> {
    compile: Compile;
    verify: Verify<PublicInput, PublicOutput>;
    Proof: ReturnType<typeof ZkProgram.Proof<FlexibleProvablePure<PublicInput>, FlexibleProvablePure<PublicOutput>>>;
    methods: Record<string, ((...args: any) => Promise<Proof<PublicInput, PublicOutput>>) | ((publicInput: PublicInput, ...args: any) => Promise<Proof<PublicInput, PublicOutput>>)>;
    analyzeMethods: () => Promise<Record<string, Awaited<ReturnType<typeof Provable.constraintSystem>>>>;
}
export declare function verifyToMockable<PublicInput, PublicOutput>(verify: Verify<PublicInput, PublicOutput>, { areProofsEnabled }: AreProofsEnabled): (proof: Proof<PublicInput, PublicOutput>) => Promise<boolean>;
export declare const MOCK_VERIFICATION_KEY: {
    data: string;
    hash: import("o1js/dist/node/lib/provable/field").Field;
};
export declare function compileToMockable(compile: Compile, { areProofsEnabled }: AreProofsEnabled): () => Promise<CompileArtifact>;
export declare abstract class ZkProgrammable<PublicInput = undefined, PublicOutput = void> {
    abstract get appChain(): AreProofsEnabled | undefined;
    abstract zkProgramFactory(): PlainZkProgram<PublicInput, PublicOutput>;
    get zkProgram(): PlainZkProgram<PublicInput, PublicOutput>;
}
export interface WithZkProgrammable<PublicInput = undefined, PublicOutput = void> {
    zkProgrammable: ZkProgrammable<PublicInput, PublicOutput>;
}
//# sourceMappingURL=ZkProgrammable.d.ts.map