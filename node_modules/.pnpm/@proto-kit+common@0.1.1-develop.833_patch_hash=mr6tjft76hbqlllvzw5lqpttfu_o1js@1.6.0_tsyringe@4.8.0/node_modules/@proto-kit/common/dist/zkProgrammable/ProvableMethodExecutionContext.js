var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { singleton } from "tsyringe";
import uniqueId from "lodash/uniqueId";
const errors = {
    moduleOrMethodNameNotSet: () => new Error("Module or method name not set"),
    proverNotSet: (moduleName, methodName) => new Error(`Prover not set for '${moduleName}.${methodName}', did you forget to decorate your method?`),
};
export class ProvableMethodExecutionResult {
    async prove() {
        if (!this.prover) {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!this.moduleName || !this.methodName) {
                throw errors.moduleOrMethodNameNotSet();
            }
            throw errors.proverNotSet(this.moduleName, this.methodName);
        }
        // turn the prover result into the desired proof type
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return (await this.prover());
    }
}
/**
 * Execution context used to wrap runtime module methods,
 * allowing them to post relevant information (such as execution status)
 * into the context without any unnecessary 'prop drilling'.
 */
export let ProvableMethodExecutionContext = class ProvableMethodExecutionContext {
    constructor() {
        this.id = uniqueId();
        this.methods = [];
        this.result = new ProvableMethodExecutionResult();
    }
    // TODO See if we should make this class generic, bc I think we can persist the type
    /**
     * Adds a method prover to the current execution context,
     * which can be collected and ran asynchronously at a later point in time.
     *
     * @param prove - Prover function to be ran later,
     * when the method execution needs to be proven
     */
    setProver(prover) {
        this.result.prover = prover;
    }
    /**
     * Adds a method to the method execution stack, reseting the execution context
     * in a case a new top-level (non nested) method call is made.
     *
     * @param methodName - Name of the method being captured in the context
     */
    beforeMethod(moduleName, methodName, args) {
        if (this.isFinished) {
            this.clear();
            this.result.moduleName = moduleName;
            this.result.methodName = methodName;
            this.result.args = args;
        }
        this.methods.push(methodName);
    }
    /**
     * Removes the latest method from the execution context stack,
     * keeping track of the amount of 'unfinished' methods. Allowing
     * for the context to distinguish between top-level and nested method calls.
     */
    afterMethod() {
        this.methods.pop();
    }
    get isTopLevel() {
        return this.methods.length === 1;
    }
    get isFinished() {
        return this.methods.length === 0;
    }
    /**
     * @returns - Current execution context state
     */
    current() {
        return {
            isFinished: this.isFinished,
            result: this.result,
        };
    }
    /**
     * Manually clears/resets the execution context
     */
    clear() {
        this.result = new ProvableMethodExecutionResult();
    }
};
ProvableMethodExecutionContext = __decorate([
    singleton()
], ProvableMethodExecutionContext);
