import type { Proof } from "o1js";
import type { ArgumentTypes } from "./provableMethod";
export declare class ProvableMethodExecutionResult {
    moduleName?: string;
    methodName?: string;
    args?: ArgumentTypes;
    prover?: () => Promise<Proof<unknown, unknown>>;
    prove<ProofType extends Proof<unknown, unknown>>(): Promise<ProofType>;
}
/**
 * Execution context used to wrap runtime module methods,
 * allowing them to post relevant information (such as execution status)
 * into the context without any unnecessary 'prop drilling'.
 */
export declare class ProvableMethodExecutionContext {
    id: string;
    methods: string[];
    result: ProvableMethodExecutionResult;
    /**
     * Adds a method prover to the current execution context,
     * which can be collected and ran asynchronously at a later point in time.
     *
     * @param prove - Prover function to be ran later,
     * when the method execution needs to be proven
     */
    setProver(prover: () => Promise<Proof<unknown, unknown>>): void;
    /**
     * Adds a method to the method execution stack, reseting the execution context
     * in a case a new top-level (non nested) method call is made.
     *
     * @param methodName - Name of the method being captured in the context
     */
    beforeMethod(moduleName: string, methodName: string, args: ArgumentTypes): void;
    /**
     * Removes the latest method from the execution context stack,
     * keeping track of the amount of 'unfinished' methods. Allowing
     * for the context to distinguish between top-level and nested method calls.
     */
    afterMethod(): void;
    get isTopLevel(): boolean;
    get isFinished(): boolean;
    /**
     * @returns - Current execution context state
     */
    current(): {
        isFinished: boolean;
        result: ProvableMethodExecutionResult;
    };
    /**
     * Manually clears/resets the execution context
     */
    clear(): void;
}
//# sourceMappingURL=ProvableMethodExecutionContext.d.ts.map