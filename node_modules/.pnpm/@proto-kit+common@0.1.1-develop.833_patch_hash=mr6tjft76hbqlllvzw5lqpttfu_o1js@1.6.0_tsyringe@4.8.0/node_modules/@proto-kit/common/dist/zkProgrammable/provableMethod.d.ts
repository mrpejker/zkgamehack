import { Proof, DynamicProof } from "o1js";
import { ProvableMethodExecutionContext } from "./ProvableMethodExecutionContext";
import type { WithZkProgrammable, ZkProgrammable } from "./ZkProgrammable";
export type O1JSPrimitive = object | string | boolean | number;
export type ArgumentTypes = (O1JSPrimitive | Proof<unknown, unknown> | DynamicProof<unknown, unknown>)[];
export type DecoratedMethod = (...args: ArgumentTypes) => Promise<unknown>;
export declare const MOCK_PROOF = "mock-proof";
export declare function toProver(methodName: string, simulatedMethod: DecoratedMethod, isFirstParameterPublicInput: boolean, ...args: ArgumentTypes): (this: ZkProgrammable<any, any>) => Promise<Proof<any, any>>;
/**
 * Decorates a provable method on a 'prover class', depending on
 * if proofs are enabled or not, either runs the respective zkProgram prover,
 * or simulates the method execution and issues a mock proof.
 *
 * @param isFirstParameterPublicInput
 * @param executionContext
 * @returns
 */
export declare function provableMethod(isFirstParameterPublicInput?: boolean, executionContext?: ProvableMethodExecutionContext): <Target extends ZkProgrammable<any, any> | WithZkProgrammable<any, any>>(target: Target, methodName: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<any> | any>) => TypedPropertyDescriptor<(...args: any[]) => Promise<any> | any>;
//# sourceMappingURL=provableMethod.d.ts.map