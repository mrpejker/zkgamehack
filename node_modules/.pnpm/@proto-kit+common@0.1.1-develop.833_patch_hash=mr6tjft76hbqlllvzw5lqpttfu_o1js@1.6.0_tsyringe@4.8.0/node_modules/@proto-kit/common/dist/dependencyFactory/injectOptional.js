var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { container, injectable, injectWithTransform, Lifecycle, scoped, } from "tsyringe";
let UndefinedDisguise = class UndefinedDisguise {
};
UndefinedDisguise = __decorate([
    injectable(),
    scoped(Lifecycle.ResolutionScoped)
], UndefinedDisguise);
class UndefinedTransform {
    transform(incoming) {
        if (incoming instanceof UndefinedDisguise) {
            return undefined;
        }
        return incoming;
    }
}
/**
 * This function injects a dependency only if it has been registered, otherwise
 * injects undefined. This can be useful for having optional dependencies, where
 * tsyringe would normally error out and not be able to resolve. With this
 * decorator, we can now do this.
 *
 * The strategy we employ here is that we inject a dummy into the global
 * container that is of type UndefinedDisguise. We can't inject undefined
 * directly, therefore we use this object to disguise itself as undefined.
 * Then a child container registers something under the same token, it by
 * default resolves that new dependency. If that doesn't happen, the
 * resolution hits our disguise, which we then convert into undefined
 * using the Transform
 */
export function injectOptional(token) {
    container.register(token, { useClass: UndefinedDisguise });
    return injectWithTransform(token, (UndefinedTransform));
}
