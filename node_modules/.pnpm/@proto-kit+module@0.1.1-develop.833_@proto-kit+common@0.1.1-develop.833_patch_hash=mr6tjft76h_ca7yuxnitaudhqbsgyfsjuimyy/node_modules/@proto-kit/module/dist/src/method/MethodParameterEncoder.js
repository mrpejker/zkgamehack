/* eslint-disable no-underscore-dangle,@typescript-eslint/consistent-type-assertions */
import { Proof, Provable, } from "o1js";
const errors = {
    fieldLengthNotMatching: (expected, actual) => new Error(`Expected ${expected} field elements, got ${actual}`),
    typeNotCompatible: (name, error) => new Error(`Cannot decode type ${name}, it has to be either a Struct, CircuitValue or built-in snarkyjs type.${error !== undefined ? `Caused by: ${error}` : ""}`),
};
export class MethodParameterEncoder {
    static fromMethod(target, methodName) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const paramtypes = Reflect.getMetadata("design:paramtypes", target, methodName);
        if (paramtypes === undefined) {
            throw new Error(`Method with name ${methodName} doesn't exist on this module`);
        }
        return new MethodParameterEncoder(paramtypes);
    }
    static fieldSize(type) {
        // as any, since we shouldn't be using this workaround in the first place
        return type.prototype._fields?.length ?? type.sizeInFields?.();
    }
    constructor(types) {
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
    }
    decode(argsJSON) {
        return this.types.map((type, index) => {
            let value;
            try {
                value = type.fromJSON(JSON.parse(argsJSON[index]));
            }
            catch (e) {
                if (e instanceof Error) {
                    throw errors.typeNotCompatible(type.constructor.name, e.message);
                }
                throw errors.typeNotCompatible(type.constructor.name);
            }
            return value;
        });
    }
    decodeFields(fields) {
        if (fields.length < this.fieldSize) {
            throw errors.fieldLengthNotMatching(this.fieldSize, fields.length);
        }
        let stack = fields.slice();
        return this.types.map((type) => {
            const numberFieldsNeeded = MethodParameterEncoder.fieldSize(type) ?? -1;
            if (numberFieldsNeeded === -1) {
                throw errors.typeNotCompatible(type.constructor.name);
            }
            const structFields = stack.slice(0, numberFieldsNeeded);
            stack = stack.slice(numberFieldsNeeded);
            return type.fromFields(structFields, []);
        });
    }
    /**
     * Variant of encode() for provable code that skips the unprovable
     * json encoding
     */
    encodeAsFields(args) {
        /**
         * Use the type info obtained previously to convert
         * the args passed to fields
         */
        return args.flatMap((argument, index) => {
            if (argument instanceof Proof) {
                const argumentType = this.types[index];
                const publicOutputType = argumentType?.publicOutputType;
                const publicInputType = argumentType?.publicInputType;
                const inputFields = publicInputType?.toFields(argument.publicInput) ?? [];
                const outputFields = publicOutputType?.toFields(argument.publicOutput) ?? [];
                return [...inputFields, ...outputFields];
            }
            const argumentType = this.types[index];
            return argumentType.toFields(argument);
        });
    }
    encode(args) {
        const argsFields = this.encodeAsFields(args);
        let argsJSON = [];
        Provable.asProver(() => {
            argsJSON = args.map((argument, index) => {
                if (argument instanceof Proof) {
                    return JSON.stringify(argument.toJSON());
                }
                const argumentType = this.types[index];
                return JSON.stringify(argumentType.toJSON(argument));
            });
        });
        return {
            argsFields,
            argsJSON,
        };
    }
    get fieldSize() {
        return this.types
            .map((type) => MethodParameterEncoder.fieldSize(type) ?? 0)
            .reduce((a, b) => a + b, 0);
    }
}
/* eslint-enable no-underscore-dangle,@typescript-eslint/consistent-type-assertions */
