var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { ConfigurableModule } from "@proto-kit/common";
import { container, injectable } from "tsyringe";
import { RuntimeMethodExecutionContext, RuntimeMethodExecutionDataStruct, } from "@proto-kit/protocol";
import { Provable } from "o1js";
import { runtimeMethodNamesMetadataKey } from "../method/runtimeMethod";
const errors = {
    inputDataNotSet: () => new Error("Input data for runtime execution not set"),
};
/**
 * Base class for runtime modules providing the necessary utilities.
 */
export let RuntimeModule = class RuntimeModule extends ConfigurableModule {
    constructor() {
        super();
        /**
         * Holds all method names that are callable throw transactions
         */
        this.runtimeMethodNames = [];
        /**
         * This property exists only to typecheck that the RuntimeModule
         * was extended correctly in e.g. a decorator. We need at least
         * one non-optional property in this class to make the typechecking work.
         */
        this.isRuntimeModule = true;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const methodNames = Reflect.getMetadata(runtimeMethodNamesMetadataKey, this);
        this.runtimeMethodNames = methodNames ?? [];
    }
    getInputs() {
        return Provable.witness(RuntimeMethodExecutionDataStruct, () => {
            const { input } = container.resolve(RuntimeMethodExecutionContext);
            if (input === undefined) {
                throw errors.inputDataNotSet();
            }
            return input;
        });
    }
    get transaction() {
        return this.getInputs().transaction;
    }
    get network() {
        return this.getInputs().networkState;
    }
};
RuntimeModule.presets = {};
RuntimeModule = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], RuntimeModule);
