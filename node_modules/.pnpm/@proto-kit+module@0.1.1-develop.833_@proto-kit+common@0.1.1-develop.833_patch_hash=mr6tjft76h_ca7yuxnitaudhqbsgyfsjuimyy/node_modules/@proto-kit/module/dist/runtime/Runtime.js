var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var Runtime_1;
/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-argument */
import { ZkProgram } from "o1js";
import { injectable } from "tsyringe";
import { ModuleContainer, ZkProgrammable, } from "@proto-kit/common";
import { MethodPublicOutput, } from "@proto-kit/protocol";
import { combineMethodName, isRuntimeMethod, runtimeMethodTypeMetadataKey, toWrappedMethod, } from "../method/runtimeMethod";
import { MethodIdFactory } from "../factories/MethodIdFactory";
export function getAllPropertyNames(obj) {
    let currentPrototype = obj;
    let keys = [];
    // if primitive (primitives still have keys) skip the first iteration
    if (!(obj instanceof Object)) {
        currentPrototype = Object.getPrototypeOf(obj);
    }
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    while (currentPrototype) {
        keys = keys.concat(Reflect.ownKeys(currentPrototype));
        currentPrototype = Object.getPrototypeOf(currentPrototype);
    }
    return keys;
}
const errors = {
    methodNotFound: (methodKey) => new Error(`Unable to find method with id ${methodKey}`),
};
export class RuntimeZkProgrammable extends ZkProgrammable {
    constructor(runtime) {
        super();
        this.runtime = runtime;
    }
    get appChain() {
        return this.runtime.appChain;
    }
    zkProgramFactory() {
        // We need to use explicit type annotations here,
        // therefore we can't use destructuring
        // eslint-disable-next-line prefer-destructuring
        const runtime = this.runtime;
        const runtimeMethods = runtime.runtimeModuleNames.reduce((allMethods, runtimeModuleName) => {
            runtime.isValidModuleName(runtime.definition.modules, runtimeModuleName);
            /**
             * Couldnt find a better way to circumvent the type assertion
             * regarding resolving only known modules. We assert in the line above
             * but we cast it to any anyways to satisfy the proof system.
             */
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            const runtimeModule = runtime.resolve(runtimeModuleName);
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            const modulePrototype = Object.getPrototypeOf(runtimeModule);
            const modulePrototypeMethods = getAllPropertyNames(runtimeModule).map((method) => method.toString());
            const moduleMethods = modulePrototypeMethods.reduce((allModuleMethods, methodName) => {
                if (isRuntimeMethod(runtimeModule, methodName)) {
                    const combinedMethodName = combineMethodName(runtimeModuleName, methodName);
                    const method = modulePrototype[methodName];
                    const invocationType = Reflect.getMetadata(runtimeMethodTypeMetadataKey, runtimeModule, methodName);
                    const wrappedMethod = Reflect.apply(toWrappedMethod, runtimeModule, [methodName, method, { invocationType }]);
                    // TODO: find out how to import the Tuple type
                    const privateInputs = Reflect.getMetadata("design:paramtypes", runtimeModule, methodName);
                    return {
                        ...allModuleMethods,
                        [combinedMethodName]: {
                            privateInputs,
                            method: wrappedMethod,
                        },
                    };
                }
                return allModuleMethods;
            }, {});
            return {
                ...allMethods,
                ...moduleMethods,
            };
        }, {});
        const sortedRuntimeMethods = Object.fromEntries(Object.entries(runtimeMethods).sort());
        const program = ZkProgram({
            name: "RuntimeProgram",
            publicOutput: MethodPublicOutput,
            methods: sortedRuntimeMethods,
        });
        const SelfProof = ZkProgram.Proof(program);
        const methods = Object.keys(sortedRuntimeMethods).reduce((boundMethods, methodName) => {
            boundMethods[methodName] = program[methodName].bind(program);
            return boundMethods;
        }, {});
        return {
            compile: program.compile.bind(program),
            verify: program.verify.bind(program),
            analyzeMethods: program.analyzeMethods.bind(program),
            Proof: SelfProof,
            methods,
        };
    }
}
/**
 * Wrapper for an application specific runtime, which helps orchestrate
 * runtime modules into an interoperable runtime.
 */
export let Runtime = Runtime_1 = class Runtime extends ModuleContainer {
    static from(definition) {
        return class RuntimeScoped extends Runtime_1 {
            constructor() {
                super(definition);
            }
        };
    }
    /**
     * Creates a new Runtime from the provided config
     *
     * @param modules - Configuration object for the constructed Runtime
     */
    constructor(definition) {
        super(definition);
        this.definition = definition;
        this.zkProgrammable = new RuntimeZkProgrammable(this);
    }
    // TODO Remove after changing DFs to type-based approach
    create(childContainerProvider) {
        super.create(childContainerProvider);
        this.useDependencyFactory(this.container.resolve(MethodIdFactory));
    }
    get appChain() {
        return this.container.resolve("AreProofsEnabled");
    }
    get stateServiceProvider() {
        return this.dependencyContainer.resolve("StateServiceProvider");
    }
    get stateService() {
        return this.stateServiceProvider.stateService;
    }
    get methodIdResolver() {
        return this.container.resolve("MethodIdResolver");
    }
    /**
     * @returns The dependency injection container of this runtime
     */
    get dependencyContainer() {
        return this.container;
    }
    /**
     * @param methodId The encoded name of the method to call.
     * Encoding: "stringToField(module.name) << 128 + stringToField(method-name)"
     */
    getMethodById(methodId) {
        const methodDescriptor = this.methodIdResolver.getMethodNameFromId(methodId);
        if (methodDescriptor === undefined) {
            return undefined;
        }
        const [moduleName, methodName] = methodDescriptor;
        this.assertIsValidModuleName(moduleName);
        const module = this.resolve(moduleName);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        const method = module[methodName];
        if (method === undefined) {
            throw errors.methodNotFound(`${moduleName}.${methodName}`);
        }
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return method.bind(module);
    }
    /**
     * Add a name and other respective properties required by RuntimeModules,
     * that come from the current Runtime
     *
     * @param moduleName - Name of the runtime module to decorate
     * @param containedModule
     */
    decorateModule(moduleName, containedModule) {
        containedModule.name = moduleName;
        containedModule.runtime = this;
        super.decorateModule(moduleName, containedModule);
    }
    /**
     * @returns A list of names of all the registered module names
     */
    get runtimeModuleNames() {
        return Object.keys(this.definition.modules);
    }
};
Runtime = Runtime_1 = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Object])
], Runtime);
/* eslint-enable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-argument */
