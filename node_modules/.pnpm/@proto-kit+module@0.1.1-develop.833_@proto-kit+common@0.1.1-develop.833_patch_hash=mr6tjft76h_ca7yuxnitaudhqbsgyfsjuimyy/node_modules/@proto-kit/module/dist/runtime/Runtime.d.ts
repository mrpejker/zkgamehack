import { ZkProgram } from "o1js";
import { DependencyContainer } from "tsyringe";
import { StringKeyOf, ModuleContainer, ModulesConfig, ModulesRecord, TypedClass, ZkProgrammable, PlainZkProgram, AreProofsEnabled, ChildContainerProvider } from "@proto-kit/common";
import { MethodPublicOutput, StateServiceProvider, SimpleAsyncStateService } from "@proto-kit/protocol";
import { RuntimeModule } from "./RuntimeModule";
import { MethodIdResolver } from "./MethodIdResolver";
import { RuntimeEnvironment } from "./RuntimeEnvironment";
export declare function getAllPropertyNames(obj: any): (string | symbol)[];
/**
 * Record of modules accepted by the Runtime module container.
 *
 * We have to use TypedClass since RuntimeModule
 * is an abstract class
 */
export type RuntimeModulesRecord = ModulesRecord<TypedClass<RuntimeModule<unknown>>>;
/**
 * Definition / required arguments for the Runtime class
 */
export interface RuntimeDefinition<Modules extends RuntimeModulesRecord> {
    modules: Modules;
    config?: ModulesConfig<Modules>;
}
export declare class RuntimeZkProgrammable<Modules extends RuntimeModulesRecord> extends ZkProgrammable<undefined, MethodPublicOutput> {
    runtime: Runtime<Modules>;
    constructor(runtime: Runtime<Modules>);
    get appChain(): AreProofsEnabled | undefined;
    zkProgramFactory(): PlainZkProgram<undefined, MethodPublicOutput>;
}
/**
 * Wrapper for an application specific runtime, which helps orchestrate
 * runtime modules into an interoperable runtime.
 */
export declare class Runtime<Modules extends RuntimeModulesRecord> extends ModuleContainer<Modules> implements RuntimeEnvironment {
    static from<Modules extends RuntimeModulesRecord>(definition: RuntimeDefinition<Modules>): TypedClass<Runtime<Modules>>;
    program?: ReturnType<typeof ZkProgram>;
    definition: RuntimeDefinition<Modules>;
    zkProgrammable: ZkProgrammable<undefined, MethodPublicOutput>;
    /**
     * Creates a new Runtime from the provided config
     *
     * @param modules - Configuration object for the constructed Runtime
     */
    constructor(definition: RuntimeDefinition<Modules>);
    create(childContainerProvider: ChildContainerProvider): void;
    get appChain(): AreProofsEnabled | undefined;
    get stateServiceProvider(): StateServiceProvider;
    get stateService(): SimpleAsyncStateService;
    get methodIdResolver(): MethodIdResolver;
    /**
     * @returns The dependency injection container of this runtime
     */
    get dependencyContainer(): DependencyContainer;
    /**
     * @param methodId The encoded name of the method to call.
     * Encoding: "stringToField(module.name) << 128 + stringToField(method-name)"
     */
    getMethodById(methodId: bigint): ((...args: unknown[]) => Promise<unknown>) | undefined;
    /**
     * Add a name and other respective properties required by RuntimeModules,
     * that come from the current Runtime
     *
     * @param moduleName - Name of the runtime module to decorate
     * @param containedModule
     */
    decorateModule(moduleName: StringKeyOf<Modules>, containedModule: InstanceType<Modules[StringKeyOf<Modules>]>): void;
    /**
     * @returns A list of names of all the registered module names
     */
    get runtimeModuleNames(): string[];
}
//# sourceMappingURL=Runtime.d.ts.map