import { StateTransition, MethodPublicOutput } from "@proto-kit/protocol";
import { ArgumentTypes } from "@proto-kit/common";
import type { RuntimeModule } from "../runtime/RuntimeModule.js";
export declare function toStateTransitionsHash(stateTransitions: StateTransition<any>[]): import("o1js/dist/node/lib/provable/field.js").Field;
export type WrappedMethod = (...args: ArgumentTypes) => MethodPublicOutput;
export type AsyncWrappedMethod = (...args: ArgumentTypes) => Promise<MethodPublicOutput>;
export declare function toWrappedMethod(this: RuntimeModule<unknown>, methodName: string, moduleMethod: (...args: ArgumentTypes) => Promise<any>, options: {
    invocationType: RuntimeMethodInvocationType;
}): AsyncWrappedMethod;
export declare function combineMethodName(runtimeModuleName: string, methodName: string): string;
export declare const runtimeMethodMetadataKey = "yab-method";
export declare const runtimeMethodNamesMetadataKey = "proto-kit-runtime-methods";
export declare const runtimeMethodTypeMetadataKey = "proto-kit-runtime-method-type";
/**
 * Checks the metadata of the provided runtime module and its method,
 * to see if it has been decorated with @runtimeMethod()
 *
 * @param target - Runtime module to check
 * @param propertyKey - Name of the method to check in the prior runtime module
 * @returns - If the provided method name is a runtime method or not
 */
export declare function isRuntimeMethod(target: RuntimeModule<unknown>, propertyKey: string): boolean;
export type RuntimeMethodInvocationType = "SIGNATURE" | "INCOMING_MESSAGE";
export declare function runtimeMessage(): (target: RuntimeModule<unknown>, methodName: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<any>>) => void;
export declare function runtimeMethod(): (target: RuntimeModule<unknown>, methodName: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<any>>) => void;
//# sourceMappingURL=runtimeMethod.d.ts.map