const errors = {
    typeNotCompatible: (name) => new Error(`Cannot decode type ${name}, it has to be either a Struct, CircuitValue or built-in snarkyjs type`),
};
export class MethodParameterDecoder {
    static fromMethod(target, methodName) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const paramtypes = Reflect.getMetadata("design:paramtypes", target, methodName);
        if (paramtypes === undefined) {
            throw new Error(`Method with name ${methodName} doesn't exist on this module`);
        }
        return new MethodParameterDecoder(paramtypes);
    }
    static fieldSize(type) {
        // as any, since we shouldn't be using this workaround in the first place
        return type.prototype._fields?.length ?? type.sizeInFields?.();
    }
    constructor(types) {
        this.types = types;
    }
    fromJSON(argsJSON) {
        return this.types.map((type, index) => {
            // eslint-disable-next-line @typescript-eslint/init-declarations
            let value;
            try {
                // eslint-disable-next-line max-len
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                value = type.fromJSON(JSON.parse(argsJSON[index]));
            }
            catch {
                throw errors.typeNotCompatible(type.constructor.name);
            }
            return value;
        });
    }
    get fieldSize() {
        return this.types
            .map((type) => MethodParameterDecoder.fieldSize(type) ?? 0)
            .reduce((a, b) => a + b, 0);
    }
}
