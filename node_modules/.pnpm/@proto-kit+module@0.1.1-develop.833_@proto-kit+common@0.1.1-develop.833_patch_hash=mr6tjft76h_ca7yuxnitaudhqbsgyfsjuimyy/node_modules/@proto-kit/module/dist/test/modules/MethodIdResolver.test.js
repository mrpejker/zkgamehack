var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import "reflect-metadata";
import { assert } from "@proto-kit/protocol";
import { Field } from "o1js";
import { beforeAll } from "@jest/globals";
import { container } from "tsyringe";
import { runtimeMethod, RuntimeModule, runtimeModule } from "../../src";
import { createTestingRuntime } from "../TestingRuntime";
import { Balances } from "./Balances";
let Admin = class Admin extends RuntimeModule {
    isAdminWithAVeryVeryVeryVeryLongName() {
        assert(Field(1).equals(Field(1)));
    }
};
__decorate([
    runtimeMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Admin.prototype, "isAdminWithAVeryVeryVeryVeryLongName", null);
Admin = __decorate([
    runtimeModule()
], Admin);
describe("methodId", () => {
    let runtime;
    let resolver;
    beforeAll(() => {
        container.clearInstances();
        ({ runtime } = createTestingRuntime({
            Admin,
            Balance: Balances,
        }, {
            Admin: {},
            Balance: {},
        }));
        resolver =
            runtime.dependencyContainer.resolve("MethodIdResolver");
    });
    it.each([
        ["Admin", "isAdminWithAVeryVeryVeryVeryLongName"],
        ["Balance", "getTotalSupply"],
        ["Balance", "getBalance"],
    ])("should pass and encode correctly", (givenModuleName, givenMethodName) => {
        expect.assertions(2);
        const methodId = resolver.getMethodId(givenModuleName, givenMethodName);
        const [moduleName, methodName] = resolver.getMethodNameFromId(methodId) ?? [
            undefined,
            undefined,
        ];
        expect(moduleName).toBe(givenModuleName);
        expect(methodName).toBe(givenMethodName);
    });
    it("should fail for invalid module name", () => {
        expect.assertions(1);
        expect(() => {
            resolver.getMethodId("Admin2", "isAdminWithAVeryVeryVeryVeryLongName");
        }).toThrow("Only known module names are allowed, using unknown module name: Admin2");
    });
});
