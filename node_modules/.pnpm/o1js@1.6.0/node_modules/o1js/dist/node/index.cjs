"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// dist/node/index.js
var node_exports = {};
__export(node_exports, {
  Account: () => Account4,
  AccountUpdate: () => AccountUpdate3,
  AccountUpdateForest: () => AccountUpdateForest,
  AccountUpdateTree: () => AccountUpdateTree,
  Bool: () => Bool4,
  Bytes: () => Bytes2,
  Cache: () => Cache,
  Character: () => Character,
  Circuit: () => Circuit,
  CircuitString: () => CircuitString,
  Crypto: () => Crypto,
  DynamicProof: () => DynamicProof,
  EcdsaSignature: () => EcdsaSignature2,
  EcdsaSignatureV2: () => EcdsaSignatureV2,
  Empty: () => Empty,
  Encoding: () => encoding_exports,
  Encryption: () => encryption_exports,
  Experimental: () => Experimental,
  FeatureFlags: () => FeatureFlags,
  Field: () => Field4,
  ForeignCurve: () => ForeignCurve,
  ForeignCurveV2: () => ForeignCurveV2,
  Gadgets: () => Gadgets,
  Group: () => Group3,
  Hash: () => Hash,
  Hashed: () => Hashed,
  Int64: () => Int64,
  Keccak: () => Keccak,
  Keypair: () => Keypair,
  Ledger: () => Ledger,
  Lightnet: () => Lightnet,
  MerkleList: () => MerkleList,
  MerkleListIterator: () => MerkleListIterator,
  MerkleMap: () => MerkleMap,
  MerkleMapWitness: () => MerkleMapWitness,
  MerkleTree: () => MerkleTree,
  MerkleWitness: () => MerkleWitness,
  Mina: () => mina_exports,
  Nullifier: () => Nullifier,
  Option: () => Option,
  Packed: () => Packed,
  Permissions: () => Permissions,
  Poseidon: () => Poseidon2,
  PrivateKey: () => PrivateKey2,
  Proof: () => Proof,
  Provable: () => Provable,
  PublicKey: () => PublicKey2,
  Reducer: () => Reducer,
  Scalar: () => Scalar3,
  ScalarField: () => ScalarField,
  SelfProof: () => SelfProof,
  Sign: () => Sign3,
  Signature: () => Signature2,
  SmartContract: () => SmartContract,
  State: () => State2,
  Struct: () => Struct,
  TokenAccountUpdateIterator: () => TokenAccountUpdateIterator,
  TokenContract: () => TokenContract,
  TokenContractV2: () => TokenContractV2,
  TokenId: () => TokenId4,
  TokenSymbol: () => TokenSymbol,
  Transaction: () => Transaction,
  TransactionVersion: () => TransactionVersion3,
  Types: () => transaction_exports,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  UInt8: () => UInt8,
  Unconstrained: () => Unconstrained,
  Undefined: () => Undefined,
  VerificationKey: () => VerificationKey,
  Void: () => Void,
  ZkProgram: () => ZkProgram,
  ZkappPublicInput: () => ZkappPublicInput,
  addCachedAccount: () => addCachedAccount,
  assert: () => assert3,
  checkZkappTransaction: () => checkZkappTransaction,
  circuitMain: () => circuitMain,
  createEcdsa: () => createEcdsa,
  createEcdsaV2: () => createEcdsaV2,
  createForeignCurve: () => createForeignCurve,
  createForeignCurveV2: () => createForeignCurveV2,
  createForeignField: () => createForeignField,
  declareMethods: () => declareMethods,
  declareState: () => declareState,
  fetchAccount: () => fetchAccount,
  fetchEvents: () => fetchEvents2,
  fetchLastBlock: () => fetchLastBlock,
  fetchTransactionStatus: () => fetchTransactionStatus,
  initializeBindings: () => initializeBindings,
  method: () => method,
  provable: () => provable,
  provablePure: () => provablePure,
  public_: () => public_,
  sendZkapp: () => sendZkapp,
  setArchiveGraphqlEndpoint: () => setArchiveGraphqlEndpoint,
  setGraphqlEndpoint: () => setGraphqlEndpoint,
  setGraphqlEndpoints: () => setGraphqlEndpoints,
  setNumberOfWorkers: () => setNumberOfWorkers,
  state: () => state2,
  verify: () => verify
});
module.exports = __toCommonJS(node_exports);

// dist/node/bindings/crypto/constants.js
var prefixes = {
  "event": "MinaZkappEvent******",
  "events": "MinaZkappEvents*****",
  "sequenceEvents": "MinaZkappSeqEvents**",
  "zkappBodyMainnet": "MainnetZkappBody****",
  "zkappBodyTestnet": "TestnetZkappBody****",
  "accountUpdateCons": "MinaAcctUpdateCons**",
  "accountUpdateNode": "MinaAcctUpdateNode**",
  "zkappMemo": "MinaZkappMemo*******",
  "signatureMainnet": "MinaSignatureMainnet",
  "signatureTestnet": "CodaSignature*******",
  "zkappUri": "MinaZkappUri********",
  "deriveTokenId": "MinaDeriveTokenId***",
  "sideLoadedVK": "MinaSideLoadedVk****"
};
var prefixHashes = {
  "CodaReceiptUC*******": [
    "2930292359494829300271368860633580634815819151887078160583250237349129726103",
    "15303314845540397914948764201521841781296890621466368017042313538410516382474",
    "8520568699315305732843613022173524514377597839978192694761879649747314556194"
  ],
  "CodaReceiptZkapp****": [
    "10173709693039436418323173817852473796760618468635274081106091878172355412495",
    "8139892805413950771311540201181177376747817902069998595519899391903936767134",
    "13514876620613630149351219463845257700223634963001020028151406467995275024594"
  ],
  "Coinbase************": [
    "16825847102297458526359719396083434368788313103713242309655412848174457920423",
    "21732702256017917816272795771734458959259892802453584375610183841451053027064",
    "20669950187190141732603807229833302926112666951294341954340514712643194206110"
  ],
  "PendingCoinbases****": [
    "16730315671906078134534118281698719603694322959719576832314142406897554025946",
    "25168172107432119701402092802564698772609386283424806773354665411015030859956",
    "20203823516569384790863281992678977204769111540506990077513414850340465376267"
  ],
  "CoinbaseStackData***": [
    "23795978781100345043289806728009175185120094645976380845310050347461663815988",
    "22848259504294538625391413055517172710405127059374914145881816600826824598643",
    "8292468073974572410325570929211069869427868613763277519881895337391418731450"
  ],
  "CoinbaseStackStaHash": [
    "335203117218289187585524630708440909952721586869179589604793956147132569543",
    "27066428515933869709871979311099618239824992817474733219473754649926311088531",
    "21249847167218596842529246266817628519376871370045151307329588726090940941283"
  ],
  "CoinbaseStack*******": [
    "10365018507282248303752506973112854406071106890516858854157506926717812932750",
    "19289691782405010481159082968251292806607879795611766141901748131065655579721",
    "8987039650233860747996941600635099179155585390854763935988086491644855810711"
  ],
  "MinaCheckpoints*****": [
    "15873130589302091361863210575263731242593763730169570459166821652327279429416",
    "27741778946681194402252199348726997679847260280438775383573755416459042152245",
    "7598438620402360345138640933713109733801127070065255775405685972203496634081"
  ],
  "MinaMergeSnark******": [
    "5465206932306554741198859294482250047374987110116571903153751264716396266207",
    "28325265961862852836567844362114881306407823522046946129773393861560948847052",
    "20049678444717746759028157787181298288785775657186008836042341914370292827996"
  ],
  "MinaBaseSnark*******": [
    "15502310217431654911062859746106286672455410530942120153504175184205809302248",
    "3469045624943527165009161295743804688154058669917024998601801713171804105078",
    "16667965011323249535055526937874001443515091810412343722400939445165393857780"
  ],
  "MinaProtoState******": [
    "5218970939948495870036503265499543025475317910763049867270287867667146978870",
    "7663210626148314949787033187186036425676070286961909238040356477815169631084",
    "19859188289320816036969227839574854326171440874550138016648548415357198703337"
  ],
  "MinaProtoStateBody**": [
    "3548547909990922956559515810876765435326873020883079662683136168632773655275",
    "134182536761489093478066959027928272525080293912190881939140820794450385287",
    "18910449726094816833941350890285540874861148441082116020102338532207375519343"
  ],
  "MinaVrfMessage******": [
    "24101363367502572671624471609928959797353672294440762288404204895418767914646",
    "5171820881164007689309616183632792746219180909518238150637460314245246143263",
    "10979796915023089328772347959806029121878467684484216605075459818053899045444"
  ],
  "MinaSignatureMainnet": [
    "28597293842583882050529337819282358444728515448690248936274177901465134844489",
    "13029865398778858891320837481651890827971447635226272051516204921834229015884",
    "2324960771278703080070347074343683653953770644553957353754880132143131569147"
  ],
  "CodaSignature*******": [
    "6547874669265470003564181123405173756111990160585052594027544303901364349512",
    "22191763046611062479784309793717481299019591714391827084400612211604078633201",
    "15360317550574394687602808211901764964514686767298144053612144955373862517277"
  ],
  "MinaVrfOutput*******": [
    "2251514781415689779315070305878469259850299612928948069881728941286436529416",
    "28445424317765931437563566658155841532256907311948842353165636913979445243675",
    "1697103740469522139030362533818365124680980524626250761960654638291888644330"
  ],
  "MinaVrfEvaluation***": [
    "28080055385183205248434069314913715411795750554846638282391132356635075327118",
    "25018718747831549163470950235902703474807728450690404911050923194299837536932",
    "3256623657773355300700179149632147114566124258546613752475489953689825740823"
  ],
  "MinaEpochSeed*******": [
    "7920024158807749362970659876749181530334941449960381128739613586571256360405",
    "13756862713999441076472977832321298402266591073703520273734381195492800342833",
    "16931743843465107540110860558687538825985475311420101960428698400767332393906"
  ],
  "MinaTransitionSnark*": [
    "11049595972041980914958840531625028328602860712038036656362464370121336040984",
    "24369517789348117364784880800333031735213111703459853079908318927717982912175",
    "996573540734206293061884582007205418029995442386259428924494388795357965385"
  ],
  "MinaAccount*********": [
    "21547009634669789644192675386133007766042650219024716227935570378579547706642",
    "3869977418072959680344087467966431440327948593054069717779845397512987438978",
    "17591003611016737523041467644989399067682599282318802410210271366172380277153"
  ],
  "MinaSideLoadedVk****": [
    "27153629295534844750482612843518005572402188741101822965689207110291504095805",
    "11073437601016088346212553894160581939150688827288603152461976873708720172824",
    "9169013693168830396847022454402673046094697740892173219744332585469764409612"
  ],
  "MinaZkappAccount****": [
    "11742420651603425685690711434636216727968618158667382343736587130720645535016",
    "20917169788479399921968659996772666237321879817943938162255353371266230737562",
    "20221577186851444354528754069740362935513598751580381763045954351047955571417"
  ],
  "MinaZkappPayload****": [
    "15735138827391397348912010094577234813869450438840158969759900004702547928125",
    "25095612872941242247876048162039143509752212627701285511972307921367391645919",
    "7245494597725009330136300549232949784423520250577599502394596645257342395146"
  ],
  "MainnetZkappBody****": [
    "10214915150831852734808709087755641273868350720962413399868532305813227181967",
    "19231103515031626108540280352804904215178644233964839448405623573586547300771",
    "3202185325412846279878024015439663797323768206239602518916650099275135615824"
  ],
  "TestnetZkappBody****": [
    "20037733640875789833090442509053816933966165101372309054048970230906793051053",
    "1106678471497583468621635190733109842219273971961053291385773425960251864224",
    "25565387364959491931899708566015584890804577695743228799735258954982776499278"
  ],
  "MinaZkappPred*******": [
    "1288860557840839698672685006364179285130411098848600694737282320588924548492",
    "24648295833336558525603848295184424886548932461541421142783307792871113347031",
    "1330615836835056811243082335077124866238751435915242573993316916713469087050"
  ],
  "MinaZkappPredAcct***": [
    "16247099195538206941970428186933809576049890124762896310373916059400681012938",
    "15171999803179862436296250357712424012107969488385552487664863256867849154640",
    "4695118160519310765712802705640939163487421977728313886668234870398464448283"
  ],
  "MinaZkappPredPS*****": [
    "28115844434401213157045670864292277190427496512916771660477513364996586226191",
    "17764239860871865704512758086410304367016330694375482081848267812860896213477",
    "2608563583120825722034995217249250504732387097295075568312443453761249924462"
  ],
  "MinaAcctUpdAcctPred*": [
    "11173347481325879282537380504137543614432174467122278589147153842480174214350",
    "22433785030516935555884954114999194863743668497200511950547006360846720681436",
    "4261224905860522407514587942832658209487173552801239748203234114069543449134"
  ],
  "MinaAcctUpdateCons**": [
    "7974184247425786365466969127827083941281743695327546149120833518746435921046",
    "1079147682067570431747049877519099849334832444581201545961023544596733431550",
    "9670106619202136718451303928765479503313491401619698334696903962327538130992"
  ],
  "MinaAcctUpdateNode**": [
    "15921812961830232432174711488904180713275251781093575291539345321597011303739",
    "5852213322332241594845871336918115662219071361771346507406094569679662937607",
    "21122827334147180286039671993443893600964526985496742826857975683524856341379"
  ],
  "MinaAcctUpdStckFrm**": [
    "1223279431820750727612295994589444883292600761079562536688416996919972234987",
    "1873141333924103856860857609363983758885824745969813373245393521390926426683",
    "3550105212452130151915860825756512345408015936295894584118372238840612023788"
  ],
  "MinaActUpStckFrmCons": [
    "2363089775097766730570162674460603870980415123701610894146069429352874281636",
    "8717086429614898734892919627864489205116600585932141922995487227707208282057",
    "14660270392332597302006144557344641683528071714290878702086758222477469533211"
  ],
  "MinaZkappUri********": [
    "534822897390732927195976832726937157108052596941484097303405936433225931144",
    "21308674973525253012607500915181592359821899373849668837401701284134790635210",
    "19235616568963430752220890547731083898076295596325584947617173371158207986317"
  ],
  "MinaZkappEvent******": [
    "4144672248660824652311280789227568759501644435839088465487215978090977152836",
    "16580012705864177241905923711864666027965216928284588602669501632136706453456",
    "28268897103231723777184618409092967932555901943057586428182153116992131011025"
  ],
  "MinaZkappEvents*****": [
    "22941690192200157010958144262626906691861453230235765939870625581651903942109",
    "8085194290973996063041942057794139208480036474122767282118588735695477304146",
    "26729904183313179836453835886592671283117737890095730465188585661277543615385"
  ],
  "MinaZkappSeqEvents**": [
    "20111532619758468729019280527752703188436440291616049387250019116440725105679",
    "28272901079534355755544153990297346241256584111406088887261772513761686581936",
    "11593971643819429831651280663135869674712971584194549509498204047075895747923"
  ],
  "MinaZkappMemo*******": [
    "2662735671148484138098041239517130399444285195614926917304994766121342901330",
    "1889560324711062089177091328630260720221153765601231238715650562289804935970",
    "4150523804923664151142435309968051550133270766858171566059780615187901817023"
  ],
  "MinaZkappTest*******": [
    "23523101868899742954180674496902908392567863852999903167375927084079494055612",
    "4491786955849351692402874941062803293792761915358826996649017458255778371918",
    "18160445324611651688025194683090940451613686777550031421971998315243738422364"
  ],
  "MinaDeriveTokenId***": [
    "6192019453766080264591455948244350296532066491511280821771403784079613278630",
    "3474280028978446563781013959252007045004226094384968366087940198662654278266",
    "20434002876694963787609307807174199928279086350854834006718281273564667456637"
  ],
  "CodaReceiptEmpty": [
    "14564582992068613478915821183083107733064540968050799295374021047658500056219",
    "21765043973285063733734239399942750176857972907855721619600674857294623000734",
    "18519955733587546799174091248819038069762857427193969217428957100491271613694"
  ],
  "MinaZkappEventsEmpty": [
    "11558119263070965853863267079253872832625419457395008685779236645292569607921",
    "25458142203119307439619503192644060065091275427503371449742352140981637359577",
    "28343474290528262467651243371210869540984529302238754668057531270656874883506"
  ],
  "MinaZkappActionsEmpty": [
    "2965377540200775924504968637505084669999360240500907972788072774778139588064",
    "17888733104410001265760460027725887240172765470923695174284923303416908725309",
    "6155733123951817300356401771271939707310716210385193729101357561319788034953"
  ],
  "MinaZkappActionStateEmptyElt": [
    "25079927036070901246064867767436987657692091363973573142121686150614948079097",
    "26431778411571512074795067173224334387034335867358343719815640998216694007738",
    "25080775363764450744501815075506845022058095277795060631172637381645274354727"
  ],
  "CoinbaseStack": [
    "13478948633790621346997153068092516261975764161208078295837519850718904039733",
    "23794571567771902109532327523992257297445027552423990566905688786749549749640",
    "12437776415960587857483436445253285567999534294199440886476575966193776753527"
  ],
  "PendingCoinbaseMerkleTree": [
    "21962074494103541153175746450273873003299668759086391980006382367241943398196",
    "2903435713642676558047328375873609628346075739786101737671585224825766548393",
    "25831764682100331646870313396659195191400312071282528592914032765816857800473"
  ]
};
var prefixHashesLegacy = {
  "CodaReceiptUC*******": [
    "17081977821176270994512651394491195177111442160604726653596300537904083542874",
    "22524836078442467808299966370016521142448937585030982609163888361124501146539",
    "12924279821307137198726349959646209575189430925513631516289320462608412110369"
  ],
  "MinaSignatureMainnet": [
    "25220214331362653986409717908235786107802222826119905443072293294098933388948",
    "7563646774167489166725044360539949525624365058064455335567047240620397351731",
    "171774671134240704318655896509797243441784148630375331692878460323037832932"
  ],
  "CodaSignature*******": [
    "28132119227444686413214523693400847740858213284875453355294308721084881982354",
    "24895072146662946646133617369498198544578131474807621989761680811592073367193",
    "3216013753133880902260672769141972972810073620591719805178695684388949134646"
  ]
};
var versionBytes = {
  "tokenIdKey": 28,
  "receiptChainHash": 12,
  "ledgerHash": 5,
  "epochSeed": 13,
  "stateHash": 16,
  "publicKey": 203,
  "userCommandMemo": 20,
  "privateKey": 90,
  "signature": 154,
  "transactionHash": 29,
  "signedCommandV1": 19
};
var protocolVersions = { "txnVersion": 3 };
var poseidonParamsKimchiFp = {
  "mds": [
    [
      "12035446894107573964500871153637039653510326950134440362813193268448863222019",
      "25461374787957152039031444204194007219326765802730624564074257060397341542093",
      "27667907157110496066452777015908813333407980290333709698851344970789663080149"
    ],
    [
      "4491931056866994439025447213644536587424785196363427220456343191847333476930",
      "14743631939509747387607291926699970421064627808101543132147270746750887019919",
      "9448400033389617131295304336481030167723486090288313334230651810071857784477"
    ],
    [
      "10525578725509990281643336361904863911009900817790387635342941550657754064843",
      "27437632000253211280915908546961303399777448677029255413769125486614773776695",
      "27566319851776897085443681456689352477426926500749993803132851225169606086988"
    ]
  ],
  "roundConstants": [
    [
      "21155079691556475130150866428468322463125560312786319980770950159250751855431",
      "16883442198399350202652499677723930673110172289234921799701652810789093522349",
      "17030687036425314703519085065002231920937594822150793091243263847382891822670"
    ],
    [
      "25216718237129482752721276445368692059997901880654047883630276346421457427360",
      "9054264347380455706540423067244764093107767235485930776517975315876127782582",
      "26439087121446593160953570192891907825526260324480347638727375735543609856888"
    ],
    [
      "15251000790817261169639394496851831733819930596125214313084182526610855787494",
      "10861916012597714684433535077722887124099023163589869801449218212493070551767",
      "18597653523270601187312528478986388028263730767495975370566527202946430104139"
    ],
    [
      "15831416454198644276563319006805490049460322229057756462580029181847589006611",
      "15171856919255965617705854914448645702014039524159471542852132430360867202292",
      "15488495958879593647482715143904752785889816789652405888927117106448507625751"
    ],
    [
      "19039802679983063488134304670998725949842655199289961967801223969839823940152",
      "4720101937153217036737330058775388037616286510783561045464678919473230044408",
      "10226318327254973427513859412126640040910264416718766418164893837597674300190"
    ],
    [
      "20878756131129218406920515859235137275859844638301967889441262030146031838819",
      "7178475685651744631172532830973371642652029385893667810726019303466125436953",
      "1996970955918516145107673266490486752153434673064635795711751450164177339618"
    ],
    [
      "15205545916434157464929420145756897321482314798910153575340430817222504672630",
      "25660296961552699573824264215804279051322332899472350724416657386062327210698",
      "13842611741937412200312851417353455040950878279339067816479233688850376089318"
    ],
    [
      "1383799642177300432144836486981606294838630135265094078921115713566691160459",
      "1135532281155277588005319334542025976079676424839948500020664227027300010929",
      "4384117336930380014868572224801371377488688194169758696438185377724744869360"
    ],
    [
      "21725577575710270071808882335900370909424604447083353471892004026180492193649",
      "676128913284806802699862508051022306366147359505124346651466289788974059668",
      "25186611339598418732666781049829183886812651492845008333418424746493100589207"
    ],
    [
      "10402240124664763733060094237696964473609580414190944671778761753887884341073",
      "11918307118590866200687906627767559273324023585642003803337447146531313172441",
      "16895677254395661024186292503536662354181715337630376909778003268311296637301"
    ],
    [
      "23818602699032741669874498456696325705498383130221297580399035778119213224810",
      "4285193711150023248690088154344086684336247475445482883105661485741762600154",
      "19133204443389422404056150665863951250222934590192266371578950735825153238612"
    ],
    [
      "5515589673266504033533906836494002702866463791762187140099560583198974233395",
      "11830435563729472715615302060564876527985621376031612798386367965451821182352",
      "7510711479224915247011074129666445216001563200717943545636462819681638560128"
    ],
    [
      "24694843201907722940091503626731830056550128225297370217610328578733387733444",
      "27361655066973784653563425664091383058914302579694897188019422193564924110528",
      "21606788186194534241166833954371013788633495786419718955480491478044413102713"
    ],
    [
      "19934060063390905409309407607814787335159021816537006003398035237707924006757",
      "8495813630060004961768092461554180468161254914257386012937942498774724649553",
      "27524960680529762202005330464726908693944660961000958842417927307941561848461"
    ],
    [
      "15178481650950399259757805400615635703086255035073919114667254549690862896985",
      "16164780354695672259791105197274509251141405713012804937107314962551600380870",
      "10529167793600778056702353412758954281652843049850979705476598375597148191979"
    ],
    [
      "721141070179074082553302896292167103755384741083338957818644728290501449040",
      "22044408985956234023934090378372374883099115753118261312473550998188148912041",
      "27068254103241989852888872162525066148367014691482601147536314217249046186315"
    ],
    [
      "3880429241956357176819112098792744584376727450211873998699580893624868748961",
      "17387097125522937623262508065966749501583017524609697127088211568136333655623",
      "6256814421247770895467770393029354017922744712896100913895513234184920631289"
    ],
    [
      "2942627347777337187690939671601251987500285937340386328746818861972711408579",
      "24031654937764287280548628128490074801809101323243546313826173430897408945397",
      "14401457902976567713827506689641442844921449636054278900045849050301331732143"
    ],
    [
      "20170632877385406450742199836933900257692624353889848352407590794211839130727",
      "24056496193857444725324410428861722338174099794084586764867109123681727290181",
      "11257913009612703357266904349759250619633397075667824800196659858304604714965"
    ],
    [
      "22228158921984425749199071461510152694025757871561406897041788037116931009246",
      "9152163378317846541430311327336774331416267016980485920222768197583559318682",
      "13906695403538884432896105059360907560653506400343268230130536740148070289175"
    ],
    [
      "7220714562509721437034241786731185291972496952091254931195414855962344025067",
      "27608867305903811397208862801981345878179337369367554478205559689592889691927",
      "13288465747219756218882697408422850918209170830515545272152965967042670763153"
    ],
    [
      "8251343892709140154567051772980662609566359215743613773155065627504813327653",
      "22035238365102171608166944627493632660244312563934708756134297161332908879090",
      "13560937766273321037807329177749403409731524715067067740487246745322577571823"
    ],
    [
      "21652518608959234550262559135285358020552897349934571164032339186996805408040",
      "22479086963324173427634460342145551255011746993910136574926173581069603086891",
      "13676501958531751140966255121288182631772843001727158043704693838707387130095"
    ],
    [
      "5680310394102577950568930199056707827608275306479994663197187031893244826674",
      "25125360450906166639190392763071557410047335755341060350879819485506243289998",
      "22659254028501616785029594492374243581602744364859762239504348429834224676676"
    ],
    [
      "23101411405087512171421838856759448177512679869882987631073569441496722536782",
      "24149774013240355952057123660656464942409328637280437515964899830988178868108",
      "5782097512368226173095183217893826020351125522160843964147125728530147423065"
    ],
    [
      "13540762114500083869920564649399977644344247485313990448129838910231204868111",
      "20421637734328811337527547703833013277831804985438407401987624070721139913982",
      "7742664118615900772129122541139124149525273579639574972380600206383923500701"
    ],
    [
      "1109643801053963021778418773196543643970146666329661268825691230294798976318",
      "16580663920817053843121063692728699890952505074386761779275436996241901223840",
      "14638514680222429058240285918830106208025229459346033470787111294847121792366"
    ],
    [
      "17080385857812672649489217965285727739557573467014392822992021264701563205891",
      "26176268111736737558502775993925696791974738793095023824029827577569530708665",
      "4382756253392449071896813428140986330161215829425086284611219278674857536001"
    ],
    [
      "13934033814940585315406666445960471293638427404971553891617533231178815348902",
      "27054912732979753314774418228399230433963143177662848084045249524271046173121",
      "28916070403698593376490976676534962592542013020010643734621202484860041243391"
    ],
    [
      "24820015636966360150164458094894587765384135259446295278101998130934963922381",
      "7969535238488580655870884015145760954416088335296905520306227531221721881868",
      "7690547696740080985104189563436871930607055124031711216224219523236060212249"
    ],
    [
      "9712576468091272384496248353414290908377825697488757134833205246106605867289",
      "12148698031438398980683630141370402088785182722473169207262735228500190477924",
      "14359657643133476969781351728574842164124292705609900285041476162075031948227"
    ],
    [
      "23563839965372067275137992801035780013422228997724286060975035719045352435470",
      "4184634822776323233231956802962638484057536837393405750680645555481330909086",
      "16249511905185772125762038789038193114431085603985079639889795722501216492487"
    ],
    [
      "11001863048692031559800673473526311616702863826063550559568315794438941516621",
      "4702354107983530219070178410740869035350641284373933887080161024348425080464",
      "23751680507533064238793742311430343910720206725883441625894258483004979501613"
    ],
    [
      "28670526516158451470169873496541739545860177757793329093045522432279094518766",
      "3568312993091537758218792253361873752799472566055209125947589819564395417072",
      "1819755756343439646550062754332039103654718693246396323207323333948654200950"
    ],
    [
      "5372129954699791301953948907349887257752247843844511069896766784624930478273",
      "17512156688034945920605615850550150476471921176481039715733979181538491476080",
      "25777105342317622165159064911913148785971147228777677435200128966844208883059"
    ],
    [
      "25350392006158741749134238306326265756085455157012701586003300872637887157982",
      "20096724945283767296886159120145376967480397366990493578897615204296873954844",
      "8063283381910110762785892100479219642751540456251198202214433355775540036851"
    ],
    [
      "4393613870462297385565277757207010824900723217720226130342463666351557475823",
      "9874972555132910032057499689351411450892722671352476280351715757363137891038",
      "23590926474329902351439438151596866311245682682435235170001347511997242904868"
    ],
    [
      "17723373371137275859467518615551278584842947963894791032296774955869958211070",
      "2350345015303336966039836492267992193191479606566494799781846958620636621159",
      "27755207882790211140683010581856487965587066971982625511152297537534623405016"
    ],
    [
      "6584607987789185408123601849106260907671314994378225066806060862710814193906",
      "609759108847171587253578490536519506369136135254150754300671591987320319770",
      "28435187585965602110074342250910608316032945187476441868666714022529803033083"
    ],
    [
      "16016664911651770663938916450245705908287192964254704641717751103464322455303",
      "17551273293154696089066968171579395800922204266630874071186322718903959339163",
      "20414195497994754529479032467015716938594722029047207834858832838081413050198"
    ],
    [
      "19773307918850685463180290966774465805537520595602496529624568184993487593855",
      "24598603838812162820757838364185126333280131847747737533989799467867231166980",
      "11040972566103463398651864390163813377135738019556270484707889323659789290225"
    ],
    [
      "5189242080957784038860188184443287562488963023922086723850863987437818393811",
      "1435203288979376557721239239445613396009633263160237764653161500252258220144",
      "13066591163578079667911016543985168493088721636164837520689376346534152547210"
    ],
    [
      "17345901407013599418148210465150865782628422047458024807490502489711252831342",
      "22139633362249671900128029132387275539363684188353969065288495002671733200348",
      "1061056418502836172283188490483332922126033656372467737207927075184389487061"
    ],
    [
      "10241738906190857416046229928455551829189196941239601756375665129874835232299",
      "27808033332417845112292408673209999320983657696373938259351951416571545364415",
      "18820154989873674261497645724903918046694142479240549687085662625471577737140"
    ],
    [
      "7983688435214640842673294735439196010654951226956101271763849527529940619307",
      "17067928657801807648925755556866676899145460770352731818062909643149568271566",
      "24472070825156236829515738091791182856425635433388202153358580534810244942762"
    ],
    [
      "25752201169361795911258625731016717414310986450004737514595241038036936283227",
      "26041505376284666160132119888949817249574689146924196064963008712979256107535",
      "23977050489096115210391718599021827780049209314283111721864956071820102846008"
    ],
    [
      "26678257097278788410676026718736087312816016749016738933942134600725962413805",
      "10480026985951498884090911619636977502506079971893083605102044931823547311729",
      "21126631300593007055117122830961273871167754554670317425822083333557535463396"
    ],
    [
      "1564862894215434177641156287699106659379648851457681469848362532131406827573",
      "13247162472821152334486419054854847522301612781818744556576865965657773174584",
      "8673615954922496961704442777870253767001276027366984739283715623634850885984"
    ],
    [
      "2794525076937490807476666942602262298677291735723129868457629508555429470085",
      "4656175953888995612264371467596648522808911819700660048695373348629527757049",
      "23221574237857660318443567292601561932489621919104226163978909845174616477329"
    ],
    [
      "1878392460078272317716114458784636517603142716091316893054365153068227117145",
      "2370412714505757731457251173604396662292063533194555369091306667486647634097",
      "17409784861870189930766639925394191888667317762328427589153989811980152373276"
    ],
    [
      "25869136641898166514111941708608048269584233242773814014385564101168774293194",
      "11361209360311194794795494027949518465383235799633128250259863567683341091323",
      "14913258820718821235077379851098720071902170702113538811112331615559409988569"
    ],
    [
      "12957012022018304419868287033513141736995211906682903915897515954290678373899",
      "17128889547450684566010972445328859295804027707361763477802050112063630550300",
      "23329219085372232771288306767242735245018143857623151155581182779769305489903"
    ],
    [
      "1607741027962933685476527275858938699728586794398382348454736018784568853937",
      "2611953825405141009309433982109911976923326848135736099261873796908057448476",
      "7372230383134982628913227482618052530364724821976589156840317933676130378411"
    ],
    [
      "20203606758501212620842735123770014952499754751430660463060696990317556818571",
      "4678361398979174017885631008335559529633853759463947250620930343087749944307",
      "27176462634198471376002287271754121925750749676999036165457559387195124025594"
    ],
    [
      "6361981813552614697928697527332318530502852015189048838072565811230204474643",
      "13815234633287489023151647353581705241145927054858922281829444557905946323248",
      "10888828634279127981352133512429657747610298502219125571406085952954136470354"
    ]
  ],
  "fullRounds": 55,
  "partialRounds": 0,
  "hasInitialRoundConstant": false,
  "stateSize": 3,
  "rate": 2,
  "power": 7
};
var poseidonParamsLegacyFp = {
  "mds": [
    [
      "5328350144166205084223774245058198666309664348635459768305312917086056785354",
      "15214731724107930304595906373487084110291887262136882623959435918484004667388",
      "22399519358931858664262538157042328690232277435337286643350379269028878354609"
    ],
    [
      "10086628405675314879458652402278736459294354590428582803795166650930540770072",
      "17127968360683744052278857147989507037142007029142438136689352416106177192235",
      "14207324749280135281015658576564097509614634975132487654324863824516044294735"
    ],
    [
      "3059104278162906687184746935153057867173086006783171716838577369156969739687",
      "16755849208683706534025643823697988418063305979108082130624352443958404325985",
      "16889774624482628108075965871448623911656600744832339664842346756371603433407"
    ]
  ],
  "roundConstants": [
    [
      "1346081094044643970582493287085428191977688221215786919106342366360741041016",
      "10635969173348128974923358283368657934408577270968219574411363948927109531877",
      "18431955373344919956072236142080066866861234899777299873162413437379924987003"
    ],
    [
      "5797044060651575840084283729791357462720161727701814038830889113712361837236",
      "931288489507796144596974766082847744938192694315568692730730202141894005205",
      "13659894470945121760517769979107966886673294523737498361566285362771110125394"
    ],
    [
      "6076231707445968054305995680347976771585015308155855387339303513025362636128",
      "28822740034050339685362260108484262889265034407340240070058997651710236456303",
      "23420266473857869790486107029614186913447272961845992963194006142267563993493"
    ],
    [
      "13753917374184785903125509246122783296344288469304898921025291716613575849357",
      "22396739346703340038555577564698139382745239004673153148674304627904081092826",
      "13064238335532551154986111986409392866270911640785653458047811526842088084911"
    ],
    [
      "23165923875642452719095776619341762858050322341374771345641255745672274104746",
      "1876216571769482372914291210815859835162659440705283782713345335434924136736",
      "25448252060136178247213604035267580231762596830634036926922217427938159849142"
    ],
    [
      "2161875315509206970842862195937323600322108268401381254431163181777726747153",
      "19159855698625842998331760283165907305622417625829203038229273729196960321630",
      "24828563875172432296791053766778475681869974948122169083176331088266823626561"
    ],
    [
      "15959479662608710141128458274961057999257961784282074767105536637788386907463",
      "8006369581283017287449277389162056290714176164680299906116833200510117952858",
      "18794336794618132129607701188430371953320538976527988886453665523008714542779"
    ],
    [
      "19408271715954593722501381885401160867835377473312521553027032015227895029571",
      "13654747284005184272412579731446984220568337794941823533879059135026064413631",
      "14094055032353750931629930778481002727722804310855727808905931659115939920989"
    ],
    [
      "13241818625838429282823260827177433104574315653706102174619924764342778921524",
      "25709259239494174564705048436260891089407557689981668111890003079561388887725",
      "26866626910239634723971078462134580196819809568632305020800296809092442642381"
    ],
    [
      "23886826350713085163238005260075062110062681905356997481925492650252417143049",
      "16853602711255261520713463306790360324679500458440235992292027384928526778856",
      "18444710386168488194610417945072711530390091945738595259171890487504771614189"
    ],
    [
      "16896789009769903615328691751424474161656500693270070895928499575572871141439",
      "23842266984616972287898037872537536999393060934879414668030219493005225085992",
      "24369698563802298585444760814856330583118549706483939267059237951238240608187"
    ],
    [
      "25360195173713628054110426524260405937218170863260484655473435413697869858790",
      "1486437708678506228822038923353468635394979165769861487132708983207562337116",
      "18653498960429911228442559598959970807723487073275324556015861725806677047150"
    ],
    [
      "18878179044241268037057256060083772636369783391816038647949347814518015576522",
      "178715779905629247116805974152863592571182389085419970371289655361443016848",
      "8381006794425876451998903949255801618132578446062133243427381291481465852184"
    ],
    [
      "4176946262813877719206528849579392120806054050640974718891398605746592169324",
      "16376345520728802444699629729684297833862527190772376028981704525651968727081",
      "8399065769082251057361366626601550736334213197703006866551331927128775757919"
    ],
    [
      "15435308585611812393531506745122614542196708285088622615406141986333182280857",
      "4082259282787276939431186930090898350392871145699460879678141552997816391817",
      "26348742719959309014730178326877937464605873211235784184917342950648457078699"
    ],
    [
      "9707631711734344681918469569872517425107158187591261754498805460753455298868",
      "27910768846011709391567916011595957279088224137468948238696800459136335473132",
      "20407239095656434708569263842372155762970847207558227886302782130015730063802"
    ],
    [
      "22726225412881182965250630589245572283256255052470345984553083359461473893802",
      "12443967854426795490638709950679156338200426963050610832781263082981525248175",
      "27102543658848146076219989119639465430524061997280788166887046421706499775415"
    ],
    [
      "14427224233985680214097547669945064793149553513421479297921556194475574770861",
      "22917454832925781549840198815703114840452733537799472739275668965081704937832",
      "3455076056123630366063931123762198941796412458154689469887583689725886013901"
    ],
    [
      "4513100023937785913596662867311227004762025658663076805918211014066645403017",
      "18187619530784075723418065322038024507729605774832001333883311123910954334059",
      "9447065431426150382325592560406989926365684509675374414068135115024495130938"
    ],
    [
      "3227816098015819796753427754968234889554095489076864339942014527747604603014",
      "14798316759185072116520458171957899889489461918408669809912344751222514418582",
      "23013904852315603905843158448056763116188801262838729536210355401378476650033"
    ],
    [
      "20979191509934291452182967564058656088941447895799901211038858159903580333267",
      "20772973010251235271448378823573767262405703078344288856168565499702414379868",
      "10105446427739226002497411811738001382334316505480517822035303561899927603685"
    ],
    [
      "11079074761356717003579108002319997196881121172538617046865136940931215263187",
      "4693927775411489288330326150094711670434597808961717172753867514688725690438",
      "18581720304902876944842830383273503265470859268712618325357902881821721540119"
    ],
    [
      "3065369948183164725765083504606321683481629263177690053939474679689088169185",
      "18515622379147081456114962668688706121098539582467584736624699157043365677487",
      "17563088600719312877716085528177751048248154461245613291986010180187238198006"
    ],
    [
      "26199746176994924146211004840756471702409132230831594954444947705902602287290",
      "7576136600627345523051497639367002272003104458453478964661395239732811642605",
      "20058687874612168338994287374025378897088936171250328231848098497610185784281"
    ],
    [
      "16894722532414195606958290526999761110785277556463400588047573469106594850228",
      "13961730805696859614283621225672002906734926278118993580398533742874863598733",
      "25256842011135514243352951950573936602906198374305137963222382546140030647211"
    ],
    [
      "18530360047537856737482157200091774590035773602620205695980247565433703032532",
      "23014819965938599260086897799541446473887833964178378497976832161473586995397",
      "27911426213258307990762460361663504655967992659180759140364181941291843542489"
    ],
    [
      "1067338118323302017358103178057182291035336430305886255160210378977812067042",
      "17219092885519007424608854460610388434712113621163885775309496940189894433620",
      "16432921127615937542183846559291144733339643093361323334499888895135356545408"
    ],
    [
      "28608851042959977114787048070153637607786033079364369200270218128830983558707",
      "10121629780013165888398831090128011045011860641816380162950736555305748332191",
      "2348036340843128746981122630521268144839343500596932561106759754644596320722"
    ],
    [
      "16619881370356823200358060093334065394764987467483650323706184068451904156452",
      "2302436627861989749837563733434625231689351276818486757748445924305258835336",
      "27514536540953539473280001431110316405453388911725550380123851609652679788049"
    ],
    [
      "9459277727420672604737117687200019308525004979918488827092207438664125039815",
      "23425670740358068509956137586663046763224562225383386726193078231034380596217",
      "7641885067011661443791509688937280323563328029517832788240965464798835873658"
    ],
    [
      "9579420382351699601929202663836555665702024548386778299996961509578687980280",
      "18513671386572584282611234979588379470994484682444053600751415262497237017703",
      "24923151431234706142737221165378041700050312199585085101919834422744926421604"
    ],
    [
      "21131320841803068139502705966375283830095161079635803028011171241658723560073",
      "19208476595309656066589572658712717685014329237892885950958199953675225096566",
      "24023185216737416080949689106968568821656545490748664446389634158498624398204"
    ],
    [
      "7510552996848634969347937904645640209946785877619890235458182993413526028718",
      "3694415017252995094553868781762548289196990492336482360084813900937464847638",
      "9219021070107873028263141554048987416559034633883158827414043929220388719352"
    ],
    [
      "5058327241234443421111591959922712922949620710493120384930391763032694640881",
      "13148252221647574076185511663661016015859769210867362839817254885265598775418",
      "15186790492457240277904880519227706403545816456632095870015828239411033220638"
    ],
    [
      "2775942914650502409705888572245750999561427024488403026572311267798009048466",
      "6277965230841030155341171319927732572492215818164736949144854827643964384893",
      "24144742149845235561087977558785057713814731737434473021812189457617252043745"
    ],
    [
      "25789129719327437503403457598813971826156253950521984610569937361506914183550",
      "21500534320778995945845999974779950304491968082325255355181901574840373597824",
      "17185359848218837018503091932245529880546896465437232425673134558221638601375"
    ],
    [
      "12253896579078110143384981818031883112606762215016553811786428215758384195713",
      "12956658260778456372481429232709881794962204180363200699121804724437678625542",
      "3023603786717368708677300377055384474816569333060487675635618249403832078921"
    ],
    [
      "4186492855716808019562789862833898284927736051002588766326482010810259565130",
      "4263939782228419774639068267872291539552889472311225829898746091327730032923",
      "24068843626280451423530509388397151179174104901782990365720205643492047328816"
    ],
    [
      "14564937827374621319716285527475223392664010281568256859627186463065876537730",
      "28367596550218705971881480694115935470211319172596432472834880507822452927283",
      "28712267437482356021504544448225827500268648754270274754623969882031853409874"
    ],
    [
      "4542596163006916397403529184431773692747461300288194722982487051249951403191",
      "2530461821259252672899452671728393208543894014761816288817584587718369998371",
      "12886393063011539390567049190923398676964700147222878509238966758839020897414"
    ],
    [
      "21593897590707514492037699253654745501762191795293908682495110982956631870528",
      "13233005790593128135480716846773978578237145313006994631606474472023504621256",
      "21621863098292803642478350494794106282518362577273973885587684567452726939909"
    ],
    [
      "26068620073001644720969640099644251616742620988609091568084348314770436291745",
      "18248589586787935500122854210401321966459127818593446990365211078521058875685",
      "21247134484403265289037859533347798468858819117600251067578809852124865474448"
    ],
    [
      "7947383127165915366383984718363902897504221803836013123394785749404572432524",
      "22173041014621867335598230447618036223462011647696367239478182269973488867154",
      "16773227734018849308448505860847939069870370055633571816925675705713088305139"
    ],
    [
      "10708707957340055662073314227607620808612686977606082605219160019699644826999",
      "21249897193797038261479589555720746994050836195265348846222835266344091683000",
      "12581195059139097540117398803363514148192715293133623516709277290477633379593"
    ],
    [
      "19779599816866992123290302397082614570282926215253589712189610064229996603178",
      "21749216503901548676985371189807470207364320167486559936962401093285243029177",
      "17600045923623503357380202389718735904174992978547372448837488832457719009224"
    ],
    [
      "2732872979548118117758016335601225525660858727422778256671975055129965858636",
      "13703031005128062046175331918702218558750713240446179585947851411173844703597",
      "28447710105386636841938034820015573492556750872924193415447818187228356409281"
    ],
    [
      "28539960355005748517007309210788803416171161412204526246799800716567376494244",
      "21329318452221893900731030722137844458345358926323127858742388587761302609863",
      "28135302149599894709369178097439582767613940517471323224020113411362601191873"
    ],
    [
      "24980774120400248734054527936006392540889095705961960837980443629260392758683",
      "20339911045808632098936066397942175169549806052128535543540543556255197716643",
      "7929293103930252545581851978492699598413941396422930641071359388697302362494"
    ],
    [
      "8911092207145893152276662096451247820054843777071569723455408545101628926203",
      "19648860643145256523615441075182036100116634560394529500146405733687718224516",
      "14635387208623683806428528837466762532853903031263830054986064902455379735903"
    ],
    [
      "11555212214346132926966321609673228184079851030522218543981385635403167028692",
      "20896918157639814425520058178561910811657326967880217845710779511927814874973",
      "4650158165912007049140499755153804318686705949436165235742106170124284287326"
    ],
    [
      "13880660273492757167295696447853232191657893303250187467329180558670697369810",
      "8043529172463774320604378774840863923445982272478964686447801046272917236836",
      "2134399296482715903442913099374581981696436050603410080564843555725771329441"
    ],
    [
      "27320952903412641133501507962185246982787769547770982814240701526492601978122",
      "23417491374379751329394424924400186404791519133465537872457405970098902747611",
      "17612427354278346772575179176139417348059847375297761006336024476146551185903"
    ],
    [
      "10710998507064742997612080847223278109404482930427999113323732519626499166548",
      "14958094513415797513745395709487730603918953350067504982704138489305723550923",
      "24096319595904213497633343966229498735553590589105811393277073274927955202995"
    ],
    [
      "17983724131200292654039765185049138356840415443160477259330748730019147254309",
      "17598096800487588874709548646068838880468456205252324677357706597166777506441",
      "27420647821110229619898200875848631488422182349567475956209153112306555222281"
    ],
    [
      "448538544835457571662601142415301047108854812427100562339376187510452313026",
      "23494184556634922103535803143214434479598067155171780264810485708203176455201",
      "22626342941879801989161990529511235538216563009907378573817996229389756621777"
    ],
    [
      "26128268137723417163973860961686381960826033145738852158792607959175787222856",
      "20225791828042873305317281581105429726352058325970107209484198122707862156597",
      "7538871133759632802857159609785118198934349221046986784429069814655215585732"
    ],
    [
      "26184554861259642274153262777073624024579929401668865520166966302070394487366",
      "28755259264665180745537307265993667261709206143628938749669440804401623257679",
      "11896066093033549470312328497237649508068258723531931099214795928200015717321"
    ],
    [
      "21657721599978732693249012287058163532690942515202465984736373311077240614059",
      "9214914097169852704753116653702415951907628005986883140609006971322091003693",
      "18710111680849814325169297240208687402588261569152088592693815711857504371037"
    ],
    [
      "6813635166770764528979084175325709935892248249948967889926276426090222296643",
      "20546585456429436268067726231902751119458200511988152296570567167520382569278",
      "20087466019194902429054761607398988292568594301671509779549344754172952693871"
    ],
    [
      "28185105286740691904534067831357491310995891986363455251895371651360605333143",
      "10108348212894231193041286244259038275269464277821588425688314560368589986063",
      "11433633215392393209829215018579238412423821563056156785641278458497271271546"
    ],
    [
      "27870881917195016999862550657996865268956893566432995492427618003637597051321",
      "102309803677783876701097881491240456320211833502658383473112057006867019389",
      "22844040227595875612525628393174357057929113317578127744718774517498324646590"
    ],
    [
      "18364790233947478619325319418813215212267974311771564959136180502266118026133",
      "2480624341921718230432383518425561514824501138863702825916674641657321180841",
      "16778939567530361665956758171503829349658551798564323167725356065198936433124"
    ],
    [
      "11947564511486966895926950599696532964589539443187518177489990556481125699966",
      "3133187646540385483015602955087323554103587039123577645562801570574691666057",
      "27704797101265438206569218421707753788081674727344603874614391656565567951541"
    ],
    [
      "13001484695584753475562184349533365512515447041450030471627087395341039487710",
      "477322000667279478600757543806155989948171541982639893984064422067850617496",
      "13913755821658634147813329813115566967428755223601185963529801459396673113438"
    ],
    [
      "16621869429023470107454028095846067937827722393398508604914831452950874033411",
      "21755744236927410239079501831014076529931327263341620300431356747367343619046",
      "26538666591151124505694487799121414506088199961481579132019627484065014831180"
    ],
    [
      "3066480818457008068617042549071052338581291837882909165666223566402713429090",
      "16182268213934119294035309949459684472027705439038023775276926916166831108357",
      "28907604876608422892474268478706783033050951245339691569015166507728369585190"
    ],
    [
      "27973960109508292680965426133498827831691369851701664449575719912259359998113",
      "1456924360278399121996742356757866616312146358469991014696110099534285524446",
      "8234248752911525485438611255163504976087091103090603316695312869292347668495"
    ],
    [
      "8716078950082339630026654067608811496722305720644485560320987802533380421009",
      "19016744645809919602099479306503354923553336014593353020688463619133130053825",
      "24379650661051444982012238084495990858827340608012118841005379796362233056432"
    ],
    [
      "2245379544097631382062919677963998259142792890502492881341386639439507471783",
      "28788137434161061988371619554419440748189388934884757179010092973102292086583",
      "7187000185648741287953633167647835668543536354944774631102766873251849991238"
    ],
    [
      "18319349500538500800225762827448369057030532278398270164660609327776487168142",
      "2622932985948021877314529887962683530522545893985767148345336304947201715671",
      "13805188629797792210337544360632964855143280581052079479249966961215582531026"
    ],
    [
      "27457600993464082637917106210690168172469473943609357897393615707457194410878",
      "15448646156961779103834447043970817898237835202826003934642165760908058355399",
      "9396792545729486882231669677795667529746274932273033601723318032992363022062"
    ],
    [
      "9927877141952679457141759789181418464292082444806533413864151258248124544859",
      "23827901395971835838179844085051957393677906360196119690926757794561937573142",
      "3273544693673216914876067527455588276979859627093391584406340272737391174619"
    ],
    [
      "19571510438350300564152393820251652609646082150148656806391655428002614034315",
      "4458840243585913642400750597703353770666314833058197517675446022682775625834",
      "6452218213610300363069953741424106105609715382419342511693148495219793324457"
    ],
    [
      "14558167930891460678441266912176752652821641543245953113671886345167213541771",
      "10650967986920075561478528461783351160938460620955779955379459848889204404950",
      "19990009778942542934049216419052172134625404062770188357110708518621145688588"
    ],
    [
      "26855242974447190235826233682457047761532515293146087151296725996543442567035",
      "22785340043356532865086769889360674409753343398766563441587096485751538658065",
      "28603049427449348335651629195385434188071937908693764500052489540779792538285"
    ],
    [
      "20545812864989828913452616721240947168977365844984763819184465128164378967167",
      "23234068381345797209897730226956922073109641728569353961504167817770340037954",
      "26031714567641615877877111172701145299483019910006153132858512509897185854695"
    ],
    [
      "9512221744061419790435674197238913998387834650389922233458121639503195504983",
      "12587458000103271975978240683793268604398305885278203470492658961734100340536",
      "9670291694005369437277651504604785512303147991710650505302465204429311229197"
    ],
    [
      "26995526763045548800439747262386290359229145489609341602564040676717570935439",
      "23742712112104280264401317024221734961713400615669958343926511931219510484675",
      "27931469778579449247589315744656633392873808631802461175539563849884447358271"
    ],
    [
      "20669006894143187877081688942720159738269397552445286314270368345994751825389",
      "26891772301075275370472640177651637211280740381619976926886106618375467277414",
      "28387986011980449959047232529988203397251084614417760995257355718700961696092"
    ],
    [
      "6579105010484741592730389416372694666279917604793318157514380025250233913402",
      "11007035767869292700964744408562802781669930023548892567535397874932420229930",
      "981148366863906885900456473323410468923514528856216824044152942069412627408"
    ],
    [
      "22213671088722307302576907504985884923571642958053627659840326928319445671280",
      "1318836216310789598614608105109389429335273432455224127576823891011367206122",
      "25586582796990779718352441955439394949194222626688223867952982491529809559257"
    ],
    [
      "4923739488579452777913681531125585976446366144127161879759262506690369040090",
      "23505612338866210737103599484620591026802005128655081877133994175016351514827",
      "323887003859465324514901860965142186539600668250760639664361851354147799637"
    ],
    [
      "10198923064967306784017949469108033682156920551672348936591491217255268794658",
      "9593680688139131432883442351722730169325112619984238956948153423155998917175",
      "27027988263960602112273050725720071355535922812577299127302015348825197871870"
    ],
    [
      "14419883951157390867695097127684346981136020111885301573583640959136319507752",
      "5104414988075833278683649298543440897371415916271358703850262680431809374355",
      "24739655595299332818980677669648719986462429574612913501586844601377825836782"
    ],
    [
      "28522818684103966731129743408029731246564480741348128436668680764518115102581",
      "21520350704208288978690888796633940487888044365108767319141211249242880355961",
      "17391005598311948834360476853940353239444383292422171321575043660157438608537"
    ],
    [
      "15367833944125677011173327826570204350687925236257190051755087781855930646142",
      "21715073802090413714601069529558707101797361591183718695054701329871284436172",
      "8994093285353831008525761670339342200997965950202092028313103110478252647618"
    ],
    [
      "8370824693889782161629525898408725452177580012023459750897244954935682978671",
      "16123253540853556024347150096993154278773652905830608614979368087152152043083",
      "3535380953353495025888433493640531836449699255364366295870140701379497967423"
    ],
    [
      "6954518484798178646508803478426114267143074508396663899281411171704702743829",
      "28903134801897070276701950388422104654018369750191967384271618837091859516942",
      "20872505363530172448468374920196608937030884647150175861507911076568784054834"
    ],
    [
      "6902861581703501105786795670676641959401710346423594578401934671029571262513",
      "10124161387604183369443890585742198433184078889862870469507328332805848271064",
      "10488004060799269337071647841224034919633445750252076195310163972966405029030"
    ],
    [
      "507704911991278613147490289466075160618843900088471236546244459176211783848",
      "7252739745607302667257774481690407709040936359589867974787811552896597703097",
      "23278073497974004442836030100920157527910770509761505828038443336325476654930"
    ],
    [
      "22766285055433137793164317120096790621982728188995759745859222009100808389090",
      "23129058299483468195787339200845749049960038336751758017949899311636830205152",
      "16665333681978951552434356320651834889869437822496200946959897681307959400425"
    ],
    [
      "12145699202182574939376505075528461451757079041659894988784442097333218352048",
      "26340666275844437932755852805027863696219004039301187587209926587657008948704",
      "19208771804191839410002226941825269105677187954811130189835856228258013753206"
    ],
    [
      "21957102494792377508237608216278079874536155315851198461024084071231867104453",
      "6933367436450995525851693784691226222726503560893470094614235356287049091852",
      "15707767379191450768747057313641112321773921923533732633534831270357733757271"
    ],
    [
      "27661963645951389261638591385668507557739541354225916772550248746235106571003",
      "19699458096897937575096494582288688995241392471402204995195057374756282223421",
      "902873385171181344315871113842580653512118892800584003934454469411716098791"
    ],
    [
      "17184835876565576154014372215369798779520343573944211203710896053325717110660",
      "664657295519303589036289440053175741110032988007278988577620229144220576240",
      "10803972669668998371638869508774217165881281885838503958226056357738500321396"
    ],
    [
      "2329846733754251453632375727999372856194157027336139087170310553870624325301",
      "14139944357035048486675740400655356660678187875721949218090128899571575479791",
      "18368148273419807418427674359327442879484531833435081951870369910704734685351"
    ],
    [
      "10480273665080572189328459165704340191901489646067580012574464138528963201459",
      "21773636700078124500346009061678153597323236568110076029811348966753228682835",
      "18184268307211429260956076021417309535471438696101133218049142374847151474905"
    ],
    [
      "25957533025669311312382992376854735734491934602484112256289764602447226406852",
      "22223261506176684934865714490719116745135417403915426392159449667435294570739",
      "22937309162832499167063076416585504361695925730111272512450449042837586253575"
    ],
    [
      "16956181785481598286719868503945127919581091625126206673934113115358441284347",
      "8497782777197814773596870810881707148695901557289856910220737358078100998191",
      "21135503731586600979470064722475007625236017670426339278983640892218291297054"
    ],
    [
      "17809297343844488723046665739910571149089769215421130894378638450427880983923",
      "72435395972188389387093550708873189001876361107443937983754878061522372356",
      "7511239878692099209014947248389283109997289411550315391143819429585903287870"
    ]
  ],
  "fullRounds": 63,
  "partialRounds": 0,
  "hasInitialRoundConstant": true,
  "stateSize": 3,
  "rate": 2,
  "power": 5
};
var mocks = {
  "dummyVerificationKeyHash": "3392518251768960475377392625298437850623664973002200885669375116181514017494"
};

// dist/node/lib/ml/base.js
var MlArray = {
  to(arr) {
    return [0, ...arr];
  },
  from([, ...arr]) {
    return arr;
  },
  map([, ...arr], map) {
    return [0, ...arr.map(map)];
  },
  mapTo(arr, map) {
    return [0, ...arr.map(map)];
  },
  mapFrom([, ...arr], map) {
    return arr.map(map);
  }
};
var MlPair = Object.assign(function MlTuple(x, y) {
  return [0, x, y];
}, {
  from([, x, y]) {
    return [x, y];
  },
  first(t) {
    return t[1];
  },
  second(t) {
    return t[2];
  }
});
var MlBool = Object.assign(function MlBool2(b2) {
  return b2 ? 1 : 0;
}, {
  from(b2) {
    return !!b2;
  }
});
var MlOption = Object.assign(function MlOption2(x) {
  return x === void 0 ? 0 : [0, x];
}, {
  from(option) {
    return option === 0 ? void 0 : option[1];
  },
  map(option, map) {
    if (option === 0)
      return 0;
    return [0, map(option[1])];
  },
  mapFrom(option, map) {
    if (option === 0)
      return void 0;
    return map(option[1]);
  },
  mapTo(option, map) {
    if (option === void 0)
      return 0;
    return [0, map(option)];
  },
  isNone(option) {
    return option === 0;
  },
  isSome(option) {
    return option !== 0;
  }
});
var MlResult = {
  ok(t) {
    return [0, t];
  },
  unitError() {
    return [1, 0];
  }
};
var MlTuple2 = {
  map([, ...mlTuple], f) {
    return [0, ...mlTuple.map(f)];
  },
  mapFrom([, ...mlTuple], f) {
    return mlTuple.map(f);
  },
  mapTo(tuple2, f) {
    return [0, ...tuple2.map(f)];
  }
};

// dist/node/bindings/crypto/bindings/util.js
function withPrefix(prefix, obj) {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => {
    return [`${prefix}_${k}`, v];
  }));
}
function mapTuple(tuple2, f) {
  return tuple2.map(f);
}

// dist/node/bindings/crypto/bindings/bigint256.js
var Bigint256Bindings = withPrefix("caml_bigint_256", {
  // TODO
  of_numeral(s, i, j) {
    throw Error("caml_bigint_256_of_numeral not implemented");
  },
  of_decimal_string(s) {
    return [0, BigInt(fromMlString(s))];
  },
  num_limbs() {
    return 4;
  },
  bytes_per_limb() {
    return 8;
  },
  div([, x], [, y]) {
    return [0, x / y];
  },
  compare([, x], [, y]) {
    if (x < y)
      return -1;
    if (x === y)
      return 0;
    return 1;
  },
  print([, x]) {
    console.log(x.toString());
  },
  to_string(x) {
    return toMlStringAscii(x[1].toString());
  },
  // TODO performance critical
  test_bit(b2, i) {
    return MlBool(!!(b2[1] & 1n << BigInt(i)));
  },
  to_bytes([, x]) {
    let ocamlBytes = caml_create_bytes(32);
    for (let i = 0; i < 32; i++) {
      let byte = Number(x & 0xffn);
      caml_bytes_unsafe_set(ocamlBytes, i, byte);
      x >>= 8n;
    }
    if (x !== 0n)
      throw Error("bigint256 doesn't fit into 32 bytes.");
    return ocamlBytes;
  },
  of_bytes(ocamlBytes) {
    let length = ocamlBytes.l;
    if (length > 32)
      throw Error(length + " bytes don't fit into bigint256");
    let x = 0n;
    let bitPosition = 0n;
    for (let i = 0; i < length; i++) {
      let byte = caml_bytes_unsafe_get(ocamlBytes, i);
      x |= BigInt(byte) << bitPosition;
      bitPosition += 8n;
    }
    return [0, x];
  },
  deep_copy([, x]) {
    return [0, x];
  }
});
function fromMlString(s) {
  return s.c;
}
function toMlStringAscii(s) {
  return new MlBytes(9, s, s.length);
}
function caml_bytes_unsafe_get(s, i) {
  switch (s.t & 6) {
    default:
      if (i >= s.c.length)
        return 0;
    case 0:
      return s.c.charCodeAt(i);
    case 4:
      return s.c[i];
  }
}
function caml_bytes_unsafe_set(s, i, c) {
  c &= 255;
  if (s.t != 4) {
    if (i == s.c.length) {
      s.c += String.fromCharCode(c);
      if (i + 1 == s.l)
        s.t = 0;
      return 0;
    }
    caml_convert_bytes_to_array(s);
  }
  s.c[i] = c;
  return 0;
}
function caml_create_bytes(len) {
  return new MlBytes(2, "", len);
}
function caml_convert_bytes_to_array(s) {
  let a2 = new Uint8Array(s.l);
  let b2 = s.c, l4 = b2.length, i = 0;
  for (; i < l4; i++)
    a2[i] = b2.charCodeAt(i);
  for (l4 = s.l; i < l4; i++)
    a2[i] = 0;
  s.c = a2;
  s.t = 4;
  return a2;
}
var MlBytes = class _MlBytes {
  constructor(tag, content, length) {
    this.t = tag;
    this.c = content;
    this.l = length;
  }
  toString() {
    if (this.t === 9)
      return this.c;
    throw Error("todo");
  }
  toUtf16() {
    return this.toString();
  }
  slice() {
    let content = this.t == 4 ? this.c.slice() : this.c;
    return new _MlBytes(this.t, content, this.l);
  }
};

// dist/node/bindings/crypto/bigint-helpers.js
function bytesToBigint32(bytes) {
  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);
  return words[0] | words[1] << 64n | words[2] << 128n | words[3] << 192n;
}
var mask64 = (1n << 64n) - 1n;
function bigintToBytes32(x, bytes) {
  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);
  words[0] = x & mask64;
  words[1] = x >> 64n & mask64;
  words[2] = x >> 128n & mask64;
  words[3] = x >> 192n;
  return bytes;
}
function bytesToBigInt(bytes) {
  let x = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    x += BigInt(byte) << bitPosition;
    bitPosition += 8n;
  }
  return x;
}
var hexToNum = {};
for (let i = 0; i < 16; i++)
  hexToNum[i.toString(16).charCodeAt(0)] = i;
var encoder = new TextEncoder();
var tmpBytes = new Uint8Array(64);
function parseHexString32(input) {
  encoder.encodeInto(input, tmpBytes);
  for (let j = 0; j < 32; j++) {
    let n1 = hexToNum[tmpBytes[2 * j]];
    let n0 = hexToNum[tmpBytes[2 * j + 1]];
    tmpBytes[j] = n1 << 4 | n0;
  }
  return bytesToBigint32(tmpBytes);
}
function bigIntToBytes(x, length) {
  if (x < 0n) {
    throw Error(`bigIntToBytes: negative numbers are not supported, got ${x}`);
  }
  if (length === void 0)
    return bigintToBytesFlexible(x);
  let bytes = Array(length);
  for (let i = 0; i < length; i++, x >>= 8n) {
    bytes[i] = Number(x & 0xffn);
  }
  if (x > 0n) {
    throw Error(`bigIntToBytes: input does not fit in ${length} bytes`);
  }
  return bytes;
}
function bigintToBytesFlexible(x) {
  let bytes = [];
  for (; x > 0n; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  return bytes;
}
function bigIntToBits(x) {
  if (x < 0n) {
    throw Error(`bigIntToBits: negative numbers are not supported, got ${x}`);
  }
  let bits = [];
  for (; x > 0n; x >>= 1n) {
    let bit2 = !!(x & 1n);
    bits.push(bit2);
  }
  return bits;
}
function changeBase(digits, base, newBase) {
  let x = fromBase(digits, base);
  let newDigits = toBase(x, newBase);
  return newDigits;
}
function fromBase(digits, base) {
  if (base <= 0n)
    throw Error("fromBase: base must be positive");
  let basePowers = [];
  for (let power2 = base, n = 1; n < digits.length; power2 **= 2n, n *= 2) {
    basePowers.push(power2);
  }
  let k = basePowers.length;
  digits = digits.concat(Array(2 ** k - digits.length).fill(0n));
  for (let i = 0; i < k; i++) {
    let newDigits = Array(digits.length >> 1);
    let basePower = basePowers[i];
    for (let j = 0; j < newDigits.length; j++) {
      newDigits[j] = digits[2 * j] + basePower * digits[2 * j + 1];
    }
    digits = newDigits;
  }
  console.assert(digits.length === 1);
  let [digit] = digits;
  return digit;
}
function toBase(x, base) {
  if (base <= 0n)
    throw Error("toBase: base must be positive");
  let basePowers = [];
  for (let power2 = base; power2 < x; power2 **= 2n) {
    basePowers.push(power2);
  }
  let digits = [x];
  let k = basePowers.length;
  for (let i = 0; i < k; i++) {
    let newDigits = Array(2 * digits.length);
    let basePower = basePowers[k - 1 - i];
    for (let j = 0; j < digits.length; j++) {
      let x2 = digits[j];
      let high = x2 / basePower;
      newDigits[2 * j + 1] = high;
      newDigits[2 * j] = x2 - high * basePower;
    }
    digits = newDigits;
  }
  while (digits[digits.length - 1] === 0n) {
    digits.pop();
  }
  return digits;
}
function log2(n) {
  if (typeof n === "number")
    n = BigInt(n);
  if (n === 1n)
    return 0;
  return (n - 1n).toString(2).length;
}
function max(a2, b2) {
  return a2 > b2 ? a2 : b2;
}
function abs(x) {
  return x < 0n ? -x : x;
}
function sign(x) {
  return x >= 0 ? 1n : -1n;
}

// dist/node/lib/util/assert.js
function assert(stmt, message) {
  if (!stmt) {
    throw Error(message ?? "Assertion failed");
  }
}
function assertPromise(value, message) {
  assert(value instanceof Promise, message ?? "Expected a promise");
  return value;
}
function assertDefined(value, message = "Input value is undefined.") {
  if (value === void 0)
    throw Error(message);
  return value;
}

// dist/node/bindings/crypto/random.js
var import_crypto = require("crypto");
function randomBytes(n) {
  return new Uint8Array((0, import_crypto.randomBytes)(n));
}

// dist/node/bindings/crypto/finite-field.js
var p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var pMinusOneOddFactor = 0x40000000000000000000000000000000224698fc094cf91b992d30edn;
var qMinusOneOddFactor = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb21n;
var twoadicRootFp = 0x2bce74deac30ebda362120830561f81aea322bf2b7bb7584bdad6fabd87ea32fn;
var twoadicRootFq = 0x2de6a9b8746d3f589e5c4dfd492ae26e9bb97ea3c106f049a70e2c1102b6d05fn;
function mod(x, p3) {
  x = x % p3;
  if (x < 0)
    return x + p3;
  return x;
}
function power(a2, n, p3) {
  a2 = mod(a2, p3);
  let x = 1n;
  for (; n > 0n; n >>= 1n) {
    if (n & 1n)
      x = mod(x * a2, p3);
    a2 = mod(a2 * a2, p3);
  }
  return x;
}
function inverse(a2, p3) {
  a2 = mod(a2, p3);
  if (a2 === 0n)
    return void 0;
  let b2 = p3;
  let x = 0n;
  let y = 1n;
  let u = 1n;
  let v = 0n;
  while (a2 !== 0n) {
    let q3 = b2 / a2;
    let r = mod(b2, a2);
    let m = x - u * q3;
    let n = y - v * q3;
    b2 = a2;
    a2 = r;
    x = u;
    y = v;
    u = m;
    v = n;
  }
  if (b2 !== 1n)
    return void 0;
  return mod(x, p3);
}
function fastInverse(x, p3, n, kmax, twoToMinusKmax) {
  x = mod(x, p3);
  if (x === 0n)
    return void 0;
  const w = 31;
  const hiBits = 31;
  const wn = BigInt(w);
  const wMask = (1n << wn) - 1n;
  let u = p3;
  let v = x;
  let r = 0n;
  let s = 1n;
  let i = 0;
  for (; i < 2 * n; i++) {
    let f0 = 1;
    let g0 = 0;
    let f1 = 0;
    let g1 = 1;
    let ulo = Number(u & wMask);
    let vlo = Number(v & wMask);
    let len = Math.max(log2(u), log2(v));
    let shift = BigInt(Math.max(len - hiBits, 0));
    let uhi = Number(u >> shift);
    let vhi = Number(v >> shift);
    for (let j = 0; j < w; j++) {
      if ((ulo & 1) === 0) {
        uhi >>= 1;
        ulo >>= 1;
        f1 <<= 1;
        g1 <<= 1;
      } else if ((vlo & 1) === 0) {
        vhi >>= 1;
        vlo >>= 1;
        f0 <<= 1;
        g0 <<= 1;
      } else {
        if (vhi <= uhi) {
          uhi = uhi - vhi >> 1;
          ulo = ulo - vlo >> 1;
          f0 = f0 + f1;
          g0 = g0 + g1;
          f1 <<= 1;
          g1 <<= 1;
        } else {
          vhi = vhi - uhi >> 1;
          vlo = vlo - ulo >> 1;
          f1 = f0 + f1;
          g1 = g0 + g1;
          f0 <<= 1;
          g0 <<= 1;
        }
      }
    }
    let f0n = BigInt(f0);
    let g0n = BigInt(g0);
    let f1n = BigInt(f1);
    let g1n = BigInt(g1);
    let unew = u * f0n - v * g0n;
    let vnew = v * g1n - u * f1n;
    u = unew >> wn;
    v = vnew >> wn;
    if (u < 0)
      u = -u, f0n = -f0n, g0n = -g0n;
    if (v < 0)
      v = -v, f1n = -f1n, g1n = -g1n;
    let rnew = r * f0n + s * g0n;
    let snew = s * g1n + r * f1n;
    r = rnew;
    s = snew;
    if (u === 0n)
      break;
    if (v === 0n) {
      assert(u === 1n, "u = 1");
      s = mod(-r, p3);
      break;
    }
  }
  let k = BigInt((i + 1) * w);
  s = mod(s * twoToMinusKmax, p3);
  s = mod(s << kmax - k, p3);
  assert(mod(x * s - 1n, p3) === 0n, "mod p");
  return s;
}
function sqrt(n, p3, Q, c, M) {
  if (n === 0n)
    return 0n;
  let t = power(n, Q - 1n >> 1n, p3);
  let R = mod(t * n, p3);
  t = mod(t * R, p3);
  while (true) {
    if (t === 1n)
      return R;
    let i = 0n;
    let s = t;
    while (s !== 1n) {
      s = mod(s * s, p3);
      i = i + 1n;
    }
    if (i === M)
      return void 0;
    let b2 = power(c, 1n << M - i - 1n, p3);
    M = i;
    c = mod(b2 * b2, p3);
    t = mod(t * c, p3);
    R = mod(R * b2, p3);
  }
}
function isSquare(x, p3) {
  if (x === 0n)
    return true;
  let sqrt1 = power(x, (p3 - 1n) / 2n, p3);
  return sqrt1 === 1n;
}
function randomField(p3, sizeInBytes, hiBitMask) {
  while (true) {
    let bytes = randomBytes(sizeInBytes);
    bytes[sizeInBytes - 1] &= hiBitMask;
    let x = bytesToBigInt(bytes);
    if (x < p3)
      return x;
  }
}
var Fp = createField(p, {
  oddFactor: pMinusOneOddFactor,
  twoadicRoot: twoadicRootFp,
  twoadicity: 32n
});
var Fq = createField(q, {
  oddFactor: qMinusOneOddFactor,
  twoadicRoot: twoadicRootFq,
  twoadicity: 32n
});
function createField(p3, constants) {
  let { oddFactor, twoadicRoot, twoadicity } = constants ?? computeFieldConstants(p3);
  let sizeInBits2 = log2(p3);
  let sizeInBytes = Math.ceil(sizeInBits2 / 8);
  let sizeHighestByte = sizeInBits2 - 8 * (sizeInBytes - 1);
  let hiBitMask = (1 << sizeHighestByte) - 1;
  const w = 31;
  const n = Math.ceil(sizeInBits2 / w);
  const kmax = BigInt(2 * n * w);
  const twoToMinusKmax = inverse(1n << kmax, p3);
  const exportedInverse = twoToMinusKmax !== void 0 ? (x) => fastInverse(x, p3, n, kmax, twoToMinusKmax) : (x) => inverse(x, p3);
  return {
    modulus: p3,
    sizeInBits: sizeInBits2,
    t: oddFactor,
    M: twoadicity,
    twoadicRoot,
    mod(x) {
      return mod(x, p3);
    },
    add(x, y) {
      return mod(x + y, p3);
    },
    not(x, bits) {
      return mod(2n ** BigInt(bits) - (x + 1n), p3);
    },
    negate(x) {
      return x === 0n ? 0n : p3 - x;
    },
    sub(x, y) {
      return mod(x - y, p3);
    },
    mul(x, y) {
      return mod(x * y, p3);
    },
    inverse: exportedInverse,
    div(x, y) {
      let yinv = exportedInverse(y);
      if (yinv === void 0)
        return;
      return mod(x * yinv, p3);
    },
    square(x) {
      return mod(x * x, p3);
    },
    isSquare(x) {
      return isSquare(x, p3);
    },
    sqrt(x) {
      return sqrt(x, p3, oddFactor, twoadicRoot, twoadicity);
    },
    power(x, n2) {
      return power(x, n2, p3);
    },
    dot(x, y) {
      let z = 0n;
      let n2 = x.length;
      for (let i = 0; i < n2; i++) {
        z += x[i] * y[i];
      }
      return mod(z, p3);
    },
    equal(x, y) {
      return mod(x - y, p3) === 0n;
    },
    isEven(x) {
      return !(x & 1n);
    },
    random() {
      return randomField(p3, sizeInBytes, hiBitMask);
    },
    fromNumber(x) {
      return mod(BigInt(x), p3);
    },
    fromBigint(x) {
      return mod(x, p3);
    },
    rot(x, bits, direction = "left", maxBits = 64n) {
      if (direction === "right")
        bits = maxBits - bits;
      let full = x << bits;
      let excess = full >> maxBits;
      let shifted = full & (1n << maxBits) - 1n;
      return shifted | excess;
    },
    leftShift(x, bits, maxBitSize = 64) {
      let shifted = x << BigInt(bits);
      return shifted & (1n << BigInt(maxBitSize)) - 1n;
    },
    rightShift(x, bits) {
      return x >> BigInt(bits);
    }
  };
}
function computeFieldConstants(p3) {
  let oddFactor = p3 - 1n;
  let twoadicity = 0n;
  while ((oddFactor & 1n) === 0n) {
    oddFactor >>= 1n;
    twoadicity++;
  }
  let z = 2n;
  while (isSquare(z, p3))
    z++;
  let twoadicRoot = power(z, oddFactor, p3);
  return { oddFactor, twoadicRoot, twoadicity };
}

// dist/node/lib/util/errors.js
var lineRemovalKeywords = [
  "o1js_node.bc.cjs",
  "/builtin/",
  "CatchAndPrettifyStacktrace"
  // Decorator name to remove from stacktrace (covers both class and method decorator)
];
function prettifyStacktrace(error) {
  error = unwrapMlException(error);
  if (!(error instanceof Error) || !error.stack)
    return error;
  const stacktrace = error.stack;
  const stacktraceLines = stacktrace.split("\n");
  const newStacktrace = [];
  for (let i = 0; i < stacktraceLines.length; i++) {
    const shouldRemoveLine = lineRemovalKeywords.some((lineToRemove) => stacktraceLines[i].includes(lineToRemove));
    if (shouldRemoveLine) {
      continue;
    }
    const trimmedLine = trimPaths(stacktraceLines[i]);
    newStacktrace.push(trimmedLine);
  }
  error.stack = newStacktrace.join("\n");
  return error;
}
async function prettifyStacktracePromise(result) {
  try {
    return await result;
  } catch (error) {
    throw prettifyStacktrace(error);
  }
}
function unwrapMlException(error) {
  if (error instanceof Error)
    return error;
  if (Array.isArray(error) && error[2] instanceof Error)
    return error[2];
  return error;
}
function trimPaths(stacktracePath) {
  const includesO1js = stacktracePath.includes("o1js");
  if (includesO1js) {
    return trimO1jsPath(stacktracePath);
  }
  const includesOpam = stacktracePath.includes("opam");
  if (includesOpam) {
    return trimOpamPath(stacktracePath);
  }
  const includesWorkspace = stacktracePath.includes("workspace_root");
  if (includesWorkspace) {
    return trimWorkspacePath(stacktracePath);
  }
  return stacktracePath;
}
function trimO1jsPath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const o1jsIndex = fullPath.indexOf("o1js");
  if (o1jsIndex === -1) {
    return stacktraceLine;
  }
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const updatedPath = fullPath.slice(o1jsIndex);
  return `${prefix}${updatedPath})`;
}
function trimOpamPath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const opamIndex = fullPath.indexOf("opam");
  if (opamIndex === -1) {
    return stacktraceLine;
  }
  const updatedPathArray = fullPath.slice(opamIndex).split("/");
  const libIndex = updatedPathArray.lastIndexOf("lib");
  if (libIndex === -1) {
    return stacktraceLine;
  }
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const trimmedPath = updatedPathArray.slice(libIndex + 1);
  trimmedPath.unshift("ocaml");
  return `${prefix}${trimmedPath.join("/")})`;
}
function trimWorkspacePath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const workspaceIndex = fullPath.indexOf("workspace_root");
  if (workspaceIndex === -1) {
    return stacktraceLine;
  }
  const updatedPathArray = fullPath.slice(workspaceIndex).split("/");
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const trimmedPath = updatedPathArray.slice(workspaceIndex);
  return `${prefix}${trimmedPath.join("/")})`;
}
function getDirectoryPath(stacktraceLine) {
  const fullPathRegex = /\(([^)]+)\)/;
  const matchedPaths = stacktraceLine.match(fullPathRegex);
  if (matchedPaths) {
    return matchedPaths[1];
  }
}
function Bug(message) {
  return Error(`${message}
This shouldn't have happened and indicates an internal bug.`);
}
function assert2(condition, message = "Failed assertion.") {
  if (!condition)
    throw Bug(message);
}

// dist/node/bindings/crypto/elliptic-curve-endomorphism.js
function Endomorphism(name, Field5, Scalar4, generator, endoScalar, endoBase) {
  if (endoScalar === void 0 || endoBase === void 0) {
    try {
      ({ endoScalar, endoBase } = computeEndoConstants(Field5, Scalar4, generator));
    } catch (e) {
      console.log(`Warning: no endomorphism for ${name}`, e?.message);
      return void 0;
    }
  }
  let endoBase_ = endoBase;
  let glvData = computeGlvData(Scalar4.modulus, endoScalar);
  return {
    scalar: endoScalar,
    base: endoBase,
    decomposeMaxBits: glvData.maxBits,
    decompose(s) {
      return decompose(s, glvData);
    },
    endomorphism(P) {
      return endomorphism(P, endoBase_, Field5.modulus);
    },
    scaleProjective(g, s) {
      return glvScaleProjective(g, s, Field5.modulus, endoBase_, glvData);
    },
    scale(g, s) {
      let gProj = projectiveFromAffine(g);
      let sGProj = glvScaleProjective(gProj, s, Field5.modulus, endoBase_, glvData);
      return projectiveToAffine(sGProj, Field5.modulus);
    }
  };
}
function decompose(s, data) {
  let { v00, v01, v10, v11, det } = data;
  let x0 = divideAndRound(-v11 * s, det);
  let x1 = divideAndRound(v10 * s, det);
  let s0 = v00 * x0 + v01 * x1 + s;
  let s1 = v10 * x0 + v11 * x1;
  return [
    { value: s0, isNegative: s0 < 0n, abs: abs(s0) },
    { value: s1, isNegative: s1 < 0n, abs: abs(s1) }
  ];
}
function endomorphism(P, endoBase, p3) {
  return { x: mod(endoBase * P.x, p3), y: P.y };
}
function endomorphismProjective(P, endoBase, p3) {
  return { x: mod(endoBase * P.x, p3), y: P.y, z: P.z };
}
function glvScaleProjective(g, s, p3, endoBase, data) {
  let endoG = endomorphismProjective(g, endoBase, p3);
  let [s0, s1] = decompose(s, data);
  let S0 = bigIntToBits(s0.abs);
  let S1 = bigIntToBits(s1.abs);
  if (s0.isNegative)
    g = projectiveNeg(g, p3);
  if (s1.isNegative)
    endoG = projectiveNeg(endoG, p3);
  let h = projectiveZero;
  for (let i = data.maxBits - 1; i >= 0; i--) {
    if (S0[i])
      h = projectiveAdd(h, g, p3);
    if (S1[i])
      h = projectiveAdd(h, endoG, p3);
    if (i === 0)
      break;
    h = projectiveDouble(h, p3);
  }
  return h;
}
function computeEndoConstants(Field5, Scalar4, G) {
  let p3 = Field5.modulus;
  let q3 = Scalar4.modulus;
  assert2(p3 % 3n === 1n, "Base field has a cube root of unity");
  assert2(q3 % 3n === 1n, "Scalar field has a cube root of unity");
  let sqrtMinus3 = Scalar4.sqrt(Scalar4.negate(3n));
  assert2(sqrtMinus3 !== void 0, "Scalar field has a square root of -3");
  let lambda = Scalar4.div(Scalar4.sub(sqrtMinus3, 1n), 2n);
  assert2(lambda !== void 0, "Scalar field has a cube root of unity");
  assert2(Scalar4.power(lambda, 3n) === 1n, "lambda is a cube root");
  assert2(lambda !== 1n, "lambda is not 1");
  let lambdaG = affineScale(G, lambda, p3);
  assert2(lambdaG.y === G.y, "multiplication by lambda is a cheap endomorphism");
  let beta = Field5.div(lambdaG.x, G.x);
  assert2(beta !== void 0, "Gx is invertible");
  assert2(Field5.power(beta, 3n) === 1n, "beta is a cube root");
  assert2(beta !== 1n, "beta is not 1");
  let R = affineScale(G, Scalar4.random(), p3);
  let lambdaR = affineScale(R, lambda, p3);
  assert2(lambdaR.x === Field5.mul(beta, R.x), "confirm endomorphism");
  assert2(lambdaR.y === R.y, "confirm endomorphism");
  return { endoScalar: lambda, endoBase: beta };
}
function computeGlvData(q3, lambda) {
  let [[v00, v01], [v10, v11]] = egcdStopEarly(lambda, q3);
  let det = v00 * v11 - v10 * v01;
  let maxS0 = (abs(v00) + abs(v01) >> 1n) + 1n;
  let maxS1 = (abs(v10) + abs(v11) >> 1n) + 1n;
  let maxBits = log2(max(maxS0, maxS1));
  return { v00, v01, v10, v11, det, maxS0, maxS1, maxBits };
}
function egcdStopEarly(l4, p3) {
  if (l4 > p3)
    throw Error("a > p");
  let [r0, r1] = [p3, l4];
  let [s0, s1] = [1n, 0n];
  let [t0, t1] = [0n, 1n];
  while (r1 * r1 > p3) {
    let quotient2 = r0 / r1;
    [r0, r1] = [r1, r0 - quotient2 * r1];
    [s0, s1] = [s1, s0 - quotient2 * s1];
    [t0, t1] = [t1, t0 - quotient2 * t1];
  }
  let quotient = r0 / r1;
  let r2 = r0 - quotient * r1;
  let t2 = t0 - quotient * t1;
  let [v00, v10] = [r1, -t1];
  let [v01, v11] = max(r0, abs(t0)) <= max(r2, abs(t2)) ? [r0, -t0] : [r2, -t2];
  return [
    [v00, v01],
    [v10, v11]
  ];
}
function divideAndRound(x, y) {
  let signz = sign(x) * sign(y);
  x = abs(x);
  y = abs(y);
  let z = x / y;
  if (2n * (x - z * y) >= y)
    z++;
  return signz * z;
}

// dist/node/bindings/crypto/elliptic-curve.js
var pallasGeneratorProjective = {
  x: 1n,
  y: 12418654782883325593414442427049395787963493412651469444558597405572177144507n
};
var vestaGeneratorProjective = {
  x: 1n,
  y: 11426906929455361843568202299992114520848200991084027513389447476559454104162n
};
var vestaEndoBase = 2942865608506852014473558576493638302197734138389222805617480874486368177743n;
var pallasEndoBase = 20444556541222657078399132219657928148671392403212669005631716460534733845831n;
var vestaEndoScalar = 8503465768106391777493614032514048814691664078728891710322960303815233784505n;
var pallasEndoScalar = 26005156700822196841419187675678338661165322343552424574062261873906994770353n;
var b = 5n;
var a = 0n;
var projectiveZero = { x: 1n, y: 1n, z: 0n };
var GroupMap = {
  create: (F, params) => {
    const { a: a2, b: b2 } = params.spec;
    if (a2 !== 0n)
      throw Error("GroupMap only supports a = 0");
    function tryDecode(x) {
      const pow3 = F.power(x, 3n);
      const y = F.add(pow3, b2);
      if (!F.isSquare(y))
        return void 0;
      return { x, y: F.sqrt(y) };
    }
    function sToVTruncated(s) {
      const { u, v, y } = s;
      return [v, F.negate(F.add(u, v)), F.add(u, F.square(y))];
    }
    function conic_to_s(c) {
      const d = F.div(c.z, c.y);
      if (d === void 0)
        throw Error(`Division undefined! ${c.z}/${c.y}`);
      const v = F.sub(d, params.u_over_2);
      return { u: params.u, v, y: c.y };
    }
    function field_to_conic(t) {
      const { z: z0, y: y0 } = params.projection_point;
      const ct = F.mul(params.conic_c, t);
      const d1 = F.add(F.mul(ct, y0), z0);
      const d2 = F.add(F.mul(ct, t), 1n);
      const d = F.div(d1, d2);
      if (d === void 0)
        throw Error(`Division undefined! ${d1}/${d2}`);
      const s = F.mul(2n, d);
      return {
        z: F.sub(z0, s),
        y: F.sub(y0, F.mul(s, t))
      };
    }
    return {
      potentialXs: (t) => sToVTruncated(conic_to_s(field_to_conic(t))),
      tryDecode
    };
  }
};
var GroupMapParamsFp = {
  u: 2n,
  u_over_2: 1n,
  conic_c: 3n,
  projection_point: {
    z: 12196889842669319921865617096620076994180062626450149327690483414064673774441n,
    y: 1n
  },
  spec: {
    a: 0n,
    b: 5n
  }
};
var GroupMapPallas = GroupMap.create(Fp, GroupMapParamsFp);
function projectiveNeg({ x, y, z }, p3) {
  return { x, y: y === 0n ? 0n : p3 - y, z };
}
function projectiveAdd(g, h, p3) {
  if (g.z === 0n)
    return h;
  if (h.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z, X2 = h.x, Y2 = h.y, Z2 = h.z;
  let Z1Z1 = mod(Z1 * Z1, p3);
  let Z2Z2 = mod(Z2 * Z2, p3);
  let U1 = mod(X1 * Z2Z2, p3);
  let U2 = mod(X2 * Z1Z1, p3);
  let S1 = mod(Y1 * Z2 * Z2Z2, p3);
  let S2 = mod(Y2 * Z1 * Z1Z1, p3);
  let H = mod(U2 - U1, p3);
  if (H === 0n) {
    if (S1 === S2)
      return projectiveDouble(g, p3);
    if (mod(S1 + S2, p3) === 0n)
      return projectiveZero;
    throw Error("projectiveAdd: invalid point");
  }
  let I = mod(H * H << 2n, p3);
  let J = mod(H * I, p3);
  let r = 2n * (S2 - S1);
  let V = mod(U1 * I, p3);
  let X3 = mod(r * r - J - 2n * V, p3);
  let Y3 = mod(r * (V - X3) - 2n * S1 * J, p3);
  let Z3 = mod(((Z1 + Z2) * (Z1 + Z2) - Z1Z1 - Z2Z2) * H, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveDouble(g, p3) {
  if (g.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z;
  if (Y1 === 0n)
    throw Error("projectiveDouble: unhandled case");
  let A = mod(X1 * X1, p3);
  let B = mod(Y1 * Y1, p3);
  let C = mod(B * B, p3);
  let D = mod(2n * ((X1 + B) * (X1 + B) - A - C), p3);
  let E = 3n * A;
  let F = mod(E * E, p3);
  let X3 = mod(F - 2n * D, p3);
  let Y3 = mod(E * (D - X3) - 8n * C, p3);
  let Z3 = mod(2n * Y1 * Z1, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveSub(g, h, p3) {
  return projectiveAdd(g, projectiveNeg(h, p3), p3);
}
function projectiveScale(g, x, p3) {
  let bits = typeof x === "bigint" ? bigIntToBits(x) : x;
  let h = projectiveZero;
  for (let bit2 of bits) {
    if (bit2)
      h = projectiveAdd(h, g, p3);
    g = projectiveDouble(g, p3);
  }
  return h;
}
function projectiveFromAffine({ x, y, infinity }) {
  if (infinity)
    return projectiveZero;
  return { x, y, z: 1n };
}
function projectiveToAffine(g, p3) {
  let z = g.z;
  if (z === 0n) {
    return { x: 0n, y: 0n, infinity: true };
  } else if (z === 1n) {
    return { x: g.x, y: g.y, infinity: false };
  } else {
    let zinv = inverse(z, p3);
    let zinv_squared = mod(zinv * zinv, p3);
    let x = mod(g.x * zinv_squared, p3);
    let y = mod(g.y * zinv * zinv_squared, p3);
    return { x, y, infinity: false };
  }
}
function projectiveEqual(g, h, p3) {
  if ((g.z === 0n || h.z === 0n) && g.z !== h.z)
    return false;
  let gz2 = mod(g.z * g.z, p3);
  let hz2 = mod(h.z * h.z, p3);
  if (mod(g.x * hz2 - h.x * gz2, p3) !== 0n)
    return false;
  let gz3 = mod(gz2 * g.z, p3);
  let hz3 = mod(hz2 * h.z, p3);
  return mod(g.y * hz3, p3) === mod(h.y * gz3, p3);
}
function projectiveOnCurve({ x, y, z }, p3, b2) {
  let x3 = mod(mod(x * x, p3) * x, p3);
  let y2 = mod(y * y, p3);
  let z3 = mod(mod(z * z, p3) * z, p3);
  let z6 = mod(z3 * z3, p3);
  return mod(y2 - x3 - b2 * z6, p3) === 0n;
}
function projectiveInSubgroup(g, p3, order) {
  let orderTimesG = projectiveScale(g, order, p3);
  return projectiveEqual(orderTimesG, projectiveZero, p3);
}
function createCurveProjective({ name, modulus: p3, order, cofactor, generator, b: b2, a: a2, endoBase, endoScalar }) {
  if (a2 !== 0n)
    throw Error("createCurveProjective only supports a = 0");
  cofactor ??= 1n;
  let hasCofactor = cofactor !== 1n;
  return {
    name,
    modulus: p3,
    order,
    cofactor,
    zero: projectiveZero,
    one: { ...generator, z: 1n },
    get endoBase() {
      if (endoBase === void 0)
        throw Error("`endoBase` for this curve was not provided.");
      return endoBase;
    },
    get endoScalar() {
      if (endoScalar === void 0)
        throw Error("`endoScalar` for this curve was not provided.");
      return endoScalar;
    },
    a: a2,
    b: b2,
    hasCofactor,
    equal(g, h) {
      return projectiveEqual(g, h, p3);
    },
    isOnCurve(g) {
      return projectiveOnCurve(g, p3, b2);
    },
    isInSubgroup(g) {
      return projectiveInSubgroup(g, p3, order);
    },
    add(g, h) {
      return projectiveAdd(g, h, p3);
    },
    double(g) {
      return projectiveDouble(g, p3);
    },
    negate(g) {
      return projectiveNeg(g, p3);
    },
    sub(g, h) {
      return projectiveSub(g, h, p3);
    },
    scale(g, s) {
      return projectiveScale(g, s, p3);
    },
    endomorphism({ x, y, z }) {
      if (endoBase === void 0)
        throw Error("endomorphism needs `endoBase` parameter.");
      return { x: mod(endoBase * x, p3), y, z };
    },
    toAffine(g) {
      return projectiveToAffine(g, p3);
    },
    fromAffine(a3) {
      return projectiveFromAffine(a3);
    }
  };
}
var Pallas = createCurveProjective({
  name: "Pallas",
  modulus: p,
  order: q,
  generator: pallasGeneratorProjective,
  b,
  a,
  endoBase: pallasEndoBase,
  endoScalar: pallasEndoScalar
});
var Vesta = createCurveProjective({
  name: "Vesta",
  modulus: q,
  order: p,
  generator: vestaGeneratorProjective,
  b,
  a,
  endoBase: vestaEndoBase,
  endoScalar: vestaEndoScalar
});
var affineZero = { x: 0n, y: 0n, infinity: true };
function affineOnCurve({ x, y, infinity }, p3, a2, b2) {
  if (infinity)
    return true;
  let x2 = mod(x * x, p3);
  return mod(y * y - x * x2 - a2 * x - b2, p3) === 0n;
}
function affineAdd(g, h, p3) {
  if (g.infinity)
    return h;
  if (h.infinity)
    return g;
  let { x: x1, y: y1 } = g;
  let { x: x2, y: y2 } = h;
  if (x1 === x2) {
    if (y1 === y2)
      return affineDouble(g, p3);
    return affineZero;
  }
  let d = inverse(x2 - x1, p3);
  if (d === void 0)
    throw Error("impossible");
  let m = mod((y2 - y1) * d, p3);
  let x3 = mod(m * m - x1 - x2, p3);
  let y3 = mod(m * (x1 - x3) - y1, p3);
  return { x: x3, y: y3, infinity: false };
}
function affineDouble({ x, y, infinity }, p3) {
  if (infinity)
    return affineZero;
  let d = inverse(2n * y, p3);
  if (d === void 0)
    throw Error("impossible");
  let m = mod(3n * x * x * d, p3);
  let x2 = mod(m * m - 2n * x, p3);
  let y2 = mod(m * (x - x2) - y, p3);
  return { x: x2, y: y2, infinity: false };
}
function affineNegate({ x, y, infinity }, p3) {
  if (infinity)
    return affineZero;
  return { x, y: y === 0n ? 0n : p3 - y, infinity };
}
function affineScale(g, s, p3) {
  let gProj = projectiveFromAffine(g);
  let sgProj = projectiveScale(gProj, s, p3);
  return projectiveToAffine(sgProj, p3);
}
var PallasAffine = createCurveAffine({
  name: "Pallas",
  modulus: p,
  order: q,
  generator: pallasGeneratorProjective,
  b,
  a,
  endoBase: pallasEndoBase,
  endoScalar: pallasEndoScalar
});
function createCurveAffine({ name, modulus: p3, order, cofactor, generator, a: a2, b: b2, endoScalar, endoBase }) {
  if (a2 !== 0n)
    throw Error("createCurveAffine only supports a = 0");
  let hasCofactor = cofactor !== void 0 && cofactor !== 1n;
  const Field5 = createField(p3);
  const Scalar4 = createField(order);
  const one = { ...generator, infinity: false };
  const Endo = Endomorphism(name, Field5, Scalar4, one, endoScalar, endoBase);
  return {
    name,
    /**
     * Arithmetic over the base field
     */
    Field: Field5,
    /**
     * Arithmetic over the scalar field
     */
    Scalar: Scalar4,
    modulus: p3,
    order,
    a: a2,
    b: b2,
    cofactor,
    hasCofactor,
    zero: affineZero,
    one,
    hasEndomorphism: Endo !== void 0,
    get Endo() {
      if (Endo === void 0)
        throw Error(`no endomorphism defined on ${name}`);
      return Endo;
    },
    from(g) {
      if (g.x === 0n && g.y === 0n)
        return affineZero;
      return { ...g, infinity: false };
    },
    fromNonzero(g) {
      if (g.x === 0n && g.y === 0n) {
        throw Error("fromNonzero: got (0, 0), which is reserved for the zero point");
      }
      return { ...g, infinity: false };
    },
    equal(g, h) {
      return mod(g.x - h.x, p3) === 0n && mod(g.y - h.y, p3) === 0n;
    },
    isOnCurve(g) {
      return affineOnCurve(g, p3, a2, b2);
    },
    isInSubgroup(g) {
      return projectiveInSubgroup(projectiveFromAffine(g), p3, order);
    },
    add(g, h) {
      return affineAdd(g, h, p3);
    },
    double(g) {
      return affineDouble(g, p3);
    },
    negate(g) {
      return affineNegate(g, p3);
    },
    sub(g, h) {
      return affineAdd(g, affineNegate(h, p3), p3);
    },
    scale(g, s) {
      return affineScale(g, s, p3);
    }
  };
}

// dist/node/bindings/crypto/bindings/curve.js
var VestaBindings = withPrefix("caml_vesta", createCurveBindings(Vesta));
var PallasBindings = withPrefix("caml_pallas", createCurveBindings(Pallas));
function createCurveBindings(Curve) {
  return {
    one() {
      return Curve.one;
    },
    add: Curve.add,
    sub: Curve.sub,
    negate: Curve.negate,
    double: Curve.double,
    scale(g, [, s]) {
      return Curve.scale(g, s);
    },
    random() {
      throw Error("random not implemented");
    },
    rng(i) {
      throw Error("rng not implemented");
    },
    endo_base() {
      return [0, Curve.endoBase];
    },
    endo_scalar() {
      return [0, Curve.endoScalar];
    },
    to_affine(g) {
      return toMlOrInfinity(Curve.toAffine(g));
    },
    of_affine(g) {
      return Curve.fromAffine(fromMlOrInfinity(g));
    },
    of_affine_coordinates(x, y) {
      return { x: x[1], y: y[1], z: 1n };
    },
    affine_deep_copy(g) {
      return toMlOrInfinity(fromMlOrInfinity(g));
    }
  };
}
var affineZero2 = { x: 0n, y: 0n, infinity: true };
var Infinity = 0;
function toMlOrInfinity(g) {
  if (g.infinity)
    return 0;
  return [0, [0, [0, g.x], [0, g.y]]];
}
function fromMlOrInfinity(g) {
  if (g === 0)
    return affineZero2;
  return { x: g[1][1][1], y: g[1][2][1], infinity: false };
}
var OrInfinity = {
  toJSON(g) {
    if (g === 0)
      return "Infinity";
    return { x: g[1][1][1].toString(), y: g[1][2][1].toString() };
  },
  fromJSON(g) {
    if (g === "Infinity")
      return 0;
    return [0, [0, [0, BigInt(g.x)], [0, BigInt(g.y)]]];
  }
};

// dist/node/bindings/crypto/bindings/field.js
var FpBindings = withPrefix("caml_pasta_fp", createFieldBindings(Fp));
var FqBindings = withPrefix("caml_pasta_fq", createFieldBindings(Fq));
function createFieldBindings(Field5) {
  return {
    size_in_bits() {
      return Field5.sizeInBits;
    },
    size() {
      return [0, Field5.modulus];
    },
    add([, x], [, y]) {
      return [0, Field5.add(x, y)];
    },
    sub([, x], [, y]) {
      return [0, Field5.sub(x, y)];
    },
    negate([, x]) {
      return [0, Field5.negate(x)];
    },
    mul([, x], [, y]) {
      return [0, Field5.mul(x, y)];
    },
    div([, x], [, y]) {
      let z = Field5.div(x, y);
      if (z === void 0)
        throw Error("division by zero");
      return [0, z];
    },
    inv([, x]) {
      return toMlOption(Field5.inverse(x));
    },
    square([, x]) {
      return [0, Field5.square(x)];
    },
    is_square([, x]) {
      return MlBool(Field5.isSquare(x));
    },
    sqrt([, x]) {
      return toMlOption(Field5.sqrt(x));
    },
    of_int(x) {
      if (x < 0)
        throw Error("of_int: inputs must be non-negative");
      return [0, Field5.fromNumber(x)];
    },
    to_string([, x]) {
      return toMlStringAscii(x.toString());
    },
    of_string(s) {
      return [0, Field5.fromBigint(BigInt(fromMlString(s)))];
    },
    print(x) {
      console.log(x[0].toString());
    },
    copy(x, [, y]) {
      x[1] = y;
    },
    mut_add(x, [, y]) {
      x[1] = Field5.add(x[1], y);
    },
    mut_sub(x, [, y]) {
      x[1] = Field5.sub(x[1], y);
    },
    mut_mul(x, [, y]) {
      x[1] = Field5.mul(x[1], y);
    },
    mut_square(x) {
      x[1] = Field5.square(x[1]);
    },
    compare(x, y) {
      return Bigint256Bindings.caml_bigint_256_compare(x, y);
    },
    equal([, x], [, y]) {
      return MlBool(x === y);
    },
    random() {
      return [0, Field5.random()];
    },
    rng(i) {
      throw Error("rng: not implemented");
    },
    to_bigint([, x]) {
      return [0, x];
    },
    of_bigint([, x]) {
      if (x >= Field5.modulus)
        throw Error("of_bigint: input exceeds field size");
      return [0, x];
    },
    two_adic_root_of_unity() {
      return [0, Field5.twoadicRoot];
    },
    domain_generator(i) {
      if (i > 32 || i < 0)
        throw Error("log2 size of evaluation domain must be in [0, 32], got " + i);
      if (i === 0)
        return [0, 1n];
      let generator = Field5.twoadicRoot;
      for (let j = 32; j > i; j--) {
        generator = mod(generator * generator, Field5.modulus);
      }
      return [0, generator];
    },
    to_bytes(x) {
      return Bigint256Bindings.caml_bigint_256_to_bytes(x);
    },
    of_bytes(bytes) {
      throw Error("of_bytes: not implemented");
    },
    deep_copy([, x]) {
      return [0, x];
    }
  };
}
function toMlOption(x) {
  if (x === void 0)
    return 0;
  return [0, [0, x]];
}

// dist/node/bindings/crypto/bindings/vector.js
var FieldVectorBindings = {
  create() {
    return [0];
  },
  length(v) {
    return v.length - 1;
  },
  emplace_back(v, x) {
    v.push(x);
  },
  get(v, i) {
    let value = v[i + 1];
    if (value === void 0) {
      throw Error(`FieldVector.get(): Index out of bounds, got ${i}/${v.length - 1}`);
    }
    return [...value];
  },
  set(v, i, x) {
    v[i + 1] = x;
  }
};
var FpVectorBindings = withPrefix("caml_fp_vector", FieldVectorBindings);
var FqVectorBindings = withPrefix("caml_fq_vector", FieldVectorBindings);

// dist/node/bindings/crypto/bindings/conversion-base.js
var fieldSizeBytes = 32;
function fieldToRust([, x], dest = new Uint8Array(32)) {
  return bigintToBytes32(x, dest);
}
function fieldFromRust(x) {
  return [0, bytesToBigint32(x)];
}
function fieldsToRustFlat([, ...fields2]) {
  let n = fields2.length;
  let flatBytes = new Uint8Array(n * fieldSizeBytes);
  for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {
    fieldToRust(fields2[i], flatBytes.subarray(offset, offset + fieldSizeBytes));
  }
  return flatBytes;
}
function fieldsFromRustFlat(fieldBytes) {
  let n = fieldBytes.length / fieldSizeBytes;
  if (!Number.isInteger(n)) {
    throw Error("fieldsFromRustFlat: invalid bytes");
  }
  let fields2 = Array(n);
  for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {
    let fieldView = new Uint8Array(fieldBytes.buffer, offset, fieldSizeBytes);
    fields2[i] = fieldFromRust(fieldView);
  }
  return [0, ...fields2];
}
function maybeFieldToRust(x) {
  return x && fieldToRust(x);
}
function affineFromRust(pt) {
  if (pt.infinity) {
    pt.free();
    return 0;
  } else {
    let x = fieldFromRust(pt.x);
    let y = fieldFromRust(pt.y);
    pt.free();
    return [0, [0, x, y]];
  }
}
var tmpBytes2 = new Uint8Array(32);
function affineToRust(pt, makeAffine) {
  let res = makeAffine();
  if (pt === Infinity) {
    res.infinity = true;
  } else {
    let [, [, x, y]] = pt;
    res.x = fieldToRust(x, tmpBytes2);
    res.y = fieldToRust(y, tmpBytes2);
  }
  return res;
}

// dist/node/bindings/crypto/bindings/conversion-core.js
function conversionCore(wasm2) {
  const fp = conversionCorePerField(wasm2, {
    CommitmentCurve: wasm2.WasmGVesta,
    makeAffine: wasm2.caml_vesta_affine_one,
    Gate: wasm2.WasmFpGate,
    PolyComm: wasm2.WasmFpPolyComm
  });
  const fq = conversionCorePerField(wasm2, {
    CommitmentCurve: wasm2.WasmGPallas,
    makeAffine: wasm2.caml_pallas_affine_one,
    Gate: wasm2.WasmFqGate,
    PolyComm: wasm2.WasmFqPolyComm
  });
  return {
    fp,
    fq,
    wireToRust: fp.wireToRust,
    // doesn't depend on the field
    mapMlArrayToRustVector([, ...array], map) {
      return mapToUint32Array(array, (x) => unwrap(map(x)));
    }
  };
}
function conversionCorePerField(wasm2, { CommitmentCurve, makeAffine, Gate, PolyComm }) {
  let self = {
    wireToRust([, row, col]) {
      return wasm2.Wire.create(row, col);
    },
    vectorToRust: fieldsToRustFlat,
    vectorFromRust: fieldsFromRustFlat,
    gateToRust(gate) {
      let [, typ, [, ...wires], coeffs] = gate;
      let rustWires = new wasm2.WasmGateWires(...mapTuple(wires, self.wireToRust));
      let rustCoeffs = fieldsToRustFlat(coeffs);
      return new Gate(typ, rustWires, rustCoeffs);
    },
    gateFromRust(wasmGate) {
      throw Error("gateFromRust not implemented");
    },
    pointToRust(point) {
      return affineToRust(point, makeAffine);
    },
    pointFromRust: affineFromRust,
    pointsToRust([, ...points]) {
      return mapToUint32Array(points, (point) => unwrap(self.pointToRust(point)));
    },
    pointsFromRust(points) {
      let arr = mapFromUintArray(points, (ptr) => affineFromRust(wrap(ptr, CommitmentCurve)));
      return [0, ...arr];
    },
    polyCommToRust(polyComm) {
      let [, camlElems] = polyComm;
      let rustShifted = void 0;
      let rustUnshifted = self.pointsToRust(camlElems);
      return new PolyComm(rustUnshifted, rustShifted);
    },
    polyCommFromRust(polyComm) {
      let rustUnshifted = polyComm.unshifted;
      let mlUnshifted = mapFromUintArray(rustUnshifted, (ptr) => {
        return affineFromRust(wrap(ptr, CommitmentCurve));
      });
      return [0, [0, ...mlUnshifted]];
    },
    polyCommsToRust([, ...comms]) {
      return mapToUint32Array(comms, (c) => unwrap(self.polyCommToRust(c)));
    },
    polyCommsFromRust(rustComms) {
      let comms = mapFromUintArray(rustComms, (ptr) => self.polyCommFromRust(wrap(ptr, PolyComm)));
      return [0, ...comms];
    }
  };
  return self;
}
function wrap(ptr, Class) {
  const obj = Object.create(Class.prototype);
  obj.__wbg_ptr = ptr;
  return obj;
}
function unwrap(obj) {
  let ptr = obj.__wbg_ptr;
  if (ptr === void 0)
    throw Error("unwrap: missing ptr");
  return ptr;
}
var registry = new FinalizationRegistry((ptr) => {
  ptr.free();
});
function freeOnFinalize(instance) {
  let instanceRepresentative = wrap(instance.__wbg_ptr, instance.constructor);
  registry.register(instance, instanceRepresentative, instance);
  return instance;
}
function mapFromUintArray(array, map) {
  let n = array.length;
  let result = Array(n);
  for (let i = 0; i < n; i++) {
    result[i] = map(array[i]);
  }
  return result;
}
function mapToUint32Array(array, map) {
  let n = array.length;
  let result = new Uint32Array(n);
  for (let i = 0; i < n; i++) {
    result[i] = map(array[i]);
  }
  return result;
}

// dist/node/bindings/crypto/bindings/conversion-proof.js
var fieldToRust_ = (x) => fieldToRust(x);
var proofEvaluationsToRust = mapProofEvaluations(fieldToRust_);
var proofEvaluationsFromRust = mapProofEvaluations(fieldFromRust);
var pointEvalsOptionToRust = mapPointEvalsOption(fieldToRust_);
var pointEvalsOptionFromRust = mapPointEvalsOption(fieldFromRust);
function proofConversion(wasm2, core) {
  return {
    fp: proofConversionPerField(core.fp, {
      ProverCommitments: wasm2.WasmFpProverCommitments,
      OpeningProof: wasm2.WasmFpOpeningProof,
      VecVec: wasm2.WasmVecVecFp,
      ProverProof: wasm2.WasmFpProverProof,
      LookupCommitments: wasm2.WasmFpLookupCommitments,
      RuntimeTable: wasm2.WasmFpRuntimeTable,
      RuntimeTableCfg: wasm2.WasmPastaFpRuntimeTableCfg,
      LookupTable: wasm2.WasmPastaFpLookupTable
    }),
    fq: proofConversionPerField(core.fq, {
      ProverCommitments: wasm2.WasmFqProverCommitments,
      OpeningProof: wasm2.WasmFqOpeningProof,
      VecVec: wasm2.WasmVecVecFq,
      ProverProof: wasm2.WasmFqProverProof,
      LookupCommitments: wasm2.WasmFqLookupCommitments,
      RuntimeTable: wasm2.WasmFqRuntimeTable,
      RuntimeTableCfg: wasm2.WasmPastaFqRuntimeTableCfg,
      LookupTable: wasm2.WasmPastaFqLookupTable
    })
  };
}
function proofConversionPerField(core, { ProverCommitments, OpeningProof, VecVec, ProverProof, LookupCommitments, RuntimeTable, RuntimeTableCfg, LookupTable }) {
  function commitmentsToRust(commitments) {
    let wComm = core.polyCommsToRust(commitments[1]);
    let zComm = core.polyCommToRust(commitments[2]);
    let tComm = core.polyCommToRust(commitments[3]);
    let lookup2 = MlOption.mapFrom(commitments[4], lookupCommitmentsToRust);
    return new ProverCommitments(wComm, zComm, tComm, lookup2);
  }
  function commitmentsFromRust(commitments) {
    let wComm = core.polyCommsFromRust(commitments.w_comm);
    let zComm = core.polyCommFromRust(commitments.z_comm);
    let tComm = core.polyCommFromRust(commitments.t_comm);
    let lookup2 = MlOption.mapTo(commitments.lookup, lookupCommitmentsFromRust);
    commitments.free();
    return [0, wComm, zComm, tComm, lookup2];
  }
  function lookupCommitmentsToRust(lookup2) {
    let sorted = core.polyCommsToRust(lookup2[1]);
    let aggreg = core.polyCommToRust(lookup2[2]);
    let runtime = MlOption.mapFrom(lookup2[3], core.polyCommToRust);
    return new LookupCommitments(sorted, aggreg, runtime);
  }
  function lookupCommitmentsFromRust(lookup2) {
    let sorted = core.polyCommsFromRust(lookup2.sorted);
    let aggreg = core.polyCommFromRust(lookup2.aggreg);
    let runtime = MlOption.mapTo(lookup2.runtime, core.polyCommFromRust);
    lookup2.free();
    return [0, sorted, aggreg, runtime];
  }
  function openingProofToRust(proof) {
    let [_, [, ...lr], delta, z1, z2, sg] = proof;
    let l4 = [0];
    let r = [0];
    for (let [, li, ri] of lr) {
      l4.push(li);
      r.push(ri);
    }
    return new OpeningProof(core.pointsToRust(l4), core.pointsToRust(r), core.pointToRust(delta), fieldToRust(z1), fieldToRust(z2), core.pointToRust(sg));
  }
  function openingProofFromRust(proof) {
    let [, ...l4] = core.pointsFromRust(proof.lr_0);
    let [, ...r] = core.pointsFromRust(proof.lr_1);
    let n = l4.length;
    if (n !== r.length)
      throw Error("openingProofFromRust: l and r length mismatch.");
    let lr = l4.map((li, i) => [0, li, r[i]]);
    let delta = core.pointFromRust(proof.delta);
    let z1 = fieldFromRust(proof.z1);
    let z2 = fieldFromRust(proof.z2);
    let sg = core.pointFromRust(proof.sg);
    proof.free();
    return [0, [0, ...lr], delta, z1, z2, sg];
  }
  function runtimeTableToRust([, id2, data]) {
    return new RuntimeTable(id2, core.vectorToRust(data));
  }
  function runtimeTableCfgToRust([, id2, firstColumn]) {
    return new RuntimeTableCfg(id2, core.vectorToRust(firstColumn));
  }
  function lookupTableToRust([, id2, [, ...data]]) {
    let n = data.length;
    let wasmData = new VecVec(n);
    for (let i = 0; i < n; i++) {
      wasmData.push(fieldsToRustFlat(data[i]));
    }
    return new LookupTable(id2, wasmData);
  }
  return {
    proofToRust([, public_evals, proof]) {
      let commitments = commitmentsToRust(proof[1]);
      let openingProof = openingProofToRust(proof[2]);
      let [, ...evals] = proofEvaluationsToRust(proof[3]);
      let publicEvals = pointEvalsOptionToRust(public_evals);
      let evalsActual = [0, publicEvals, ...evals];
      let ftEval1 = fieldToRust(proof[4]);
      let public_2 = fieldsToRustFlat(proof[5]);
      let [, ...prevChallenges] = proof[6];
      let n = prevChallenges.length;
      let prevChallengeScalars = new VecVec(n);
      let prevChallengeCommsMl = [0];
      for (let [, scalars, comms] of prevChallenges) {
        prevChallengeScalars.push(fieldsToRustFlat(scalars));
        prevChallengeCommsMl.push(comms);
      }
      let prevChallengeComms = core.polyCommsToRust(prevChallengeCommsMl);
      return new ProverProof(commitments, openingProof, evalsActual, ftEval1, public_2, prevChallengeScalars, prevChallengeComms);
    },
    proofFromRust(wasmProof) {
      let commitments = commitmentsFromRust(wasmProof.commitments);
      let openingProof = openingProofFromRust(wasmProof.proof);
      let [, wasmPublicEvals, ...wasmEvals] = wasmProof.evals;
      let publicEvals = pointEvalsOptionFromRust(wasmPublicEvals);
      let evals = proofEvaluationsFromRust([0, ...wasmEvals]);
      let ftEval1 = fieldFromRust(wasmProof.ft_eval1);
      let public_2 = fieldsFromRustFlat(wasmProof.public_);
      let prevChallengeScalars = wasmProof.prev_challenges_scalars;
      let [, ...prevChallengeComms] = core.polyCommsFromRust(wasmProof.prev_challenges_comms);
      let prevChallenges = prevChallengeComms.map((comms, i) => {
        let scalars = fieldsFromRustFlat(prevChallengeScalars.get(i));
        return [0, scalars, comms];
      });
      wasmProof.free();
      let proof = [
        0,
        commitments,
        openingProof,
        evals,
        ftEval1,
        public_2,
        [0, ...prevChallenges]
      ];
      return [0, publicEvals, proof];
    },
    runtimeTablesToRust([, ...tables]) {
      return mapToUint32Array(tables, (table) => unwrap(runtimeTableToRust(table)));
    },
    runtimeTableCfgsToRust([, ...tableCfgs]) {
      return mapToUint32Array(tableCfgs, (tableCfg) => unwrap(runtimeTableCfgToRust(tableCfg)));
    },
    lookupTablesToRust([, ...tables]) {
      return mapToUint32Array(tables, (table) => unwrap(lookupTableToRust(table)));
    }
  };
}
function createMapPointEvals(map) {
  return (evals) => {
    let [, zeta, zeta_omega] = evals;
    return [0, MlArray.map(zeta, map), MlArray.map(zeta_omega, map)];
  };
}
function mapPointEvalsOption(map) {
  return (evals) => MlOption.map(evals, createMapPointEvals(map));
}
function mapProofEvaluations(map) {
  const mapPointEvals = createMapPointEvals(map);
  const mapPointEvalsOption2 = (evals) => MlOption.map(evals, mapPointEvals);
  return function mapProofEvaluations2(evals) {
    let [, w, z, s, coeffs, genericSelector, poseidonSelector, completeAddSelector, mulSelector, emulSelector, endomulScalarSelector, rangeCheck0Selector, rangeCheck1Selector, foreignFieldAddSelector, foreignFieldMulSelector, xorSelector, rotSelector, lookupAggregation, lookupTable, lookupSorted, runtimeLookupTable, runtimeLookupTableSelector, xorLookupSelector, lookupGateLookupSelector, rangeCheckLookupSelector, foreignFieldMulLookupSelector] = evals;
    return [
      0,
      MlTuple2.map(w, mapPointEvals),
      mapPointEvals(z),
      MlTuple2.map(s, mapPointEvals),
      MlTuple2.map(coeffs, mapPointEvals),
      mapPointEvals(genericSelector),
      mapPointEvals(poseidonSelector),
      mapPointEvals(completeAddSelector),
      mapPointEvals(mulSelector),
      mapPointEvals(emulSelector),
      mapPointEvals(endomulScalarSelector),
      mapPointEvalsOption2(rangeCheck0Selector),
      mapPointEvalsOption2(rangeCheck1Selector),
      mapPointEvalsOption2(foreignFieldAddSelector),
      mapPointEvalsOption2(foreignFieldMulSelector),
      mapPointEvalsOption2(xorSelector),
      mapPointEvalsOption2(rotSelector),
      mapPointEvalsOption2(lookupAggregation),
      mapPointEvalsOption2(lookupTable),
      MlArray.map(lookupSorted, mapPointEvalsOption2),
      mapPointEvalsOption2(runtimeLookupTable),
      mapPointEvalsOption2(runtimeLookupTableSelector),
      mapPointEvalsOption2(xorLookupSelector),
      mapPointEvalsOption2(lookupGateLookupSelector),
      mapPointEvalsOption2(rangeCheckLookupSelector),
      mapPointEvalsOption2(foreignFieldMulLookupSelector)
    ];
  };
}

// dist/node/bindings/crypto/bindings/conversion-verifier-index.js
function verifierIndexConversion(wasm2, core) {
  return {
    fp: verifierIndexConversionPerField(wasm2, core.fp, {
      Domain: wasm2.WasmFpDomain,
      VerificationEvals: wasm2.WasmFpPlonkVerificationEvals,
      Shifts: wasm2.WasmFpShifts,
      VerifierIndex: wasm2.WasmFpPlonkVerifierIndex,
      LookupVerifierIndex: wasm2.WasmFpLookupVerifierIndex,
      LookupSelector: wasm2.WasmFpLookupSelectors
    }),
    fq: verifierIndexConversionPerField(wasm2, core.fq, {
      Domain: wasm2.WasmFqDomain,
      VerificationEvals: wasm2.WasmFqPlonkVerificationEvals,
      Shifts: wasm2.WasmFqShifts,
      VerifierIndex: wasm2.WasmFqPlonkVerifierIndex,
      LookupVerifierIndex: wasm2.WasmFqLookupVerifierIndex,
      LookupSelector: wasm2.WasmFqLookupSelectors
    })
  };
}
function verifierIndexConversionPerField(wasm2, core, { Domain, VerificationEvals, Shifts, VerifierIndex, LookupVerifierIndex, LookupSelector }) {
  function domainToRust([, logSizeOfGroup, groupGen]) {
    return new Domain(logSizeOfGroup, fieldToRust(groupGen));
  }
  function domainFromRust(domain) {
    let logSizeOfGroup = domain.log_size_of_group;
    let groupGen = fieldFromRust(domain.group_gen);
    domain.free();
    return [0, logSizeOfGroup, groupGen];
  }
  function verificationEvalsToRust(evals) {
    let sigmaComm = core.polyCommsToRust(evals[1]);
    let coefficientsComm = core.polyCommsToRust(evals[2]);
    let genericComm = core.polyCommToRust(evals[3]);
    let psmComm = core.polyCommToRust(evals[4]);
    let completeAddComm = core.polyCommToRust(evals[5]);
    let mulComm = core.polyCommToRust(evals[6]);
    let emulComm = core.polyCommToRust(evals[7]);
    let endomulScalarComm = core.polyCommToRust(evals[8]);
    let xorComm = MlOption.mapFrom(evals[9], core.polyCommToRust);
    let rangeCheck0Comm = MlOption.mapFrom(evals[10], core.polyCommToRust);
    let rangeCheck1Comm = MlOption.mapFrom(evals[11], core.polyCommToRust);
    let foreignFieldAddComm = MlOption.mapFrom(evals[12], core.polyCommToRust);
    let foreignFieldMulComm = MlOption.mapFrom(evals[13], core.polyCommToRust);
    let rotComm = MlOption.mapFrom(evals[14], core.polyCommToRust);
    return new VerificationEvals(sigmaComm, coefficientsComm, genericComm, psmComm, completeAddComm, mulComm, emulComm, endomulScalarComm, xorComm, rangeCheck0Comm, rangeCheck1Comm, foreignFieldAddComm, foreignFieldMulComm, rotComm);
  }
  function verificationEvalsFromRust(evals) {
    let mlEvals = [
      0,
      core.polyCommsFromRust(evals.sigma_comm),
      core.polyCommsFromRust(evals.coefficients_comm),
      core.polyCommFromRust(evals.generic_comm),
      core.polyCommFromRust(evals.psm_comm),
      core.polyCommFromRust(evals.complete_add_comm),
      core.polyCommFromRust(evals.mul_comm),
      core.polyCommFromRust(evals.emul_comm),
      core.polyCommFromRust(evals.endomul_scalar_comm),
      MlOption.mapTo(evals.xor_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.range_check0_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.range_check1_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.foreign_field_add_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.foreign_field_mul_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.rot_comm, core.polyCommFromRust)
    ];
    evals.free();
    return mlEvals;
  }
  function lookupVerifierIndexToRust(lookup2) {
    let [, joint_lookup_used, lookup_table, selectors, table_ids, lookup_info, runtime_tables_selector] = lookup2;
    return new LookupVerifierIndex(MlBool.from(joint_lookup_used), core.polyCommsToRust(lookup_table), lookupSelectorsToRust(selectors), MlOption.mapFrom(table_ids, core.polyCommToRust), lookupInfoToRust(lookup_info), MlOption.mapFrom(runtime_tables_selector, core.polyCommToRust));
  }
  function lookupVerifierIndexFromRust(lookup2) {
    let mlLookup = [
      0,
      MlBool(lookup2.joint_lookup_used),
      core.polyCommsFromRust(lookup2.lookup_table),
      lookupSelectorsFromRust(lookup2.lookup_selectors),
      MlOption.mapTo(lookup2.table_ids, core.polyCommFromRust),
      lookupInfoFromRust(lookup2.lookup_info),
      MlOption.mapTo(lookup2.runtime_tables_selector, core.polyCommFromRust)
    ];
    lookup2.free();
    return mlLookup;
  }
  function lookupSelectorsToRust([, lookup2, xor4, range_check, ffmul]) {
    return new LookupSelector(MlOption.mapFrom(xor4, core.polyCommToRust), MlOption.mapFrom(lookup2, core.polyCommToRust), MlOption.mapFrom(range_check, core.polyCommToRust), MlOption.mapFrom(ffmul, core.polyCommToRust));
  }
  function lookupSelectorsFromRust(selector) {
    let lookup2 = MlOption.mapTo(selector.lookup, core.polyCommFromRust);
    let xor4 = MlOption.mapTo(selector.xor, core.polyCommFromRust);
    let range_check = MlOption.mapTo(selector.range_check, core.polyCommFromRust);
    let ffmul = MlOption.mapTo(selector.ffmul, core.polyCommFromRust);
    selector.free();
    return [0, lookup2, xor4, range_check, ffmul];
  }
  function lookupInfoToRust([, maxPerRow, maxJointSize, features]) {
    let [, patterns, joint_lookup_used, uses_runtime_tables] = features;
    let [, xor4, lookup2, range_check, foreign_field_mul] = patterns;
    let wasmPatterns = new wasm2.LookupPatterns(MlBool.from(xor4), MlBool.from(lookup2), MlBool.from(range_check), MlBool.from(foreign_field_mul));
    let wasmFeatures = new wasm2.LookupFeatures(wasmPatterns, MlBool.from(joint_lookup_used), MlBool.from(uses_runtime_tables));
    return new wasm2.LookupInfo(maxPerRow, maxJointSize, wasmFeatures);
  }
  function lookupInfoFromRust(info) {
    let features = info.features;
    let patterns = features.patterns;
    let mlInfo = [
      0,
      info.max_per_row,
      info.max_joint_size,
      [
        0,
        [
          0,
          MlBool(patterns.xor),
          MlBool(patterns.lookup),
          MlBool(patterns.range_check),
          MlBool(patterns.foreign_field_mul)
        ],
        MlBool(features.joint_lookup_used),
        MlBool(features.uses_runtime_tables)
      ]
    ];
    info.free();
    return mlInfo;
  }
  let self = {
    shiftsToRust([, ...shifts]) {
      let s = shifts.map((s2) => fieldToRust(s2));
      return new Shifts(s[0], s[1], s[2], s[3], s[4], s[5], s[6]);
    },
    shiftsFromRust(s) {
      let shifts = [s.s0, s.s1, s.s2, s.s3, s.s4, s.s5, s.s6];
      s.free();
      return [0, ...shifts.map(fieldFromRust)];
    },
    verifierIndexToRust(vk) {
      let domain = domainToRust(vk[1]);
      let maxPolySize = vk[2];
      let nPublic = vk[3];
      let prevChallenges = vk[4];
      let srs2 = vk[5];
      let evals = verificationEvalsToRust(vk[6]);
      let shifts = self.shiftsToRust(vk[7]);
      let lookupIndex = MlOption.mapFrom(vk[8], lookupVerifierIndexToRust);
      let zkRows = vk[9];
      return new VerifierIndex(domain, maxPolySize, nPublic, prevChallenges, srs2, evals, shifts, lookupIndex, zkRows);
    },
    verifierIndexFromRust(vk) {
      let mlVk = [
        0,
        domainFromRust(vk.domain),
        vk.max_poly_size,
        vk.public_,
        vk.prev_challenges,
        freeOnFinalize(vk.srs),
        verificationEvalsFromRust(vk.evals),
        self.shiftsFromRust(vk.shifts),
        MlOption.mapTo(vk.lookup_index, lookupVerifierIndexFromRust),
        vk.zk_rows
      ];
      vk.free();
      return mlVk;
    }
  };
  return self;
}

// dist/node/bindings/crypto/bindings/conversion-oracles.js
function oraclesConversion(wasm2) {
  return {
    fp: oraclesConversionPerField({
      RandomOracles: wasm2.WasmFpRandomOracles,
      Oracles: wasm2.WasmFpOracles
    }),
    fq: oraclesConversionPerField({
      RandomOracles: wasm2.WasmFqRandomOracles,
      Oracles: wasm2.WasmFqOracles
    })
  };
}
function oraclesConversionPerField({ RandomOracles, Oracles }) {
  function randomOraclesToRust(ro) {
    let jointCombinerMl = MlOption.from(ro[1]);
    let jointCombinerChal = maybeFieldToRust(jointCombinerMl?.[1][1]);
    let jointCombiner = maybeFieldToRust(jointCombinerMl?.[2]);
    let beta = fieldToRust(ro[2]);
    let gamma = fieldToRust(ro[3]);
    let alphaChal = fieldToRust(ro[4][1]);
    let alpha = fieldToRust(ro[5]);
    let zeta = fieldToRust(ro[6]);
    let v = fieldToRust(ro[7]);
    let u = fieldToRust(ro[8]);
    let zetaChal = fieldToRust(ro[9][1]);
    let vChal = fieldToRust(ro[10][1]);
    let uChal = fieldToRust(ro[11][1]);
    return new RandomOracles(jointCombinerChal, jointCombiner, beta, gamma, alphaChal, alpha, zeta, v, u, zetaChal, vChal, uChal);
  }
  function randomOraclesFromRust(ro) {
    let jointCombinerChal = ro.joint_combiner_chal;
    let jointCombiner = ro.joint_combiner;
    let jointCombinerOption = MlOption(jointCombinerChal && jointCombiner && [
      0,
      [0, fieldFromRust(jointCombinerChal)],
      fieldFromRust(jointCombiner)
    ]);
    let mlRo = [
      0,
      jointCombinerOption,
      fieldFromRust(ro.beta),
      fieldFromRust(ro.gamma),
      [0, fieldFromRust(ro.alpha_chal)],
      fieldFromRust(ro.alpha),
      fieldFromRust(ro.zeta),
      fieldFromRust(ro.v),
      fieldFromRust(ro.u),
      [0, fieldFromRust(ro.zeta_chal)],
      [0, fieldFromRust(ro.v_chal)],
      [0, fieldFromRust(ro.u_chal)]
    ];
    return mlRo;
  }
  return {
    oraclesToRust(oracles) {
      let [, o, pEval, openingPrechallenges, digestBeforeEvaluations] = oracles;
      return new Oracles(randomOraclesToRust(o), fieldToRust(pEval[1]), fieldToRust(pEval[2]), fieldsToRustFlat(openingPrechallenges), fieldToRust(digestBeforeEvaluations));
    },
    oraclesFromRust(oracles) {
      let mlOracles = [
        0,
        randomOraclesFromRust(oracles.o),
        [0, fieldFromRust(oracles.p_eval0), fieldFromRust(oracles.p_eval1)],
        fieldsFromRustFlat(oracles.opening_prechallenges),
        fieldFromRust(oracles.digest_before_evaluations)
      ];
      return mlOracles;
    }
  };
}

// dist/node/bindings/crypto/bindings/env.js
var jsEnvironment = "node";

// dist/node/lib/util/fs.js
var import_cachedir = __toESM(require("cachedir"), 1);
var import_node_fs = require("node:fs");
var import_node_path = require("node:path");

// dist/node/lib/proof-system/cache.js
var cacheHeaderVersion = 1;
function withVersion(header, version = cacheHeaderVersion) {
  let uniqueId = `${header.uniqueId}-${version}`;
  return { ...header, version, uniqueId };
}
function readCache(cache2, header, transform) {
  try {
    let result = cache2.read(header);
    if (result === void 0) {
      if (cache2.debug)
        console.trace("cache miss");
      return void 0;
    }
    if (transform === void 0)
      return result;
    return transform(result);
  } catch (e) {
    if (cache2.debug)
      console.log("Failed to read cache", e);
    return void 0;
  }
}
function writeCache(cache2, header, value) {
  if (!cache2.canWrite)
    return false;
  try {
    cache2.write(header, value);
    return true;
  } catch (e) {
    if (cache2.debug)
      console.log("Failed to write cache", e);
    return false;
  }
}
var None = {
  read() {
    throw Error("not available");
  },
  write() {
    throw Error("not available");
  },
  canWrite: false
};
var FileSystem = (cacheDirectory, debug) => ({
  read({ persistentId, uniqueId, dataType }) {
    if (jsEnvironment !== "node")
      throw Error("file system not available");
    let currentId = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, `${persistentId}.header`), "utf8");
    if (currentId !== uniqueId)
      return void 0;
    if (dataType === "string") {
      let string = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId), "utf8");
      return new TextEncoder().encode(string);
    } else {
      let buffer = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId));
      return new Uint8Array(buffer.buffer);
    }
  },
  write({ persistentId, uniqueId, dataType }, data) {
    if (jsEnvironment !== "node")
      throw Error("file system not available");
    (0, import_node_fs.mkdirSync)(cacheDirectory, { recursive: true });
    (0, import_node_fs.writeFileSync)((0, import_node_path.resolve)(cacheDirectory, `${persistentId}.header`), uniqueId, {
      encoding: "utf8"
    });
    (0, import_node_fs.writeFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId), data, {
      encoding: dataType === "string" ? "utf8" : void 0
    });
  },
  canWrite: jsEnvironment === "node",
  debug
});
var FileSystemDefault = FileSystem((0, import_cachedir.default)("o1js"));
var Cache = {
  /**
   * Store data on the file system, in a directory of your choice.
   *
   * Data will be stored in two files per cache entry: a data file and a `.header` file.
   * The header file just contains a unique string which is used to determine whether we can use the cached data.
   *
   * Note: this {@link Cache} only caches data in Node.js.
   */
  FileSystem,
  /**
   * Store data on the file system, in a standard cache directory depending on the OS.
   *
   * Data will be stored in two files per cache entry: a data file and a `.header` file.
   * The header file just contains a unique string which is used to determine whether we can use the cached data.
   *
   * Note: this {@link Cache} only caches data in Node.js.
   */
  FileSystemDefault,
  /**
   * Don't store anything.
   */
  None
};

// dist/node/bindings/crypto/bindings/srs.js
function empty() {
  return {};
}
var srsStore = { fp: empty(), fq: empty() };
var cache;
function setSrsCache(c) {
  cache = c;
}
function unsetSrsCache() {
  cache = void 0;
}
var srsVersion = 1;
function cacheHeaderLagrange(f, domainSize) {
  let id2 = `lagrange-basis-${f}-${domainSize}`;
  return withVersion({
    kind: "lagrange-basis",
    persistentId: id2,
    uniqueId: id2,
    dataType: "string"
  }, srsVersion);
}
function cacheHeaderSrs(f, domainSize) {
  let id2 = `srs-${f}-${domainSize}`;
  return withVersion({
    kind: "srs",
    persistentId: id2,
    uniqueId: id2,
    dataType: "string"
  }, srsVersion);
}
function srs(wasm2, conversion) {
  return {
    fp: srsPerField("fp", wasm2, conversion),
    fq: srsPerField("fq", wasm2, conversion)
  };
}
function srsPerField(f, wasm2, conversion) {
  let createSrs = (s) => wasm2[`caml_${f}_srs_create_parallel`](s);
  let getSrs = wasm2[`caml_${f}_srs_get`];
  let setSrs = wasm2[`caml_${f}_srs_set`];
  let maybeLagrangeCommitment = wasm2[`caml_${f}_srs_maybe_lagrange_commitment`];
  let lagrangeCommitment = wasm2[`caml_${f}_srs_lagrange_commitment`];
  let setLagrangeBasis = wasm2[`caml_${f}_srs_set_lagrange_basis`];
  let getLagrangeBasis = (srs2, n) => wasm2[`caml_${f}_srs_get_lagrange_basis`](srs2, n);
  return {
    /**
     * returns existing stored SRS or falls back to creating a new one
     */
    create(size) {
      let srs2 = srsStore[f][size];
      if (srs2 === void 0) {
        if (cache === void 0) {
          srs2 = createSrs(size);
        } else {
          let header = cacheHeaderSrs(f, size);
          srs2 = readCache(cache, header, (bytes) => {
            let jsonSrs = JSON.parse(new TextDecoder().decode(bytes));
            let mlSrs = MlArray.mapTo(jsonSrs, OrInfinity.fromJSON);
            let wasmSrs = conversion[f].pointsToRust(mlSrs);
            return setSrs(wasmSrs);
          });
          if (srs2 === void 0) {
            srs2 = createSrs(size);
            if (cache.canWrite) {
              let wasmSrs = getSrs(srs2);
              let mlSrs = conversion[f].pointsFromRust(wasmSrs);
              let jsonSrs = MlArray.mapFrom(mlSrs, OrInfinity.toJSON);
              let bytes = new TextEncoder().encode(JSON.stringify(jsonSrs));
              writeCache(cache, header, bytes);
            }
          }
        }
        srsStore[f][size] = srs2;
      }
      return srsStore[f][size];
    },
    /**
     * returns ith Lagrange basis commitment for a given domain size
     */
    lagrangeCommitment(srs2, domainSize, i) {
      let commitment = maybeLagrangeCommitment(srs2, domainSize, i);
      if (commitment === void 0) {
        if (cache === void 0) {
          commitment = lagrangeCommitment(srs2, domainSize, i);
        } else {
          let header = cacheHeaderLagrange(f, domainSize);
          let didRead = readCache(cache, header, (bytes) => {
            let comms = JSON.parse(new TextDecoder().decode(bytes));
            let mlComms = polyCommsFromJSON(comms);
            let wasmComms = conversion[f].polyCommsToRust(mlComms);
            setLagrangeBasis(srs2, domainSize, wasmComms);
            return true;
          });
          if (didRead !== true) {
            let wasmComms = getLagrangeBasis(srs2, domainSize);
            if (cache.canWrite) {
              let mlComms = conversion[f].polyCommsFromRust(wasmComms);
              let comms = polyCommsToJSON(mlComms);
              let bytes = new TextEncoder().encode(JSON.stringify(comms));
              writeCache(cache, header, bytes);
            }
          }
          let c = maybeLagrangeCommitment(srs2, domainSize, i);
          assert2(c !== void 0, "commitment exists after setting");
          commitment = c;
        }
      }
      return conversion[f].polyCommFromRust(commitment);
    },
    /**
     * adds Lagrange basis for a given domain size
     */
    addLagrangeBasis(srs2, logSize) {
      this.lagrangeCommitment(srs2, 1 << logSize, 0);
    }
  };
}
function polyCommsToJSON(comms) {
  return MlArray.mapFrom(comms, ([, elems]) => {
    return {
      shifted: MlArray.mapFrom(elems, OrInfinity.toJSON),
      unshifted: void 0
    };
  });
}
function polyCommsFromJSON(json) {
  return MlArray.mapTo(json, ({ shifted, unshifted }) => {
    return [0, MlArray.mapTo(shifted, OrInfinity.fromJSON)];
  });
}

// dist/node/bindings/crypto/bindings.js
var tsBindings = {
  jsEnvironment,
  prefixHashes,
  prefixHashesLegacy,
  ...Bigint256Bindings,
  ...FpBindings,
  ...FqBindings,
  ...VestaBindings,
  ...PallasBindings,
  ...FpVectorBindings,
  ...FqVectorBindings,
  rustConversion: createRustConversion,
  srs: (wasm2) => srs(wasm2, getRustConversion(wasm2))
};
globalThis.__snarkyTsBindings = tsBindings;
function createRustConversion(wasm2) {
  let core = conversionCore(wasm2);
  let verifierIndex = verifierIndexConversion(wasm2, core);
  let oracles = oraclesConversion(wasm2);
  let proof = proofConversion(wasm2, core);
  return {
    fp: { ...core.fp, ...verifierIndex.fp, ...oracles.fp, ...proof.fp },
    fq: { ...core.fq, ...verifierIndex.fq, ...oracles.fq, ...proof.fq },
    fieldsToRustFlat,
    fieldsFromRustFlat,
    wireToRust: core.wireToRust,
    mapMlArrayToRustVector: core.mapMlArrayToRustVector
  };
}
var rustConversion;
function getRustConversion(wasm2) {
  return rustConversion ?? (rustConversion = createRustConversion(wasm2));
}

// dist/node/bindings/js/node/node-backend.js
var import_worker_threads = require("worker_threads");
var import_os = __toESM(require("os"), 1);
var import_plonk_wasm = __toESM(require("./bindings/compiled/_node_bindings/plonk_wasm.cjs"), 1);
var import_url = require("url");

// dist/node/lib/proof-system/workers.js
var workers = {
  numWorkers: void 0
};
var setNumberOfWorkers = (numWorkers) => {
  workers.numWorkers = numWorkers;
};

// dist/node/bindings/js/node/node-backend.js
var import_meta = {};
var url = import_meta.url;
var filename = url !== void 0 ? (0, import_url.fileURLToPath)(url) : __filename;
var wasm = import_plonk_wasm.default;
var workersReadyResolve;
var workersReady;
globalThis.startWorkers = startWorkers;
globalThis.terminateWorkers = terminateWorkers;
if (!import_worker_threads.isMainThread) {
  import_worker_threads.parentPort.postMessage({ type: "wasm_bindgen_worker_ready" });
  wasm.wbg_rayon_start_worker(import_worker_threads.workerData.receiver);
}
var state = "none";
var isNeededBy = 0;
var initializingPromise;
var exitingPromise;
async function withThreadPool(run) {
  isNeededBy++;
  switch (state) {
    case "none":
      initializingPromise = initThreadPool();
      state = "initializing";
      break;
    case "initializing":
    case "running":
      break;
    case "exiting":
      initializingPromise = exitingPromise.then(initThreadPool);
      state = "initializing";
      break;
  }
  await initializingPromise;
  initializingPromise = void 0;
  state = "running";
  let result;
  try {
    result = await run();
  } finally {
    isNeededBy--;
    switch (state) {
      case "none":
      case "initializing":
      case "exiting":
        console.error("bug in thread pool state machine");
        break;
      case "running":
        if (isNeededBy < 1) {
          exitingPromise = exitThreadPool();
          state = "exiting";
          await exitingPromise;
          if (state === "exiting") {
            exitingPromise = void 0;
            state = "none";
          }
        }
        break;
    }
  }
  return result;
}
async function initThreadPool() {
  if (!import_worker_threads.isMainThread)
    return;
  workersReady = new Promise((resolve2) => workersReadyResolve = resolve2);
  await wasm.initThreadPool(Math.max(1, workers.numWorkers ?? (import_os.default.availableParallelism() ?? 1) - 1), filename);
  await workersReady;
  workersReady = void 0;
}
async function exitThreadPool() {
  if (!import_worker_threads.isMainThread)
    return;
  await wasm.exitThreadPool();
}
var wasmWorkers = [];
async function startWorkers(src, memory, builder) {
  wasmWorkers = [];
  await Promise.all(Array.from({ length: builder.numThreads() }, () => {
    let worker = new import_worker_threads.Worker(src, {
      workerData: { memory, receiver: builder.receiver() }
    });
    wasmWorkers.push(worker);
    let target = worker;
    let type = "wasm_bindgen_worker_ready";
    return new Promise((resolve2) => {
      let done = false;
      target.on("message", function onMsg(data) {
        if (data == null || data.type !== type || done)
          return;
        done = true;
        resolve2(worker);
      });
    });
  }));
  builder.build();
  workersReadyResolve();
}
async function terminateWorkers() {
  return Promise.all(wasmWorkers.map((w) => w.terminate())).then(() => wasmWorkers = void 0);
}

// dist/node/snarky.js
var Snarky;
var Ledger;
var Pickles;
var Test_;
var isInitialized = false;
async function initializeBindings() {
  if (isInitialized)
    return;
  isInitialized = true;
  let snarky;
  CJS:
    if (typeof require !== "undefined") {
      snarky = require("./bindings/compiled/_node_bindings/o1js_node.bc.cjs");
    }
  ({ Snarky, Ledger, Pickles, Test: Test_ } = snarky);
}
async function Test() {
  await initializeBindings();
  return Test_;
}

// dist/node/bindings/lib/provable-generic.js
var complexTypes = /* @__PURE__ */ new Set(["object", "function"]);
var primitives = /* @__PURE__ */ new Set([Number, String, Boolean, BigInt, null, void 0]);
function createDerivers() {
  const HashInput3 = createHashInput();
  function isProvable(typeObj) {
    return "sizeInFields" in typeObj && "toFields" in typeObj && "fromFields" in typeObj && "check" in typeObj && "toValue" in typeObj && "fromValue" in typeObj && "toAuxiliary" in typeObj;
  }
  function hasProvable(typeObj) {
    return "provable" in typeObj && (typeof typeObj.provable === "object" || typeof typeObj.provable === "function") && typeObj.provable !== null && isProvable(typeObj.provable);
  }
  function provable3(typeObj, options) {
    if (!isPrimitive(typeObj) && !complexTypes.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function sizeInFields(typeObj2) {
      if (isPrimitive(typeObj2))
        return 0;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (hasProvable(typeObj2))
        return typeObj2.provable.sizeInFields();
      if (Array.isArray(typeObj2))
        return typeObj2.map(sizeInFields).reduce((a2, b2) => a2 + b2, 0);
      if (isProvable(typeObj2))
        return typeObj2.sizeInFields();
      return Object.values(typeObj2).map(sizeInFields).reduce((a2, b2) => a2 + b2, 0);
    }
    function toFields(typeObj2, obj) {
      if (isPrimitive(typeObj2))
        return [];
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (hasProvable(typeObj2))
        return typeObj2.provable.toFields(obj);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i) => toFields(t, obj[i])).flat();
      if (isProvable(typeObj2))
        return typeObj2.toFields(obj);
      return Object.keys(typeObj2).map((k) => toFields(typeObj2[k], obj[k])).flat();
    }
    function toAuxiliary(typeObj2, obj) {
      if (typeObj2 === Number)
        return [obj ?? 0];
      if (typeObj2 === String)
        return [obj ?? ""];
      if (typeObj2 === Boolean)
        return [obj ?? false];
      if (typeObj2 === BigInt)
        return [obj ?? 0n];
      if (typeObj2 === void 0 || typeObj2 === null)
        return [];
      if (isPrimitive(typeObj2) || !complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (hasProvable(typeObj2))
        return typeObj2.provable.toAuxiliary(obj);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i) => toAuxiliary(t, obj?.[i]));
      if (isProvable(typeObj2))
        return typeObj2.toAuxiliary(obj);
      return Object.keys(typeObj2).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
    }
    function fromFields(typeObj2, fields2, aux = []) {
      if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
        return aux[0];
      if (typeObj2 === void 0 || typeObj2 === null)
        return typeObj2;
      if (isPrimitive(typeObj2) || !complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (hasProvable(typeObj2))
        return typeObj2.provable.fromFields(fields2, aux);
      if (Array.isArray(typeObj2)) {
        let array = [];
        let i = 0;
        let offset = 0;
        for (let subObj of typeObj2) {
          let size = sizeInFields(subObj);
          array.push(fromFields(subObj, fields2.slice(offset, offset + size), aux[i]));
          offset += size;
          i++;
        }
        return array;
      }
      if (isProvable(typeObj2))
        return typeObj2.fromFields(fields2, aux);
      let keys = Object.keys(typeObj2);
      let values = fromFields(keys.map((k) => typeObj2[k]), fields2, aux);
      return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
    }
    function check(typeObj2, obj) {
      if (isPrimitive(typeObj2))
        return;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (hasProvable(typeObj2))
        return typeObj2.provable.check(obj);
      if (Array.isArray(typeObj2))
        return typeObj2.forEach((t, i) => check(t, obj[i]));
      if (isProvable(typeObj2))
        return typeObj2.check(obj);
      if (display(typeObj2) === "Struct") {
        throw new Error(`provable: cannot run check() on 'Struct' type. Instead of using 'Struct' directly, extend 'Struct' to create a specific type.

Example:
// Incorrect Usage:
class MyStruct extends Struct({
  fieldA: Struct, // This is incorrect
}) {}

// Correct Usage:
class MyStruct extends Struct({
  fieldA: MySpecificStruct, // Use the specific struct type
}) {}
`);
      }
      if (typeof typeObj2 === "function") {
        throw new Error(`provable: invalid type detected. Functions are not supported as types. Ensure you are passing an instance of a supported type or an anonymous object.
`);
      }
      return Object.keys(typeObj2).forEach((k) => check(typeObj2[k], obj[k]));
    }
    const toValue = createMap("toValue");
    const fromValue = createMap("fromValue");
    let { empty: empty4, fromJSON, toJSON, toInput } = signable2(
      typeObj,
      // if one of these is true, we don't want to continue searching for 'signable' methods
      (obj) => isProvable(obj) || hasProvable(obj)
    );
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj),
      toAuxiliary: (obj) => toAuxiliary(typeObj, obj),
      fromFields: (fields2, aux) => fromFields(typeObj, fields2, aux),
      check: (obj) => check(typeObj, obj),
      toValue(x) {
        return toValue(typeObj, x);
      },
      fromValue(v) {
        return fromValue(typeObj, v);
      },
      toInput: (obj) => toInput(obj),
      toJSON: (obj) => toJSON(obj),
      fromJSON: (json) => fromJSON(json),
      empty: () => empty4()
    };
  }
  function signable2(typeObj, shouldTerminate) {
    let objectKeys = typeof typeObj === "object" && typeObj !== null ? Object.keys(typeObj) : [];
    let primitives3 = /* @__PURE__ */ new Set([
      Number,
      String,
      Boolean,
      BigInt,
      null,
      void 0
    ]);
    if (!primitives3.has(typeObj) && !complexTypes.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function toInput(typeObj2, obj) {
      if (primitives3.has(typeObj2))
        return {};
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if ("provable" in typeObj2)
        return toInput(typeObj2.provable, obj);
      if (Array.isArray(typeObj2)) {
        return typeObj2.map((t, i) => toInput(t, obj[i])).reduce(HashInput3.append, HashInput3.empty);
      }
      if ("toInput" in typeObj2)
        return typeObj2.toInput(obj);
      if ("toFields" in typeObj2) {
        return { fields: typeObj2.toFields(obj) };
      }
      return Object.keys(typeObj2).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput3.append, HashInput3.empty);
    }
    function toJSON(typeObj2, obj) {
      if (typeObj2 === BigInt)
        return obj.toString();
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return obj;
      if (typeObj2 === void 0 || typeObj2 === null)
        return null;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if ("provable" in typeObj2)
        return toJSON(typeObj2.provable, obj);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i) => toJSON(t, obj[i]));
      if ("toJSON" in typeObj2)
        return typeObj2.toJSON(obj);
      if (shouldTerminate?.(typeObj2) === true) {
        throw Error(`Expected \`toJSON()\` method on ${display(typeObj2)}`);
      }
      return Object.fromEntries(Object.keys(typeObj2).map((k) => [k, toJSON(typeObj2[k], obj[k])]));
    }
    function fromJSON(typeObj2, json) {
      if (typeObj2 === BigInt)
        return BigInt(json);
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return json;
      if (typeObj2 === null || typeObj2 === void 0)
        return void 0;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if ("provable" in typeObj2)
        return fromJSON(typeObj2.provable, json);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i) => fromJSON(t, json[i]));
      if ("fromJSON" in typeObj2)
        return typeObj2.fromJSON(json);
      if (shouldTerminate?.(typeObj2) === true) {
        throw Error(`Expected \`fromJSON()\` method on ${display(typeObj2)}`);
      }
      let keys = Object.keys(typeObj2);
      let values = fromJSON(keys.map((k) => typeObj2[k]), keys.map((k) => json[k]));
      return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
    }
    function empty4(typeObj2) {
      if (typeObj2 === Number)
        return 0;
      if (typeObj2 === String)
        return "";
      if (typeObj2 === Boolean)
        return false;
      if (typeObj2 === BigInt)
        return 0n;
      if (typeObj2 === null || typeObj2 === void 0)
        return typeObj2;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if ("provable" in typeObj2)
        return empty4(typeObj2.provable);
      if (Array.isArray(typeObj2))
        return typeObj2.map(empty4);
      if ("empty" in typeObj2)
        return typeObj2.empty();
      if (shouldTerminate?.(typeObj2) === true) {
        throw Error(`Expected \`empty()\` method on ${display(typeObj2)}`);
      }
      return Object.fromEntries(Object.keys(typeObj2).map((k) => [k, empty4(typeObj2[k])]));
    }
    return {
      toInput: (obj) => toInput(typeObj, obj),
      toJSON: (obj) => toJSON(typeObj, obj),
      fromJSON: (json) => fromJSON(typeObj, json),
      empty: () => empty4(typeObj)
    };
  }
  function display(typeObj) {
    if ("name" in typeObj)
      return typeObj.name;
    return "anonymous type object";
  }
  function createMap(name) {
    function map(typeObj, obj) {
      if (primitives.has(typeObj))
        return obj;
      if (!complexTypes.has(typeof typeObj))
        throw Error(`provable: unsupported type "${typeObj}"`);
      if (hasProvable(typeObj) && name in typeObj.provable)
        return typeObj.provable[name](obj);
      if (Array.isArray(typeObj))
        return typeObj.map((t, i) => map(t, obj[i]));
      if (name in typeObj)
        return typeObj[name](obj);
      return Object.fromEntries(Object.keys(typeObj).map((k) => [k, map(typeObj[k], obj[k])]));
    }
    return map;
  }
  return { provable: provable3, signable: signable2 };
}
function isPrimitive(typeObj) {
  return primitives.has(typeObj);
}
function createHashInput() {
  return {
    get empty() {
      return {};
    },
    append(input1, input2) {
      return {
        fields: (input1.fields ?? []).concat(input2.fields ?? []),
        packed: (input1.packed ?? []).concat(input2.packed ?? [])
      };
    }
  };
}

// dist/node/bindings/crypto/non-negative.js
function assertNonNegativeInteger(n, message) {
  if (!Number.isInteger(n) || n < 0)
    throw Error(message);
}
function assertPositiveInteger(n, message) {
  if (!Number.isInteger(n) || n <= 0)
    throw Error(message);
}

// dist/node/bindings/lib/binable.js
function defineBinable({ toBytes, readBytes }) {
  let readBytes_ = (bytes, offset) => {
    assertNonNegativeInteger(offset, "readBytes: offset must be integer >= 0");
    if (offset >= bytes.length)
      throw Error("readBytes: offset must be within bytes length");
    let [value, end] = readBytes(bytes, offset);
    if (end < offset)
      throw Error("offset returned by readBytes must be greater than initial offset");
    if (end > bytes.length)
      throw Error("offset returned by readBytes must not exceed bytes length");
    return [value, end];
  };
  return {
    toBytes,
    readBytes: readBytes_,
    // spec: fromBytes throws if the input bytes are not all used
    fromBytes(bytes) {
      let [value, offset] = readBytes_(bytes, 0);
      if (offset < bytes.length)
        throw Error("fromBytes: input bytes left over");
      return value;
    }
  };
}
function withVersionNumber(binable, versionNumber) {
  return defineBinable({
    toBytes(t) {
      let bytes = binable.toBytes(t);
      bytes.unshift(versionNumber);
      return bytes;
    },
    readBytes(bytes, offset) {
      let version = bytes[offset++];
      if (version !== versionNumber) {
        throw Error(`fromBytes: Invalid version byte. Expected ${versionNumber}, got ${version}.`);
      }
      return binable.readBytes(bytes, offset);
    }
  });
}
function withCheck({ toBytes, readBytes }, check) {
  return defineBinable({
    toBytes,
    readBytes(bytes, start) {
      let [value, end] = readBytes(bytes, start);
      check(value);
      return [value, end];
    }
  });
}
function record(binables, keys) {
  let binablesTuple = keys.map((key) => binables[key]);
  let tupleBinable = tuple(binablesTuple);
  return defineBinable({
    toBytes(t) {
      let array = keys.map((key) => t[key]);
      return tupleBinable.toBytes(array);
    },
    readBytes(bytes, start) {
      let [tupleValue, end] = tupleBinable.readBytes(bytes, start);
      let value = Object.fromEntries(keys.map((key, i) => [key, tupleValue[i]]));
      return [value, end];
    }
  });
}
function tuple(binables) {
  let n = binables.length;
  return defineBinable({
    toBytes(t) {
      let bytes = [];
      for (let i = 0; i < n; i++) {
        let subBytes = binables[i].toBytes(t[i]);
        bytes.push(...subBytes);
      }
      return bytes;
    },
    readBytes(bytes, offset) {
      let values = [];
      for (let i = 0; i < n; i++) {
        let [value, newOffset] = binables[i].readBytes(bytes, offset);
        offset = newOffset;
        values.push(value);
      }
      return [values, offset];
    }
  });
}
var BinableString = defineBinable({
  toBytes(t) {
    return [stringLengthInBytes(t), ...stringToBytes(t)];
  },
  readBytes(bytes, offset) {
    let length = bytes[offset++];
    let end = offset + length;
    let string = stringFromBytes(bytes.slice(offset, end));
    return [string, end];
  }
});
var CODE_NEG_INT8 = 255;
var CODE_INT16 = 254;
var CODE_INT32 = 253;
var CODE_INT64 = 252;
function BinableInt(bits) {
  let maxValue = 1n << BigInt(bits - 1);
  let nBytes = bits >> 3;
  if (nBytes * 8 !== bits)
    throw Error("bits must be evenly divisible by 8");
  return defineBinable({
    toBytes(n) {
      if (n < -maxValue || n >= maxValue)
        throw Error(`int${bits} out of range, got ${n}`);
      if (n >= 0) {
        if (n < 0x80n)
          return bigIntToBytes(n, 1);
        if (n < 0x8000n)
          return [CODE_INT16, ...bigIntToBytes(n, 2)];
        if (n < 2147483648)
          return [CODE_INT32, ...bigIntToBytes(n, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(n, 8)];
      } else {
        let M = 1n << 64n;
        if (n >= -0x80n)
          return [CODE_NEG_INT8, ...bigIntToBytes(M + n & 0xffn, 1)];
        if (n >= -0x8000n)
          return [CODE_INT16, ...bigIntToBytes(M + n & 0xffffn, 2)];
        if (n >= -2147483648)
          return [CODE_INT32, ...bigIntToBytes(M + n & 0xffffffffn, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(M + n, 8)];
      }
    },
    readBytes(bytes, offset) {
      let code = bytes[offset++];
      if (code < 128)
        return [BigInt(code), offset];
      let size = {
        [CODE_NEG_INT8]: 1,
        [CODE_INT16]: 2,
        [CODE_INT32]: 4,
        [CODE_INT64]: 8
      }[code];
      if (size === void 0) {
        throw Error("binable integer: invalid start byte");
      }
      let end = offset + size;
      let x = fillUInt(bytes.slice(offset, end), nBytes);
      if (x >= maxValue) {
        x -= 2n * maxValue;
      }
      if (x < -maxValue || x >= maxValue) {
        throw Error(`int${bits} out of range, got ${x}`);
      }
      return [x, end];
    }
  });
}
function fillUInt(startBytes, nBytes) {
  let n = startBytes.length;
  let lastBit = startBytes[n - 1] >> 7;
  let fillByte = lastBit === 1 ? 255 : 0;
  let intBytes = startBytes.concat(Array(nBytes - n).fill(fillByte));
  let x = bytesToBigInt(intBytes);
  return x;
}
function BinableUint(bits) {
  let binableInt = BinableInt(bits);
  let maxValue = 1n << BigInt(bits - 1);
  return iso(binableInt, {
    to(uint) {
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits} out of range, got ${uint}`);
      let ret = uint >= maxValue ? uint - 2n * maxValue : uint;
      return ret;
    },
    from(int) {
      let uint = int < 0n ? int + 2n * maxValue : int;
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits} out of range, got ${uint}`);
      return uint;
    }
  });
}
var BinableInt64 = BinableInt(64);
var BinableInt32 = BinableInt(32);
var BinableUint64 = BinableUint(64);
var BinableUint32 = BinableUint(32);
function prefixToField(Field5, prefix) {
  let fieldSize = Field5.sizeInBytes;
  if (prefix.length >= fieldSize)
    throw Error("prefix too long");
  let stringBytes = stringToBytes(prefix);
  return Field5.fromBytes(stringBytes.concat(Array(fieldSize - stringBytes.length).fill(0)));
}
function bitsToBytes([...bits]) {
  let bytes = [];
  while (bits.length > 0) {
    let byteBits = bits.splice(0, 8);
    let byte = 0;
    for (let i = 0; i < 8; i++) {
      if (!byteBits[i])
        continue;
      byte |= 1 << i;
    }
    bytes.push(byte);
  }
  return bytes;
}
function bytesToBits(bytes) {
  return bytes.map((byte) => {
    let bits = Array(8);
    for (let i = 0; i < 8; i++) {
      bits[i] = !!(byte & 1);
      byte >>= 1;
    }
    return bits;
  }).flat();
}
function withBits(binable, sizeInBits2) {
  return {
    ...binable,
    toBits(t) {
      return bytesToBits(binable.toBytes(t)).slice(0, sizeInBits2);
    },
    fromBits(bits) {
      return binable.fromBytes(bitsToBytes(bits));
    },
    sizeInBytes: Math.ceil(sizeInBits2 / 8),
    sizeInBits: sizeInBits2
  };
}
function iso(binable, { to, from }) {
  return defineBinable({
    toBytes(s) {
      return binable.toBytes(to(s));
    },
    readBytes(bytes, offset) {
      let [value, end] = binable.readBytes(bytes, offset);
      return [from(value), end];
    }
  });
}
var encoder2 = new TextEncoder();
var decoder = new TextDecoder();
function stringToBytes(s) {
  return [...encoder2.encode(s)];
}
function stringFromBytes(bytes) {
  return decoder.decode(Uint8Array.from(bytes));
}
function stringLengthInBytes(s) {
  return encoder2.encode(s).length;
}

// dist/node/mina-signer/src/derivers-bigint.js
var { signable } = createDerivers();
function SignableBigint(check) {
  return {
    toInput(x) {
      return { fields: [x], packed: [] };
    },
    toJSON(x) {
      return x.toString();
    },
    fromJSON(json) {
      if (isNaN(json) || isNaN(parseFloat(json))) {
        throw Error(`fromJSON: expected a numeric string, got "${json}"`);
      }
      let x = BigInt(json);
      check(x);
      return x;
    },
    empty() {
      return 0n;
    }
  };
}
function BinableBigint(sizeInBits2, check) {
  let sizeInBytes = Math.ceil(sizeInBits2 / 8);
  return withBits(defineBinable({
    toBytes(x) {
      return bigIntToBytes(x, sizeInBytes);
    },
    readBytes(bytes, start) {
      let x = 0n;
      let bitPosition = 0n;
      let end = Math.min(start + sizeInBytes, bytes.length);
      for (let i = start; i < end; i++) {
        x += BigInt(bytes[i]) << bitPosition;
        bitPosition += 8n;
      }
      check(x);
      return [x, end];
    }
  }), sizeInBits2);
}
function BinableBool(check) {
  return withBits(defineBinable({
    toBytes(x) {
      return [x ? 1 : 0];
    },
    readBytes(bytes, start) {
      let byte = bytes[start];
      check(byte);
      return [byte === 1, start + 1];
    }
  }), 1);
}

// dist/node/mina-signer/src/field-bigint.js
var sizeInBits = Fp.sizeInBits;
var minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
var checkField = checkRange(0n, Fp.modulus, "Field");
var checkBool = checkAllowList(/* @__PURE__ */ new Set([0n, 1n]), "Bool");
var checkBoolBytes = checkAllowList(/* @__PURE__ */ new Set([0, 1]), "Bool");
var checkSign = checkAllowList(/* @__PURE__ */ new Set([1n, minusOne]), "Sign");
var BinableFp = BinableBigint(Fp.sizeInBits, checkField);
var SignableFp = SignableBigint(checkField);
var Field = pseudoClass(function Field2(value) {
  return mod(BigInt(value), Fp.modulus);
}, { ...SignableFp, ...BinableFp, ...Fp, toBigint: (x) => x });
var Bool = pseudoClass(function Bool2(value) {
  return value;
}, {
  ...BinableBool(checkBoolBytes),
  fromBigint(x) {
    checkBool(x);
    return x === 0n ? false : true;
  },
  toBigint(x) {
    return x ? 1n : 0n;
  },
  toInput(x) {
    return { fields: [], packed: [[Bool.toBigint(x), 1]] };
  },
  toBoolean(x) {
    return x;
  },
  toJSON(x) {
    return x;
  },
  fromJSON(b2) {
    return b2;
  },
  empty() {
    return false;
  },
  sizeInBytes: 1,
  fromField(x) {
    return Bool.fromBigint(x);
  }
});
function Unsigned(bits) {
  let maxValue = (1n << BigInt(bits)) - 1n;
  let checkUnsigned = checkRange(0n, 1n << BigInt(bits), `UInt${bits}`);
  let binable = BinableBigint(bits, checkUnsigned);
  let bytes = Math.ceil(bits / 8);
  return pseudoClass(function Unsigned2(value) {
    let x = BigInt(value);
    checkUnsigned(x);
    return x;
  }, {
    ...SignableBigint(checkUnsigned),
    ...binable,
    toInput(x) {
      return { fields: [], packed: [[x, bits]] };
    },
    maxValue,
    random() {
      return binable.fromBytes([...randomBytes(bytes)]);
    }
  });
}
var UInt32 = Unsigned(32);
var UInt64 = Unsigned(64);
var Sign = pseudoClass(function Sign2(value) {
  if (value !== 1 && value !== -1)
    throw Error("Sign: input must be 1 or -1.");
  return mod(BigInt(value), Fp.modulus);
}, {
  ...SignableBigint(checkSign),
  ...BinableBigint(1, checkSign),
  empty() {
    return 1n;
  },
  toInput(x) {
    return { fields: [], packed: [[x === 1n ? 1n : 0n, 1]] };
  },
  fromFields([x]) {
    if (x === 0n)
      return 1n;
    checkSign(x);
    return x;
  },
  toJSON(x) {
    return x === 1n ? "Positive" : "Negative";
  },
  fromJSON(x) {
    if (x !== "Positive" && x !== "Negative")
      throw Error("Sign: invalid input");
    return x === "Positive" ? 1n : minusOne;
  }
});
function pseudoClass(constructor, module2) {
  return Object.assign(constructor, module2);
}
function checkRange(lower, upper, name) {
  return (x) => {
    if (x < lower)
      throw Error(`${name}: inputs smaller than ${lower} are not allowed, got ${x}`);
    if (x >= upper)
      throw Error(`${name}: inputs larger than ${upper - 1n} are not allowed, got ${x}`);
  };
}
function checkAllowList(valid, name) {
  return (x) => {
    if (!valid.has(x)) {
      throw Error(`${name}: input must be one of ${[...valid].join(", ")}, got ${x}`);
    }
  };
}

// dist/node/lib/util/global-context.js
var Context = { create };
function create(options = {
  allowsNesting: true,
  default: void 0
}) {
  let t = Object.assign(function() {
    return t.data[t.data.length - 1]?.context;
  }, {
    data: [],
    allowsNesting: options.allowsNesting ?? true,
    get: () => get(t),
    has: () => t.data.length !== 0,
    runWith(context, func) {
      let id2 = enter(t, context);
      let result;
      let resultContext;
      try {
        result = func(context);
      } finally {
        resultContext = leave(t, id2);
      }
      return [resultContext, result];
    },
    async runWithAsync(context, func) {
      let id2 = enter(t, context);
      let result;
      let resultContext;
      try {
        result = await func(context);
      } finally {
        resultContext = leave(t, id2);
      }
      return [resultContext, result];
    },
    enter: (context) => enter(t, context),
    leave: (id2) => leave(t, id2),
    id: () => {
      if (t.data.length === 0)
        throw Error(contextConflictMessage);
      return t.data[t.data.length - 1].id;
    }
  });
  if (options.default !== void 0)
    enter(t, options.default);
  return t;
}
function enter(t, context) {
  if (t.data.length > 0 && !t.allowsNesting) {
    throw Error(contextConflictMessage);
  }
  let id2 = Math.random();
  let trace = Error().stack?.slice(5);
  t.data.push({ context, id: id2, trace });
  return id2;
}
function leave(t, id2) {
  let current = t.data.pop();
  if (current === void 0)
    throw Error(contextConflictMessage);
  if (current.id !== id2) {
    let message = contextConflictMessage;
    let expected = t.data.find((c) => c.id === id2);
    if (expected?.trace) {
      message += `

We wanted to leave the global context entered here:${expected.trace}`;
      if (current.trace) {
        message += `

But we actually would have left the global context entered here:${current.trace}`;
        message += `

Our first recommendation is to check for a missing 'await' in the second stack trace.`;
      }
      message += `

`;
    }
    throw Error(message);
  }
  return current.context;
}
function get(t) {
  if (t.data.length === 0)
    throw Error(contextConflictMessage);
  let current = t.data[t.data.length - 1];
  return current.context;
}
var contextConflictMessage = `The global context managed by o1js reached an inconsistent state. This could be caused by one of the following reasons:

- You are missing an 'await' somewhere, which causes a new global context to be entered before we finished the last one.

- You are importing two different instances of o1js, which leads to inconsistent tracking of the global context in one of those instances.
  - This is a common problem in projects that use o1js as part of a UI!

- You are running multiple async operations concurrently, which conflict in using the global context.
  - Running async o1js operations (like proving) in parallel is not supported! Try running everything serially.
  
Investigate the stack traces below for more hints about the problem.`;

// dist/node/lib/provable/core/provable-context.js
var snarkContext = Context.create({ default: {} });
function inProver() {
  return !!snarkContext.get().inProver;
}
function inCheckedComputation() {
  let ctx = snarkContext.get();
  return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;
}
function inCompile() {
  return !!snarkContext.get().inCompile;
}
function inAnalyze() {
  return !!snarkContext.get().inAnalyze;
}
function asProver(f) {
  if (inCheckedComputation()) {
    Snarky.run.asProver(f);
  } else {
    f();
  }
}
async function generateWitness(f, { checkConstraints = true } = {}) {
  await initializeBindings();
  let id2 = snarkContext.enter({ inCheckedComputation: true });
  try {
    let finish = Snarky.run.enterGenerateWitness();
    if (!checkConstraints)
      Snarky.run.setEvalConstraints(MlBool(false));
    await f();
    return finish();
  } catch (error) {
    throw prettifyStacktrace(error);
  } finally {
    if (!checkConstraints)
      Snarky.run.setEvalConstraints(MlBool(true));
    snarkContext.leave(id2);
  }
}
async function constraintSystem(f) {
  await initializeBindings();
  let id2 = snarkContext.enter({ inAnalyze: true, inCheckedComputation: true });
  try {
    let finish = Snarky.run.enterConstraintSystem();
    await f();
    let cs = finish();
    return constraintSystemToJS(cs);
  } catch (error) {
    throw prettifyStacktrace(error);
  } finally {
    snarkContext.leave(id2);
  }
}
function constraintSystemToJS(cs) {
  let json = Snarky.constraintSystem.toJson(cs);
  let rows = Snarky.constraintSystem.rows(cs);
  let digest = Snarky.constraintSystem.digest(cs);
  let { gates, publicInputSize } = gatesFromJson(json);
  return {
    rows,
    digest,
    gates,
    publicInputSize,
    print() {
      printGates(gates);
    },
    summary() {
      return summarizeGates(gates);
    }
  };
}
function gatesFromJson(cs) {
  let gates = cs.gates.map(({ typ, wires, coeffs: hexCoeffs }) => {
    let coeffs = hexCoeffs.map((hex) => parseHexString32(hex).toString());
    return { type: typ, wires, coeffs };
  });
  return { publicInputSize: cs.public_input_size, gates };
}
function summarizeGates(gates) {
  let gateTypes = {};
  gateTypes["Total rows"] = gates.length;
  for (let gate of gates) {
    gateTypes[gate.type] ??= 0;
    gateTypes[gate.type]++;
  }
  return gateTypes;
}
function printGates(gates) {
  for (let i = 0, n = gates.length; i < n; i++) {
    let { type, wires, coeffs } = gates[i];
    console.log(i.toString().padEnd(4, " "), type.padEnd(15, " "), coeffsToPretty(type, coeffs).padEnd(30, " "), wiresToPretty(wires, i));
  }
  console.log();
}
var minusRange = Fp.modulus - (1n << 64n);
function coeffsToPretty(type, coeffs) {
  if (coeffs.length === 0)
    return "";
  if (type === "Generic" && coeffs.length > 5) {
    let first = coeffsToPretty(type, coeffs.slice(0, 5));
    let second = coeffsToPretty(type, coeffs.slice(5));
    return `${first} ${second}`;
  }
  if (type === "Poseidon" && coeffs.length > 3) {
    return `${coeffsToPretty(type, coeffs.slice(0, 3)).slice(0, -1)} ...]`;
  }
  let str = coeffs.map((c) => {
    let c0 = BigInt(c);
    if (c0 > minusRange)
      c0 -= Fp.modulus;
    let cStr = c0.toString();
    if (cStr.length > 4)
      return `${cStr.slice(0, 4)}..`;
    return cStr;
  }).join(" ");
  return `[${str}]`;
}
function wiresToPretty(wires, row) {
  let strWires = [];
  let n = wires.length;
  for (let col = 0; col < n; col++) {
    let wire = wires[col];
    if (wire.row === row && wire.col === col)
      continue;
    if (wire.row === row) {
      strWires.push(`${col}->${wire.col}`);
    } else {
      strWires.push(`${col}->(${wire.row},${wire.col})`);
    }
  }
  return strWires.join(", ");
}

// dist/node/lib/provable/core/fieldvar.js
function constToBigint(x) {
  return x[1];
}
function constFromBigint(x) {
  return [0, Fp.mod(x)];
}
var FieldConst = {
  fromBigint: constFromBigint,
  toBigint: constToBigint,
  equal(x, y) {
    return x[1] === y[1];
  },
  [0]: constFromBigint(0n),
  [1]: constFromBigint(1n),
  [-1]: constFromBigint(-1n)
};
var FieldType;
(function(FieldType2) {
  FieldType2[FieldType2["Constant"] = 0] = "Constant";
  FieldType2[FieldType2["Var"] = 1] = "Var";
  FieldType2[FieldType2["Add"] = 2] = "Add";
  FieldType2[FieldType2["Scale"] = 3] = "Scale";
})(FieldType || (FieldType = {}));
var FieldVar = {
  // constructors
  Constant(x) {
    return [FieldType.Constant, x];
  },
  Var(x) {
    return [FieldType.Var, x];
  },
  Add(x, y) {
    return [FieldType.Add, x, y];
  },
  Scale(c, x) {
    return [FieldType.Scale, c, x];
  },
  constant(x) {
    let x0 = typeof x === "bigint" ? FieldConst.fromBigint(x) : x;
    return [FieldType.Constant, x0];
  },
  add(x, y) {
    if (FieldVar.isConstant(x) && x[1][1] === 0n)
      return y;
    if (FieldVar.isConstant(y) && y[1][1] === 0n)
      return x;
    if (FieldVar.isConstant(x) && FieldVar.isConstant(y)) {
      return FieldVar.constant(Fp.add(x[1][1], y[1][1]));
    }
    return [FieldType.Add, x, y];
  },
  scale(c, x) {
    let c0 = typeof c === "bigint" ? FieldConst.fromBigint(c) : c;
    if (c0[1] === 0n)
      return FieldVar.constant(0n);
    if (c0[1] === 1n)
      return x;
    if (FieldVar.isConstant(x)) {
      return FieldVar.constant(Fp.mul(c0[1], x[1][1]));
    }
    if (FieldVar.isScale(x)) {
      return [
        FieldType.Scale,
        FieldConst.fromBigint(Fp.mul(c0[1], x[1][1])),
        x[2]
      ];
    }
    return [FieldType.Scale, c0, x];
  },
  // type guards
  isConstant(x) {
    return x[0] === FieldType.Constant;
  },
  isVar(x) {
    return x[0] === FieldType.Var;
  },
  isAdd(x) {
    return x[0] === FieldType.Add;
  },
  isScale(x) {
    return x[0] === FieldType.Scale;
  },
  [0]: [FieldType.Constant, FieldConst[0]],
  [1]: [FieldType.Constant, FieldConst[1]],
  [-1]: [FieldType.Constant, FieldConst[-1]]
};

// dist/node/lib/provable/core/field-constructor.js
var fieldConstructor;
var boolConstructor;
function setFieldConstructor(constructor) {
  fieldConstructor = constructor;
}
function setBoolConstructor(constructor) {
  boolConstructor = constructor;
}
function createField2(value) {
  if (fieldConstructor === void 0)
    throw Error("Cannot construct a Field before the class was defined.");
  return new fieldConstructor(value);
}
function createBool(value) {
  if (boolConstructor === void 0)
    throw Error("Cannot construct a Bool before the class was defined.");
  return new boolConstructor(value);
}
function createBoolUnsafe(value) {
  return getBool().Unsafe.fromField(value);
}
function getField() {
  if (fieldConstructor === void 0)
    throw Error("Field class not defined yet.");
  return fieldConstructor;
}
function getBool() {
  if (boolConstructor === void 0)
    throw Error("Bool class not defined yet.");
  return boolConstructor;
}

// dist/node/lib/util/types.js
var Tuple = {
  map(tuple2, f) {
    return tuple2.map(f);
  }
};
var TupleN = {
  map(tuple2, f) {
    return tuple2.map(f);
  },
  fromArray(n, arr) {
    assert2(arr.length === n, `Expected array of length ${n}, got ${arr.length}`);
    return arr;
  },
  hasLength(n, tuple2) {
    return tuple2.length === n;
  }
};

// dist/node/lib/provable/core/exists.js
function exists(size, compute) {
  let finish = Snarky.run.enterAsProver(size);
  if (!Snarky.run.inProver()) {
    let vars2 = MlArray.mapFrom(finish(MlOption()), createVarField);
    return TupleN.fromArray(size, vars2);
  }
  let values = compute();
  if (values.length !== size)
    throw Error(`Expected witnessed values of length ${size}, got ${values.length}.`);
  let inputValues = MlArray.mapTo(values, FieldConst.fromBigint);
  let fieldVars = finish(MlOption(inputValues));
  let vars = MlArray.mapFrom(fieldVars, createVarField);
  return TupleN.fromArray(size, vars);
}
function existsOne(compute) {
  return exists(1, () => [compute()])[0];
}
async function existsAsync(size, compute) {
  let finish = Snarky.run.enterAsProver(size);
  if (!Snarky.run.inProver()) {
    let vars2 = MlArray.mapFrom(finish(MlOption()), createVarField);
    return TupleN.fromArray(size, vars2);
  }
  let values = await compute();
  if (values.length !== size)
    throw Error(`Expected witnessed values of length ${size}, got ${values.length}.`);
  let inputValues = MlArray.mapTo(values, FieldConst.fromBigint);
  let fieldVars = finish(MlOption(inputValues));
  let vars = MlArray.mapFrom(fieldVars, createVarField);
  return TupleN.fromArray(size, vars);
}
function createVarField(x) {
  return createField2(x);
}

// dist/node/lib/provable/gates.js
var Gates = {
  rangeCheck0,
  rangeCheck1,
  xor,
  zero,
  rotate,
  generic,
  lookup,
  foreignFieldAdd,
  foreignFieldMul,
  raw
};
function rangeCheck0(x, xLimbs12, xLimbs2, isCompact) {
  Snarky.gates.rangeCheck0(x.value, MlTuple2.mapTo(xLimbs12, (x2) => x2.value), MlTuple2.mapTo(xLimbs2, (x2) => x2.value), isCompact ? FieldConst[1] : FieldConst[0]);
}
function rangeCheck1(v2, v12, vCurr, vNext) {
  Snarky.gates.rangeCheck1(v2.value, v12.value, MlTuple2.mapTo(vCurr, (x) => x.value), MlTuple2.mapTo(vNext, (x) => x.value));
}
function rotate(field, rotated, excess, limbs, crumbs, two_to_rot) {
  Snarky.gates.rotate(field.value, rotated.value, excess.value, MlArray.to(limbs.map((x) => x.value)), MlArray.to(crumbs.map((x) => x.value)), FieldConst.fromBigint(two_to_rot));
}
function xor(input1, input2, outputXor, in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3) {
  Snarky.gates.xor(input1.value, input2.value, outputXor.value, in1_0.value, in1_1.value, in1_2.value, in1_3.value, in2_0.value, in2_1.value, in2_2.value, in2_3.value, out0.value, out1.value, out2.value, out3.value);
}
function generic(coefficients, inputs) {
  Snarky.gates.generic(fieldConst(coefficients.left), fieldVar(inputs.left), fieldConst(coefficients.right), fieldVar(inputs.right), fieldConst(coefficients.out), fieldVar(inputs.out), fieldConst(coefficients.mul), fieldConst(coefficients.const));
}
function lookup(tableId, index0, value0, index1, value1, index2, value2) {
  Snarky.gates.lookup([
    0,
    tableId.value,
    index0.value,
    value0.value,
    index1.value,
    value1.value,
    index2.value,
    value2.value
  ]);
}
function zero(a2, b2, c) {
  raw(KimchiGateType.Zero, [a2, b2, c], []);
}
function foreignFieldAdd({ left, right, overflow, carry, modulus, sign: sign3 }) {
  Snarky.gates.foreignFieldAdd(MlTuple2.mapTo(left, (x) => x.value), MlTuple2.mapTo(right, (x) => x.value), overflow.value, carry.value, MlTuple2.mapTo(modulus, FieldConst.fromBigint), FieldConst.fromBigint(sign3));
}
function foreignFieldMul(inputs) {
  let { left, right, remainder, quotient, quotientHiBound, product1, carry0, carry1p, carry1c, foreignFieldModulus2, negForeignFieldModulus } = inputs;
  Snarky.gates.foreignFieldMul(MlTuple2.mapTo(left, (x) => x.value), MlTuple2.mapTo(right, (x) => x.value), MlTuple2.mapTo(remainder, (x) => x.value), MlTuple2.mapTo(quotient, (x) => x.value), quotientHiBound.value, MlTuple2.mapTo(product1, (x) => x.value), carry0.value, MlTuple2.mapTo(carry1p, (x) => x.value), MlTuple2.mapTo(carry1c, (x) => x.value), FieldConst.fromBigint(foreignFieldModulus2), MlTuple2.mapTo(negForeignFieldModulus, FieldConst.fromBigint));
}
function raw(kind, values, coefficients) {
  let n = values.length;
  let padding2 = exists(15 - n, () => Array(15 - n).fill(0n));
  Snarky.gates.raw(kind, MlArray.to(values.concat(padding2).map((x) => x.value)), MlArray.to(coefficients.map(FieldConst.fromBigint)));
}
var KimchiGateType;
(function(KimchiGateType2) {
  KimchiGateType2[KimchiGateType2["Zero"] = 0] = "Zero";
  KimchiGateType2[KimchiGateType2["Generic"] = 1] = "Generic";
  KimchiGateType2[KimchiGateType2["Poseidon"] = 2] = "Poseidon";
  KimchiGateType2[KimchiGateType2["CompleteAdd"] = 3] = "CompleteAdd";
  KimchiGateType2[KimchiGateType2["VarBaseMul"] = 4] = "VarBaseMul";
  KimchiGateType2[KimchiGateType2["EndoMul"] = 5] = "EndoMul";
  KimchiGateType2[KimchiGateType2["EndoMulScalar"] = 6] = "EndoMulScalar";
  KimchiGateType2[KimchiGateType2["Lookup"] = 7] = "Lookup";
  KimchiGateType2[KimchiGateType2["CairoClaim"] = 8] = "CairoClaim";
  KimchiGateType2[KimchiGateType2["CairoInstruction"] = 9] = "CairoInstruction";
  KimchiGateType2[KimchiGateType2["CairoFlags"] = 10] = "CairoFlags";
  KimchiGateType2[KimchiGateType2["CairoTransition"] = 11] = "CairoTransition";
  KimchiGateType2[KimchiGateType2["RangeCheck0"] = 12] = "RangeCheck0";
  KimchiGateType2[KimchiGateType2["RangeCheck1"] = 13] = "RangeCheck1";
  KimchiGateType2[KimchiGateType2["ForeignFieldAdd"] = 14] = "ForeignFieldAdd";
  KimchiGateType2[KimchiGateType2["ForeignFieldMul"] = 15] = "ForeignFieldMul";
  KimchiGateType2[KimchiGateType2["Xor16"] = 16] = "Xor16";
  KimchiGateType2[KimchiGateType2["Rot64"] = 17] = "Rot64";
})(KimchiGateType || (KimchiGateType = {}));
function fieldVar(x) {
  if (typeof x === "bigint")
    return FieldVar.constant(x);
  return Array.isArray(x) ? x : x.value;
}
function fieldConst(x) {
  return typeof x === "bigint" ? FieldConst.fromBigint(x) : x;
}

// dist/node/lib/provable/gadgets/common.js
function toVar(x_) {
  let x = createField2(x_);
  if (isVar(x))
    return x;
  let xVar = existsOne(() => x.toBigInt());
  xVar.assertEquals(x);
  return xVar;
}
function isVar(x) {
  return FieldVar.isVar(fieldVar(x));
}
function toVars(fields2) {
  return Tuple.map(fields2, toVar);
}
function assert3(stmt, message) {
  if (typeof stmt === "boolean") {
    if (!stmt)
      throw Error(message ?? "Assertion failed");
  } else {
    stmt.assertTrue(message ?? "Assertion failed");
  }
}
function bitSlice(x, start, length) {
  return x >> BigInt(start) & (1n << BigInt(length)) - 1n;
}
function bit(x, i) {
  return x >> BigInt(i) & 1n;
}
function divideWithRemainder(numerator, denominator) {
  const quotient = numerator / denominator;
  const remainder = numerator - denominator * quotient;
  return { quotient, remainder };
}
function isConstant(...args) {
  return args.every((x) => x.isConstant());
}

// dist/node/lib/provable/gadgets/basic.js
function arrayGet(array, index) {
  let i = toVar(index);
  let a2 = existsOne(() => array[Number(i.toBigInt())].toBigInt());
  let n = array.length;
  for (let j = 0; j < n; j++) {
    let zj = existsOne(() => {
      let zj2 = Fp.div(Fp.sub(a2.toBigInt(), array[j].toBigInt()), Fp.sub(i.toBigInt(), Fp.fromNumber(j)));
      return zj2 ?? 0n;
    });
    if (array[j].isConstant()) {
      assertBilinear(zj, i, [1n, -BigInt(j), 0n, array[j].toBigInt()], a2);
    } else {
      let aMinusAj = toVar(a2.sub(array[j]));
      assertBilinear(zj, i, [1n, -BigInt(j), 0n, 0n], aMinusAj);
    }
  }
  return a2;
}
function assertOneOf(x, allowed) {
  let xv = toVar(x);
  let [c1, c2, ...c] = allowed;
  let n = c.length;
  if (n === 0) {
    assertBilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);
    return;
  }
  let z = bilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);
  for (let i = 0; i < n; i++) {
    if (i < n - 1) {
      z = bilinear(z, xv, [1n, -c[i], 0n, 0n]);
    } else {
      assertBilinear(z, xv, [1n, -c[i], 0n, 0n]);
    }
  }
}
function assertNotVectorEquals(x, c) {
  let xv = x.map(toVar);
  let n = c.length;
  assert(n > 1 && x.length === n, "vector lengths must match");
  let z = exists(n, () => {
    let z2 = Array(n).fill(0n);
    let i = x.findIndex((xi, i2) => xi.toBigInt() !== c[i2]);
    if (i === -1)
      return z2;
    z2[i] = Fp.inverse(Fp.sub(x[i].toBigInt(), c[i])) ?? 0n;
    return z2;
  });
  let products = xv.map((xi, i) => {
    return bilinear(xi, z[i], [1n, 0n, -c[i], 0n]);
  });
  let sum2 = products[0];
  for (let i = 1; i < n - 1; i++) {
    sum2 = bilinear(sum2, products[i], [0n, 1n, 1n, 0n]);
  }
  assertBilinear(sum2, products[n - 1], [0n, 1n, 1n, -1n]);
}
function linear(x, [a2, b2]) {
  let z = existsOne(() => {
    let x0 = createField2(x).toBigInt();
    return a2 * x0 + b2;
  });
  Gates.generic({ left: a2, right: 0n, out: -1n, mul: 0n, const: b2 }, { left: x, right: emptyCell(), out: z });
  return z;
}
function bilinear(x, y, [a2, b2, c, d]) {
  let z = existsOne(() => {
    let x0 = createField2(x).toBigInt();
    let y0 = createField2(y).toBigInt();
    return a2 * x0 * y0 + b2 * x0 + c * y0 + d;
  });
  Gates.generic({ left: b2, right: c, out: -1n, mul: a2, const: d }, { left: x, right: y, out: z });
  return z;
}
function assertBilinear(x, y, [a2, b2, c, d], z) {
  Gates.generic({ left: b2, right: c, out: z === void 0 ? 0n : -1n, mul: a2, const: d }, { left: x, right: y, out: z === void 0 ? emptyCell() : z });
}
function emptyCell() {
  return existsOne(() => 0n);
}
function reduceToScaledVar(x) {
  let { constant: c, terms } = toLinearCombination(fieldVar(x));
  terms.sort(([, [, i]], [, [, j]]) => i - j);
  if (terms.length === 0) {
    return [FieldType.Constant, FieldConst.fromBigint(c)];
  }
  if (terms.length === 1) {
    let [s, x2] = terms[0];
    if (c === 0n) {
      return [FieldType.Scale, FieldConst.fromBigint(s), x2];
    } else {
      let res2 = linear(x2, [s, c]);
      return [FieldType.Scale, FieldConst[1], res2.value];
    }
  }
  let [[s0, x0], ...rest] = terms;
  let [s1, x1] = rest.pop();
  for (let [si, xi] of rest.reverse()) {
    x1 = bilinear(xi, x1, [0n, si, s1, 0n]).value;
    s1 = 1n;
  }
  let res = bilinear(x0, x1, [0n, s0, s1, c]);
  return [FieldType.Scale, FieldConst[1], res.value];
}
function toLinearCombination(x, sx = 1n, lincom = {
  constant: 0n,
  terms: []
}) {
  let { constant, terms } = lincom;
  if (sx === 0n)
    return lincom;
  switch (x[0]) {
    case FieldType.Constant: {
      let [, [, c]] = x;
      return { constant: Fp.add(constant, Fp.mul(sx, c)), terms };
    }
    case FieldType.Var: {
      let [, i] = x;
      let y = terms.find((t) => t[1][1] === i);
      if (y === void 0)
        return { constant, terms: [[sx, x], ...terms] };
      let [sy] = y;
      y[0] = Fp.add(sy, sx);
      if (y[0] === 0n) {
        terms = terms.filter((t) => t[1][1] !== i);
      }
      return { constant, terms };
    }
    case FieldType.Scale: {
      let [, [, s], v] = x;
      return toLinearCombination(v, Fp.mul(sx, s), lincom);
    }
    case FieldType.Add: {
      let [, x1, x2] = x;
      lincom = toLinearCombination(x1, sx, lincom);
      return toLinearCombination(x2, sx, lincom);
    }
  }
}
function isVar2(x) {
  return x[0] === FieldType.Scale;
}
function isConst(x) {
  return x[0] === FieldType.Constant;
}
function getVar(x) {
  return [x[1][1], x[2]];
}
function getConst(x) {
  return x[1][1];
}
var ScaledVar = { isVar: isVar2, getVar, isConst, getConst };

// dist/node/lib/provable/gadgets/compatible.js
var { isVar: isVar3, getVar: getVar2, isConst: isConst2, getConst: getConst2 } = ScaledVar;
function assertMulCompatible(x, y, z) {
  let xv = reduceToScaledVar(x);
  let yv = reduceToScaledVar(y);
  let zv = reduceToScaledVar(z);
  if (isVar3(xv) && isVar3(yv) && isVar3(zv)) {
    let [[sx, x2], [sy, y2], [sz, z2]] = [getVar2(xv), getVar2(yv), getVar2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: sz, mul: -sx * sy, const: 0n }, { left: x2, right: y2, out: z2 });
  }
  if (isVar3(xv) && isVar3(yv) && isConst2(zv)) {
    let [[sx, x2], [sy, y2], sz] = [getVar2(xv), getVar2(yv), getConst2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: 0n, mul: sx * sy, const: -sz }, { left: x2, right: y2, out: emptyCell() });
  }
  if (isVar3(xv) && isConst2(yv) && isVar3(zv)) {
    let [[sx, x2], sy, [sz, z2]] = [getVar2(xv), getConst2(yv), getVar2(zv)];
    return Gates.generic({ left: sx * sy, right: 0n, out: -sz, mul: 0n, const: 0n }, { left: x2, right: emptyCell(), out: z2 });
  }
  if (isConst2(xv) && isVar3(yv) && isVar3(zv)) {
    let [sx, [sy, y2], [sz, z2]] = [getConst2(xv), getVar2(yv), getVar2(zv)];
    return Gates.generic({ left: 0n, right: sx * sy, out: -sz, mul: 0n, const: 0n }, { left: emptyCell(), right: y2, out: z2 });
  }
  if (isVar3(xv) && isConst2(yv) && isConst2(zv)) {
    let [[sx, x2], sy, sz] = [getVar2(xv), getConst2(yv), getConst2(zv)];
    return Gates.generic({ left: sx * sy, right: 0n, out: 0n, mul: 0n, const: -sz }, { left: x2, right: emptyCell(), out: emptyCell() });
  }
  if (isConst2(xv) && isVar3(yv) && isConst2(zv)) {
    let [sx, [sy, y2], sz] = [getConst2(xv), getVar2(yv), getConst2(zv)];
    return Gates.generic({ left: 0n, right: sx * sy, out: 0n, mul: 0n, const: -sz }, { left: emptyCell(), right: y2, out: emptyCell() });
  }
  if (isConst2(xv) && isConst2(yv) && isVar3(zv)) {
    let [sx, sy, [sz, z2]] = [getConst2(xv), getConst2(yv), getVar2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: sz, mul: 0n, const: -sx * sy }, { left: emptyCell(), right: emptyCell(), out: z2 });
  }
  if (isConst2(xv) && isConst2(yv) && isConst2(zv)) {
    let [sx, sy, sz] = [getConst2(xv), getConst2(yv), getConst2(zv)];
    assert3(Fp.equal(Fp.mul(sx, sy), sz), `assertMul(): ${sx} * ${sy} !== ${sz}`);
    return;
  }
  assert3(false, `assertMul(): unreachable`);
}
function assertSquareCompatible(x, z) {
  let xv = reduceToScaledVar(x);
  let zv = reduceToScaledVar(z);
  if (isVar3(xv) && isVar3(zv)) {
    let [[sx, x2], [sz, z2]] = [getVar2(xv), getVar2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: -sz, mul: sx ** 2n, const: 0n }, { left: x2, right: x2, out: z2 });
  }
  if (isVar3(xv) && isConst2(zv)) {
    let [[sx, x2], sz] = [getVar2(xv), getConst2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: 0n, mul: sx ** 2n, const: -sz }, { left: x2, right: x2, out: emptyCell() });
  }
  if (isConst2(xv) && isVar3(zv)) {
    let [sx, [sz, z2]] = [getConst2(xv), getVar2(zv)];
    return Gates.generic({ left: 0n, right: 0n, out: sz, mul: 0n, const: -(sx ** 2n) }, { left: emptyCell(), right: emptyCell(), out: z2 });
  }
  if (isConst2(xv) && isConst2(zv)) {
    let [sx, sz] = [getConst2(xv), getConst2(zv)];
    assert3(Fp.equal(Fp.square(sx), sz), `assertSquare(): ${sx}^2 !== ${sz}`);
    return;
  }
  assert3(false, `assertSquare(): unreachable`);
}
function assertBooleanCompatible(x) {
  let xv = reduceToScaledVar(x);
  if (isVar3(xv)) {
    let [s, x2] = getVar2(xv);
    return Gates.generic({ left: -s, right: 0n, out: 0n, mul: s ** 2n, const: 0n }, { left: x2, right: x2, out: emptyCell() });
  }
  let x0 = getConst2(xv);
  assert3(Fp.equal(Fp.square(x0), x0), `assertBoolean(): ${x} is not 0 or 1`);
}
function assertEqualCompatible(x, y) {
  let yv = reduceToScaledVar(y);
  let xv = reduceToScaledVar(x);
  if (isVar3(xv) && isVar3(yv)) {
    let [[sx, x2], [sy, y2]] = [getVar2(xv), getVar2(yv)];
    if (sx === sy) {
      return Snarky.field.assertEqual(x2, y2);
    }
    return Gates.generic({ left: sx, right: -sy, out: 0n, mul: 0n, const: 0n }, { left: x2, right: y2, out: emptyCell() });
  }
  if (isVar3(xv) && isConst2(yv)) {
    let [[sx, x2], sy] = [getVar2(xv), getConst2(yv)];
    return Snarky.field.assertEqual(FieldVar.scale(sx, x2), FieldVar.constant(sy));
  }
  if (isConst2(xv) && isVar3(yv)) {
    let [sx, [sy, y2]] = [getConst2(xv), getVar2(yv)];
    return Snarky.field.assertEqual(FieldVar.constant(sx), FieldVar.scale(sy, y2));
  }
  if (isConst2(xv) && isConst2(yv)) {
    let [sx, sy] = [getConst2(xv), getConst2(yv)];
    assert3(Fp.equal(sx, sy), `assertEqual(): ${sx} !== ${sy}`);
    return;
  }
  assert3(false, `assertEqual(): unreachable`);
}

// dist/node/lib/provable/bool.js
var Bool3 = class _Bool {
  constructor(x) {
    if (x instanceof _Bool) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      this.value = x;
      return;
    }
    this.value = FieldVar.constant(BigInt(x));
  }
  isConstant() {
    return this.value[0] === FieldType.Constant;
  }
  /**
   * Converts a {@link Bool} to a {@link Field}. `false` becomes 0 and `true` becomes 1.
   */
  toField() {
    return _Bool.toField(this);
  }
  /**
   * @returns a new {@link Bool} that is the negation of this {@link Bool}.
   */
  not() {
    if (this.isConstant()) {
      return new _Bool(!this.toBoolean());
    }
    let not2 = new Field3(1).sub(this.toField());
    return new _Bool(not2.value);
  }
  /**
   * @param y A {@link Bool} to AND with this {@link Bool}.
   * @returns a new {@link Bool} that is set to true only if
   * this {@link Bool} and `y` are also true.
   */
  and(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new _Bool(this.toBoolean() && toBoolean(y));
    }
    return new _Bool(this.toField().mul(_Bool.toField(y)).value);
  }
  /**
   * @param y a {@link Bool} to OR with this {@link Bool}.
   * @returns a new {@link Bool} that is set to true if either
   * this {@link Bool} or `y` is true.
   */
  or(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new _Bool(this.toBoolean() || toBoolean(y));
    }
    return this.not().and(new _Bool(y).not()).not();
  }
  /**
   * Whether this Bool implies another Bool `y`.
   *
   * This is the same as `x.not().or(y)`: if `x` is true, then `y` must be true for the implication to be true.
   *
   * @example
   * ```ts
   * let isZero = x.equals(0);
   * let lessThan10 = x.lessThan(10);
   * assert(isZero.implies(lessThan10), 'x = 0 implies x < 10');
   * ```
   */
  implies(y) {
    return this.not().or(y);
  }
  /**
   * Proves that this {@link Bool} is equal to `y`.
   * @param y a {@link Bool}.
   */
  assertEquals(y, message) {
    try {
      if (this.isConstant() && isConstant2(y)) {
        if (this.toBoolean() !== toBoolean(y)) {
          throw Error(`Bool.assertEquals(): ${this} != ${y}`);
        }
        return;
      }
      this.toField().assertEquals(_Bool.toField(y));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Proves that this {@link Bool} is `true`.
   */
  assertTrue(message) {
    try {
      if (this.isConstant() && !this.toBoolean()) {
        throw Error(`Bool.assertTrue(): ${this} != ${true}`);
      }
      this.assertEquals(true);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Proves that this {@link Bool} is `false`.
   */
  assertFalse(message) {
    try {
      if (this.isConstant() && this.toBoolean()) {
        throw Error(`Bool.assertFalse(): ${this} != ${false}`);
      }
      this.assertEquals(false);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Returns true if this {@link Bool} is equal to `y`.
   * @param y a {@link Bool}.
   */
  equals(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new _Bool(this.toBoolean() === toBoolean(y));
    }
    if (isConstant2(y)) {
      if (toBoolean(y))
        return this;
      else
        return this.not();
    }
    if (this.isConstant()) {
      return new _Bool(y).equals(this);
    }
    let z = existsOne(() => BigInt(this.toBoolean() !== toBoolean(y)));
    let x = this.toField();
    let y_ = _Bool.toField(y);
    assertMulCompatible(x.add(x), y_, x.add(y_).sub(z));
    return new _Bool(z.value).not();
  }
  /**
   * Returns the size of this type.
   */
  sizeInFields() {
    return 1;
  }
  /**
   * Serializes this {@link Bool} into {@link Field} elements.
   */
  toFields() {
    return _Bool.toFields(this);
  }
  /**
   * Serialize the {@link Bool} to a string, e.g. for printing.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  toString() {
    return this.toBoolean().toString();
  }
  /**
   * Serialize the {@link Bool} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  toJSON() {
    return this.toBoolean();
  }
  /**
   * This converts the {@link Bool} to a JS `boolean`.
   * This can only be called on non-witness values.
   */
  toBoolean() {
    if (this.isConstant()) {
      return FieldConst.equal(this.value[1], FieldConst[1]);
    }
    if (!Snarky.run.inProverBlock()) {
      throw Error(readVarMessage("toBoolean", "b", "Bool"));
    }
    let value = Snarky.field.readVar(this.value);
    return FieldConst.equal(value, FieldConst[1]);
  }
  static toField(x) {
    return new Field3(toFieldVar(x));
  }
  /**
   * Boolean negation.
   */
  static not(x) {
    if (x instanceof _Bool) {
      return x.not();
    }
    return new _Bool(!x);
  }
  /**
   * Boolean AND operation.
   */
  static and(x, y) {
    if (x instanceof _Bool) {
      return x.and(y);
    }
    return new _Bool(x).and(y);
  }
  /**
   * Boolean OR operation.
   */
  static or(x, y) {
    if (x instanceof _Bool) {
      return x.or(y);
    }
    return new _Bool(x).or(y);
  }
  /**
   * Asserts if both {@link Bool} are equal.
   */
  static assertEqual(x, y) {
    if (x instanceof _Bool) {
      x.assertEquals(y);
      return;
    }
    new _Bool(x).assertEquals(y);
  }
  /**
   * Checks two {@link Bool} for equality.
   */
  static equal(x, y) {
    if (x instanceof _Bool) {
      return x.equals(y);
    }
    return new _Bool(x).equals(y);
  }
  /**
   * Static method to serialize a {@link Bool} into an array of {@link Field} elements.
   */
  static toFields(x) {
    return [_Bool.toField(x)];
  }
  /**
   * Static method to serialize a {@link Bool} into its auxiliary data.
   */
  static toAuxiliary(_) {
    return [];
  }
  /**
   * Creates a data structure from an array of serialized {@link Field} elements.
   */
  static fromFields(fields2) {
    if (fields2.length !== 1) {
      throw Error(`Bool.fromFields(): expected 1 field, got ${fields2.length}`);
    }
    return new _Bool(fields2[0].value);
  }
  /**
   * `Provable<Bool>.toValue()`
   */
  static toValue(x) {
    return x.toBoolean();
  }
  /**
   * `Provable<Bool>.fromValue()`
   */
  static fromValue(b2) {
    if (typeof b2 === "boolean")
      return new _Bool(b2);
    return b2;
  }
  /**
   * Serialize a {@link Bool} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  static toJSON(x) {
    return x.toBoolean();
  }
  /**
   * Deserialize a JSON structure into a {@link Bool}.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  static fromJSON(b2) {
    return new _Bool(b2);
  }
  /**
   * Returns the size of this type.
   */
  static sizeInFields() {
    return 1;
  }
  static empty() {
    return new _Bool(false);
  }
  static toInput(x) {
    return { packed: [[x.toField(), 1]] };
  }
  static toBytes(b2) {
    return BoolBinable.toBytes(b2);
  }
  static fromBytes(bytes) {
    return BoolBinable.fromBytes(bytes);
  }
  static readBytes(bytes, offset) {
    return BoolBinable.readBytes(bytes, offset);
  }
  static check(x) {
    x.toField().assertBool();
  }
};
Bool3.sizeInBytes = 1;
Bool3.Unsafe = {
  /**
   * Converts a {@link Field} into a {@link Bool}. This is an **unsafe** operation
   * as it assumes that the field element is either 0 or 1 (which might not be true).
   *
   * Only use this if you have already constrained the Field element to be 0 or 1.
   *
   * @param x a {@link Field}
   */
  fromField(x) {
    return new Bool3(x.value);
  }
};
setBoolConstructor(Bool3);
var BoolBinable = defineBinable({
  toBytes(b2) {
    return [Number(b2.toBoolean())];
  },
  readBytes(bytes, offset) {
    return [new Bool3(!!bytes[offset]), offset + 1];
  }
});
function isConstant2(x) {
  if (typeof x === "boolean") {
    return true;
  }
  return x.isConstant();
}
function toBoolean(x) {
  if (typeof x === "boolean") {
    return x;
  }
  return x.toBoolean();
}
function toFieldVar(x) {
  if (x instanceof Bool3)
    return x.value;
  return FieldVar.constant(BigInt(x));
}

// dist/node/lib/provable/types/provable-intf.js
var ProvableType = {
  get(type) {
    return (typeof type === "object" || typeof type === "function") && type !== null && "provable" in type ? type.provable : type;
  }
};

// dist/node/lib/provable/types/provable-derivers.js
var HashInput = createHashInput();
var { provable } = createDerivers();
function provablePure(typeObj) {
  return provable(typeObj, { isPure: true });
}
function provableTuple(types) {
  return provable(types);
}
function provableFromClass(Class, typeObj) {
  let raw2 = provable(typeObj);
  return {
    sizeInFields: raw2.sizeInFields,
    toFields: raw2.toFields,
    toAuxiliary: raw2.toAuxiliary,
    fromFields(fields2, aux) {
      return construct(Class, raw2.fromFields(fields2, aux));
    },
    check(value) {
      if (Class.check !== void 0) {
        Class.check(value);
      } else {
        raw2.check(value);
      }
    },
    toValue: raw2.toValue,
    fromValue(x) {
      return construct(Class, raw2.fromValue(x));
    },
    toInput: raw2.toInput,
    toJSON: raw2.toJSON,
    fromJSON(x) {
      return construct(Class, raw2.fromJSON(x));
    },
    empty() {
      return Class.empty !== void 0 ? Class.empty() : construct(Class, raw2.empty());
    }
  };
}
function construct(Class, value) {
  let instance = Object.create(Class.prototype);
  return Object.assign(instance, value);
}
function provableExtends(S, base) {
  return {
    sizeInFields() {
      return base.sizeInFields();
    },
    toFields(value) {
      return base.toFields(value);
    },
    toAuxiliary(value) {
      return base.toAuxiliary(value);
    },
    fromFields(fields2, aux) {
      return new S(base.fromFields(fields2, aux));
    },
    check(value) {
      base.check(value);
    },
    toValue(value) {
      return base.toValue(value);
    },
    fromValue(value) {
      return new S(base.fromValue(value));
    },
    empty() {
      return new S(base.empty());
    },
    toInput(value) {
      return base.toInput(value);
    }
  };
}

// dist/node/lib/provable/types/witness.js
function witness(type, compute) {
  const provable3 = ProvableType.get(type);
  let ctx = snarkContext.get();
  if (!inCheckedComputation() || ctx.inWitnessBlock) {
    return clone(provable3, provable3.fromValue(compute()));
  }
  let proverValue = void 0;
  let fields2;
  let id2 = snarkContext.enter({ ...ctx, inWitnessBlock: true });
  try {
    fields2 = exists(provable3.sizeInFields(), () => {
      let value2 = provable3.fromValue(compute());
      proverValue = value2;
      let fields3 = provable3.toFields(value2);
      return fields3.map((x) => x.toBigInt());
    });
  } finally {
    snarkContext.leave(id2);
  }
  let aux = provable3.toAuxiliary(proverValue);
  let value = provable3.fromFields(fields2, aux);
  provable3.check(value);
  return value;
}
async function witnessAsync(type, compute) {
  const provable3 = ProvableType.get(type);
  let ctx = snarkContext.get();
  if (!inCheckedComputation() || ctx.inWitnessBlock) {
    let value2 = await compute();
    return clone(provable3, provable3.fromValue(value2));
  }
  let proverValue = void 0;
  let fields2;
  let id2 = snarkContext.enter({ ...ctx, inWitnessBlock: true });
  try {
    fields2 = await existsAsync(provable3.sizeInFields(), async () => {
      let value2 = provable3.fromValue(await compute());
      proverValue = value2;
      let fields3 = provable3.toFields(value2);
      return fields3.map((x) => x.toBigInt());
    });
  } finally {
    snarkContext.leave(id2);
  }
  let aux = provable3.toAuxiliary(proverValue);
  let value = provable3.fromFields(fields2, aux);
  provable3.check(value);
  return value;
}
function witnessFields(size, compute) {
  if (!inCheckedComputation() || snarkContext.get().inWitnessBlock) {
    let fields2 = compute().map((x) => createField2(x));
    return TupleN.fromArray(size, fields2);
  }
  return exists(size, () => {
    let fields2 = compute().map((x) => typeof x === "bigint" ? x : x.toBigInt());
    return TupleN.fromArray(size, fields2);
  });
}
function clone(type, value) {
  let fields2 = type.toFields(value);
  let aux = type.toAuxiliary?.(value) ?? [];
  return type.fromFields(fields2, aux);
}

// dist/node/lib/provable/provable.js
var Provable = {
  /**
   * Create a new witness. A witness, or variable, is a value that is provided as input
   * by the prover. This provides a flexible way to introduce values from outside into the circuit.
   * However, note that nothing about how the value was created is part of the proof - `Provable.witness`
   * behaves exactly like user input. So, make sure that after receiving the witness you make any assertions
   * that you want to associate with it.
   * @example
   * Example for re-implementing `Field.inv` with the help of `witness`:
   * ```ts
   * let invX = Provable.witness(Field, () => {
   *   // compute the inverse of `x` outside the circuit, however you like!
   *   return Field.inv(x);
   * }
   * // prove that `invX` is really the inverse of `x`:
   * invX.mul(x).assertEquals(1);
   * ```
   */
  witness,
  /**
   * Witness a tuple of field elements. This works just like {@link Provable.witness},
   * but optimized for witnessing plain field elements, which is especially common
   * in low-level provable code.
   */
  witnessFields,
  /**
   * Create a new witness from an async callback.
   *
   * See {@link Provable.witness} for more information.
   */
  witnessAsync,
  /**
   * Proof-compatible if-statement.
   * This behaves like a ternary conditional statement in JS.
   *
   * **Warning**: Since `Provable.if()` is a normal JS function call, both the if and the else branch
   * are evaluated before calling it. Therefore, you can't use this function
   * to guard against execution of one of the branches. It only allows you to pick one of two values.
   *
   * @example
   * ```ts
   * const condition = Bool(true);
   * const result = Provable.if(condition, Field(1), Field(2)); // returns Field(1)
   * ```
   */
  if: if_,
  /**
   * Generalization of {@link Provable.if} for choosing between more than two different cases.
   * It takes a "mask", which is an array of `Bool`s that contains only one `true` element, a type/constructor, and an array of values of that type.
   * The result is that value which corresponds to the true element of the mask.
   * @example
   * ```ts
   * let x = Provable.switch([Bool(false), Bool(true)], Field, [Field(1), Field(2)]);
   * x.assertEquals(2);
   * ```
   */
  switch: switch_,
  /**
   * Asserts that two values are equal.
   * @example
   * ```ts
   * class MyStruct extends Struct({ a: Field, b: Bool }) {};
   * const a: MyStruct = { a: Field(0), b: Bool(false) };
   * const b: MyStruct = { a: Field(1), b: Bool(true) };
   * Provable.assertEqual(MyStruct, a, b);
   * ```
   */
  assertEqual,
  /**
   * Asserts that two values are equal, if an enabling condition is true.
   *
   * If the condition is false, the assertion is skipped.
   */
  assertEqualIf,
  /**
   * Checks if two elements are equal.
   * @example
   * ```ts
   * class MyStruct extends Struct({ a: Field, b: Bool }) {};
   * const a: MyStruct = { a: Field(0), b: Bool(false) };
   * const b: MyStruct = { a: Field(1), b: Bool(true) };
   * const isEqual = Provable.equal(MyStruct, a, b);
   * ```
   */
  equal,
  /**
   * Creates a {@link Provable} for a generic array.
   * @example
   * ```ts
   * const ProvableArray = Provable.Array(Field, 5);
   * ```
   */
  Array: provableArray,
  /**
   * Check whether a value is constant.
   * See {@link FieldVar} for more information about constants and variables.
   *
   * @example
   * ```ts
   * let x = Field(42);
   * Provable.isConstant(Field, x); // true
   * ```
   */
  isConstant: isConstant3,
  /**
   * Interface to log elements within a circuit. Similar to `console.log()`.
   * @example
   * ```ts
   * const element = Field(42);
   * Provable.log(element);
   * ```
   */
  log,
  /**
   * Runs code as a prover.
   * @example
   * ```ts
   * Provable.asProver(() => {
   *   // Your prover code here
   * });
   * ```
   */
  asProver,
  /**
   * Runs provable code quickly, without creating a proof, but still checking whether constraints are satisfied.
   * @example
   * ```ts
   * await Provable.runAndCheck(() => {
   *   // Your code to check here
   * });
   * ```
   */
  async runAndCheck(f) {
    await generateWitness(f, { checkConstraints: true });
  },
  /**
   * Runs provable code quickly, without creating a proof, and not checking whether constraints are satisfied.
   * @example
   * ```ts
   * await Provable.runUnchecked(() => {
   *   // Your code to run here
   * });
   * ```
   */
  async runUnchecked(f) {
    await generateWitness(f, { checkConstraints: false });
  },
  /**
   * Returns information about the constraints created by the callback function.
   * @example
   * ```ts
   * const result = await Provable.constraintSystem(circuit);
   * console.log(result);
   * ```
   */
  constraintSystem,
  /**
   * Checks if the code is run in prover mode.
   * @example
   * ```ts
   * if (Provable.inProver()) {
   *   // Prover-specific code
   * }
   * ```
   */
  inProver,
  /**
   * Checks if the code is run in checked computation mode.
   * @example
   * ```ts
   * if (Provable.inCheckedComputation()) {
   *   // Checked computation-specific code
   * }
   * ```
   */
  inCheckedComputation,
  /**
   * Returns a constant version of a provable type.
   */
  toConstant(type, value) {
    type = ProvableType.get(type);
    return type.fromFields(type.toFields(value).map((x) => x.toConstant()), type.toAuxiliary(value));
  }
};
function assertEqual(typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return assertEqualImplicit(typeOrX, xOrY);
  } else {
    return assertEqualExplicit(typeOrX, xOrY, yOrUndefined);
  }
}
function assertEqualImplicit(x, y) {
  let xs = x.toFields();
  let ys = y.toFields();
  let n = checkLength("Provable.assertEqual", xs, ys);
  for (let i = 0; i < n; i++) {
    xs[i].assertEquals(ys[i]);
  }
}
function assertEqualExplicit(type, x, y) {
  type = ProvableType.get(type);
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  for (let i = 0; i < xs.length; i++) {
    xs[i].assertEquals(ys[i]);
  }
}
function equal(typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return equalImplicit(typeOrX, xOrY);
  } else {
    return equalExplicit(typeOrX, xOrY, yOrUndefined);
  }
}
function equalImplicit(x, y) {
  let xs = x.toFields();
  let ys = y.toFields();
  checkLength("Provable.equal", xs, ys);
  return xs.map((x2, i) => x2.equals(ys[i])).reduce(Bool3.and);
}
function equalExplicit(type, x, y) {
  type = ProvableType.get(type);
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  return xs.map((x2, i) => x2.equals(ys[i])).reduce(Bool3.and);
}
function if_(condition, typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return ifImplicit(condition, typeOrX, xOrY);
  } else {
    return ifExplicit(condition, typeOrX, xOrY, yOrUndefined);
  }
}
function ifField(b2, x, y) {
  return b2.mul(x.sub(y)).add(y).seal();
}
function ifExplicit(condition, type, x, y) {
  type = ProvableType.get(type);
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  let b2 = condition.toField();
  if (b2.isConstant()) {
    return clone2(type, condition.toBoolean() ? x : y);
  }
  let fields2 = xs.map((xi, i) => ifField(b2, xi, ys[i]));
  let aux = auxiliary(type, () => condition.toBoolean() ? x : y);
  return type.fromFields(fields2, aux);
}
function ifImplicit(condition, x, y) {
  let type = x.constructor;
  if (type === void 0)
    throw Error(`You called Provable.if(bool, x, y) with an argument x that has no constructor, which is not supported.
If x, y are Structs or other custom types, you can use the following:
Provable.if(bool, MyType, x, y)`);
  if (type !== y.constructor) {
    throw Error(`Provable.if: Mismatched argument types. Try using an explicit type argument:
Provable.if(bool, MyType, x, y)`);
  }
  if (!("fromFields" in type && "toFields" in type)) {
    throw Error(`Provable.if: Invalid argument type. Try using an explicit type argument:
Provable.if(bool, MyType, x, y)`);
  }
  return ifExplicit(condition, type, x, y);
}
function switch_(mask, type, values, { allowNonExclusive = false } = {}) {
  let type_ = ProvableType.get(type);
  let nValues = values.length;
  if (mask.length !== nValues)
    throw Error(`Provable.switch: \`values\` and \`mask\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`);
  let checkMask = () => {
    if (allowNonExclusive)
      return;
    let nTrue = mask.filter((b2) => b2.toBoolean()).length;
    if (nTrue > 1) {
      throw Error(`Provable.switch: \`mask\` must have 0 or 1 true element, found ${nTrue}.`);
    }
  };
  if (mask.every((b2) => b2.toField().isConstant()))
    checkMask();
  else
    Provable.asProver(checkMask);
  let size = type_.sizeInFields();
  let fields2 = Array(size).fill(new Field3(0));
  for (let i = 0; i < nValues; i++) {
    let valueFields = type_.toFields(values[i]);
    let maskField = mask[i].toField();
    for (let j = 0; j < size; j++) {
      let maybeField = valueFields[j].mul(maskField);
      fields2[j] = fields2[j].add(maybeField);
    }
  }
  let aux = auxiliary(type_, () => {
    let i = mask.findIndex((b2) => b2.toBoolean());
    if (i === -1)
      return void 0;
    return values[i];
  });
  return type_.fromFields(fields2, aux);
}
function assertEqualIf(enabled, type, x, y) {
  let xOrY = ifExplicit(enabled, type, y, x);
  assertEqual(type, x, xOrY);
}
function isConstant3(type, x) {
  return ProvableType.get(type).toFields(x).every((x2) => x2.isConstant());
}
function log(...args) {
  asProver(() => {
    let prettyArgs = [];
    for (let arg of args) {
      if (arg?.toPretty !== void 0)
        prettyArgs.push(arg.toPretty());
      else {
        try {
          prettyArgs.push(JSON.parse(JSON.stringify(arg)));
        } catch {
          prettyArgs.push(arg);
        }
      }
    }
    console.log(...prettyArgs);
  });
}
function checkLength(name, xs, ys) {
  let n = xs.length;
  let m = ys.length;
  if (n !== m) {
    throw Error(`${name}: inputs must contain the same number of field elements, got ${n} !== ${m}`);
  }
  return n;
}
function clone2(type, value) {
  let fields2 = type.toFields(value);
  let aux = type.toAuxiliary?.(value) ?? [];
  return type.fromFields(fields2, aux);
}
function auxiliary(type, compute) {
  let aux;
  Provable.asProver(() => {
    let value = compute();
    if (value !== void 0) {
      aux = type.toAuxiliary?.(value);
    }
  });
  return aux ?? type.toAuxiliary?.() ?? [];
}
var memoizationContext = Context.create();
function memoizeWitness(type, compute) {
  return Provable.witness(type, () => {
    if (!memoizationContext.has())
      return compute();
    let context = memoizationContext.get();
    let { memoized, currentIndex } = context;
    let currentValue = memoized[currentIndex];
    if (currentValue === void 0) {
      let value = compute();
      let fields2 = type.toFields(value).map((x) => x.toConstant());
      let aux = type.toAuxiliary(value);
      currentValue = { fields: fields2, aux };
      memoized[currentIndex] = currentValue;
    }
    context.currentIndex += 1;
    return type.fromFields(currentValue.fields, currentValue.aux);
  });
}
function getBlindingValue() {
  if (!memoizationContext.has())
    return Field3.random();
  let context = memoizationContext.get();
  if (context.blindingValue === void 0) {
    context.blindingValue = Field3.random();
  }
  return context.blindingValue;
}
function provableArray(elementType, length) {
  let type = ProvableType.get(elementType);
  return {
    /**
     * Returns the size of this structure in {@link Field} elements.
     * @returns size of this structure
     */
    sizeInFields() {
      let elementLength = type.sizeInFields();
      return elementLength * length;
    },
    /**
     * Serializes this structure into {@link Field} elements.
     * @returns an array of {@link Field} elements
     */
    toFields(array) {
      return array.map((e) => type.toFields(e)).flat();
    },
    /**
     * Serializes this structure's auxiliary data.
     * @returns auxiliary data
     */
    toAuxiliary(array) {
      let array_ = array ?? Array(length).fill(void 0);
      return array_?.map((e) => type.toAuxiliary(e));
    },
    /**
     * Deserializes an array of {@link Field} elements into this structure.
     */
    fromFields(fields2, aux) {
      let array = [];
      let size = type.sizeInFields();
      let n = length;
      for (let i = 0, offset = 0; i < n; i++, offset += size) {
        array[i] = type.fromFields(fields2.slice(offset, offset + size), aux?.[i]);
      }
      return array;
    },
    check(array) {
      for (let i = 0; i < length; i++) {
        type.check(array[i]);
      }
    },
    toValue(x) {
      return x.map((v) => type.toValue(v));
    },
    fromValue(x) {
      return x.map((v) => type.fromValue(v));
    },
    /**
     * Encodes this structure into a JSON-like object.
     */
    toJSON(array) {
      if (!("toJSON" in type)) {
        throw Error("circuitArray.toJSON: element type has no toJSON method");
      }
      return array.map((v) => type.toJSON(v));
    },
    /**
     * Decodes a JSON-like object into this structure.
     */
    fromJSON(json) {
      if (!("fromJSON" in type)) {
        throw Error("circuitArray.fromJSON: element type has no fromJSON method");
      }
      return json.map((a2) => type.fromJSON(a2));
    },
    toInput(array) {
      if (!("toInput" in type)) {
        throw Error("circuitArray.toInput: element type has no toInput method");
      }
      return array.reduce((curr, value) => HashInput.append(curr, type.toInput(value)), HashInput.empty);
    },
    empty() {
      if (!("empty" in type)) {
        throw Error("circuitArray.empty: element type has no empty() method");
      }
      return Array.from({ length }, () => type.empty());
    }
  };
}

// dist/node/lib/provable/gadgets/foreign-field.js
var import_tslib = require("tslib");

// dist/node/lib/provable/types/unconstrained.js
var Unconstrained = class _Unconstrained {
  constructor(isSome, value) {
    this.option = { isSome, value };
  }
  /**
   * Read an unconstrained value.
   *
   * Note: Can only be called outside provable code.
   */
  get() {
    if (inCheckedComputation() && !Snarky.run.inProverBlock())
      throw Error(`You cannot use Unconstrained.get() in provable code.

The only place where you can read unconstrained values is in Provable.witness()
and Provable.asProver() blocks, which execute outside the proof.
`);
    assert2(this.option.isSome, "Empty `Unconstrained`");
    return this.option.value;
  }
  /**
   * Modify the unconstrained value.
   */
  set(value) {
    this.option = { isSome: true, value };
  }
  /**
   * Set the unconstrained value to the same as another `Unconstrained`.
   */
  setTo(value) {
    this.option = value.option;
  }
  /**
   * Create an `Unconstrained` with the given `value`.
   *
   * Note: If `T` contains provable types, `Unconstrained.from` is an anti-pattern,
   * because it stores witnesses in a space that's intended to be used outside the proof.
   * Something like the following should be used instead:
   *
   * ```ts
   * let xWrapped = Unconstrained.witness(() => Provable.toConstant(type, x));
   * ```
   */
  static from(value) {
    if (value instanceof _Unconstrained)
      return value;
    return new _Unconstrained(true, value);
  }
  /**
   * Create an `Unconstrained` from a witness computation.
   */
  static witness(compute) {
    return witness(_Unconstrained, compute);
  }
  /**
   * Update an `Unconstrained` by a witness computation.
   */
  updateAsProver(compute) {
    return asProver(() => {
      let value = this.get();
      this.set(compute(value));
    });
  }
  static withEmpty(empty4) {
    return {
      ..._Unconstrained.provable,
      empty: () => _Unconstrained.from(empty4)
    };
  }
  /**
   * @deprecated
   */
  static provableWithEmpty(empty4) {
    return _Unconstrained.withEmpty(empty4);
  }
};
Unconstrained.provable = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: (t) => [t ?? new Unconstrained(false)],
  fromFields: (_, [t]) => t,
  check: () => {
  },
  toValue: (t) => t.get(),
  fromValue: (t) => Unconstrained.from(t),
  toInput: () => ({}),
  empty: () => {
    throw Error("There is no default empty value for Unconstrained.");
  }
};

// dist/node/lib/provable/types/fields.js
var ProvableField = {
  sizeInFields: () => 1,
  toFields: (x) => [x],
  toAuxiliary: () => [],
  fromFields: ([x]) => x,
  check: () => {
  },
  toValue: (x) => x.toBigInt(),
  fromValue: (x) => createField2(x),
  toInput: (x) => ({ fields: [x] }),
  toJSON: (x) => getField().toJSON(x),
  fromJSON: (x) => getField().fromJSON(x),
  empty: () => createField2(0)
};
function modifiedField(methods) {
  return Object.assign({}, ProvableField, methods);
}
var id = (t) => t;
function fields(length) {
  return {
    sizeInFields: () => length,
    toFields: id,
    toAuxiliary: () => [],
    fromFields: id,
    check: () => {
    },
    toValue: (x) => x.map((y) => y.toBigInt()),
    fromValue: (x) => x.map(createField2),
    toInput: (x) => ({ fields: x }),
    toJSON: (x) => x.map(getField().toJSON),
    fromJSON: (x) => x.map(getField().fromJSON),
    empty: () => {
      let zero2 = createField2(0);
      return new Array(length).fill(zero2);
    }
  };
}

// dist/node/lib/provable/gadgets/range-check.js
function rangeCheck32(x) {
  if (x.isConstant()) {
    if (x.toBigInt() >= 1n << 32n) {
      throw Error(`rangeCheck32: expected field to fit in 32 bits, got ${x}`);
    }
    return;
  }
  let actual = rangeCheckHelper(32, x);
  actual.assertEquals(x);
}
function rangeCheck64(x) {
  if (x.isConstant()) {
    let xx = x.toBigInt();
    if (xx >= 1n << 64n) {
      throw Error(`rangeCheck64: expected field to fit in 64 bits, got ${x}`);
    }
    return [
      createField2(bitSlice(xx, 52, 12)),
      createField2(bitSlice(xx, 40, 12)),
      createField2(bitSlice(xx, 28, 12)),
      createField2(bitSlice(xx, 16, 12))
    ];
  }
  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, 2),
      bitSlice(xx, 2, 2),
      bitSlice(xx, 4, 2),
      bitSlice(xx, 6, 2),
      bitSlice(xx, 8, 2),
      bitSlice(xx, 10, 2),
      bitSlice(xx, 12, 2),
      bitSlice(xx, 14, 2)
    ];
  });
  let [x16, x28, x40, x52] = exists(4, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 16, 12),
      bitSlice(xx, 28, 12),
      bitSlice(xx, 40, 12),
      bitSlice(xx, 52, 12)
    ];
  });
  Gates.rangeCheck0(
    x,
    [createField2(0), createField2(0), x52, x40, x28, x16],
    [x14, x12, x10, x8, x6, x4, x2, x0],
    false
    // not using compact mode
  );
  return [x52, x40, x28, x16];
}
var l = 88n;
var l2 = 2n * l;
var l3 = 3n * l;
var lMask = (1n << l) - 1n;
var l2Mask = (1n << l2) - 1n;
function multiRangeCheck([x, y, z]) {
  if (x.isConstant() && y.isConstant() && z.isConstant()) {
    if (x.toBigInt() >> l || y.toBigInt() >> l || z.toBigInt() >> l) {
      throw Error(`Expected fields to fit in ${l} bits, got ${x}, ${y}, ${z}`);
    }
    return;
  }
  [x, y, z] = toVars([x, y, z]);
  let zero2 = toVar(0n);
  let [x64, x76] = rangeCheck0Helper(x);
  let [y64, y76] = rangeCheck0Helper(y);
  rangeCheck1Helper({ x64, x76, y64, y76, z, yz: zero2 });
}
function compactMultiRangeCheck(xy, z) {
  if (xy.isConstant() && z.isConstant()) {
    if (xy.toBigInt() >> l2 || z.toBigInt() >> l) {
      throw Error(`Expected fields to fit in ${l2} and ${l} bits respectively, got ${xy}, ${z}`);
    }
    let [x2, y2] = splitCompactLimb(xy.toBigInt());
    return [createField2(x2), createField2(y2), z];
  }
  [xy, z] = toVars([xy, z]);
  let [x, y] = exists(2, () => splitCompactLimb(xy.toBigInt()));
  let [z64, z76] = rangeCheck0Helper(z, false);
  let [x64, x76] = rangeCheck0Helper(x, true);
  rangeCheck1Helper({ x64: z64, x76: z76, y64: x64, y76: x76, z: y, yz: xy });
  return [x, y, z];
}
function splitCompactLimb(x01) {
  return [x01 & lMask, x01 >> l];
}
function rangeCheck0Helper(x, isCompact = false) {
  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, 2),
      bitSlice(xx, 2, 2),
      bitSlice(xx, 4, 2),
      bitSlice(xx, 6, 2),
      bitSlice(xx, 8, 2),
      bitSlice(xx, 10, 2),
      bitSlice(xx, 12, 2),
      bitSlice(xx, 14, 2)
    ];
  });
  let [x16, x28, x40, x52, x64, x76] = exists(6, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 16, 12),
      bitSlice(xx, 28, 12),
      bitSlice(xx, 40, 12),
      bitSlice(xx, 52, 12),
      bitSlice(xx, 64, 12),
      bitSlice(xx, 76, 12)
    ];
  });
  Gates.rangeCheck0(x, [x76, x64, x52, x40, x28, x16], [x14, x12, x10, x8, x6, x4, x2, x0], isCompact);
  return [x64, x76];
}
function rangeCheck1Helper(inputs) {
  let { x64, x76, y64, y76, z, yz } = inputs;
  let [z22, z24, z26, z28, z30, z32, z34, z36, z38, z50, z62, z74, z86] = exists(13, () => {
    let zz = z.toBigInt();
    return [
      bitSlice(zz, 22, 2),
      bitSlice(zz, 24, 2),
      bitSlice(zz, 26, 2),
      bitSlice(zz, 28, 2),
      bitSlice(zz, 30, 2),
      bitSlice(zz, 32, 2),
      bitSlice(zz, 34, 2),
      bitSlice(zz, 36, 2),
      bitSlice(zz, 38, 12),
      bitSlice(zz, 50, 12),
      bitSlice(zz, 62, 12),
      bitSlice(zz, 74, 12),
      bitSlice(zz, 86, 2)
    ];
  });
  let [z0, z2, z4, z6, z8, z10, z12, z14, z16, z18, z20] = exists(11, () => {
    let zz = z.toBigInt();
    return [
      bitSlice(zz, 0, 2),
      bitSlice(zz, 2, 2),
      bitSlice(zz, 4, 2),
      bitSlice(zz, 6, 2),
      bitSlice(zz, 8, 2),
      bitSlice(zz, 10, 2),
      bitSlice(zz, 12, 2),
      bitSlice(zz, 14, 2),
      bitSlice(zz, 16, 2),
      bitSlice(zz, 18, 2),
      bitSlice(zz, 20, 2)
    ];
  });
  Gates.rangeCheck1(z, yz, [z86, z74, z62, z50, z38, z36, z34, z32, z30, z28, z26, z24, z22], [z20, z18, z16, x76, x64, y76, y64, z14, z12, z10, z8, z6, z4, z2, z0]);
}
function rangeCheckHelper(length, x) {
  assert3(length <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${length}`);
  assert3(length > 0, `bit length must be positive, got ${length}`);
  assert3(length % 16 === 0, "`length` has to be a multiple of 16.");
  let lengthDiv16 = length / 16;
  if (x.isConstant()) {
    let bits = BinableFp.toBits(x.toBigInt()).slice(0, length).concat(Array(Fp.sizeInBits - length).fill(false));
    return createField2(BinableFp.fromBits(bits));
  }
  let y = Snarky.field.truncateToBits16(lengthDiv16, x.value);
  return createField2(y);
}
function rangeCheckN(n, x, message = "") {
  assert3(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);
  assert3(n > 0, `bit length must be positive, got ${n}`);
  assert3(n % 16 === 0, "`length` has to be a multiple of 16.");
  if (x.isConstant()) {
    if (x.toBigInt() >= 1n << BigInt(n)) {
      throw Error(`rangeCheckN: expected field to fit in ${n} bits, got ${x}.
${message}`);
    }
    return;
  }
  let actual = rangeCheckHelper(n, x);
  actual.assertEquals(x, message);
}
function isDefinitelyInRangeN(n, x) {
  assert3(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);
  assert3(n > 0, `bit length must be positive, got ${n}`);
  assert3(n % 16 === 0, "`length` has to be a multiple of 16.");
  if (x.isConstant()) {
    return createBool(x.toBigInt() < 1n << BigInt(n));
  }
  let actual = rangeCheckHelper(n, x);
  return actual.equals(x);
}
function rangeCheck16(x) {
  if (x.isConstant()) {
    assert3(x.toBigInt() < 1n << 16n, `rangeCheck16: expected field to fit in 8 bits, got ${x}`);
    return;
  }
  rangeCheckHelper(16, x).assertEquals(x);
}
function rangeCheck8(x) {
  if (x.isConstant()) {
    assert3(x.toBigInt() < 1n << 8n, `rangeCheck8: expected field to fit in 8 bits, got ${x}`);
    return;
  }
  rangeCheckHelper(16, x).assertEquals(x);
  let x256 = x.mul(1 << 8).seal();
  rangeCheckHelper(16, x256).assertEquals(x256);
}

// dist/node/lib/provable/gadgets/foreign-field.js
var _Sum_instances;
var _Sum_result;
var _Sum_summands;
var _Sum_ops;
var _Sum_return;
var ForeignField = {
  add(x, y, f) {
    return sum([x, y], [1n], f);
  },
  sub(x, y, f) {
    return sum([x, y], [-1n], f);
  },
  negate(x, f) {
    return sum([Field32.from(0n), x], [-1n], f);
  },
  sum,
  Sum(x) {
    return new Sum(x);
  },
  mul: multiply,
  inv: inverse2,
  div: divide,
  assertMul,
  assertAlmostReduced,
  assertLessThan,
  assertLessThanOrEqual,
  equals
};
function sum(x, sign3, f) {
  assert3(x.length === sign3.length + 1, "inputs and operators match");
  if (x.every(Field32.isConstant)) {
    let xBig = x.map(Field32.toBigint);
    let sum2 = sign3.reduce((sum3, s, i) => sum3 + s * xBig[i + 1], xBig[0]);
    return Field32.from(mod(sum2, f));
  }
  x = x.map(toVars);
  let result = x[0];
  for (let i = 0; i < sign3.length; i++) {
    ({ result } = singleAdd(result, x[i + 1], sign3[i], f));
  }
  Gates.zero(...result);
  indirectMultiRangeChange(result);
  return result;
}
function singleAdd(x, y, sign3, f) {
  let f_ = split(f);
  let [r0, r1, r2, overflow, carry] = exists(5, () => {
    let x_ = toBigint3(x);
    let y_ = toBigint3(y);
    let r = combine(x_) + sign3 * combine(y_);
    let overflow2 = 0n;
    if (sign3 === 1n && r >= f)
      overflow2 = 1n;
    if (sign3 === -1n && r < 0n)
      overflow2 = -1n;
    if (f === 0n)
      overflow2 = 0n;
    let r01 = combine2(x_) + sign3 * combine2(y_) - overflow2 * combine2(f_);
    let carry2 = r01 >> l2;
    r01 &= l2Mask;
    let [r02, r12] = split2(r01);
    let r22 = x_[2] + sign3 * y_[2] - overflow2 * f_[2] + carry2;
    return [r02, r12, r22, overflow2, carry2];
  });
  foreignFieldAdd({ left: x, right: y, overflow, carry, modulus: f_, sign: sign3 });
  return { result: [r0, r1, r2], overflow };
}
function multiply(a2, b2, f) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(a2) && Field32.isConstant(b2)) {
    let ab = Field32.toBigint(a2) * Field32.toBigint(b2);
    return Field32.from(mod(ab, f));
  }
  let { r01, r2, q: q3 } = multiplyNoRangeCheck(a2, b2, f);
  multiRangeCheck(q3);
  let r = compactMultiRangeCheck(r01, r2);
  return r;
}
function inverse2(x, f) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(x)) {
    let xInv2 = inverse(Field32.toBigint(x), f);
    assert3(xInv2 !== void 0, "inverse exists");
    return Field32.from(xInv2);
  }
  let xInv = exists(3, () => {
    let xInv2 = inverse(Field32.toBigint(x), f);
    return xInv2 === void 0 ? [0n, 0n, 0n] : split(xInv2);
  });
  multiRangeCheck(xInv);
  let xInv2Bound = weakBound(xInv[2], f);
  let one = [createField2(1n), createField2(0n)];
  assertMulInternal(x, xInv, one, f);
  multiRangeCheck([xInv2Bound, createField2(0n), createField2(0n)]);
  return xInv;
}
function divide(x, y, f, { allowZeroOverZero = false } = {}) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(x) && Field32.isConstant(y)) {
    let yInv = inverse(Field32.toBigint(y), f);
    assert3(yInv !== void 0, "inverse exists");
    return Field32.from(mod(Field32.toBigint(x) * yInv, f));
  }
  let z = exists(3, () => {
    let yInv = inverse(Field32.toBigint(y), f);
    if (yInv === void 0)
      return [0n, 0n, 0n];
    return split(mod(Field32.toBigint(x) * yInv, f));
  });
  multiRangeCheck(z);
  let z2Bound = weakBound(z[2], f);
  assertMulInternal(z, y, x, f);
  multiRangeCheck([z2Bound, createField2(0n), createField2(0n)]);
  if (!allowZeroOverZero) {
    ForeignField.equals(y, 0n, f).assertFalse();
  }
  return z;
}
function assertMulInternal(x, y, xy, f, message) {
  let { r01, r2, q: q3 } = multiplyNoRangeCheck(x, y, f);
  multiRangeCheck(q3);
  if (xy.length === 2) {
    let [xy01, xy2] = xy;
    r01.assertEquals(xy01, message);
    r2.assertEquals(xy2, message);
  } else {
    let xy01 = xy[0].add(xy[1].mul(1n << l));
    r01.assertEquals(xy01, message);
    r2.assertEquals(xy[2], message);
  }
}
function multiplyNoRangeCheck(a2, b2, f) {
  let f_ = (1n << l3) - f;
  let [f_0, f_1, f_2] = split(f_);
  let f2 = f >> l2;
  let f2Bound = (1n << l) - f2 - 1n;
  let witnesses = exists(21, () => {
    let [a0, a1, a22] = toBigint3(a2);
    let [b0, b1, b22] = toBigint3(b2);
    let ab = combine([a0, a1, a22]) * combine([b0, b1, b22]);
    let q4 = ab / f;
    let r = ab - q4 * f;
    let [q02, q12, q23] = split(q4);
    let [r0, r1, r22] = split(r);
    let r012 = combine2([r0, r1]);
    let p0 = a0 * b0 + q02 * f_0;
    let p1 = a0 * b1 + a1 * b0 + q02 * f_1 + q12 * f_0;
    let p22 = a0 * b22 + a1 * b1 + a22 * b0 + q02 * f_2 + q12 * f_1 + q23 * f_0;
    let [p102, p1102, p1112] = split(p1);
    let p11 = combine2([p1102, p1112]);
    let c02 = p0 + (p102 << l) - r012 >> l2;
    let c1 = p22 - r22 + p11 + c02 >> l;
    let c1_002 = bitSlice(c1, 0, 12);
    let c1_122 = bitSlice(c1, 12, 12);
    let c1_242 = bitSlice(c1, 24, 12);
    let c1_362 = bitSlice(c1, 36, 12);
    let c1_482 = bitSlice(c1, 48, 12);
    let c1_602 = bitSlice(c1, 60, 12);
    let c1_722 = bitSlice(c1, 72, 12);
    let c1_842 = bitSlice(c1, 84, 2);
    let c1_862 = bitSlice(c1, 86, 2);
    let c1_882 = bitSlice(c1, 88, 2);
    let c1_902 = bitSlice(c1, 90, 1);
    let q2Bound2 = q23 + f2Bound;
    return [
      r012,
      r22,
      q02,
      q12,
      q23,
      q2Bound2,
      p102,
      p1102,
      p1112,
      c02,
      c1_002,
      c1_122,
      c1_242,
      c1_362,
      c1_482,
      c1_602,
      c1_722,
      c1_842,
      c1_862,
      c1_882,
      c1_902
    ];
  });
  let [r01, r2, q0, q1, q22, q2Bound, p10, p110, p111, c0, c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72, c1_84, c1_86, c1_88, c1_90] = witnesses;
  let q3 = [q0, q1, q22];
  Gates.foreignFieldMul({
    left: a2,
    right: b2,
    remainder: [r01, r2],
    quotient: q3,
    quotientHiBound: q2Bound,
    product1: [p10, p110, p111],
    carry0: c0,
    carry1p: [c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72],
    carry1c: [c1_84, c1_86, c1_88, c1_90],
    foreignFieldModulus2: f2,
    negForeignFieldModulus: [f_0, f_1, f_2]
  });
  multiRangeCheck([p10, p110, q2Bound]);
  return { r01, r2, q: q3 };
}
function weakBound(x, f) {
  if ((f & l2Mask) === 0n) {
    return x.add(lMask + 1n - (f >> l2));
  }
  return x.add(lMask - (f >> l2));
}
function assertAlmostReduced(xs, f, skipMrc = false) {
  let bounds = [];
  for (let x of xs) {
    if (!skipMrc)
      multiRangeCheck(x);
    bounds.push(weakBound(x[2], f));
    if (TupleN.hasLength(3, bounds)) {
      multiRangeCheck(bounds);
      bounds = [];
    }
  }
  if (TupleN.hasLength(1, bounds)) {
    multiRangeCheck([...bounds, createField2(0n), createField2(0n)]);
  }
  if (TupleN.hasLength(2, bounds)) {
    multiRangeCheck([...bounds, createField2(0n)]);
  }
}
function equals(x, c, f) {
  assert3(c >= 0n && c < f, "equals: c must be in [0, f)");
  if (Field32.isConstant(x)) {
    return createBool(mod(Field32.toBigint(x), f) === c);
  }
  if (f >= 1n << l2) {
    let x01 = toVar(x[0].add(x[1].mul(1n << l)));
    let [c01, c2] = [c & l2Mask, c >> l2];
    let [cPlusF01, cPlusF2] = [c + f & l2Mask, c + f >> l2];
    let isC = x01.equals(c01).and(x[2].equals(c2));
    let isCPlusF = x01.equals(cPlusF01).and(x[2].equals(cPlusF2));
    return isC.or(isCPlusF);
  } else {
    ForeignField.assertLessThan(x, f);
    let x012 = toVar(x[0].add(x[1].mul(1n << l)).add(x[2].mul(1n << l2)));
    return x012.equals(c);
  }
}
var provableLimb = modifiedField({
  toInput(x) {
    return { packed: [[x, Number(l)]] };
  }
});
var Field32 = {
  /**
   * Turn a bigint into a 3-tuple of Fields
   */
  from(x) {
    if (Array.isArray(x))
      return x;
    return Tuple.map(split(x), createField2);
  },
  /**
   * Turn a 3-tuple of Fields into a bigint
   */
  toBigint(x) {
    return combine(toBigint3(x));
  },
  /**
   * Turn several 3-tuples of Fields into bigints
   */
  toBigints(...xs) {
    return Tuple.map(xs, Field32.toBigint);
  },
  /**
   * Check whether a 3-tuple of Fields is constant
   */
  isConstant(x) {
    return x.every((x2) => x2.isConstant());
  },
  /**
   * `Provable<T>` interface for `Field3 = [Field, Field, Field]`.
   *
   * Note: Witnessing this creates a plain tuple of field elements without any implicit
   * range checks.
   */
  provable: {
    ...provableTuple([provableLimb, provableLimb, provableLimb]),
    toValue(x) {
      return Field32.toBigint(x);
    },
    fromValue(x) {
      if (typeof x === "bigint")
        return Field32.from(x);
      return x;
    }
  }
};
function toBigint3(x) {
  return Tuple.map(x, (x2) => x2.toBigInt());
}
function combine([x0, x1, x2]) {
  return x0 + (x1 << l) + (x2 << l2);
}
function split(x) {
  return [x & lMask, x >> l & lMask, x >> l2 & lMask];
}
function combine2([x0, x1]) {
  return x0 + (x1 << l);
}
function split2(x) {
  return [x & lMask, x >> l & lMask];
}
function assertMul(x, y, xy, f, message) {
  x = Sum.fromUnfinished(x);
  y = Sum.fromUnfinished(y);
  xy = Sum.fromUnfinished(xy);
  assert3(BigInt(Math.ceil(Math.sqrt(x.length * y.length))) * f < 1n << 258n, `Foreign modulus is too large for multiplication of sums of lengths ${x.length} and ${y.length}`);
  let y0 = y.finishForMulInput(f);
  let xy0 = xy.finish(f);
  let x0 = x.finishForMulInput(f, true);
  if (Field32.isConstant(x0) && Field32.isConstant(y0) && Field32.isConstant(xy0)) {
    let x_ = Field32.toBigint(x0);
    let y_ = Field32.toBigint(y0);
    let xy_ = Field32.toBigint(xy0);
    assert3(mod(x_ * y_, f) === xy_, message ?? "assertMul(): incorrect multiplication result");
    return;
  }
  assertMulInternal(x0, y0, xy0, f, message);
}
var Sum = class _Sum {
  constructor(x) {
    _Sum_instances.add(this);
    _Sum_result.set(this, void 0);
    _Sum_summands.set(this, void 0);
    _Sum_ops.set(this, []);
    (0, import_tslib.__classPrivateFieldSet)(this, _Sum_summands, [x], "f");
  }
  get result() {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") !== void 0, "sum not finished");
    return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f");
  }
  get length() {
    return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").length;
  }
  add(y) {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    (0, import_tslib.__classPrivateFieldGet)(this, _Sum_ops, "f").push(1n);
    (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").push(y);
    return this;
  }
  sub(y) {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    (0, import_tslib.__classPrivateFieldGet)(this, _Sum_ops, "f").push(-1n);
    (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").push(y);
    return this;
  }
  isConstant() {
    return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").every(Field32.isConstant);
  }
  finish(f, isChained = false) {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    let signs = (0, import_tslib.__classPrivateFieldGet)(this, _Sum_ops, "f");
    let n = signs.length;
    if (n === 0)
      return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f")[0]);
    if (this.isConstant()) {
      return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, sum((0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f"), signs, f));
    }
    let x = (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").map(toVars);
    let result = x[0];
    for (let i = 0; i < n; i++) {
      ({ result } = singleAdd(result, x[i + 1], signs[i], f));
    }
    if (!isChained)
      Gates.zero(...result);
    (0, import_tslib.__classPrivateFieldSet)(this, _Sum_result, result, "f");
    return result;
  }
  // TODO this is complex and should be removed once we fix the ffadd gate to constrain all limbs individually
  finishForMulInput(f, isChained = false) {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    let signs = (0, import_tslib.__classPrivateFieldGet)(this, _Sum_ops, "f");
    let n = signs.length;
    if (n === 0)
      return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f")[0]);
    if (this.isConstant()) {
      return (0, import_tslib.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, sum((0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f"), signs, f));
    }
    let xs = (0, import_tslib.__classPrivateFieldGet)(this, _Sum_summands, "f").map(toVars);
    let f0 = f & lMask;
    let x0 = xs[0][0];
    let x0s = [];
    let overflows = [];
    let xRef = Unconstrained.witness(() => Field32.toBigint(xs[0]));
    for (let i = 0; i < n; i++) {
      let [carry, overflow] = exists(2, () => {
        let x2 = xRef.get();
        let x02 = x2 & lMask;
        let xi = toBigint3(xs[i + 1]);
        let sign3 = signs[i];
        x2 += sign3 * combine(xi);
        let overflow2 = 0n;
        if (sign3 === 1n && x2 >= f)
          overflow2 = 1n;
        if (sign3 === -1n && x2 < 0n)
          overflow2 = -1n;
        if (f === 0n)
          overflow2 = 0n;
        xRef.set(x2 - overflow2 * f);
        x02 = x02 + sign3 * xi[0] - overflow2 * f0;
        let carry2 = x02 >> l;
        return [carry2, overflow2];
      });
      overflows.push(overflow);
      assertOneOf(carry, [0n, 1n, -1n]);
      x0 = toVar(x0.add(xs[i + 1][0].mul(signs[i])).sub(overflow.mul(f0)).sub(carry.mul(1n << l)));
      x0s.push(x0);
    }
    let x = xs[0];
    for (let i = 0; i < n; i++) {
      let { result, overflow } = singleAdd(x, xs[i + 1], signs[i], f);
      result[0].assertEquals(x0s[i]);
      overflow.assertEquals(overflows[i]);
      x = result;
    }
    if (!isChained)
      Gates.zero(...x);
    (0, import_tslib.__classPrivateFieldSet)(this, _Sum_result, x, "f");
    return x;
  }
  rangeCheck() {
    assert3((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f") !== void 0, "sum not finished");
    if ((0, import_tslib.__classPrivateFieldGet)(this, _Sum_ops, "f").length > 0)
      multiRangeCheck((0, import_tslib.__classPrivateFieldGet)(this, _Sum_result, "f"));
  }
  static fromUnfinished(x) {
    if (x instanceof _Sum) {
      assert3((0, import_tslib.__classPrivateFieldGet)(x, _Sum_result, "f") === void 0, "sum already finished");
      return x;
    }
    return new _Sum(x);
  }
};
_Sum_result = /* @__PURE__ */ new WeakMap(), _Sum_summands = /* @__PURE__ */ new WeakMap(), _Sum_ops = /* @__PURE__ */ new WeakMap(), _Sum_instances = /* @__PURE__ */ new WeakSet(), _Sum_return = function _Sum_return2(x) {
  (0, import_tslib.__classPrivateFieldSet)(this, _Sum_result, x, "f");
  return x;
};
function assertLessThan(x, y) {
  let y_ = Field32.from(y);
  if (Field32.isConstant(x) && Field32.isConstant(y_)) {
    assert3(Field32.toBigint(x) < Field32.toBigint(y_), "assertLessThan: got x >= y");
    return;
  }
  if (Field32.isConstant(y_)) {
    y = typeof y === "bigint" ? y : Field32.toBigint(y);
    assert3(y > 0n, "assertLessThan: y <= 0, so x < y is impossible");
    ForeignField.negate(x, y - 1n);
    return;
  }
  sum([y_, x, Field32.from(1n)], [-1n, -1n], 0n);
}
function assertLessThanOrEqual(x, y) {
  assert3(typeof y !== "bigint" || y >= 0n, "assertLessThanOrEqual: upper bound must be positive");
  let y_ = Field32.from(y);
  if (Field32.isConstant(x) && Field32.isConstant(y_)) {
    assert3(Field32.toBigint(x) <= Field32.toBigint(y_), "assertLessThan: got x > y");
    return;
  }
  sum([y_, x], [-1n], 0n);
}
function field3FromBits(bits) {
  const Field5 = getField();
  let limbSize = Number(l);
  let l0 = Field5.fromBits(bits.slice(0 * limbSize, 1 * limbSize));
  let l1 = Field5.fromBits(bits.slice(1 * limbSize, 2 * limbSize));
  let l22 = Field5.fromBits(bits.slice(2 * limbSize, 3 * limbSize));
  return [l0, l1, l22];
}
function indirectMultiRangeChange(x, message = "multi-range check failed") {
  let xTrunc = exists(3, () => {
    let [x0, x1, x2] = toBigint3(x);
    return [x0 & lMask, x1 & lMask, x2 & lMask];
  });
  multiRangeCheck(xTrunc);
  x[0].assertEquals(xTrunc[0], message);
  x[1].assertEquals(xTrunc[1], message);
  x[2].assertEquals(xTrunc[2], message);
}

// dist/node/lib/provable/gadgets/comparison.js
function assertLessThanOrEqualGeneric(x, y, rangeCheck) {
  rangeCheck(y.sub(x).seal());
}
function assertLessThanGeneric(x, y, rangeCheck) {
  rangeCheck(y.sub(1).sub(x).seal());
}
function lessThanGeneric(x, y, c, rangeCheck) {
  let b2 = existsOne(() => BigInt(x.toBigInt() < y.toBigInt()));
  let isLessThan = b2.assertBool();
  rangeCheck(b2.mul(c).add(x).sub(y).seal());
  return isLessThan;
}
function lessThanOrEqualGeneric(x, y, c, rangeCheck) {
  let b2 = existsOne(() => BigInt(x.toBigInt() <= y.toBigInt()));
  let isLessThanOrEqual = b2.assertBool();
  rangeCheck(b2.mul(c).add(x).sub(y).sub(1).seal());
  return isLessThanOrEqual;
}
function assertLessThanFull(x, y) {
  let xBig = fieldToField3(x);
  let yBig = fieldToField3(y);
  ForeignField.assertLessThan(xBig, yBig);
  ForeignField.assertLessThan(yBig, Fp.modulus);
}
function assertLessThanOrEqualFull(x, y) {
  let xBig = fieldToField3(x);
  let yBig = fieldToField3(y);
  ForeignField.assertLessThanOrEqual(xBig, yBig);
  ForeignField.assertLessThan(yBig, Fp.modulus);
}
function lessThanFull(x, y) {
  let b2 = existsOne(() => BigInt(x.toBigInt() < y.toBigInt()));
  let isLessThan = b2.assertBool();
  let xBig = fieldToField3(x);
  let yBig = fieldToField3(y);
  ForeignField.assertLessThan(xBig, Fp.modulus);
  ForeignField.assertLessThan(yBig, Fp.modulus);
  let [p0, p1, p22] = Field32.from(Fp.modulus);
  let bTimesP = [p0.mul(b2), p1.mul(b2), p22.mul(b2)];
  let z = ForeignField.sum([bTimesP, xBig, yBig], [1n, -1n], 0n);
  ForeignField.assertLessThan(z, Fp.modulus);
  return isLessThan;
}
function lessThanOrEqualFull(x, y) {
  return lessThanFull(y, x).not();
}
function isOddAndHigh(x) {
  if (x.isConstant()) {
    let x0 = x.toBigInt();
    return { isOdd: createBool((x0 & 1n) === 1n), high: createField2(x0 >> 1n) };
  }
  let [b2, z] = exists(2, () => {
    let x0 = x.toBigInt();
    return [x0 & 1n, x0 >> 1n];
  });
  let isOdd = b2.assertBool();
  z.assertLessThan((Fp.modulus + 1n) / 2n);
  b2.add(z.mul(2n)).assertEquals(x);
  let x_ = existsOne(() => b2.toBigInt() === 0n ? 0n : Fp.inverse(x.toBigInt()) ?? 0n);
  x.mul(x_).assertEquals(b2);
  return { isOdd, high: z };
}
function fieldToField3(x) {
  if (x.isConstant())
    return Field32.from(x.toBigInt());
  let xBig = witness(Field32, () => x.toBigInt());
  multiRangeCheck(xBig);
  let [x0, x1, x2] = xBig;
  let x_ = x0.add(x1.mul(1n << l)).add(x2.mul(1n << l2));
  x_.assertEquals(x);
  return xBig;
}

// dist/node/lib/provable/field.js
var Field3 = class _Field {
  /**
   * Coerce anything "field-like" (bigint, number, string, and {@link Field}) to a Field.
   */
  constructor(x) {
    if (x instanceof _Field) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      if (typeof x[1] === "bigint") {
        this.value = FieldVar.constant(x);
        return;
      } else {
        this.value = x;
        return;
      }
    }
    this.value = FieldVar.constant(Fp.mod(BigInt(x)));
  }
  // helpers
  static from(x) {
    if (x instanceof _Field)
      return x;
    return new _Field(x);
  }
  /**
   * Check whether this {@link Field} element is a hard-coded constant in the constraint system.
   * If a {@link Field} is constructed outside a zkApp method, it is a constant.
   *
   * @example
   * ```ts
   * console.log(Field(42).isConstant()); // true
   * ```
   *
   * @example
   * ```ts
   * \@method myMethod(x: Field) {
   *    console.log(x.isConstant()); // false
   * }
   * ```
   *
   * @return A `boolean` showing if this {@link Field} is a constant or not.
   */
  isConstant() {
    return this.value[0] === FieldType.Constant;
  }
  /**
   * Create a {@link Field} element equivalent to this {@link Field} element's value,
   * but is a constant.
   * See {@link Field.isConstant} for more information about what is a constant {@link Field}.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * someField.toConstant().assertEquals(someField); // Always true
   * ```
   *
   * @return A constant {@link Field} element equivalent to this {@link Field} element.
   */
  toConstant() {
    return toConstant(this, "toConstant");
  }
  /**
   * Serialize the {@link Field} to a bigint, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the bigint representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toBigInt());
   * ```
   *
   * @return A bigint equivalent to the bigint representation of the Field.
   */
  toBigInt() {
    let x = toConstant(this, "toBigInt");
    return FieldConst.toBigint(x.value[1]);
  }
  /**
   * Serialize the {@link Field} to a string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toString());
   * ```
   *
   * @return A string equivalent to the string representation of the Field.
   */
  toString() {
    return toConstant(this, "toString").toBigInt().toString();
  }
  /**
   * Assert that this {@link Field} is equal another "field-like" value.
   * Calling this function is equivalent to `Field(...).equals(...).assertEquals(Bool(true))`.
   * See {@link Field.equals} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertEquals(y, message) {
    try {
      if (this.isConstant() && isConstant4(y)) {
        if (this.toBigInt() !== toFp(y)) {
          throw Error(`Field.assertEquals(): ${this} != ${y}`);
        }
        return;
      }
      assertEqualCompatible(this, toFieldVar2(y));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Add a field-like value to this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const sum = x.add(5);
   *
   * sum.assertEquals(Field(8));
   * ```
   *
   * **Warning**: This is a modular addition in the pasta field.
   * @example
   * ```ts
   * const x = Field(1);
   * const sum = x.add(Field(-7));
   *
   * // If you try to print sum - `console.log(sum.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 + (-7) circles around the field to become p - 6.
   * // You can use the reverse operation of addition (subtraction) to prove the sum is calculated correctly.
   *
   * sum.sub(x).assertEquals(Field(-7));
   * sum.sub(Field(-7)).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to add to the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular addition of the two value.
   */
  add(y) {
    if (this.isConstant() && isConstant4(y)) {
      return new _Field(Fp.add(this.toBigInt(), toFp(y)));
    }
    let z = FieldVar.add(this.value, toFieldVar2(y));
    return new _Field(z);
  }
  /**
   * Negate a {@link Field}. This is equivalent to multiplying the {@link Field} by -1.
   *
   * @example
   * ```ts
   * const negOne = Field(1).neg();
   * negOne.assertEquals(-1);
   * ```
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * someField.neg().assertEquals(someField.mul(Field(-1))); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * **Warning**: This is a modular negation. For details, see the {@link sub} method.
   *
   * @return A {@link Field} element that is equivalent to the element multiplied by -1.
   */
  neg() {
    if (this.isConstant()) {
      return new _Field(Fp.negate(this.toBigInt()));
    }
    let z = FieldVar.scale(FieldConst[-1], this.value);
    return new _Field(z);
  }
  /**
   * Subtract another "field-like" value from this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const difference = x.sub(5);
   *
   * difference.assertEquals(Field(-2));
   * ```
   *
   * **Warning**: This is a modular subtraction in the pasta field.
   *
   * @example
   * ```ts
   * const x = Field(1);
   * const difference = x.sub(Field(2));
   *
   * // If you try to print difference - `console.log(difference.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 - 2 circles around the field to become p - 1.
   * // You can use the reverse operation of subtraction (addition) to prove the difference is calculated correctly.
   * difference.add(Field(2)).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to subtract from the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular difference of the two value.
   */
  sub(y) {
    return this.add(_Field.from(y).neg());
  }
  /**
   * Checks if this {@link Field} is odd. Returns `true` for odd elements and `false` for even elements.
   *
   * See {@link Field.isEven} for examples.
   */
  isOdd() {
    return isOddAndHigh(this).isOdd;
  }
  /**
   * Checks if this {@link Field} is even. Returns `true` for even elements and `false` for odd elements.
   *
   * @example
   * ```ts
   * let a = Field(5);
   * a.isEven(); // false
   *
   * let b = Field(4);
   * b.isEven(); // true
   * ```
   */
  isEven() {
    return this.isOdd().not();
  }
  /**
   * Multiply another "field-like" value with this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const product = x.mul(Field(5));
   *
   * product.assertEquals(Field(15));
   * ```
   *
   * @param value - a "field-like" value to multiply with the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular difference of the two value.
   */
  mul(y) {
    if (this.isConstant() && isConstant4(y)) {
      return new _Field(Fp.mul(this.toBigInt(), toFp(y)));
    }
    if (isConstant4(y)) {
      let z2 = FieldVar.scale(toFieldConst(y), this.value);
      return new _Field(z2);
    }
    if (this.isConstant()) {
      let z2 = FieldVar.scale(this.value[1], y.value);
      return new _Field(z2);
    }
    let z = existsOne(() => Fp.mul(this.toBigInt(), toFp(y)));
    assertMulCompatible(this, y, z);
    return z;
  }
  /**
   * [Modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of this {@link Field} element.
   * Equivalent to 1 divided by this {@link Field}, in the sense of modular arithmetic.
   *
   * Proves that this Field is non-zero, or throws a "Division by zero" error.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * const inverse = someField.inv();
   * inverse.assertEquals(Field(1).div(someField)); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * **Warning**: This is a modular inverse. See {@link div} method for more details.
   *
   * @return A {@link Field} element that is equivalent to one divided by this element.
   */
  inv() {
    if (this.isConstant()) {
      let z2 = Fp.inverse(this.toBigInt());
      if (z2 === void 0)
        throw Error("Field.inv(): Division by zero");
      return new _Field(z2);
    }
    let z = existsOne(() => Fp.inverse(this.toBigInt()) ?? 0n);
    assertMulCompatible(this, z, FieldVar[1]);
    return z;
  }
  /**
   * Divide another "field-like" value through this {@link Field}.
   *
   * Proves that the denominator is non-zero, or throws a "Division by zero" error.
   *
   * @example
   * ```ts
   * const x = Field(6);
   * const quotient = x.div(Field(3));
   *
   * quotient.assertEquals(Field(2));
   * ```
   *
   * **Warning**: This is a modular division in the pasta field. You can think this as the reverse operation of modular multiplication.
   *
   * @example
   * ```ts
   * const x = Field(2);
   * const y = Field(5);
   *
   * const quotient = x.div(y);
   *
   * // If you try to print quotient - `console.log(quotient.toBigInt())` - you will realize that it prints a very big integer because this is a modular inverse.
   * // You can use the reverse operation of division (multiplication) to prove the quotient is calculated correctly.
   *
   * quotient.mul(y).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to divide with the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular division of the two value.
   */
  div(y) {
    return this.mul(_Field.from(y).inv());
  }
  /**
   * Square this {@link Field} element.
   *
   * @example
   * ```ts
   * const someField = Field(7);
   * const square = someField.square();
   *
   * square.assertEquals(someField.mul(someField)); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * ** Warning: This is a modular multiplication. See `mul()` method for more details.
   *
   * @return A {@link Field} element equivalent to the multiplication of the {@link Field} element with itself.
   */
  square() {
    if (this.isConstant()) {
      return new _Field(Fp.square(this.toBigInt()));
    }
    let z = existsOne(() => Fp.square(this.toBigInt()));
    assertSquareCompatible(this, z);
    return z;
  }
  /**
   * Take the square root of this {@link Field} element.
   *
   * Proves that the Field element has a square root in the finite field, or throws if it doesn't.
   *
   * @example
   * ```ts
   * let z = x.sqrt();
   * z.mul(z).assertEquals(x); // true for every `x`
   * ```
   *
   * **Warning**: This is a modular square root, which is any number z that satisfies z*z = x (mod p).
   * Note that, if a square root z exists, there also exists a second one, -z (which is different if z != 0).
   * Therefore, this method leaves an adversarial prover the choice between two different values to return.
   *
   * @return A {@link Field} element equivalent to the square root of the {@link Field} element.
   */
  sqrt() {
    if (this.isConstant()) {
      let z2 = Fp.sqrt(this.toBigInt());
      if (z2 === void 0)
        throw Error(`Field.sqrt(): input ${this} has no square root in the field.`);
      return new _Field(z2);
    }
    let z = existsOne(() => Fp.sqrt(this.toBigInt()) ?? 0n);
    assertSquareCompatible(z, this);
    return z;
  }
  /**
   * Check if this {@link Field} is equal another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * Field(5).equals(5).assertEquals(Bool(true));
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is equal another "field-like" value.
   */
  equals(y) {
    if (this.isConstant() && isConstant4(y)) {
      return new Bool3(this.toBigInt() === toFp(y));
    }
    let xMinusY = this.sub(y).seal();
    let [b2, z] = exists(2, () => {
      let xmy = xMinusY.toBigInt();
      let z2 = Fp.inverse(xmy) ?? 0n;
      let b3 = Fp.sub(1n, Fp.mul(z2, xmy));
      return [b3, z2];
    });
    assertMulCompatible(b2, xMinusY, FieldVar[0]);
    assertMulCompatible(z, xMinusY, new _Field(1).sub(b2));
    return Bool3.Unsafe.fromField(b2);
  }
  /**
   * Check if this {@link Field} is less than another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used prove to the validity of this statement.
   *
   * @example
   * ```ts
   * let isTrue = Field(2).lessThan(3);
   * ```
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behavior when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * let isFalse = Field(1).div(3).lessThan(Field(1).div(2)); // in fact, 1/3 > 1/2
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is less than another "field-like" value.
   */
  lessThan(y) {
    if (this.isConstant() && isConstant4(y)) {
      return new Bool3(this.toBigInt() < toFp(y));
    }
    return lessThanFull(this, _Field.from(y));
  }
  /**
   * Check if this {@link Field} is less than or equal to another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * let isTrue = Field(3).lessThanOrEqual(3);
   * ```
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * let isFalse = Field(1).div(3).lessThanOrEqual(Field(1).div(2)); // in fact, 1/3 > 1/2
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is less than or equal another "field-like" value.
   */
  lessThanOrEqual(y) {
    if (this.isConstant() && isConstant4(y)) {
      return new Bool3(this.toBigInt() <= toFp(y));
    }
    return lessThanOrEqualFull(this, _Field.from(y));
  }
  /**
   * Check if this {@link Field} is greater than another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * let isTrue = Field(5).greaterThan(3);
   * ```
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * let isFalse = Field(1).div(2).greaterThan(Field(1).div(3); // in fact, 1/3 > 1/2
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is greater than another "field-like" value.
   */
  greaterThan(y) {
    return _Field.from(y).lessThan(this);
  }
  /**
   * Check if this {@link Field} is greater than or equal another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * let isTrue = Field(3).greaterThanOrEqual(3);
   * ```
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * let isFalse = Field(1).div(2).greaterThanOrEqual(Field(1).div(3); // in fact, 1/3 > 1/2
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is greater than or equal another "field-like" value.
   */
  greaterThanOrEqual(y) {
    return _Field.from(y).lessThanOrEqual(this);
  }
  /**
   * Assert that this {@link Field} is less than another "field-like" value.
   *
   * Note: This uses fewer constraints than `x.lessThan(y).assertTrue()`.
   * See {@link lessThan} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThan(y, message) {
    try {
      if (this.isConstant() && isConstant4(y)) {
        if (!(this.toBigInt() < toFp(y))) {
          throw Error(`Field.assertLessThan(): expected ${this} < ${y}`);
        }
        return;
      }
      assertLessThanFull(this, _Field.from(y));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Assert that this {@link Field} is less than or equal to another "field-like" value.
   *
   * Note: This uses fewer constraints than `x.lessThanOrEqual(y).assertTrue()`.
   * See {@link Field.lessThanOrEqual} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThanOrEqual(y, message) {
    try {
      if (this.isConstant() && isConstant4(y)) {
        if (!(this.toBigInt() <= toFp(y))) {
          throw Error(`Field.assertLessThan(): expected ${this} <= ${y}`);
        }
        return;
      }
      assertLessThanOrEqualFull(this, _Field.from(y));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Assert that this {@link Field} is greater than another "field-like" value.
   *
   * Note: This uses fewer constraints than `x.greaterThan(y).assertTrue()`.
   * See {@link Field.greaterThan} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThan(y, message) {
    _Field.from(y).assertLessThan(this, message);
  }
  /**
   * Assert that this {@link Field} is greater than or equal to another "field-like" value.
   *
   * Note: This uses fewer constraints than `x.greaterThanOrEqual(y).assertTrue()`.
   * See {@link Field.greaterThanOrEqual} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThanOrEqual(y, message) {
    _Field.from(y).assertLessThanOrEqual(this, message);
  }
  /**
   * Assert that this {@link Field} does not equal another field-like value.
   *
   * Note: This uses fewer constraints than `x.equals(y).assertFalse()`.
   *
   * @example
   * ```ts
   * x.assertNotEquals(0, "expect x to be non-zero");
   * ```
   */
  assertNotEquals(y, message) {
    try {
      if (this.isConstant() && isConstant4(y)) {
        if (this.toBigInt() === toFp(y)) {
          throw Error(`Field.assertNotEquals(): ${this} = ${y}`);
        }
        return;
      }
      if (isConstant4(y)) {
        let x = toVar(this);
        let y0 = toFp(y);
        let z = existsOne(() => Fp.inverse(this.toBigInt() - y0) ?? 0n);
        assertBilinear(x, z, [1n, 0n, -y0, -1n]);
        return;
      }
      this.sub(y).inv();
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Prove that this {@link Field} is equal to 0 or 1.
   * Returns the Field wrapped in a {@link Bool}.
   *
   * If the assertion fails, the code throws an error.
   *
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertBool(message) {
    try {
      if (this.isConstant()) {
        let x = this.toBigInt();
        assert2(x === 0n || x === 1n, `Field.assertBool(): expected ${x} to be 0 or 1`);
        return new Bool3(x === 1n);
      }
      assertBooleanCompatible(this);
      return Bool3.Unsafe.fromField(this);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link Field} element.
   *
   * If you use the optional `length` argument, proves that the field element fits in `length` bits.
   * The `length` has to be between 0 and 254 and the method throws if it isn't.
   *
   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,
   * which by default is 254 bits. Prefer to pass a smaller `length` if possible.
   *
   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.
   *
   * @return An array of {@link Bool} element representing little endian binary representation of this {@link Field}.
   */
  toBits(length = 254) {
    checkBitLength("Field.toBits()", length, 254);
    if (this.isConstant()) {
      let bits2 = BinableFp.toBits(this.toBigInt());
      if (bits2.slice(length).some((bit2) => bit2))
        throw Error(`Field.toBits(): ${this} does not fit in ${length} bits`);
      return bits2.slice(0, length).map((b2) => new Bool3(b2));
    }
    let bits = Provable.witness(Provable.Array(Bool3, length), () => {
      let f = this.toBigInt();
      return Array.from({ length }, (_, k) => new Bool3(!!(f >> BigInt(k) & 0x1n)));
    });
    _Field.fromBits(bits).assertEquals(this, `Field.toBits(): Input does not fit in ${length} bits`);
    return bits;
  }
  /**
   * Convert a bit array into a {@link Field} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)
   *
   * The method throws if the given bits do not fit in a single Field element. In this case, no more than 254 bits are allowed because some 255 bit integers do not fit into a single Field element.
   *
   * **Important**: If the given `bytes` array is an array of `booleans` or {@link Bool} elements that all are `constant`, the resulting {@link Field} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type, the resulting {@link Field} will be a variable as well.
   *
   * @param bytes - An array of {@link Bool} or `boolean` type.
   *
   * @return A {@link Field} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bytes` array.
   */
  static fromBits(bits) {
    const length = bits.length;
    checkBitLength("Field.fromBits()", length, 254);
    if (bits.every((b2) => typeof b2 === "boolean" || b2.toField().isConstant())) {
      let bits_ = bits.map((b2) => typeof b2 === "boolean" ? b2 : b2.toBoolean()).concat(Array(Fp.sizeInBits - length).fill(false));
      return new _Field(BinableFp.fromBits(bits_));
    }
    return bits.map((b2) => new Bool3(b2)).reduce((acc, bit2, idx) => {
      const shift = 1n << BigInt(idx);
      return acc.add(bit2.toField().mul(shift));
    }, _Field.from(0)).seal();
  }
  /**
   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.
   *
   * In o1js, addition and scaling (multiplication of variables by a constant) of variables is represented as an AST - [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree). For example, the expression `x.add(y).mul(2)` is represented as `Scale(2, Add(x, y))`.
   *
   *  A new internal variable is created only when the variable is needed in a multiplicative or any higher level constraint (for example multiplication of two {@link Field} elements) to represent the operation.
   *
   * The `seal()` function tells o1js to stop building an AST and create a new variable right away.
   *
   * @return A {@link Field} element that is equal to the result of AST that was previously on this {@link Field} element.
   */
  seal() {
    let { constant, terms } = toLinearCombination(this.value);
    if (terms.length === 0)
      return ConstantField(constant);
    if (terms.length === 1 && constant === 0n) {
      let [c, x2] = terms[0];
      if (c === 1n)
        return VarField(x2);
    }
    let x = existsOne(() => this.toBigInt());
    this.assertEquals(x);
    return x;
  }
  /**
   * A random {@link Field} element.
   *
   * @example
   * ```ts
   * console.log(Field.random().toBigInt()); // Run this code twice!
   * ```
   *
   * @return A random {@link Field} element.
   */
  static random() {
    return new _Field(Fp.random());
  }
  // internal stuff
  // Provable<Field>
  /**
   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.
   *
   * Static function to serializes a {@link Field} into an array of {@link Field} elements.
   * This will be always an array of length 1, where the first and only element equals the given parameter itself.
   *
   * @param value - the {@link Field} element to cast the array from.
   *
   * @return A {@link Field} array of length 1 created from this {@link Field}.
   */
  static toFields(x) {
    return [x];
  }
  /**
   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.
   *
   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.
   *
   * @param value - The {@link Field} element to get the auxiliary data of, optional. If not provided, the function returns an empty array.
   */
  static toAuxiliary() {
    return [];
  }
  /**
   * This function is the implementation of {@link Provable.sizeInFields} for the {@link Field} type.
   *
   * Size of the {@link Field} type is 1, as it is the primitive type.
   * This function returns a regular number, so you cannot use it to prove something on chain. You can use it during debugging or to understand the memory complexity of some type.
   *
   * @example
   * ```ts
   * console.log(Field.sizeInFields()); // Prints 1
   * ```
   *
   * @return A number representing the size of the {@link Field} type in terms of {@link Field} type itself.
   */
  static sizeInFields() {
    return 1;
  }
  /**
   * Implementation of {@link Provable.fromFields} for the {@link Field} type.
   *
   * **Warning**: This function is designed for internal use. It is not intended to be used by a zkApp developer.
   *
   * Creates a {@link Field} from an array of Fields of length 1.
   *
   * @param fields - an array of length 1 serialized from {@link Field} elements.
   *
   * @return The first {@link Field} element of the given array.
   */
  static fromFields([x]) {
    return x;
  }
  /**
   * This function is the implementation of {@link Provable.check} in {@link Field} type.
   *
   * As any field element can be a {@link Field}, this function does not create any assertions, so it does nothing.
   *
   * @param value - the {@link Field} element to check.
   */
  static check() {
  }
  /**
   * `Provable<Field>.toValue()`
   */
  static toValue(x) {
    return x.toBigInt();
  }
  /**
   * Convert a {@link Field} element to a bigint.
   */
  static toBigint(x) {
    return x.toBigInt();
  }
  /**
   * `Provable<Field>.fromValue()`
   */
  static fromValue(x) {
    return _Field.from(x);
  }
  /**
   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.
   *
   * The result will be always an array of length 1, where the first and only element equals the {@link Field} itself.
   *
   * @return A {@link Field} array of length 1 created from this {@link Field}.
   */
  toFields() {
    return _Field.toFields(this);
  }
  /**
   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.
   *
   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.
   */
  toAuxiliary() {
    return _Field.toAuxiliary();
  }
  // ProvableExtended<Field>
  static empty() {
    return new _Field(0n);
  }
  /**
   * Serialize the {@link Field} to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toJSON());
   * ```
   *
   * @return A string equivalent to the JSON representation of the {@link Field}.
   */
  toJSON() {
    return toConstant(this, "toJSON").toString();
  }
  /**
   * Serialize the given {@link Field} element to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(Field.toJSON(someField));
   * ```
   *
   * @param value - The JSON string to coerce the {@link Field} from.
   *
   * @return A string equivalent to the JSON representation of the given {@link Field}.
   */
  static toJSON(x) {
    return x.toJSON();
  }
  /**
   * Deserialize a JSON string containing a "field-like" value into a {@link Field} element.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}.
   *
   * @param value - the "field-like" value to coerce the {@link Field} from.
   *
   * @return A {@link Field} coerced from the given JSON string.
   */
  static fromJSON(json) {
    return new _Field(SignableFp.fromJSON(json));
  }
  /**
   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.
   *
   * This function is the implementation of `ProvableExtended.toInput()` for the {@link Field} type.
   *
   * @param value - The {@link Field} element to get the `input` array.
   *
   * @return An object where the `fields` key is a {@link Field} array of length 1 created from this {@link Field}.
   *
   */
  static toInput(x) {
    return { fields: [x] };
  }
  // Binable<Field>
  /**
   * Create an array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.
   * Note that the array has always 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.
   *
   * @param value - The {@link Field} element to generate the array of bytes of.
   *
   * @return An array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.
   *
   */
  static toBytes(x) {
    return FieldBinable.toBytes(x);
  }
  /**
   * Part of the `Binable` interface.
   *
   * **Warning**: This function is for internal use. It is not intended to be used by a zkApp developer.
   */
  static readBytes(bytes, offset) {
    return FieldBinable.readBytes(bytes, offset);
  }
  /**
   * Coerce a new {@link Field} element using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.
   * Note that the given `bytes` array may have at most 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the byte representation of the {@link Field}.
   *
   * @param bytes - The bytes array to coerce the {@link Field} from.
   *
   * @return A new {@link Field} element created using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.
   */
  static fromBytes(bytes) {
    return FieldBinable.fromBytes(bytes);
  }
};
Field3.ORDER = Fp.modulus;
Field3.sizeInBytes = BinableFp.sizeInBytes;
Field3.sizeInBits = Fp.sizeInBits;
setFieldConstructor(Field3);
var FieldBinable = defineBinable({
  toBytes(t) {
    let t0 = toConstantField(t, "toBytes").toBigInt();
    return BinableFp.toBytes(t0);
  },
  readBytes(bytes, offset) {
    let uint8array = new Uint8Array(32);
    uint8array.set(bytes.slice(offset, offset + 32));
    let x = BinableFp.fromBytes([...uint8array]);
    return [new Field3(x), offset + 32];
  }
});
function isConstant4(x) {
  let type = typeof x;
  if (type === "bigint" || type === "number" || type === "string") {
    return true;
  }
  return x.isConstant();
}
function toFp(x) {
  let type = typeof x;
  if (type === "bigint" || type === "number" || type === "string") {
    return Fp.mod(BigInt(x));
  }
  return x.toBigInt();
}
function toFieldConst(x) {
  if (x instanceof Field3)
    return x.value[1];
  return FieldConst.fromBigint(Fp.mod(BigInt(x)));
}
function toFieldVar2(x) {
  if (x instanceof Field3)
    return x.value;
  return FieldVar.constant(Fp.mod(BigInt(x)));
}
function withMessage(error, message) {
  if (message === void 0 || !(error instanceof Error))
    return error;
  error.message = `${message}
${error.message}`;
  return error;
}
function checkBitLength(name, length, maxLength = Fp.sizeInBits) {
  if (length > maxLength)
    throw Error(`${name}: bit length must be ${maxLength} or less, got ${length}`);
  if (length < 0)
    throw Error(`${name}: bit length must be non-negative, got ${length}`);
}
function toConstant(x, name) {
  return toConstantField(x, name, "x", "field element");
}
function toConstantField(x, methodName, varName = "x", varDescription = "field element") {
  if (x.isConstant())
    return x;
  assert2(inCheckedComputation(), "variables only exist inside checked computations");
  if (Snarky.run.inProverBlock()) {
    let value = Snarky.field.readVar(x.value);
    return new Field3(value);
  }
  throw Error(readVarMessage(methodName, varName, varDescription));
}
function readVarMessage(methodName, varName, varDescription) {
  return `${varName}.${methodName}() was called on a variable ${varDescription} \`${varName}\` in provable code.
This is not supported, because variables represent an abstract computation, 
which only carries actual values during proving, but not during compiling.

Also, reading out JS values means that whatever you're doing with those values will no longer be
linked to the original variable in the proof, which makes this pattern prone to security holes.

You can check whether your ${varDescription} is a variable or a constant by using ${varName}.isConstant().

To inspect values for debugging, use Provable.log(${varName}). For more advanced use cases,
there is \`Provable.asProver(() => { ... })\` which allows you to use ${varName}.${methodName}() inside the callback.
Warning: whatever happens inside asProver() will not be part of the zk proof.
`;
}
function VarField(x) {
  return new Field3(x);
}
function ConstantField(x) {
  return new Field3(x);
}

// dist/node/lib/util/base58.js
var import_js_sha256 = require("js-sha256");
var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
var inverseAlphabet = {};
alphabet.forEach((c, i) => {
  inverseAlphabet[c] = i;
});
function toBase58Check(input, versionByte) {
  let withVersion2 = [versionByte, ...input];
  let checksum = computeChecksum(withVersion2);
  let withChecksum = withVersion2.concat(checksum);
  return toBase58(withChecksum);
}
function fromBase58Check(base582, versionByte) {
  let bytes = fromBase58(base582);
  let checksum = bytes.slice(-4);
  let originalBytes = bytes.slice(0, -4);
  let actualChecksum = computeChecksum(originalBytes);
  if (!arrayEqual(checksum, actualChecksum))
    throw Error("fromBase58Check: invalid checksum");
  if (originalBytes[0] !== versionByte)
    throw Error(`fromBase58Check: input version byte ${versionByte} does not match encoded version byte ${originalBytes[0]}`);
  return originalBytes.slice(1);
}
function toBase58(bytes) {
  let z = 0;
  while (bytes[z] === 0)
    z++;
  let digits = [...bytes].map(BigInt).reverse();
  let base58Digits = changeBase(digits, 256n, 58n).reverse();
  base58Digits = Array(z).fill(0n).concat(base58Digits);
  return base58Digits.map((x) => alphabet[Number(x)]).join("");
}
function fromBase58(base582) {
  let base58Digits = [...base582].map((c) => {
    let digit = inverseAlphabet[c];
    if (digit === void 0)
      throw Error("fromBase58: invalid character");
    return BigInt(digit);
  });
  let z = 0;
  while (base58Digits[z] === 0n)
    z++;
  let digits = changeBase(base58Digits.reverse(), 58n, 256n).reverse();
  digits = Array(z).fill(0n).concat(digits);
  return digits.map(Number);
}
function computeChecksum(input) {
  let hash1 = import_js_sha256.sha256.create();
  hash1.update(input);
  let hash22 = import_js_sha256.sha256.create();
  hash22.update(hash1.array());
  return hash22.array().slice(0, 4);
}
function base58(binable, versionByte) {
  return {
    toBase58(t) {
      let bytes = binable.toBytes(t);
      return toBase58Check(bytes, versionByte);
    },
    fromBase58(base582) {
      let bytes = fromBase58Check(base582, versionByte);
      return binable.fromBytes(bytes);
    }
  };
}
function withBase58(binable, versionByte) {
  return { ...binable, ...base58(binable, versionByte) };
}
function customEncoding(Field5, versionByte, versionNumber) {
  let customField = versionNumber !== void 0 ? withVersionNumber(Field5, versionNumber) : Field5;
  return base58(customField, versionByte);
}
var RECEIPT_CHAIN_HASH_VERSION = 1;
var LEDGER_HASH_VERSION = 1;
var EPOCH_SEED_VERSION = 1;
var STATE_HASH_VERSION = 1;
function fieldEncodings(Field5) {
  const TokenId5 = customEncoding(Field5, versionBytes.tokenIdKey);
  const ReceiptChainHash4 = customEncoding(Field5, versionBytes.receiptChainHash, RECEIPT_CHAIN_HASH_VERSION);
  const LedgerHash2 = customEncoding(Field5, versionBytes.ledgerHash, LEDGER_HASH_VERSION);
  const EpochSeed2 = customEncoding(Field5, versionBytes.epochSeed, EPOCH_SEED_VERSION);
  const StateHash4 = customEncoding(Field5, versionBytes.stateHash, STATE_HASH_VERSION);
  return { TokenId: TokenId5, ReceiptChainHash: ReceiptChainHash4, LedgerHash: LedgerHash2, EpochSeed: EpochSeed2, StateHash: StateHash4 };
}
function arrayEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i = 0; i < a2.length; i++) {
    if (a2[i] !== b2[i])
      return false;
  }
  return true;
}

// dist/node/mina-signer/src/curve-bigint.js
var versionNumbers = {
  field: 1,
  scalar: 1,
  publicKey: 1,
  signature: 1
};
var Group = {
  toProjective({ x, y }) {
    return Pallas.fromAffine({ x, y, infinity: false });
  },
  /**
   * Convert a projective point to a non-zero affine point.
   * Throws an error if the point is zero / infinity, i.e. if z === 0
   */
  fromProjective(point) {
    let { x, y, infinity } = Pallas.toAffine(point);
    if (infinity)
      throw Error("Group.fromProjective: point is infinity");
    return { x, y };
  },
  get generatorMina() {
    return Group.fromProjective(Pallas.one);
  },
  scale(point, scalar) {
    return Group.fromProjective(Pallas.scale(Group.toProjective(point), scalar));
  },
  b: Pallas.b,
  toFields({ x, y }) {
    return [x, y];
  }
};
var FieldWithVersion = withVersionNumber(Field, versionNumbers.field);
var BinablePublicKey = withVersionNumber(withCheck(record({ x: FieldWithVersion, isOdd: Bool }, ["x", "isOdd"]), ({ x }) => {
  let { mul, add: add3 } = Field;
  let ySquared = add3(mul(x, mul(x, x)), Pallas.b);
  if (!Field.isSquare(ySquared)) {
    throw Error("PublicKey: not a valid group element");
  }
}), versionNumbers.publicKey);
var PublicKey = {
  ...signable({ x: Field, isOdd: Bool }),
  ...withBase58(BinablePublicKey, versionBytes.publicKey),
  toJSON(publicKey) {
    return PublicKey.toBase58(publicKey);
  },
  fromJSON(json) {
    return PublicKey.fromBase58(json);
  },
  toGroup({ x, isOdd }) {
    let { mul, add: add3 } = Field;
    let ySquared = add3(mul(x, mul(x, x)), Pallas.b);
    let y = Field.sqrt(ySquared);
    if (y === void 0) {
      throw Error("PublicKey.toGroup: not a valid group element");
    }
    if (isOdd !== !!(y & 1n))
      y = Field.negate(y);
    return { x, y };
  },
  fromGroup({ x, y }) {
    let isOdd = !!(y & 1n);
    return { x, isOdd };
  },
  equal(pk1, pk2) {
    return pk1.x === pk2.x && pk1.isOdd === pk2.isOdd;
  },
  toInputLegacy({ x, isOdd }) {
    return { fields: [x], bits: [!!isOdd] };
  }
};
var checkScalar = checkRange(0n, Fq.modulus, "Scalar");
var Scalar = pseudoClass(function Scalar2(value) {
  return mod(BigInt(value), Fq.modulus);
}, {
  ...SignableBigint(checkScalar),
  ...BinableBigint(Fq.sizeInBits, checkScalar),
  ...Fq
});
var BinablePrivateKey = withVersionNumber(Scalar, versionNumbers.scalar);
var Base58PrivateKey = base58(BinablePrivateKey, versionBytes.privateKey);
var PrivateKey = {
  ...Scalar,
  ...signable(Scalar),
  ...Base58PrivateKey,
  ...BinablePrivateKey,
  toPublicKey(key) {
    return PublicKey.fromGroup(Group.scale(Group.generatorMina, key));
  },
  convertPrivateKeyToBase58WithMod
};
var Bigint256 = BinableBigint(256, () => {
});
var OutOfDomainKey = base58(withVersionNumber(Bigint256, versionNumbers.scalar), versionBytes.privateKey);
function convertPrivateKeyToBase58WithMod(keyBase58) {
  let key = OutOfDomainKey.fromBase58(keyBase58);
  key = mod(key, Fq.modulus);
  return PrivateKey.toBase58(key);
}

// dist/node/lib/provable/gadgets/native-curve.js
function scaleField(P, s) {
  let { x, y } = P;
  if (x.isConstant() && y.isConstant() && s.isConstant()) {
    let sP = PallasAffine.scale(PallasAffine.fromNonzero({ x: x.toBigInt(), y: y.toBigInt() }), s.toBigInt());
    return { x: createField2(sP.x), y: createField2(sP.y) };
  }
  const Field5 = getField();
  const Point2 = provable({ x: Field5, y: Field5 });
  let { isOdd: sLo, high: sHi } = isOddAndHigh(s);
  let shift = Fq.mod(-(1n << 255n));
  assert3((shift & 1n) === 0n);
  let shiftHi = shift >> 1n;
  let tLo = sLo;
  let tHi = sHi.add(shiftHi).seal();
  assert3(shiftHi < Fp.modulus / 2n);
  let isEdgeCase = sHi.equals(0n);
  let tHiSafe = Provable.if(isEdgeCase, createField2(0n), tHi);
  let [, RMl, [, ...tHiBitsMl]] = Snarky.group.scaleFastUnpack([0, x.value, y.value], [0, tHiSafe.value], 255);
  let R = { x: createField2(RMl[1]), y: createField2(RMl[2]) };
  createField2(tHiBitsMl[254]).assertEquals(0n);
  let RminusP = addNonZero(R, negate(P));
  R = Provable.if(tLo, Point2, R, RminusP);
  let zero2 = createField2(0n);
  let zeroPoint = { x: zero2, y: zero2 };
  let edgeCaseResult = Provable.if(sLo, Point2, P, zeroPoint);
  return Provable.if(isEdgeCase, Point2, edgeCaseResult, R);
}
function scaleShifted({ x, y }, { lowBit: tLo, high254: tHi }, numHighBits = 254) {
  if (isConstant(x, y, tHi, tLo)) {
    let sP = PallasAffine.scale(PallasAffine.fromNonzero({ x: x.toBigInt(), y: y.toBigInt() }), Fq.mod(tLo.toField().toBigInt() + 2n * tHi.toBigInt() + (1n << 255n)));
    return { x: createField2(sP.x), y: createField2(sP.y) };
  }
  const Field5 = getField();
  const Point2 = provable({ x: Field5, y: Field5 });
  let zero2 = createField2(0n);
  let equalsMinusShift = tHi.equals(Fq.modulus - (1n << 254n));
  let equalsMinusShiftMinus1 = tHi.equals(Fq.modulus - (1n << 254n) - 1n);
  let isEdgeCase = equalsMinusShift.or(equalsMinusShiftMinus1);
  let tHiSafe = Provable.if(isEdgeCase, zero2, tHi);
  let [, RMl, [, ...tHiBitsMl]] = Snarky.group.scaleFastUnpack([0, x.value, y.value], [0, tHiSafe.value], 255);
  let P = { x, y };
  let R = { x: createField2(RMl[1]), y: createField2(RMl[2]) };
  for (let i = numHighBits; i < 255; i++) {
    createField2(tHiBitsMl[i]).assertEquals(zero2);
  }
  let edgeCaseY = y.mul(equalsMinusShift.toField().mul(2n).sub(1n));
  let edgeCaseResult = { x, y: edgeCaseY };
  R = Provable.if(isEdgeCase, Point2, edgeCaseResult, R);
  let { result: RminusP, isInfinity } = add(R, negate(P));
  RminusP = Provable.if(isInfinity, Point2, { x: zero2, y: zero2 }, RminusP);
  R = Provable.if(tLo, Point2, R, RminusP);
  return R;
}
function fieldToShiftedScalar(s) {
  if (s.isConstant()) {
    let t = Fq.mod(s.toBigInt() - (1n << 255n));
    let lowBit = createBool((t & 1n) === 1n);
    let high254 = createField2(t >> 1n);
    return { lowBit, high254 };
  }
  let { isOdd: sLo, high: sHi } = isOddAndHigh(s);
  let shift = Fq.mod(-(1n << 255n));
  assert3((shift & 1n) === 0n);
  let shiftHi = shift >> 1n;
  let tLo = sLo;
  let tHi = sHi.add(shiftHi).seal();
  assert3(shiftHi < Fp.modulus / 2n);
  return { lowBit: tLo, high254: tHi };
}
function field3ToShiftedScalar(s) {
  if (Field32.isConstant(s)) {
    let t3 = Fq.mod(Field32.toBigint(s) - (1n << 255n));
    let lowBit = createBool((t3 & 1n) === 1n);
    let high254 = createField2(t3 >> 1n);
    return { lowBit, high254 };
  }
  let twoTo255 = Field32.from(Fq.mod(1n << 255n));
  let t = ForeignField.sub(s, twoTo255, Fq.modulus);
  let [t0, t1, t2] = t;
  ForeignField.assertLessThan(t, Fq.modulus);
  let [tLo, tHi00, tHi01] = exists(3, () => {
    let t3 = t0.toBigInt();
    return [bit(t3, 0), bitSlice(t3, 1, 64), bitSlice(t3, 65, 23)];
  });
  let tLoBool = tLo.assertBool();
  rangeCheck64(tHi00);
  rangeCheck64(tHi01);
  let tHi0 = tHi00.add(tHi01.mul(1n << 64n));
  tLo.add(tHi0.mul(2n)).assertEquals(t0);
  let tHi = tHi0.add(t1.mul(1n << l - 1n)).add(t2.mul(1n << 2n * l - 1n)).seal();
  return { lowBit: tLoBool, high254: tHi };
}
function add(g, h) {
  let witnesses = exists(7, () => {
    let x1 = g.x.toBigInt();
    let y1 = g.y.toBigInt();
    let x2 = h.x.toBigInt();
    let y2 = h.y.toBigInt();
    let sameX = BigInt(x1 === x2);
    let inf2 = BigInt(sameX && y1 !== y2);
    let infZ = sameX ? Fp.inverse(y2 - y1) ?? 0n : 0n;
    let x21Inv = Fp.inverse(x2 - x1) ?? 0n;
    let slopeDouble = Fp.div(3n * x1 ** 2n, 2n * y1) ?? 0n;
    let slopeAdd = Fp.mul(y2 - y1, x21Inv);
    let s2 = sameX ? slopeDouble : slopeAdd;
    let x32 = Fp.mod(s2 ** 2n - x1 - x2);
    let y32 = Fp.mod(s2 * (x1 - x32) - y1);
    return [sameX, inf2, infZ, x21Inv, s2, x32, y32];
  });
  let [same_x, inf, inf_z, x21_inv, s, x3, y3] = witnesses;
  Snarky.gates.ecAdd(MlPair(g.x.seal().value, g.y.seal().value), MlPair(h.x.seal().value, h.y.seal().value), MlPair(x3.value, y3.value), inf.value, same_x.value, s.value, inf_z.value, x21_inv.value);
  let isInfinity = createBoolUnsafe(inf);
  return { result: { x: x3, y: y3 }, isInfinity };
}
function addNonZero(g, h) {
  let { result, isInfinity } = add(g, h);
  isInfinity.assertFalse();
  return result;
}
function negate(g) {
  return { x: g.x, y: g.y.neg() };
}

// dist/node/lib/provable/scalar.js
var Scalar3 = class _Scalar {
  constructor(lowBit, high254) {
    this.lowBit = lowBit;
    this.high254 = high254;
  }
  /**
   * Create a constant {@link Scalar} from a bigint, number, string or Scalar.
   *
   * If the input is too large, it is reduced modulo the scalar field size.
   */
  static from(s) {
    if (s instanceof _Scalar)
      return s;
    let t = Fq.mod(BigInt(s) - (1n << 255n));
    let lowBit = new Bool3((t & 1n) === 1n);
    let high254 = new Field3(t >> 1n);
    return new _Scalar(lowBit, high254);
  }
  /**
   * Provable method to convert a {@link ShiftedScalar} to a {@link Scalar}.
   */
  static fromShiftedScalar(s) {
    return new _Scalar(s.lowBit, s.high254);
  }
  /**
   * Provable method to convert a {@link Field} into a {@link Scalar}.
   *
   * This is always possible and unambiguous, since the scalar field is larger than the base field.
   */
  static fromField(s) {
    let { lowBit, high254 } = fieldToShiftedScalar(s);
    return new _Scalar(lowBit, high254);
  }
  /**
   * Check whether this {@link Scalar} is a hard-coded constant in the constraint system.
   * If a {@link Scalar} is constructed outside provable code, it is a constant.
   */
  isConstant() {
    let { lowBit, high254 } = this;
    return isConstant(lowBit, high254);
  }
  /**
   * Convert this {@link Scalar} into a constant if it isn't already.
   *
   * If the scalar is a variable, this only works inside `asProver` or `witness` blocks.
   *
   * See {@link FieldVar} for an explanation of constants vs. variables.
   */
  toConstant() {
    if (this.isConstant())
      return this;
    return Provable.toConstant(_Scalar, this);
  }
  /**
   * Convert this {@link Scalar} into a bigint
   */
  toBigInt() {
    let { lowBit, high254 } = this.toConstant();
    let t = lowBit.toField().toBigInt() + 2n * high254.toBigInt();
    return Fq.mod(t + (1n << 255n));
  }
  /**
   * Creates a Scalar from an array of {@link Bool}.
   * This method is provable.
   */
  static fromBits(bits) {
    let length = bits.length;
    checkBitLength("Scalar.fromBits()", length, 255);
    let sBig = field3FromBits(bits);
    let { lowBit, high254 } = field3ToShiftedScalar(sBig);
    return new _Scalar(lowBit, high254);
  }
  /**
   * Returns a random {@link Scalar}.
   * Randomness can not be proven inside a circuit!
   */
  static random() {
    return _Scalar.from(Fq.random());
  }
  // operations on constant scalars
  /**
   * Negate a scalar field element.
   *
   * **Warning**: This method is not available for provable code.
   */
  neg() {
    let x = assertConstant(this, "neg");
    let z = Fq.negate(x);
    return _Scalar.from(z);
  }
  /**
   * Add scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  add(y) {
    let x = assertConstant(this, "add");
    let y0 = assertConstant(y, "add");
    let z = Fq.add(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Subtract scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  sub(y) {
    let x = assertConstant(this, "sub");
    let y0 = assertConstant(y, "sub");
    let z = Fq.sub(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Multiply scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  mul(y) {
    let x = assertConstant(this, "mul");
    let y0 = assertConstant(y, "mul");
    let z = Fq.mul(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Divide scalar field elements.
   * Throws if the denominator is zero.
   *
   * **Warning**: This method is not available for provable code.
   */
  div(y) {
    let x = assertConstant(this, "div");
    let y0 = assertConstant(y, "div");
    let z = Fq.div(x, y0);
    if (z === void 0)
      throw Error("Scalar.div(): Division by zero");
    return _Scalar.from(z);
  }
  /**
   * Serialize a Scalar into a Field element plus one bit, where the bit is represented as a Bool.
   *
   * **Warning**: This method is not available for provable code.
   *
   * Note: Since the Scalar field is slightly larger than the base Field, an additional high bit
   * is needed to represent all Scalars. However, for a random Scalar, the high bit will be `false` with overwhelming probability.
   */
  toFieldsCompressed() {
    let s = assertConstant(this, "toFieldsCompressed");
    let lowBitSize = BigInt(Fq.sizeInBits - 1);
    let lowBitMask = (1n << lowBitSize) - 1n;
    return {
      field: new Field3(s & lowBitMask),
      highBit: new Bool3(s >> lowBitSize === 1n)
    };
  }
  // internal stuff
  // Provable<Scalar>
  /**
   * Part of the {@link Provable} interface.
   *
   * Serialize a {@link Scalar} into an array of {@link Field} elements.
   *
   * **Warning**: This function is for internal usage. It returns 255 field elements
   * which represent the Scalar in a shifted, bitwise format.
   * The fields are not constrained to be boolean.
   */
  static toFields(x) {
    return [x.lowBit.toField(), x.high254];
  }
  /**
   * Serialize this Scalar to Field elements.
   *
   * **Warning**: This function is for internal usage. It returns 255 field elements
   * which represent the Scalar in a shifted, bitwise format.
   * The fields are not constrained to be boolean.
   *
   * Check out {@link Scalar.toFieldsCompressed} for a user-friendly serialization
   * that can be used outside proofs.
   */
  toFields() {
    return _Scalar.toFields(this);
  }
  /**
   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.
   *
   * This function is the implementation of `ProvableExtended.toInput()` for the {@link Scalar} type.
   *
   * @param value - The {@link Scalar} element to get the `input` array.
   *
   * @return An object where the `fields` key is a {@link Field} array of length 1 created from this {@link Field}.
   *
   */
  static toInput(x) {
    return { fields: [x.high254], packed: [[x.lowBit.toField(), 1]] };
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Serialize a {@link Scalar} into its auxiliary data, which are empty.
   */
  static toAuxiliary() {
    return [];
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Creates a data structure from an array of serialized {@link Field} elements.
   */
  static fromFields(fields2) {
    assert(fields2.length === 2, `Scalar.fromFields(): expected 2 fields, got ${fields2.length}`);
    let lowBit = Bool3.Unsafe.fromField(fields2[0]);
    let high254 = fields2[1];
    return new _Scalar(lowBit, high254);
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns the size of this type in {@link Field} elements.
   */
  static sizeInFields() {
    return 2;
  }
  /**
   * Part of the {@link Provable} interface.
   */
  static check(s) {
    return Bool3.check(s.lowBit);
  }
  static toValue(x) {
    return x.toBigInt();
  }
  static fromValue(x) {
    return _Scalar.from(x);
  }
  // ProvableExtended<Scalar>
  /**
   * Serialize a {@link Scalar} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.
   */
  static toJSON(x) {
    let s = assertConstant(x, "toJSON");
    return s.toString();
  }
  /**
   * Serializes this Scalar to a string
   */
  toJSON() {
    return _Scalar.toJSON(this);
  }
  /**
   * Deserialize a JSON structure into a {@link Scalar}.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.
   */
  static fromJSON(x) {
    return _Scalar.from(Scalar.fromJSON(x));
  }
  static empty() {
    return _Scalar.from(0n);
  }
};
Scalar3.ORDER = Fq.modulus;
function assertConstant(x, name) {
  assert(x.isConstant(), `${name}() is not available in provable code.
That means it can't be called in a @method or similar environment, and there's no alternative implemented to achieve that.`);
  return x.toBigInt();
}

// dist/node/lib/provable/group.js
var Group2 = class _Group {
  /**
   * The generator `g` of the Group.
   */
  static get generator() {
    return new _Group({ x: Pallas.one.x, y: Pallas.one.y });
  }
  /**
   * Unique representation of the `zero` element of the Group (the identity element of addition in this Group).
   *
   * **Note**: The `zero` element is represented as `(0, 0)`.
   *
   * ```typescript
   * // g + -g = 0
   * g.add(g.neg()).assertEquals(zero);
   * // g + 0 = g
   * g.add(zero).assertEquals(g);
   * ```
   */
  static get zero() {
    return new _Group({ x: 0, y: 0 });
  }
  /**
   * Coerces anything group-like to a {@link Group}.
   */
  constructor({ x, y }) {
    this.x = x instanceof Field3 ? x : new Field3(x);
    this.y = y instanceof Field3 ? y : new Field3(y);
    if (isConstant5(this)) {
      if (this.x.equals(0).and(this.y.equals(0)).toBoolean())
        return;
      const { add: add3, mul, square } = Fp;
      let x_bigint = this.x.toBigInt();
      let y_bigint = this.y.toBigInt();
      let onCurve = add3(mul(x_bigint, mul(x_bigint, x_bigint)), Pallas.b) === square(y_bigint);
      if (!onCurve) {
        throw Error(`(x: ${x_bigint}, y: ${y_bigint}) is not a valid group element`);
      }
    }
  }
  /**
   * Checks if this element is the `zero` element `{x: 0, y: 0}`.
   */
  isZero() {
    return this.x.equals(0);
  }
  /**
   * Adds this {@link Group} element to another {@link Group} element.
   *
   * ```ts
   * let g1 = Group({ x: -1, y: 2})
   * let g2 = g1.add(g1)
   * ```
   */
  add(g) {
    if (isConstant5(this) && isConstant5(g)) {
      if (this.isZero().toBoolean()) {
        return g;
      } else if (g.isZero().toBoolean()) {
        return this;
      } else {
        let g_proj = Pallas.add(toProjective(this), toProjective(g));
        return fromProjective(g_proj);
      }
    } else {
      let { result, isInfinity } = add(this, g);
      let gIsZero = g.isZero();
      let onlyThisIsZero = this.isZero().and(gIsZero.not());
      let isNegation = isInfinity;
      let isNormalAddition = gIsZero.or(onlyThisIsZero).or(isNegation).not();
      return Provable.switch([gIsZero, onlyThisIsZero, isNegation, isNormalAddition], _Group, [this, g, _Group.zero, new _Group(result)], { allowNonExclusive: true });
    }
  }
  /**
   * Lower-level variant of {@link add} which doesn't handle the case where one of the operands is zero, and
   * asserts that the output is non-zero.
   *
   * Optionally, zero outputs can be allowed by setting `allowZeroOutput` to `true`.
   *
   * **Warning**: If one of the inputs is zero, the result will be garbage and the proof useless.
   * This case has to be prevented or handled separately by the caller of this method.
   */
  addNonZero(g2, allowZeroOutput = false) {
    if (isConstant5(this) && isConstant5(g2)) {
      let { x, y, infinity } = PallasAffine.add(toAffine(this), toAffine(g2));
      assert(!infinity || allowZeroOutput, "Group.addNonzero(): Result is zero");
      return fromAffine({ x, y, infinity });
    }
    let { result, isInfinity } = add(this, g2);
    if (allowZeroOutput) {
      return Provable.if(isInfinity, _Group.zero, new _Group(result));
    } else {
      isInfinity.assertFalse("Group.addNonzero(): Result is zero");
      return new _Group(result);
    }
  }
  /**
   * Subtracts another {@link Group} element from this one.
   */
  sub(g) {
    return this.add(g.neg());
  }
  /**
   * Negates this {@link Group}. Under the hood, it simply negates the `y` coordinate and leaves the `x` coordinate as is.
   */
  neg() {
    let { x, y } = this;
    return new _Group({ x, y: y.neg() });
  }
  /**
   * Elliptic curve scalar multiplication. Scales the {@link Group} element `n`-times by itself, where `n` is the {@link Scalar}.
   *
   * ```typescript
   * let s = Scalar(5);
   * let 5g = g.scale(s);
   * ```
   */
  scale(s) {
    if (s instanceof Field3)
      return new _Group(scaleField(this, s));
    let scalar = Scalar3.from(s);
    if (isConstant5(this) && scalar.isConstant()) {
      let g_proj = Pallas.scale(toProjective(this), scalar.toBigInt());
      return fromProjective(g_proj);
    } else {
      let result = scaleShifted(this, scalar);
      return new _Group(result);
    }
  }
  /**
   * Assert that this {@link Group} element equals another {@link Group} element.
   * Throws an error if the assertion fails.
   *
   * ```ts
   * g1.assertEquals(g2);
   * ```
   */
  assertEquals(g, message) {
    let { x: x1, y: y1 } = this;
    let { x: x2, y: y2 } = g;
    x1.assertEquals(x2, message);
    y1.assertEquals(y2, message);
  }
  /**
   * Check if this {@link Group} element equals another {@link Group} element.
   * Returns a {@link Bool}.
   *
   * ```ts
   * g1.equals(g1); // Bool(true)
   * ```
   */
  equals(g) {
    let { x: x1, y: y1 } = this;
    let { x: x2, y: y2 } = g;
    return x1.equals(x2).and(y1.equals(y2));
  }
  static toValue({ x, y }) {
    return { x: x.toBigInt(), y: y.toBigInt() };
  }
  static fromValue(g) {
    return new _Group(g);
  }
  /**
   * Serializes this {@link Group} element to a JSON object.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  toJSON() {
    return {
      x: this.x.toString(),
      y: this.y.toString()
    };
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an array containing this {@link Group} element as an array of {@link Field} elements.
   */
  toFields() {
    return [this.x, this.y];
  }
  /**
   * Coerces two x and y coordinates into a {@link Group} element.
   */
  static from(x, y) {
    return new _Group({ x, y });
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an array containing a {@link Group} element as an array of {@link Field} elements.
   */
  static toFields(g) {
    return g.toFields();
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an empty array.
   */
  static toAuxiliary(g) {
    return [];
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Deserializes a {@link Group} element from a list of field elements.
   */
  static fromFields([x, y]) {
    return new _Group({ x, y });
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns 2.
   */
  static sizeInFields() {
    return 2;
  }
  /**
   * Serializes a {@link Group} element to a JSON object.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  static toJSON(g) {
    return g.toJSON();
  }
  /**
   * Deserializes a JSON-like structure to a {@link Group} element.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  static fromJSON({ x, y }) {
    return new _Group({ x, y });
  }
  /**
   * Checks that a {@link Group} element is constraint properly by checking that the element is on the curve.
   */
  static check(g) {
    try {
      const { x, y } = g;
      let x2 = x.square();
      let x3 = x2.mul(x);
      let ax = x.mul(Pallas.a);
      let isZero = x.equals(0).and(y.equals(0));
      isZero.or(x3.add(ax).add(Pallas.b).equals(y.square())).assertTrue();
    } catch (error) {
      if (!(error instanceof Error))
        return error;
      throw `${`Element (x: ${g.x}, y: ${g.y}) is not an element of the group.`}
${error.message}`;
    }
  }
  static toInput(x) {
    return {
      fields: [x.x, x.y]
    };
  }
  static empty() {
    return _Group.zero;
  }
};
function isConstant5(g) {
  return g.x.isConstant() && g.y.isConstant();
}
function toProjective(g) {
  return Pallas.fromAffine({
    x: g.x.toBigInt(),
    y: g.y.toBigInt(),
    infinity: false
  });
}
function fromProjective({ x, y, z }) {
  return fromAffine(Pallas.toAffine({ x, y, z }));
}
function fromAffine({ x, y, infinity }) {
  return infinity ? Group2.zero : new Group2({ x, y });
}
function toAffine(g) {
  return PallasAffine.from({ x: g.x.toBigInt(), y: g.y.toBigInt() });
}

// dist/node/lib/provable/wrapped.js
var Field4 = toFunctionConstructor(Field3);
var Bool4 = toFunctionConstructor(Bool3);
var Group3 = toFunctionConstructor(Group2);
function toFunctionConstructor(Class) {
  function Constructor(...args) {
    return new Class(...args);
  }
  Object.defineProperties(Constructor, Object.getOwnPropertyDescriptors(Class));
  return Constructor;
}

// dist/node/bindings/lib/generic.js
var emptyType = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: () => [],
  fromFields: () => null,
  check: () => {
  },
  toInput: () => ({}),
  toJSON: () => null,
  fromJSON: () => null,
  empty: () => null,
  toValue: () => null,
  fromValue: () => null
};
var undefinedType = {
  ...emptyType,
  fromFields: () => void 0,
  toJSON: () => null,
  fromJSON: () => void 0,
  empty: () => void 0,
  toValue: () => void 0,
  fromValue: () => void 0
};
var primitiveTypes = /* @__PURE__ */ new Set(["number", "string", "null"]);
function EmptyUndefined() {
  return undefinedType;
}
function EmptyVoid() {
  return undefinedType;
}
var primitiveTypeMap = {
  number: {
    ...emptyType,
    toAuxiliary: (value = 0) => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value,
    empty: () => 0,
    toValue: (value) => value,
    fromValue: (value) => value
  },
  string: {
    ...emptyType,
    toAuxiliary: (value = "") => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value,
    empty: () => "",
    toValue: (value) => value,
    fromValue: (value) => value
  },
  null: emptyType
};

// dist/node/lib/provable/crypto/poseidon.js
var import_tslib2 = require("tslib");

// dist/node/lib/provable/crypto/hash-generic.js
function createHashHelpers(Field5, Hash2) {
  function salt2(prefix) {
    return Hash2.update(Hash2.initialState(), [prefixToField(Field5, prefix)]);
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Hash2.update(init, input)[0];
  }
  return { salt: salt2, emptyHashWithPrefix: emptyHashWithPrefix2, hashWithPrefix: hashWithPrefix3 };
}

// dist/node/lib/ml/fields.js
var MlFieldArray = {
  to(arr) {
    return MlArray.to(arr.map((x) => x.value));
  },
  from([, ...arr]) {
    return arr.map((x) => new Field3(x));
  }
};
var MlFieldConstArray = {
  to(arr) {
    return MlArray.to(arr.map((x) => x.toConstant().value[1]));
  },
  from([, ...arr]) {
    return arr.map((x) => new Field3(x));
  }
};

// dist/node/bindings/crypto/poseidon.js
function fieldToGroup(x) {
  const { potentialXs, tryDecode } = GroupMapPallas;
  const xs = potentialXs(x);
  return xs.map((x2) => tryDecode(x2)).find((x2) => x2);
}
function makeHashToGroup(hash3) {
  return (input) => {
    let digest = hash3(input);
    let g = fieldToGroup(digest);
    if (g === void 0)
      return void 0;
    let isOdd = (g.y & 1n) === 1n;
    let y = isOdd ? Fp.negate(g.y) : g.y;
    return { x: g.x, y };
  };
}
var PoseidonSpec = createPoseidon(Fp, poseidonParamsKimchiFp);
var Poseidon = {
  ...PoseidonSpec,
  hashToGroup: makeHashToGroup(PoseidonSpec.hash)
};
var PoseidonLegacy = createPoseidon(Fp, poseidonParamsLegacyFp);
function createPoseidon(Fp2, { fullRounds, partialRounds, hasInitialRoundConstant, stateSize, rate, power: power_, roundConstants: roundConstants_, mds: mds_ }) {
  if (partialRounds !== 0) {
    throw Error("we don't support partial rounds");
  }
  assertPositiveInteger(rate, "rate must be a positive integer");
  assertPositiveInteger(fullRounds, "fullRounds must be a positive integer");
  assertPositiveInteger(power_, "power must be a positive integer");
  let power2 = BigInt(power_);
  let roundConstants = roundConstants_.map((arr) => arr.map(BigInt));
  let mds = mds_.map((arr) => arr.map(BigInt));
  function initialState() {
    return Array(stateSize).fill(0n);
  }
  function hash3(input) {
    let state3 = update(initialState(), input);
    return state3[0];
  }
  function update([...state3], input) {
    if (input.length === 0) {
      permutation2(state3);
      return state3;
    }
    let n = Math.ceil(input.length / rate) * rate;
    input = input.concat(Array(n - input.length).fill(0n));
    for (let blockIndex = 0; blockIndex < n; blockIndex += rate) {
      for (let i = 0; i < rate; i++) {
        state3[i] = Fp2.add(state3[i], input[blockIndex + i]);
      }
      permutation2(state3);
    }
    return state3;
  }
  function permutation2(state3) {
    let offset = 0;
    if (hasInitialRoundConstant) {
      for (let i = 0; i < stateSize; i++) {
        state3[i] = Fp2.add(state3[i], roundConstants[0][i]);
      }
      offset = 1;
    }
    for (let round2 = 0; round2 < fullRounds; round2++) {
      for (let i = 0; i < stateSize; i++) {
        state3[i] = Fp2.power(state3[i], power2);
      }
      let oldState = [...state3];
      for (let i = 0; i < stateSize; i++) {
        state3[i] = Fp2.dot(mds[i], oldState);
        state3[i] = Fp2.add(state3[i], roundConstants[round2 + offset][i]);
      }
    }
  }
  return { initialState, update, hash: hash3 };
}

// dist/node/lib/provable/crypto/poseidon.js
var _Sponge_sponge;
var Sponge = class {
  // TODO: implement constant version in TS. currently, you need to call `initializeBindings()` before successfully calling this
  constructor() {
    _Sponge_sponge.set(this, void 0);
    let isChecked = Provable.inCheckedComputation();
    assert2(Snarky !== void 0, "Poseidon.Sponge(): bindings are not initialized, try calling `await initializeBindings()` first.");
    (0, import_tslib2.__classPrivateFieldSet)(this, _Sponge_sponge, Snarky.poseidon.sponge.create(isChecked), "f");
  }
  absorb(x) {
    Snarky.poseidon.sponge.absorb((0, import_tslib2.__classPrivateFieldGet)(this, _Sponge_sponge, "f"), x.value);
  }
  squeeze() {
    return Field4(Snarky.poseidon.sponge.squeeze((0, import_tslib2.__classPrivateFieldGet)(this, _Sponge_sponge, "f")));
  }
};
_Sponge_sponge = /* @__PURE__ */ new WeakMap();
var Poseidon2 = {
  hash(input) {
    if (isConstant6(input)) {
      return Field4(Poseidon.hash(toBigints(input)));
    }
    return Poseidon2.update(Poseidon2.initialState(), input)[0];
  },
  update(state3, input) {
    if (isConstant6(state3) && isConstant6(input)) {
      let newState2 = Poseidon.update(toBigints(state3), toBigints(input));
      return TupleN.fromArray(3, newState2.map(Field4));
    }
    let newState = Snarky.poseidon.update(MlFieldArray.to(state3), MlFieldArray.to(input));
    return MlFieldArray.from(newState);
  },
  hashWithPrefix(prefix, input) {
    let init = Poseidon2.update(Poseidon2.initialState(), [
      prefixToField2(prefix)
    ]);
    return Poseidon2.update(init, input)[0];
  },
  initialState() {
    return [Field4(0), Field4(0), Field4(0)];
  },
  Unsafe: {
    /**
     * Low-level version of `Poseidon.hashToGroup()`.
     *
     * **Warning**: This function is marked unsafe because its output is not deterministic.
     * It returns the square root of a value without constraining which of the two possible
     * square roots is chosen. This allows the prover to choose between two different hashes,
     * which can be a vulnerability if consuming code treats the output as unique.
     */
    hashToGroup(input) {
      if (isConstant6(input)) {
        let result = Poseidon.hashToGroup(toBigints(input));
        assert2(result !== void 0, "hashToGroup works on all inputs");
        return new Group2(result);
      }
      let [, x, y] = Snarky.poseidon.hashToGroup(MlFieldArray.to(input));
      return new Group2({ x, y });
    }
  },
  /**
   * Hashes a list of field elements to a point on the Pallas curve.
   *
   * The output point is deterministic and its discrete log is not efficiently computable.
   */
  hashToGroup(input) {
    if (isConstant6(input))
      return Poseidon2.Unsafe.hashToGroup(input);
    let { x, y } = Poseidon2.Unsafe.hashToGroup(input);
    let sign3 = Field4.from(1n).sub(y.isOdd().toField().mul(2n));
    y = y.mul(sign3);
    return new Group2({ x, y });
  },
  /**
   * Hashes a provable type efficiently.
   *
   * ```ts
   * let skHash = Poseidon.hashPacked(PrivateKey, secretKey);
   * ```
   *
   * Note: Instead of just doing `Poseidon.hash(value.toFields())`, this
   * uses the `toInput()` method on the provable type to pack the input into as few
   * field elements as possible. This saves constraints because packing has a much
   * lower per-field element cost than hashing.
   */
  hashPacked(type, value) {
    let input = ProvableType.get(type).toInput(value);
    let packed = packToFields(input);
    return Poseidon2.hash(packed);
  },
  Sponge
};
function hashConstant(input) {
  return Field4(Poseidon.hash(toBigints(input)));
}
var HashHelpers = createHashHelpers(Field4, Poseidon2);
var { salt, emptyHashWithPrefix, hashWithPrefix } = HashHelpers;
function prefixToField2(prefix) {
  if (prefix.length * 8 >= 255)
    throw Error("prefix too long");
  let bits = [...prefix].map((char) => {
    let bits2 = [];
    for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {
      if (j === 7)
        assert2(c === 0, `Invalid character ${char}, only ASCII characters are supported.`);
      bits2.push(!!(c & 1));
    }
    return bits2;
  }).flat();
  return Field4.fromBits(bits);
}
function packToFields({ fields: fields2 = [], packed = [] }) {
  if (packed.length === 0)
    return fields2;
  let packedBits = [];
  let currentPackedField = Field4(0);
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField.mul(Field4(1n << BigInt(size))).add(field);
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields2.concat(packedBits);
}
function isHashable(obj) {
  if (!obj) {
    return false;
  }
  const hasToInput = "toInput" in obj && typeof obj.toInput === "function";
  const hasEmpty = "empty" in obj && typeof obj.empty === "function";
  return hasToInput && hasEmpty;
}
var TokenSymbolPure = {
  toFields({ field }) {
    return [field];
  },
  toAuxiliary(value) {
    return [value?.symbol ?? ""];
  },
  fromFields([field], [symbol]) {
    return { symbol, field };
  },
  sizeInFields() {
    return 1;
  },
  check({ field }) {
    rangeCheckN(48, field);
  },
  toValue({ symbol }) {
    return symbol;
  },
  fromValue(symbol) {
    if (typeof symbol !== "string")
      return symbol;
    let bytesLength = new TextEncoder().encode(symbol).length;
    if (bytesLength > 6)
      throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
    let field = prefixToField2(symbol);
    return { symbol, field };
  },
  toJSON({ symbol }) {
    return symbol;
  },
  fromJSON(symbol) {
    let field = prefixToField2(symbol);
    return { symbol, field };
  },
  toInput({ field }) {
    return { packed: [[field, 48]] };
  },
  empty() {
    return { symbol: "", field: Field4(0n) };
  }
};
var TokenSymbol = class _TokenSymbol extends Struct(TokenSymbolPure) {
  static from(value) {
    return _TokenSymbol.fromValue(value);
  }
};
function emptyReceiptChainHash() {
  return emptyHashWithPrefix("CodaReceiptEmpty");
}
function isConstant6(fields2) {
  return fields2.every((x) => x.isConstant());
}
function toBigints(fields2) {
  return fields2.map((x) => x.toBigInt());
}

// dist/node/lib/proof-system/prover-keys.js
var KeyType;
(function(KeyType2) {
  KeyType2[KeyType2["StepProvingKey"] = 0] = "StepProvingKey";
  KeyType2[KeyType2["StepVerificationKey"] = 1] = "StepVerificationKey";
  KeyType2[KeyType2["WrapProvingKey"] = 2] = "WrapProvingKey";
  KeyType2[KeyType2["WrapVerificationKey"] = 3] = "WrapVerificationKey";
})(KeyType || (KeyType = {}));
function parseHeader(programName, methods, header) {
  let hash3 = Pickles.util.fromMlString(header[1][2][7]);
  switch (header[0]) {
    case KeyType.StepProvingKey:
    case KeyType.StepVerificationKey: {
      let kind = snarkKeyStringKind[header[0]];
      let methodIndex = header[1][3];
      let methodName = methods[methodIndex].methodName;
      let persistentId = sanitize(`${kind}-${programName}-${methodName}`);
      let uniqueId = sanitize(`${kind}-${programName}-${methodIndex}-${methodName}-${hash3}`);
      return {
        version: cacheHeaderVersion,
        uniqueId,
        kind,
        persistentId,
        programName,
        methodName,
        methodIndex,
        hash: hash3,
        dataType: snarkKeySerializationType[header[0]]
      };
    }
    case KeyType.WrapProvingKey:
    case KeyType.WrapVerificationKey: {
      let kind = snarkKeyStringKind[header[0]];
      let dataType = snarkKeySerializationType[header[0]];
      let persistentId = sanitize(`${kind}-${programName}`);
      let uniqueId = sanitize(`${kind}-${programName}-${hash3}`);
      return {
        version: cacheHeaderVersion,
        uniqueId,
        kind,
        persistentId,
        programName,
        hash: hash3,
        dataType
      };
    }
  }
}
function encodeProverKey(value) {
  switch (value[0]) {
    case KeyType.StepProvingKey: {
      let index = value[1][1];
      let encoded = wasm.caml_pasta_fp_plonk_index_encode(index);
      return encoded;
    }
    case KeyType.StepVerificationKey: {
      let vkMl = value[1];
      const rustConversion2 = getRustConversion(wasm);
      let vkWasm = rustConversion2.fp.verifierIndexToRust(vkMl);
      let string = wasm.caml_pasta_fp_plonk_verifier_index_serialize(vkWasm);
      return new TextEncoder().encode(string);
    }
    case KeyType.WrapProvingKey: {
      let index = value[1][1];
      let encoded = wasm.caml_pasta_fq_plonk_index_encode(index);
      return encoded;
    }
    case KeyType.WrapVerificationKey: {
      let vk = value[1];
      let string = Pickles.encodeVerificationKey(vk);
      return new TextEncoder().encode(string);
    }
    default:
      value;
      throw Error("unreachable");
  }
}
function decodeProverKey(header, bytes) {
  switch (header[0]) {
    case KeyType.StepProvingKey: {
      let srs2 = Pickles.loadSrsFp();
      let index = wasm.caml_pasta_fp_plonk_index_decode(bytes, srs2);
      let cs = header[1][4];
      return [KeyType.StepProvingKey, [0, index, cs]];
    }
    case KeyType.StepVerificationKey: {
      let srs2 = Pickles.loadSrsFp();
      let string = new TextDecoder().decode(bytes);
      let vkWasm = wasm.caml_pasta_fp_plonk_verifier_index_deserialize(srs2, string);
      const rustConversion2 = getRustConversion(wasm);
      let vkMl = rustConversion2.fp.verifierIndexFromRust(vkWasm);
      return [KeyType.StepVerificationKey, vkMl];
    }
    case KeyType.WrapProvingKey: {
      let srs2 = Pickles.loadSrsFq();
      let index = wasm.caml_pasta_fq_plonk_index_decode(bytes, srs2);
      let cs = header[1][3];
      return [KeyType.WrapProvingKey, [0, index, cs]];
    }
    case KeyType.WrapVerificationKey: {
      let string = new TextDecoder().decode(bytes);
      let vk = Pickles.decodeVerificationKey(string);
      return [KeyType.WrapVerificationKey, vk];
    }
    default:
      header;
      throw Error("unreachable");
  }
}
function sanitize(string) {
  return string.toLowerCase().replace(/[^a-z0-9_-]/g, "_");
}
var snarkKeyStringKind = {
  [KeyType.StepProvingKey]: "step-pk",
  [KeyType.StepVerificationKey]: "step-vk",
  [KeyType.WrapProvingKey]: "wrap-pk",
  [KeyType.WrapVerificationKey]: "wrap-vk"
};
var snarkKeySerializationType = {
  [KeyType.StepProvingKey]: "bytes",
  [KeyType.StepVerificationKey]: "string",
  [KeyType.WrapProvingKey]: "bytes",
  [KeyType.WrapVerificationKey]: "string"
};

// dist/node/lib/proof-system/zkprogram.js
var Undefined = EmptyUndefined();
var Empty = Undefined;
var Void = EmptyVoid();
var FeatureFlags = {
  /**
   * Returns a feature flag configuration where all flags are set to false.
   */
  allNone: {
    rangeCheck0: false,
    rangeCheck1: false,
    foreignFieldAdd: false,
    foreignFieldMul: false,
    xor: false,
    rot: false,
    lookup: false,
    runtimeTables: false
  },
  /**
   * Returns a feature flag configuration where all flags are optional.
   */
  allMaybe: {
    rangeCheck0: void 0,
    rangeCheck1: void 0,
    foreignFieldAdd: void 0,
    foreignFieldMul: void 0,
    xor: void 0,
    rot: void 0,
    lookup: void 0,
    runtimeTables: void 0
  },
  /**
   * Given a list of gates, returns the feature flag configuration that the gates use.
   */
  fromGates: featureFlagsFromGates,
  /**
   * Given a ZkProgram, return the feature flag configuration that fits the given program.
   * This function considers all methods of the specified ZkProgram and finds a configuration that fits all.
   */
  fromZkProgram: async (program) => await fromZkProgramList([program]),
  /**
   * Given a list of ZkPrograms, return the feature flag configuration that fits the given set of programs.
   * This function considers all methods of all specified ZkPrograms and finds a configuration that fits all.
   */
  fromZkProgramList
};
async function fromZkProgramList(programs) {
  let flatMethodIntfs = [];
  for (const program of programs) {
    let methodInterface = await program.analyzeMethods();
    flatMethodIntfs.push(...Object.values(methodInterface));
  }
  return featureFlagsfromFlatMethodIntfs(flatMethodIntfs);
}
async function featureFlagsfromFlatMethodIntfs(methodIntfs) {
  let flags = methodIntfs.map(({ gates }) => {
    return featureFlagsFromGates(gates);
  });
  if (flags.length === 0)
    throw Error("The ZkProgram has no methods, in order to calculate feature flags, please attach a method to your ZkProgram.");
  let globalFlags = {
    rangeCheck0: false,
    rangeCheck1: false,
    foreignFieldAdd: false,
    foreignFieldMul: false,
    xor: false,
    rot: false,
    lookup: false,
    runtimeTables: false
  };
  if (flags.length === 1)
    return flags[0];
  flags.forEach((featureFlags, i) => {
    for (const [flagType, currentFlag] of Object.entries(featureFlags)) {
      if (i === 0) {
        globalFlags[flagType] = currentFlag;
      } else if (globalFlags[flagType] != currentFlag) {
        globalFlags[flagType] = void 0;
      }
    }
  });
  return globalFlags;
}
var ProofBase = class {
  toJSON() {
    let type = getStatementType(this.constructor);
    return {
      publicInput: type.input.toFields(this.publicInput).map(String),
      publicOutput: type.output.toFields(this.publicOutput).map(String),
      maxProofsVerified: this.maxProofsVerified,
      proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof])
    };
  }
  constructor({ proof, publicInput, publicOutput, maxProofsVerified }) {
    this.shouldVerify = Bool4(false);
    this.publicInput = publicInput;
    this.publicOutput = publicOutput;
    this.proof = proof;
    this.maxProofsVerified = maxProofsVerified;
  }
};
ProofBase.publicInputType = void 0;
ProofBase.publicOutputType = void 0;
ProofBase.tag = () => {
  throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput, PublicOutput> { ... }`);
};
var Proof = class extends ProofBase {
  verify() {
    this.shouldVerify = Bool4(true);
  }
  verifyIf(condition) {
    this.shouldVerify = condition;
  }
  static async fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson }) {
    await initializeBindings();
    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
    let type = getStatementType(this);
    let publicInput = type.input.fromFields(publicInputJson.map(Field4));
    let publicOutput = type.output.fromFields(publicOutputJson.map(Field4));
    return new this({
      publicInput,
      publicOutput,
      proof,
      maxProofsVerified
    });
  }
  /**
   * Dummy proof. This can be useful for ZkPrograms that handle the base case in the same
   * method as the inductive case, using a pattern like this:
   *
   * ```ts
   * method(proof: SelfProof<I, O>, isRecursive: Bool) {
   *   proof.verifyIf(isRecursive);
   *   // ...
   * }
   * ```
   *
   * To use such a method in the base case, you need a dummy proof:
   *
   * ```ts
   * let dummy = await MyProof.dummy(publicInput, publicOutput, 1);
   * await myProgram.myMethod(dummy, Bool(false));
   * ```
   *
   * **Note**: The types of `publicInput` and `publicOutput`, as well as the `maxProofsVerified` parameter,
   * must match your ZkProgram. `maxProofsVerified` is the maximum number of proofs that any of your methods take as arguments.
   */
  static async dummy(publicInput, publicOutput, maxProofsVerified, domainLog2 = 14) {
    let dummyRaw = await dummyProof(maxProofsVerified, domainLog2);
    return new this({
      publicInput,
      publicOutput,
      proof: dummyRaw,
      maxProofsVerified
    });
  }
};
var sideloadedKeysCounter = 0;
var DynamicProof = class extends ProofBase {
  static tag() {
    let counter;
    if (this.memoizedCounter !== void 0) {
      counter = this.memoizedCounter;
    } else {
      counter = sideloadedKeysCounter++;
      this.memoizedCounter = counter;
    }
    return { name: `o1js-sideloaded-${counter}` };
  }
  /**
   * Verifies this DynamicProof using a given verification key
   * @param vk The verification key this proof will be verified against
   */
  verify(vk) {
    this.shouldVerify = Bool4(true);
    this.usedVerificationKey = vk;
  }
  verifyIf(vk, condition) {
    this.shouldVerify = condition;
    this.usedVerificationKey = vk;
  }
  static async fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson }) {
    await initializeBindings();
    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
    let type = getStatementType(this);
    let publicInput = type.input.fromFields(publicInputJson.map(Field4));
    let publicOutput = type.output.fromFields(publicOutputJson.map(Field4));
    return new this({
      publicInput,
      publicOutput,
      proof,
      maxProofsVerified
    });
  }
  static async dummy(publicInput, publicOutput, maxProofsVerified, domainLog2 = 14) {
    return this.fromProof(await Proof.dummy(publicInput, publicOutput, maxProofsVerified, domainLog2));
  }
  /**
   * Converts a Proof into a DynamicProof carrying over all relevant data.
   * This method can be used to convert a Proof computed by a ZkProgram
   * into a DynamicProof that is accepted in a circuit that accepts DynamicProofs
   */
  static fromProof(proof) {
    return new this({
      publicInput: proof.publicInput,
      publicOutput: proof.publicOutput,
      maxProofsVerified: proof.maxProofsVerified,
      proof: proof.proof
    });
  }
};
DynamicProof.featureFlags = FeatureFlags.allNone;
async function verify(proof, verificationKey) {
  await initializeBindings();
  let picklesProof;
  let statement;
  if (typeof proof.proof === "string") {
    [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);
    let input = MlFieldConstArray.to(proof.publicInput.map(Field4));
    let output = MlFieldConstArray.to(proof.publicOutput.map(Field4));
    statement = MlPair(input, output);
  } else {
    picklesProof = proof.proof;
    let type = getStatementType(proof.constructor);
    let input = toFieldConsts(type.input, proof.publicInput);
    let output = toFieldConsts(type.output, proof.publicOutput);
    statement = MlPair(input, output);
  }
  let vk = typeof verificationKey === "string" ? verificationKey : verificationKey.data;
  return prettifyStacktracePromise(withThreadPool(() => Pickles.verify(statement, picklesProof, vk)));
}
var compiledTags = /* @__PURE__ */ new WeakMap();
var CompiledTag = {
  get(tag) {
    return compiledTags.get(tag);
  },
  store(tag, compiledTag) {
    compiledTags.set(tag, compiledTag);
  }
};
var sideloadedKeysMap = {};
var SideloadedTag = {
  get(tag) {
    return sideloadedKeysMap[tag];
  },
  store(tag, compiledTag) {
    sideloadedKeysMap[tag] = compiledTag;
  }
};
function ZkProgram(config) {
  let methods = config.methods;
  let publicInputType = ProvableType.get(config.publicInput ?? Undefined);
  let publicOutputType = ProvableType.get(config.publicOutput ?? Void);
  let selfTag = { name: config.name };
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = publicInputType;
  SelfProof2.publicOutputType = publicOutputType;
  SelfProof2.tag = () => selfTag;
  let methodKeys = Object.keys(methods).sort();
  let methodIntfs = methodKeys.map((key) => sortMethodArguments("program", key, methods[key].privateInputs, SelfProof2));
  let methodFunctions = methodKeys.map((key) => methods[key].method);
  let maxProofsVerified = getMaxProofsVerified(methodIntfs);
  async function analyzeMethods() {
    let methodsMeta = {};
    for (let i = 0; i < methodIntfs.length; i++) {
      let methodEntry = methodIntfs[i];
      methodsMeta[methodEntry.methodName] = await analyzeMethod(publicInputType, methodEntry, methodFunctions[i]);
    }
    return methodsMeta;
  }
  let compileOutput;
  async function compile({ cache: cache2 = Cache.FileSystemDefault, forceRecompile = false } = {}) {
    let methodsMeta = await analyzeMethods();
    let gates = methodKeys.map((k) => methodsMeta[k].gates);
    let { provers: provers2, verify: verify4, verificationKey } = await compileProgram({
      publicInputType,
      publicOutputType,
      methodIntfs,
      methods: methodFunctions,
      gates,
      proofSystemTag: selfTag,
      cache: cache2,
      forceRecompile,
      overrideWrapDomain: config.overrideWrapDomain
    });
    compileOutput = { provers: provers2, verify: verify4 };
    return { verificationKey };
  }
  function toProver(key, i) {
    async function prove_(publicInput, ...args) {
      let picklesProver = compileOutput?.provers?.[i];
      if (picklesProver === void 0) {
        throw Error(`Cannot prove execution of program.${key}(), no prover found. Try calling \`await program.compile()\` first, this will cache provers in the background.`);
      }
      let publicInputFields = toFieldConsts(publicInputType, publicInput);
      let previousProofs = MlArray.to(getPreviousProofsForProver(args, methodIntfs[i]));
      let id2 = snarkContext.enter({ witnesses: args, inProver: true });
      let result;
      try {
        result = await picklesProver(publicInputFields, previousProofs);
      } finally {
        snarkContext.leave(id2);
      }
      let [publicOutputFields, proof] = MlPair.from(result);
      let publicOutput = fromFieldConsts(publicOutputType, publicOutputFields);
      class ProgramProof extends Proof {
      }
      ProgramProof.publicInputType = publicInputType;
      ProgramProof.publicOutputType = publicOutputType;
      ProgramProof.tag = () => selfTag;
      return new ProgramProof({
        publicInput,
        publicOutput,
        proof,
        maxProofsVerified
      });
    }
    let prove;
    if (publicInputType === Undefined || publicInputType === Void) {
      prove = (...args) => prove_(void 0, ...args);
    } else {
      prove = prove_;
    }
    return [key, prove];
  }
  let provers = Object.fromEntries(methodKeys.map(toProver));
  function verify3(proof) {
    if (compileOutput?.verify === void 0) {
      throw Error(`Cannot verify proof, verification key not found. Try calling \`await program.compile()\` first.`);
    }
    let statement = MlPair(toFieldConsts(publicInputType, proof.publicInput), toFieldConsts(publicOutputType, proof.publicOutput));
    return compileOutput.verify(statement, proof.proof);
  }
  async function digest() {
    let methodsMeta = await analyzeMethods();
    let digests = methodKeys.map((k) => Field4(BigInt("0x" + methodsMeta[k].digest)));
    return hashConstant(digests).toBigInt().toString(16);
  }
  return Object.assign(selfTag, {
    compile,
    verify: verify3,
    digest,
    analyzeMethods,
    publicInputType,
    publicOutputType,
    privateInputTypes: Object.fromEntries(methodKeys.map((key) => [key, methods[key].privateInputs])),
    rawMethods: Object.fromEntries(methodKeys.map((key) => [key, methods[key].method]))
  }, provers);
}
var SelfProof = class extends Proof {
};
var VerificationKey = class extends Struct({
  ...provable({ data: String, hash: Field4 }),
  toJSON({ data }) {
    return data;
  }
}) {
};
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
  let witnessArgs = [];
  let proofArgs = [];
  let allArgs = [];
  for (let i = 0; i < privateInputs.length; i++) {
    let privateInput = privateInputs[i];
    if (isProof(privateInput)) {
      if (privateInput === ProofBase || privateInput === Proof || privateInput === DynamicProof) {
        const proofClassName = privateInput.name;
        throw Error(`You cannot use the \`${proofClassName}\` class directly. Instead, define a subclass:
class MyProof extends ${proofClassName}<PublicInput, PublicOutput> { ... }`);
      }
      allArgs.push({ type: "proof", index: proofArgs.length });
      if (privateInput === SelfProof) {
        proofArgs.push(selfProof);
      } else {
        proofArgs.push(privateInput);
      }
    } else if (isAsFields(privateInput)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput);
    } else if (isAsFields(privateInput?.provable)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput.provable);
    } else {
      throw Error(`Argument ${i + 1} of method ${methodName} is not a provable type: ${privateInput}`);
    }
  }
  if (proofArgs.length > 2) {
    throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  return { methodName, witnessArgs, proofArgs, allArgs };
}
function isAsFields(type) {
  return (typeof type === "function" || typeof type === "object") && type !== null && ["toFields", "fromFields", "sizeInFields", "toAuxiliary"].every((s) => s in type);
}
function isProof(type) {
  return type === Proof || type === DynamicProof || typeof type === "function" && type.prototype instanceof ProofBase;
}
function isDynamicProof(type) {
  return typeof type === "function" && type.prototype instanceof DynamicProof;
}
function getPreviousProofsForProver(methodArgs, { allArgs }) {
  let previousProofs = [];
  for (let i = 0; i < allArgs.length; i++) {
    let arg = allArgs[i];
    if (arg.type === "proof") {
      previousProofs[arg.index] = methodArgs[i].proof;
    }
  }
  return previousProofs;
}
var maxProofsToWrapDomain = { 0: 0, 1: 1, 2: 1 };
async function compileProgram({ publicInputType, publicOutputType, methodIntfs, methods, gates, proofSystemTag, cache: cache2, forceRecompile, overrideWrapDomain }) {
  await initializeBindings();
  if (methodIntfs.length === 0)
    throw Error(`The Program you are trying to compile has no methods. 
Try adding a method to your ZkProgram or SmartContract.
If you are using a SmartContract, make sure you are using the @method decorator.`);
  let rules = methodIntfs.map((methodEntry, i) => picklesRuleFromFunction(publicInputType, publicOutputType, methods[i], proofSystemTag, methodEntry, gates[i]));
  let maxProofs = getMaxProofsVerified(methodIntfs);
  overrideWrapDomain ??= maxProofsToWrapDomain[maxProofs];
  let picklesCache = [
    0,
    function read_(mlHeader) {
      if (forceRecompile)
        return MlResult.unitError();
      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);
      let result = readCache(cache2, header, (bytes) => decodeProverKey(mlHeader, bytes));
      if (result === void 0)
        return MlResult.unitError();
      return MlResult.ok(result);
    },
    function write_(mlHeader, value) {
      if (!cache2.canWrite)
        return MlResult.unitError();
      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);
      let didWrite = writeCache(cache2, header, encodeProverKey(value));
      if (!didWrite)
        return MlResult.unitError();
      return MlResult.ok(void 0);
    },
    MlBool(cache2.canWrite)
  ];
  let { verificationKey, provers, verify: verify3, tag } = await prettifyStacktracePromise(withThreadPool(async () => {
    let result;
    let id2 = snarkContext.enter({ inCompile: true });
    setSrsCache(cache2);
    try {
      result = Pickles.compile(MlArray.to(rules), {
        publicInputSize: publicInputType.sizeInFields(),
        publicOutputSize: publicOutputType.sizeInFields(),
        storable: picklesCache,
        overrideWrapDomain
      });
      let { getVerificationKey, provers: provers2, verify: verify4, tag: tag2 } = result;
      CompiledTag.store(proofSystemTag, tag2);
      let [, data, hash3] = await getVerificationKey();
      let verificationKey2 = { data, hash: Field4(hash3) };
      return {
        verificationKey: verificationKey2,
        provers: MlArray.from(provers2),
        verify: verify4,
        tag: tag2
      };
    } finally {
      snarkContext.leave(id2);
      unsetSrsCache();
    }
  }));
  let wrappedProvers = provers.map((prover) => async function picklesProver(publicInput, previousProofs) {
    return prettifyStacktracePromise(withThreadPool(() => prover(publicInput, previousProofs)));
  });
  let wrappedVerify = async function picklesVerify(statement, proof) {
    return prettifyStacktracePromise(withThreadPool(() => verify3(statement, proof)));
  };
  return {
    verificationKey,
    provers: wrappedProvers,
    verify: wrappedVerify,
    tag
  };
}
function analyzeMethod(publicInputType, methodIntf, method2) {
  return Provable.constraintSystem(() => {
    let args = synthesizeMethodArguments(methodIntf, true);
    let publicInput = emptyWitness(publicInputType);
    if (publicInputType === Undefined || publicInputType === Void)
      return method2(...args);
    return method2(publicInput, ...args);
  });
}
function inCircuitVkHash(inCircuitVk) {
  const digest = Pickles.sideLoaded.vkDigest(inCircuitVk);
  const salt2 = Snarky.poseidon.update(MlFieldArray.to([Field4(0), Field4(0), Field4(0)]), MlFieldArray.to([prefixToField(Field4, prefixes.sideLoadedVK)]));
  const newState = Snarky.poseidon.update(salt2, digest);
  const stateFields = MlFieldArray.from(newState);
  return stateFields[0];
}
function picklesRuleFromFunction(publicInputType, publicOutputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }, gates) {
  async function main(publicInput) {
    let { witnesses: argsWithoutPublicInput, inProver: inProver2 } = snarkContext.get();
    assert2(!(inProver2 && argsWithoutPublicInput === void 0));
    let finalArgs = [];
    let proofs = [];
    let previousStatements = [];
    for (let i = 0; i < allArgs.length; i++) {
      let arg = allArgs[i];
      if (arg.type === "witness") {
        let type = witnessArgs[arg.index];
        try {
          finalArgs[i] = Provable.witness(type, () => {
            return argsWithoutPublicInput?.[i] ?? emptyValue(type);
          });
        } catch (e) {
          e.message = `Error when witnessing in ${methodName}, argument ${i}: ${e.message}`;
          throw e;
        }
      } else if (arg.type === "proof") {
        let Proof3 = proofArgs[arg.index];
        let type = getStatementType(Proof3);
        let proof_ = argsWithoutPublicInput?.[i] ?? {
          proof: void 0,
          publicInput: emptyValue(type.input),
          publicOutput: emptyValue(type.output)
        };
        let { proof, publicInput: publicInput2, publicOutput: publicOutput2 } = proof_;
        publicInput2 = Provable.witness(type.input, () => publicInput2);
        publicOutput2 = Provable.witness(type.output, () => publicOutput2);
        let proofInstance = new Proof3({ publicInput: publicInput2, publicOutput: publicOutput2, proof });
        finalArgs[i] = proofInstance;
        proofs.push({ proofInstance, classReference: Proof3 });
        let input = toFieldVars(type.input, publicInput2);
        let output = toFieldVars(type.output, publicOutput2);
        previousStatements.push(MlPair(input, output));
      }
    }
    let result;
    if (publicInputType === Undefined || publicInputType === Void) {
      result = await func(...finalArgs);
    } else {
      let input = fromFieldVars(publicInputType, publicInput);
      result = await func(input, ...finalArgs);
    }
    proofs.forEach(({ proofInstance, classReference }) => {
      if (!(proofInstance instanceof DynamicProof)) {
        return;
      }
      const tag = classReference.tag();
      const computedTag = SideloadedTag.get(tag.name);
      const vk = proofInstance.usedVerificationKey;
      if (vk === void 0) {
        throw new Error("proof.verify() not called, call it at least once in your circuit");
      }
      if (Provable.inProver()) {
        Pickles.sideLoaded.inProver(computedTag, vk.data);
      }
      const circuitVk = Pickles.sideLoaded.vkToCircuit(() => vk.data);
      const hash3 = inCircuitVkHash(circuitVk);
      Field4(hash3).assertEquals(vk.hash, "Provided VerificationKey hash not correct");
      Pickles.sideLoaded.inCircuit(computedTag, circuitVk);
    });
    let hasPublicOutput = publicOutputType.sizeInFields() !== 0;
    let publicOutput = hasPublicOutput ? publicOutputType.toFields(result) : [];
    return {
      publicOutput: MlFieldArray.to(publicOutput),
      previousStatements: MlArray.to(previousStatements),
      shouldVerify: MlArray.to(proofs.map((proof) => proof.proofInstance.shouldVerify.toField().value))
    };
  }
  if (proofArgs.length > 2) {
    throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  let proofsToVerify = proofArgs.map((Proof3) => {
    let tag = Proof3.tag();
    if (tag === proofSystemTag)
      return { isSelf: true };
    else if (isDynamicProof(Proof3)) {
      let computedTag;
      if (SideloadedTag.get(tag.name) === void 0) {
        computedTag = Pickles.sideLoaded.create(tag.name, Proof3.maxProofsVerified, Proof3.publicInputType?.sizeInFields() ?? 0, Proof3.publicOutputType?.sizeInFields() ?? 0, featureFlagsToMlOption(Proof3.featureFlags));
        SideloadedTag.store(tag.name, computedTag);
      } else {
        computedTag = SideloadedTag.get(tag.name);
      }
      return { isSelf: false, tag: computedTag };
    } else {
      let compiledTag = CompiledTag.get(tag);
      if (compiledTag === void 0) {
        throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.
Try to run ${tag.name}.compile() first.`);
      }
      return { isSelf: false, tag: compiledTag };
    }
  });
  let featureFlags = featureFlagsToMlOption(featureFlagsFromGates(gates));
  return {
    identifier: methodName,
    main,
    featureFlags,
    proofsToVerify: MlArray.to(proofsToVerify)
  };
}
function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }, asVariables = false) {
  let args = [];
  let empty4 = asVariables ? emptyWitness : emptyValue;
  for (let arg of allArgs) {
    if (arg.type === "witness") {
      args.push(empty4(witnessArgs[arg.index]));
    } else if (arg.type === "proof") {
      let Proof3 = proofArgs[arg.index];
      let type = getStatementType(Proof3);
      let publicInput = empty4(type.input);
      let publicOutput = empty4(type.output);
      args.push(new Proof3({ publicInput, publicOutput, proof: void 0 }));
    }
  }
  return args;
}
function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }, args) {
  let constArgs = [];
  for (let i = 0; i < allArgs.length; i++) {
    let arg = args[i];
    let { type, index } = allArgs[i];
    if (type === "witness") {
      constArgs.push(Provable.toConstant(witnessArgs[index], arg));
    } else if (type === "proof") {
      let Proof3 = proofArgs[index];
      let type2 = getStatementType(Proof3);
      let publicInput = Provable.toConstant(type2.input, arg.publicInput);
      let publicOutput = Provable.toConstant(type2.output, arg.publicOutput);
      constArgs.push(new Proof3({ publicInput, publicOutput, proof: arg.proof }));
    }
  }
  return constArgs;
}
function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }, args) {
  let typesAndValues = [];
  for (let i = 0; i < allArgs.length; i++) {
    let arg = args[i];
    let { type, index } = allArgs[i];
    if (type === "witness") {
      typesAndValues.push({ type: witnessArgs[index], value: arg });
    } else if (type === "proof") {
      let Proof3 = proofArgs[index];
      let proof = arg;
      let types = getStatementType(Proof3);
      let type2 = provablePure({ input: types.input, output: types.output });
      let value = { input: proof.publicInput, output: proof.publicOutput };
      typesAndValues.push({ type: type2, value });
    }
  }
  return typesAndValues;
}
function emptyValue(type) {
  return type.fromFields(Array(type.sizeInFields()).fill(Field4(0)), type.toAuxiliary());
}
function emptyWitness(type) {
  return Provable.witness(type, () => emptyValue(type));
}
function getStatementType(Proof3) {
  if (Proof3.publicInputType === void 0 || Proof3.publicOutputType === void 0) {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput, PublicOutput> { ... }`);
  }
  return {
    input: Proof3.publicInputType,
    output: Proof3.publicOutputType
  };
}
function getMaxProofsVerified(methodIntfs) {
  return methodIntfs.reduce((acc, { proofArgs }) => Math.max(acc, proofArgs.length), 0);
}
function fromFieldVars(type, fields2) {
  return type.fromFields(MlFieldArray.from(fields2));
}
function toFieldVars(type, value) {
  return MlFieldArray.to(type.toFields(value));
}
function fromFieldConsts(type, fields2) {
  return type.fromFields(MlFieldConstArray.from(fields2));
}
function toFieldConsts(type, value) {
  return MlFieldConstArray.to(type.toFields(value));
}
ZkProgram.Proof = function(program) {
  var _a2;
  return _a2 = class ZkProgramProof extends Proof {
  }, _a2.publicInputType = program.publicInputType, _a2.publicOutputType = program.publicOutputType, _a2.tag = () => program, _a2;
};
async function dummyProof(maxProofsVerified, domainLog2) {
  await initializeBindings();
  return withThreadPool(async () => Pickles.dummyProof(maxProofsVerified, domainLog2)[1]);
}
var dummyProofCache;
async function dummyBase64Proof() {
  if (dummyProofCache)
    return dummyProofCache;
  let proof = await dummyProof(2, 15);
  let base64Proof = Pickles.proofToBase64([2, proof]);
  dummyProofCache = base64Proof;
  return base64Proof;
}
var gateToFlag = {
  RangeCheck0: "rangeCheck0",
  RangeCheck1: "rangeCheck1",
  ForeignFieldAdd: "foreignFieldAdd",
  ForeignFieldMul: "foreignFieldMul",
  Xor16: "xor",
  Rot64: "rot",
  Lookup: "lookup"
};
function featureFlagsFromGates(gates) {
  let flags = {
    rangeCheck0: false,
    rangeCheck1: false,
    foreignFieldAdd: false,
    foreignFieldMul: false,
    xor: false,
    rot: false,
    lookup: false,
    runtimeTables: false
  };
  for (let gate of gates) {
    let flag = gateToFlag[gate.type];
    if (flag !== void 0)
      flags[flag] = true;
  }
  return flags;
}
function featureFlagsToMlOption(flags) {
  const { rangeCheck0: rangeCheck02, rangeCheck1: rangeCheck12, foreignFieldAdd: foreignFieldAdd2, foreignFieldMul: foreignFieldMul2, xor: xor4, rot, lookup: lookup2, runtimeTables } = flags;
  return [
    0,
    MlOption.mapTo(rangeCheck02, MlBool),
    MlOption.mapTo(rangeCheck12, MlBool),
    MlOption.mapTo(foreignFieldAdd2, MlBool),
    MlOption.mapTo(foreignFieldMul2, MlBool),
    MlOption.mapTo(xor4, MlBool),
    MlOption.mapTo(rot, MlBool),
    MlOption.mapTo(lookup2, MlBool),
    MlOption.mapTo(runtimeTables, MlBool)
  ];
}
function Prover() {
  return {
    async run(witnesses, proverData, callback) {
      let id2 = snarkContext.enter({ witnesses, proverData, inProver: true });
      try {
        return await callback();
      } finally {
        snarkContext.leave(id2);
      }
    },
    getData() {
      return snarkContext.get().proverData;
    }
  };
}

// dist/node/lib/provable/types/struct.js
function Struct(type) {
  class Struct_ {
    constructor(value) {
      Object.assign(this, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @returns the size of this struct in field elements
     */
    static sizeInFields() {
      return this.type.sizeInFields();
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw list of field elements that represent this struct inside the proof
     */
    static toFields(value) {
      return this.type.toFields(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw non-field element data contained in the struct
     */
    static toAuxiliary(value) {
      return this.type.toAuxiliary(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns a representation of this struct as field elements, which can be hashed efficiently
     */
    static toInput(value) {
      return this.type.toInput(value);
    }
    /**
     * Convert this struct to a JSON object, consisting only of numbers, strings, booleans, arrays and plain objects.
     * @param value
     * @returns a JSON representation of this struct
     */
    static toJSON(value) {
      return this.type.toJSON(value);
    }
    /**
     * Convert from a JSON object to an instance of this struct.
     * @param json
     * @returns a JSON representation of this struct
     */
    static fromJSON(json) {
      let value = this.type.fromJSON(json);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * Create an instance of this struct filled with default values
     * @returns an empty instance of this struct
     */
    static empty() {
      let value = this.type.empty();
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Method to make assertions which should be always made whenever a struct of this type is created in a proof.
     * @param value
     */
    static check(value) {
      return this.type.check(value);
    }
    /**
     * `Provable<T>.toValue()`
     */
    static toValue(x) {
      return this.type.toValue(x);
    }
    /**
     * `Provable<T>.fromValue()`
     */
    static fromValue(v) {
      let value = this.type.fromValue(v);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Recover a struct from its raw field elements and auxiliary data.
     * @param fields the raw fields elements
     * @param aux the raw non-field element data
     */
    static fromFields(fields2, aux) {
      let value = this.type.fromFields(fields2, aux);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
  }
  Struct_.type = provable(type);
  return Struct_;
}
function StructNoJson(type) {
  return Struct(type);
}
var primitives2 = /* @__PURE__ */ new Set([Field4, Bool4, Scalar3, Group3]);
function isPrimitive2(obj) {
  for (let P of primitives2) {
    if (obj instanceof P)
      return true;
  }
  return false;
}
function cloneCircuitValue(obj) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  if (obj.constructor !== void 0 && "clone" in obj.constructor) {
    return obj.constructor.clone(obj);
  }
  if ("clone" in obj && typeof obj.clone === "function") {
    return obj.clone(obj);
  }
  if (Array.isArray(obj))
    return obj.map(cloneCircuitValue);
  if (obj instanceof Set)
    return new Set([...obj].map(cloneCircuitValue));
  if (obj instanceof Map)
    return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
  if (ArrayBuffer.isView(obj))
    return new obj.constructor(obj);
  if (isPrimitive2(obj)) {
    return obj;
  }
  if (obj instanceof Proof || obj instanceof DynamicProof) {
    return obj;
  }
  let propertyDescriptors = {};
  for (let [key, value] of Object.entries(obj)) {
    propertyDescriptors[key] = {
      value: cloneCircuitValue(value),
      writable: true,
      enumerable: true,
      configurable: true
    };
  }
  return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a2, b2) {
  if (typeof a2 !== "object" || a2 === null || typeof b2 !== "object" || b2 === null)
    return a2 === b2;
  if (Array.isArray(a2)) {
    return Array.isArray(b2) && a2.length === b2.length && a2.every((a_, i) => circuitValueEquals(a_, b2[i]));
  }
  if (a2 instanceof Set) {
    return b2 instanceof Set && a2.size === b2.size && [...a2].every((a_) => b2.has(a_));
  }
  if (a2 instanceof Map) {
    return b2 instanceof Map && a2.size === b2.size && [...a2].every(([k, v]) => circuitValueEquals(v, b2.get(k)));
  }
  if (ArrayBuffer.isView(a2) && !(a2 instanceof DataView)) {
    return ArrayBuffer.isView(b2) && !(b2 instanceof DataView) && circuitValueEquals([...a2], [...b2]);
  }
  if ("equals" in a2 && typeof a2.equals === "function") {
    let isEqual = a2.equals(b2).toBoolean();
    if (typeof isEqual === "boolean")
      return isEqual;
    if (isEqual instanceof Bool4)
      return isEqual.toBoolean();
  }
  if ("toFields" in a2 && typeof a2.toFields === "function" && "toFields" in b2 && typeof b2.toFields === "function") {
    let aFields = a2.toFields();
    let bFields = b2.toFields();
    return aFields.every((a3, i) => a3.equals(bFields[i]).toBoolean());
  }
  let aEntries = Object.entries(a2).filter(([, v]) => v !== void 0);
  let bEntries = Object.entries(b2).filter(([, v]) => v !== void 0);
  if (aEntries.length !== bEntries.length)
    return false;
  return aEntries.every(([key, value]) => key in b2 && circuitValueEquals(b2[key], value));
}

// dist/node/lib/provable/gadgets/arithmetic.js
function divMod32(n, quotientBits = 32) {
  if (n.isConstant()) {
    assert2(n.toBigInt() < 1n << 64n, `n needs to fit into 64 bit, but got ${n.toBigInt()}`);
    let nBigInt = n.toBigInt();
    let q3 = nBigInt >> 32n;
    let r = nBigInt - (q3 << 32n);
    return {
      remainder: new Field4(r),
      quotient: new Field4(q3)
    };
  }
  let [quotient, remainder] = Provable.witness(provableTuple([Field4, Field4]), () => {
    let nBigInt = n.toBigInt();
    let q3 = nBigInt >> 32n;
    let r = nBigInt - (q3 << 32n);
    return [q3, r];
  });
  if (quotientBits === 1) {
    quotient.assertBool();
  } else {
    rangeCheckN(quotientBits, quotient);
  }
  rangeCheck32(remainder);
  n.assertEquals(quotient.mul(1n << 32n).add(remainder));
  return {
    remainder,
    quotient
  };
}
function addMod32(x, y) {
  return divMod32(x.add(y), 1).remainder;
}

// dist/node/lib/provable/gadgets/bitwise.js
function not(a2, length, checked = false) {
  validateBitLength(length, 240, "not");
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2.toBigInt()} does not fit into ${padLength} bits`);
    return new Field3(Fp.not(a2.toBigInt(), length));
  }
  let allOnes = new Field3(2n ** BigInt(length) - 1n);
  if (checked) {
    return xor2(a2, allOnes, length);
  } else {
    return allOnes.sub(a2).seal();
  }
}
function xor2(a2, b2, length) {
  validateBitLength(length, 240, "xor");
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant() && b2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2} does not fit into ${padLength} bits`);
    assert3(b2.toBigInt() < max2, `${b2} does not fit into ${padLength} bits`);
    return new Field3(a2.toBigInt() ^ b2.toBigInt());
  }
  let outputXor = Provable.witness(Field3, () => a2.toBigInt() ^ b2.toBigInt());
  buildXor(a2, b2, outputXor, padLength);
  return outputXor;
}
function buildXor(a2, b2, out, padLength) {
  while (padLength !== 0) {
    let slices = exists(15, () => {
      let a0 = a2.toBigInt();
      let b0 = b2.toBigInt();
      let out02 = out.toBigInt();
      return [
        // slices of a
        bitSlice(a0, 0, 4),
        bitSlice(a0, 4, 4),
        bitSlice(a0, 8, 4),
        bitSlice(a0, 12, 4),
        // slices of b
        bitSlice(b0, 0, 4),
        bitSlice(b0, 4, 4),
        bitSlice(b0, 8, 4),
        bitSlice(b0, 12, 4),
        // slices of expected output
        bitSlice(out02, 0, 4),
        bitSlice(out02, 4, 4),
        bitSlice(out02, 8, 4),
        bitSlice(out02, 12, 4),
        // next values
        a0 >> 16n,
        b0 >> 16n,
        out02 >> 16n
      ];
    });
    let [in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3, aNext, bNext, outNext] = slices;
    Gates.xor(a2, b2, out, in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3);
    a2 = aNext;
    b2 = bNext;
    out = outNext;
    padLength = padLength - 16;
  }
  Gates.zero(a2, b2, out);
  let zero2 = new Field3(0);
  zero2.assertEquals(a2);
  zero2.assertEquals(b2);
  zero2.assertEquals(out);
}
function and(a2, b2, length) {
  validateBitLength(length, 240, "and");
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant() && b2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2} does not fit into ${padLength} bits`);
    assert3(b2.toBigInt() < max2, `${b2} does not fit into ${padLength} bits`);
    return new Field3(a2.toBigInt() & b2.toBigInt());
  }
  let outputAnd = Provable.witness(Field3, () => a2.toBigInt() & b2.toBigInt());
  let sum2 = a2.add(b2);
  let xorOutput = xor2(a2, b2, length);
  outputAnd.mul(2).add(xorOutput).assertEquals(sum2);
  return outputAnd;
}
function rotate64(field, bits, direction = "left") {
  assert3(bits >= 0 && bits <= 64, `rotation: expected bits to be between 0 and 64, got ${bits}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << 64n, `rotation: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Fp.rot(field.toBigInt(), BigInt(bits), direction));
  }
  const [rotated] = rot64(field, bits, direction);
  return rotated;
}
function rotate32(field, bits, direction = "left") {
  assert3(bits <= 32 && bits > 0, "bits must be between 0 and 32");
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << 32n, `rotation: expected field to be at most 32 bits, got ${field.toBigInt()}`);
    return new Field3(Fp.rot(field.toBigInt(), BigInt(bits), direction, 32n));
  }
  let { quotient: excess, remainder: shifted } = divMod32(field.mul(1n << BigInt(direction === "left" ? bits : 32 - bits)));
  let rotated = shifted.add(excess);
  rangeCheck32(rotated);
  return rotated;
}
function rot64(field, bits, direction = "left") {
  const rotationBits = direction === "right" ? 64 - bits : bits;
  const big2Power64 = 1n << 64n;
  const big2PowerRot = 1n << BigInt(rotationBits);
  const [rotated, excess, shifted, bound] = Provable.witness(Provable.Array(Field3, 4), () => {
    const f = field.toBigInt();
    const { quotient: excess2, remainder: shifted2 } = divideWithRemainder(f * big2PowerRot, big2Power64);
    const rotated2 = shifted2 + excess2;
    const bound2 = excess2 + big2Power64 - big2PowerRot;
    return [rotated2, excess2, shifted2, bound2];
  });
  toVar(0n);
  let boundSlices = exists(12, () => {
    let bound0 = bound.toBigInt();
    return [
      bitSlice(bound0, 52, 12),
      // bits 52-64
      bitSlice(bound0, 40, 12),
      // bits 40-52
      bitSlice(bound0, 28, 12),
      // bits 28-40
      bitSlice(bound0, 16, 12),
      // bits 16-28
      bitSlice(bound0, 14, 2),
      // bits 14-16
      bitSlice(bound0, 12, 2),
      // bits 12-14
      bitSlice(bound0, 10, 2),
      // bits 10-12
      bitSlice(bound0, 8, 2),
      // bits 8-10
      bitSlice(bound0, 6, 2),
      // bits 6-8
      bitSlice(bound0, 4, 2),
      // bits 4-6
      bitSlice(bound0, 2, 2),
      // bits 2-4
      bitSlice(bound0, 0, 2)
      // bits 0-2
    ];
  });
  let [b52, b40, b28, b16, b14, b12, b10, b8, b6, b4, b2, b0] = boundSlices;
  Gates.rotate(field, rotated, excess, [b52, b40, b28, b16], [b14, b12, b10, b8, b6, b4, b2, b0], big2PowerRot);
  rangeCheck64(shifted);
  return [rotated, excess, shifted];
}
function rightShift64(field, bits) {
  assert3(bits >= 0 && bits <= 64, `rightShift: expected bits to be between 0 and 64, got ${bits}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << 64n, `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Fp.rightShift(field.toBigInt(), bits));
  }
  const [, excess] = rot64(field, bits, "right");
  return excess;
}
function leftShift64(field, bits) {
  assert3(bits >= 0 && bits <= 64, `rightShift: expected bits to be between 0 and 64, got ${bits}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << 64n, `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Fp.leftShift(field.toBigInt(), bits));
  }
  const [, , shifted] = rot64(field, bits, "left");
  return shifted;
}
function leftShift32(field, bits) {
  let { remainder: shifted } = divMod32(field.mul(1n << BigInt(bits)));
  return shifted;
}
function validateBitLength(length, maxLength, functionName) {
  assert3(length > 0, `${functionName}: Input length must be a positive value.`);
  assert3(length <= maxLength, `${functionName}: Length ${length} exceeds maximum of ${maxLength} bits.`);
}

// dist/node/lib/provable/int.js
var import_tslib3 = require("tslib");

// dist/node/lib/provable/types/circuit-value.js
var import_reflect_metadata = require("reflect-metadata");
var CircuitValue = class {
  constructor(...props) {
    if (props.length === 0)
      return;
    let fields2 = this.constructor.prototype._fields;
    if (fields2 === void 0)
      return;
    if (props.length !== fields2.length) {
      throw Error(`${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields2.length}`);
    }
    for (let i = 0; i < fields2.length; ++i) {
      let [key] = fields2[i];
      this[key] = props[i];
    }
  }
  static fromObject(value) {
    return Object.assign(Object.create(this.prototype), value);
  }
  static sizeInFields() {
    const fields2 = this.prototype._fields;
    return fields2.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
  }
  static toFields(v) {
    const res = [];
    const fields2 = this.prototype._fields;
    if (fields2 === void 0 || fields2 === null) {
      return res;
    }
    for (let i = 0, n = fields2.length; i < n; ++i) {
      const [key, propType] = fields2[i];
      const subElts = propType.toFields(v[key]);
      subElts.forEach((x) => res.push(x));
    }
    return res;
  }
  static toAuxiliary() {
    return [];
  }
  static toInput(v) {
    let input = { fields: [], packed: [] };
    let fields2 = this.prototype._fields;
    if (fields2 === void 0)
      return input;
    for (let i = 0, n = fields2.length; i < n; ++i) {
      let [key, type] = fields2[i];
      if ("toInput" in type) {
        input = HashInput.append(input, type.toInput(v[key]));
        continue;
      }
      let xs = type.toFields(v[key]);
      input.fields.push(...xs);
    }
    return input;
  }
  toFields() {
    return this.constructor.toFields(this);
  }
  static toValue(v) {
    const res = {};
    let fields2 = this.prototype._fields ?? [];
    fields2.forEach(([key, propType]) => {
      res[key] = propType.toValue(v[key]);
    });
    return res;
  }
  static fromValue(value) {
    let props = {};
    let fields2 = this.prototype._fields ?? [];
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw Error(`${this.name}.fromValue(): invalid input ${value}`);
    }
    for (let i = 0; i < fields2.length; ++i) {
      let [key, propType] = fields2[i];
      if (value[key] === void 0) {
        throw Error(`${this.name}.fromValue(): invalid input ${value}`);
      } else {
        props[key] = propType.fromValue(value[key]);
      }
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
  toConstant() {
    return this.constructor.toConstant(this);
  }
  equals(x) {
    return Provable.equal(this, x);
  }
  assertEquals(x) {
    Provable.assertEqual(this, x);
  }
  isConstant() {
    return this.toFields().every((x) => x.isConstant());
  }
  static fromFields(xs) {
    const fields2 = this.prototype._fields;
    if (xs.length < fields2.length) {
      throw Error(`${this.name}.fromFields: Expected ${fields2.length} field elements, got ${xs?.length}`);
    }
    let offset = 0;
    const props = {};
    for (let i = 0; i < fields2.length; ++i) {
      const [key, propType] = fields2[i];
      const propSize = propType.sizeInFields();
      const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);
      props[key] = propVal;
      offset += propSize;
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static check(v) {
    const fields2 = this.prototype._fields;
    if (fields2 === void 0 || fields2 === null) {
      return;
    }
    for (let i = 0; i < fields2.length; ++i) {
      const [key, propType] = fields2[i];
      const value = v[key];
      if (propType.check === void 0)
        throw Error("bug: CircuitValue without .check()");
      propType.check(value);
    }
  }
  static toConstant(t) {
    const xs = this.toFields(t);
    return this.fromFields(xs.map((x) => x.toConstant()));
  }
  static toJSON(v) {
    const res = {};
    if (this.prototype._fields !== void 0) {
      const fields2 = this.prototype._fields;
      fields2.forEach(([key, propType]) => {
        res[key] = propType.toJSON(v[key]);
      });
    }
    return res;
  }
  static fromJSON(value) {
    let props = {};
    let fields2 = this.prototype._fields;
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
    }
    if (fields2 !== void 0) {
      for (let i = 0; i < fields2.length; ++i) {
        let [key, propType] = fields2[i];
        if (value[key] === void 0) {
          throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
        } else {
          props[key] = propType.fromJSON(value[key]);
        }
      }
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static empty() {
    const fields2 = this.prototype._fields ?? [];
    let props = {};
    fields2.forEach(([key, propType]) => {
      props[key] = propType.empty();
    });
    return Object.assign(Object.create(this.prototype), props);
  }
};
function prop(target, key) {
  const fieldType = Reflect.getMetadata("design:type", target, key);
  if (!target.hasOwnProperty("_fields")) {
    target._fields = [];
  }
  if (fieldType === void 0) {
  } else if (fieldType.toFields && fieldType.fromFields) {
    target._fields.push([key, fieldType]);
  } else {
    console.log(`warning: property ${key} missing field element conversion methods`);
  }
}
function arrayProp(elementType, length) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([key, Provable.Array(elementType, length)]);
  };
}

// dist/node/lib/provable/int.js
var UInt642 = class _UInt64 extends CircuitValue {
  /**
   * Create a {@link UInt64}.
   * The max value of a {@link UInt64} is `2^64 - 1 = UInt64.MAXINT()`.
   *
   * **Warning**: Cannot overflow, an error is thrown if the result is greater than UInt64.MAXINT()
   */
  constructor(x) {
    if (x instanceof _UInt64 || x instanceof UInt322)
      x = x.value.value;
    let value = Field4(x);
    super(value);
    _UInt64.checkConstant(value);
  }
  /**
   * Static method to create a {@link UInt64} with value `0`.
   */
  static get zero() {
    return new _UInt64(0);
  }
  /**
   * Static method to create a {@link UInt64} with value `1`.
   */
  static get one() {
    return new _UInt64(1);
  }
  /**
   * Turns the {@link UInt64} into a string.
   * @returns
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt64} into a {@link BigInt}.
   * @returns
   */
  toBigInt() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.
   */
  toUInt32() {
    let uint322 = new UInt322(this.value.value);
    UInt322.check(uint322);
    return uint322;
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, clamping to the 32 bits range if it's too large.
   * ```ts
   * UInt64.from(4294967296).toUInt32Clamped().toString(); // "4294967295"
   * ```
   */
  toUInt32Clamped() {
    let max2 = (1n << 32n) - 1n;
    let field = Provable.if(this.greaterThan(_UInt64.from(max2)), Field4.from(max2), this.value);
    return UInt322.Unsafe.fromField(field);
  }
  static check(x) {
    rangeCheckN(_UInt64.NUM_BITS, x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 64]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt64: Expected number between 0 and 2^64 - 1, got ${xBig}`);
    }
    return x;
  }
  /**
   * Creates a new {@link UInt64}.
   */
  static from(x) {
    if (x instanceof _UInt64)
      return x;
    return new this(x);
  }
  /**
   * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.
   */
  static MAXINT() {
    return new _UInt64((1n << 64n) - 1n);
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt64.from(y).value;
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new _UInt64(q4),
        rest: new _UInt64(r2)
      };
    }
    y_ = y_.seal();
    let q3 = Provable.witness(Field4, () => new Field4(x.toBigInt() / y_.toBigInt()));
    rangeCheckN(_UInt64.NUM_BITS, q3);
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheckN(_UInt64.NUM_BITS, r);
    let r_ = new _UInt64(r.value);
    let q_ = new _UInt64(q3.value);
    r_.assertLessThan(new _UInt64(y_.value));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisible by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z.value);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z.value);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z.value);
  }
  /**
   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param x {@link UInt64} element to XOR.
   *
   * @example
   * ```ts
   * let a = UInt64.from(0b0101);
   * let b = UInt64.from(0b0011);
   *
   * let c = a.xor(b);
   * c.assertEquals(0b0110);
   * ```
   */
  xor(x) {
    return new _UInt64(xor2(this.value, x.value, _UInt64.NUM_BITS).value);
  }
  /**
   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate operates over 64 bit for UInt64 types.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * NOT is implemented as a subtraction of the input from the all one bitmask
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // NOTing 4 bits with the unchecked version
   * let a = UInt64.from(0b0101);
   * let b = a.not(false);
   *
   * console.log(b.toBigInt().toString(2));
   * // 1111111111111111111111111111111111111111111111111111111111111010
   *
   * ```
   *
   * @param a - The value to apply NOT to.
   *
   */
  not() {
    return new _UInt64(not(this.value, _UInt64.NUM_BITS, false).value);
  }
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param bits amount of bits to rotate this {@link UInt64} element with.
   * @param direction left or right rotation direction.
   *
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100);
   * const y = x.rotate(2, 'left');
   * const z = x.rotate(2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   * ```
   */
  rotate(bits, direction = "left") {
    return new _UInt64(rotate64(this.value, bits, direction).value);
  }
  /**
   * Performs a left shift operation on the provided {@link UInt64} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt64} element to the left. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100); // 12 in binary
   * const y = x.leftShift(2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift(bits) {
    return new _UInt64(leftShift64(this.value, bits).value);
  }
  /**
   * Performs a right shift operation on the provided {@link UInt64} element.
   * This operation is similar to the `>>` shift operation in JavaScript,
   * where bits are shifted to the right, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt64} element to the right. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100); // 12 in binary
   * const y = x.rightShift(2); // right shift by 2 bits
   * y.assertEquals(0b000011); // 3 in binary
   * ```
   */
  rightShift(bits) {
    return new _UInt64(rightShift64(this.value, bits).value);
  }
  /**
   * Bitwise AND gadget on {@link UInt64} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below.
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   *
   * @example
   * ```typescript
   * let a = UInt64.from(3);    // ... 000011
   * let b = UInt64.from(5);    // ... 000101
   *
   * let c = a.and(b);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(x) {
    return new _UInt64(and(this.value, x.value, _UInt64.NUM_BITS).value);
  }
  /**
   * Checks if a {@link UInt64} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    }
    return lessThanOrEqualGeneric(this.value, y.value, 1n << 64n, (v) => rangeCheckN(_UInt64.NUM_BITS, v));
  }
  /**
   * Asserts that a {@link UInt64} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];
      return assert(x0 <= y0, message ?? `UInt64.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
    }
    assertLessThanOrEqualGeneric(this.value, y.value, (v) => rangeCheckN(_UInt64.NUM_BITS, v, message));
  }
  /**
   *
   * Checks if a {@link UInt64} is less than another one.
   */
  lessThan(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() < y.value.toBigInt());
    }
    return lessThanGeneric(this.value, y.value, 1n << 64n, (v) => rangeCheckN(_UInt64.NUM_BITS, v));
  }
  /**
   * Asserts that a {@link UInt64} is less than another one.
   */
  assertLessThan(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];
      return assert(x0 < y0, message ?? `UInt64.assertLessThan: expected ${x0} < ${y0}`);
    }
    assertLessThanGeneric(this.value, y.value, (v) => rangeCheckN(_UInt64.NUM_BITS, v, message));
  }
  /**
   * Checks if a {@link UInt64} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * Asserts that a {@link UInt64} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Checks if a {@link UInt64} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return y.lessThanOrEqual(this);
  }
  /**
   * Asserts that a {@link UInt64} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  static toValue(x) {
    return x.value.toBigInt();
  }
  static fromValue(x) {
    return _UInt64.from(x);
  }
};
UInt642.NUM_BITS = 64;
UInt642.Unsafe = {
  /**
   * Create a {@link UInt64} from a {@link Field} without constraining its range.
   *
   * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 64 bits.\
   * Only use this if you know what you are doing, otherwise use the safe {@link UInt64.from}.
   */
  fromField(x) {
    return new UInt642(x.value);
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], UInt642.prototype, "value", void 0);
var UInt322 = class _UInt32 extends CircuitValue {
  /**
   * Create a {@link UInt32}.
   * The max value of a {@link UInt32} is `2^32 - 1 = UInt32.MAXINT()`.
   *
   * **Warning**: Cannot overflow, an error is thrown if the result is greater than UInt32.MAXINT()
   */
  constructor(x) {
    if (x instanceof _UInt32)
      x = x.value.value;
    let value = Field4(x);
    super(value);
    _UInt32.checkConstant(value);
  }
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get zero() {
    return new _UInt32(0);
  }
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get one() {
    return new _UInt32(1);
  }
  /**
   * Turns the {@link UInt32} into a string.
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt32} into a {@link BigInt}.
   */
  toBigint() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt32} into a {@link UInt64}.
   */
  toUInt64() {
    return new UInt642(this.value.value);
  }
  static check(x) {
    rangeCheck32(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 32]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt32: Expected number between 0 and 2^32 - 1, got ${xBig}`);
    }
    return x;
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link UInt32}.
   */
  static from(x) {
    if (x instanceof _UInt32)
      return x;
    return new this(x);
  }
  /**
   * Creates a {@link UInt32} with a value of 4,294,967,295.
   */
  static MAXINT() {
    return new _UInt32((1n << 32n) - 1n);
  }
  /**
   * Addition modulo 2^32. Check {@link Gadgets.addMod32} for a detailed description.
   */
  addMod32(y) {
    return new _UInt32(addMod32(this.value, y.value).value);
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt32.from(y).value;
    if (x.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new _UInt32(new Field4(q4.toString()).value),
        rest: new _UInt32(new Field4(r2.toString()).value)
      };
    }
    y_ = y_.seal();
    let q3 = Provable.witness(Field4, () => new Field4(x.toBigInt() / y_.toBigInt()));
    rangeCheck32(q3);
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheck32(r);
    let r_ = new _UInt32(r.value);
    let q_ = new _UInt32(q3.value);
    r_.assertLessThan(new _UInt32(y_.value));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `x * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisible by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z.value);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z.value);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z.value);
  }
  /**
   * Bitwise XOR gadget on {@link UInt32} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param x {@link UInt32} element to compare.
   *
   * @example
   * ```ts
   * let a = UInt32.from(0b0101);
   * let b = UInt32.from(0b0011);
   *
   * let c = a.xor(b);
   * c.assertEquals(0b0110);
   * ```
   */
  xor(x) {
    return new _UInt32(xor2(this.value, x.value, _UInt32.NUM_BITS).value);
  }
  /**
   * Bitwise NOT gate on {@link UInt32} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate operates over 32 bit for UInt32 types.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * NOT is implemented as a subtraction of the input from the all one bitmask.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // NOTing 4 bits with the unchecked version
   * let a = UInt32.from(0b0101);
   * let b = a.not();
   *
   * console.log(b.toBigInt().toString(2));
   * // 11111111111111111111111111111010
   * ```
   *
   * @param a - The value to apply NOT to.
   */
  not() {
    return new _UInt32(not(this.value, _UInt32.NUM_BITS, false).value);
  }
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param bits amount of bits to rotate this {@link UInt32} element with.
   * @param direction left or right rotation direction.
   *
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100);
   * const y = x.rotate(2, 'left');
   * const z = x.rotate(2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   * ```
   */
  rotate(bits, direction = "left") {
    return new _UInt32(rotate32(this.value, bits, direction).value);
  }
  /**
   * Performs a left shift operation on the provided {@link UInt32} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * The operation expects the input to be range checked to 32 bit.
   *
   * @param bits Amount of bits to shift the {@link UInt32} element to the left. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100); // 12 in binary
   * const y = x.leftShift(2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift(bits) {
    return new _UInt32(leftShift32(this.value, bits).value);
  }
  /**
   * Performs a left right operation on the provided {@link UInt32} element.
   * This operation is similar to the `>>` shift operation in JavaScript,
   * where bits are shifted to the right, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt32} element to the right. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * The operation expects the input to be range checked to 32 bit.
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100); // 12 in binary
   * const y = x.rightShift(2); // left shift by 2 bits
   * y.assertEquals(0b000011); // 48 in binary
   * ```
   */
  rightShift(bits) {
    return new _UInt32(rightShift64(this.value, bits).value);
  }
  /**
   * Bitwise AND gadget on {@link UInt32} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below.
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   *
   * @example
   * ```typescript
   * let a = UInt32.from(3);    // ... 000011
   * let b = UInt32.from(5);    // ... 000101
   *
   * let c = a.and(b, 2);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(x) {
    return new _UInt32(and(this.value, x.value, _UInt32.NUM_BITS).value);
  }
  /**
   * Checks if a {@link UInt32} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    }
    return lessThanOrEqualGeneric(this.value, y.value, 1n << 32n, (v) => rangeCheckN(_UInt32.NUM_BITS, v));
  }
  /**
   * Asserts that a {@link UInt32} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];
      return assert(x0 <= y0, message ?? `UInt32.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
    }
    assertLessThanOrEqualGeneric(this.value, y.value, (v) => rangeCheckN(_UInt32.NUM_BITS, v, message));
  }
  /**
   * Checks if a {@link UInt32} is less than another one.
   */
  lessThan(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() < y.value.toBigInt());
    }
    return lessThanGeneric(this.value, y.value, 1n << 64n, (v) => rangeCheckN(UInt642.NUM_BITS, v));
  }
  /**
   * Asserts that a {@link UInt32} is less than another one.
   */
  assertLessThan(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];
      return assert(x0 < y0, message ?? `UInt32.assertLessThan: expected ${x0} < ${y0}`);
    }
    assertLessThanGeneric(this.value, y.value, (v) => rangeCheckN(_UInt32.NUM_BITS, v, message));
  }
  /**
   * Checks if a {@link UInt32} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * Asserts that a {@link UInt32} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Checks if a {@link UInt32} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return y.lessThanOrEqual(this);
  }
  /**
   * Asserts that a {@link UInt32} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  static toValue(x) {
    return x.value.toBigInt();
  }
  static fromValue(x) {
    return _UInt32.from(x);
  }
};
UInt322.NUM_BITS = 32;
UInt322.Unsafe = {
  /**
   * Create a {@link UInt32} from a {@link Field} without constraining its range.
   *
   * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 32 bits.\
   * Only use this if you know what you are doing, otherwise use the safe {@link UInt32.from}.
   */
  fromField(x) {
    return new UInt322(x.value);
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], UInt322.prototype, "value", void 0);
var Sign3 = class _Sign extends CircuitValue {
  static get one() {
    return new _Sign(Field4(1));
  }
  static get minusOne() {
    return new _Sign(Field4(-1));
  }
  static check(x) {
    x.value.square().assertEquals(1);
  }
  static empty() {
    return _Sign.one;
  }
  static toInput(x) {
    return { packed: [[x.isPositive().toField(), 1]] };
  }
  static toJSON(x) {
    if (x.toString() === "1")
      return "Positive";
    if (x.neg().toString() === "1")
      return "Negative";
    throw Error(`Invalid Sign: ${x}`);
  }
  static fromJSON(x) {
    return x === "Positive" ? new _Sign(Field4(1)) : new _Sign(Field4(-1));
  }
  neg() {
    return new _Sign(this.value.neg());
  }
  mul(y) {
    return new _Sign(this.value.mul(y.value));
  }
  isPositive() {
    return this.value.equals(1);
  }
  isNegative() {
    return this.value.equals(-1);
  }
  toString() {
    return this.value.toString();
  }
  static toValue(x) {
    return x.value.toBigInt();
  }
  static fromValue(x) {
    if (x instanceof _Sign)
      return x;
    return new _Sign(Field4(x));
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], Sign3.prototype, "value", void 0);
var Int64 = class _Int64 extends CircuitValue {
  // Some thoughts regarding the representation as field elements:
  // toFields returns the in-circuit representation, so the main objective is to minimize the number of constraints
  // that result from this representation. Therefore, I think the only candidate for an efficient 1-field representation
  // is the one where the Int64 is the field: toFields = Int64 => [Int64.magnitude.mul(Int64.sign)]. Anything else involving
  // bit packing would just lead to very inefficient circuit operations.
  //
  // So, is magnitude * sign ("1-field") a more efficient representation than (magnitude, sign) ("2-field")?
  // Several common operations like add, mul, etc, operate on 1-field so in 2-field they result in one additional multiplication
  // constraint per operand. However, the check operation (constraining to 64 bits + a sign) which is called at the introduction
  // of every witness, and also at the end of add, mul, etc, operates on 2-field. So here, the 1-field representation needs
  // to add an additional magnitude * sign = Int64 multiplication constraint, which will typically cancel out most of the gains
  // achieved by 1-field elsewhere.
  // There are some notable operations for which 2-field is definitely better:
  //
  // * div and mod (which do integer division with rounding on the magnitude)
  // * converting the Int64 to a Currency.Amount.Signed (for the zkapp balance), which has the exact same (magnitude, sign) representation we use here.
  //
  // The second point is one of the main things an Int64 is used for, and was the original motivation to use 2 fields.
  // Overall, I think the existing implementation is the optimal one.
  /**
   * @deprecated Use {@link Int64.create} for safe creation.
   *
   * WARNING: This constructor allows for ambiguous representation of zero (both +0 and -0).
   * This can lead to unexpected behavior in operations like {@link isPositive()} and {@link mod()}.
   *
   * Security Implications:
   * 1. A malicious prover could choose either positive or negative zero.
   * 2. Arithmetic operations that result in 0 may allow an attacker to arbitrarily choose the sign.
   * 3. This ambiguity could be exploited in protocols using Int64s for calculations like PNL tracking.
   *
   * Recommended Fix:
   * Use Int64.create() which enforces a canonical representation of zero, or
   * explicitly handle the zero case in operations like mod().
   *
   * @param magnitude - The magnitude of the integer as a UInt64.
   * @param [sgn=Sign.one] - The sign of the integer. Default is positive (Sign.one).
   */
  constructor(magnitude, sgn = Sign3.one) {
    super(magnitude, sgn);
  }
  /**
   * Safely creates a new Int64 instance, enforcing canonical representation of zero.
   * This is the recommended way to create Int64 instances.
   *
   * @param magnitude - The magnitude of the integer as a UInt64
   * @param sgn - The sign of the integer.
   * @returns A new Int64 instance with a canonical representation.
   *
   * @example
   * ```ts
   * const x = Int64.create(0); // canonical representation of zero
   * ```
   */
  static create(magnitude, sign3 = Sign3.one) {
    const mag = UInt642.from(magnitude);
    const isZero = mag.equals(UInt642.zero);
    const canonicalSign = Provable.if(isZero, Sign3.one, sign3);
    return new _Int64(mag, canonicalSign);
  }
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * Does check if the {@link Field} is within range.
   */
  static fromFieldUnchecked(x) {
    let TWO64 = 1n << 64n;
    let xBigInt = x.toBigInt();
    let isValidPositive = xBigInt < TWO64;
    let isValidNegative = Field4.ORDER - xBigInt < TWO64;
    if (!isValidPositive && !isValidNegative)
      throw Error(`Int64: Expected a value between (-2^64, 2^64), got ${x}`);
    let magnitude = (isValidPositive ? x : x.neg()).toConstant();
    let sign3 = isValidPositive ? Sign3.one : Sign3.minusOne;
    return new _Int64(UInt642.Unsafe.fromField(magnitude), sign3);
  }
  // this doesn't check ranges because we assume they're already checked on UInts
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * **Does not** check if the {@link Field} is within range.
   */
  static fromUnsigned(x) {
    return new _Int64(x instanceof UInt322 ? x.toUInt64() : x);
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link Int64}.
   *
   * Check the range if the argument is a constant.
   */
  static from(x) {
    if (x instanceof _Int64)
      return x;
    if (x instanceof UInt642 || x instanceof UInt322) {
      return _Int64.fromUnsigned(x);
    }
    return _Int64.fromFieldUnchecked(Field4(x));
  }
  fromObjectV2(obj) {
    return _Int64.create(UInt642.from(obj.magnitude), Sign3.fromValue(obj.sgn));
  }
  /**
   * Turns the {@link Int64} into a string.
   */
  toString() {
    let abs2 = this.magnitude.toString();
    let sgn = this.isPositive().toBoolean() || abs2 === "0" ? "" : "-";
    return sgn + abs2;
  }
  isConstant() {
    return this.magnitude.value.isConstant() && this.sgn.isConstant();
  }
  // --- circuit-compatible operations below ---
  // the assumption here is that all Int64 values that appear in a circuit are already checked as valid
  // this is because Provable.witness calls .check, which calls .check on each prop, i.e. UInt64 and Sign
  // so we only have to do additional checks if an operation on valid inputs can have an invalid outcome (example: overflow)
  /**
   * Static method to create a {@link Int64} with value `0`.
   */
  static get zero() {
    return new _Int64(UInt642.zero);
  }
  /**
   * Static method to create a {@link Int64} with value `1`.
   */
  static get one() {
    return new _Int64(UInt642.one);
  }
  /**
   * Static method to create a {@link Int64} with value `-1`.
   */
  static get minusOne() {
    return new _Int64(UInt642.one).neg();
  }
  /**
   * Returns the {@link Field} value.
   */
  toField() {
    return this.magnitude.value.mul(this.sgn.value);
  }
  /**
   * Static method to create a {@link Int64} from a {@link Field}.
   */
  static fromField(x) {
    if (x.isConstant())
      return _Int64.fromFieldUnchecked(x);
    let xInt = Provable.witness(_Int64, () => _Int64.fromFieldUnchecked(x));
    xInt.toField().assertEquals(x);
    return xInt;
  }
  /**
   * @deprecated Use {@link negV2()} instead.
   * The current implementation will not be backwards-compatible with v2.
   */
  neg() {
    return new _Int64(this.magnitude, this.sgn.neg());
  }
  /**
   * Negates the current Int64 value.
   *
   * This method returns a new Int64 instance with the opposite sign of the current value.
   * If the current value is zero, it returns zero.
   *
   * @returns A new Int64 instance with the negated value.
   *
   * @example
   * ```ts
   * Int64.from(5).negV2();
   * ```
   *
   * @see {@link Int64#from} for creating Int64 instances
   * @see {@link Int64#zero} for the zero constant
   *
   * @throws {Error} Implicitly, if the internal Provable.if condition fails
   */
  negV2() {
    return Provable.if(this.magnitude.value.equals(0), _Int64.zero, new _Int64(this.magnitude, this.sgn.neg()));
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().add(y_.toField()));
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().sub(y_.toField()));
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().mul(y_.toField()));
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   * On negative numbers, this rounds towards zero.
   */
  div(y) {
    let y_ = _Int64.from(y);
    let { quotient } = this.magnitude.divMod(y_.magnitude);
    let sign3 = this.sgn.mul(y_.sgn);
    return new _Int64(quotient, sign3);
  }
  /**
   * Integer division with canonical zero representation.
   *
   * @param y - The divisor. Can be an Int64, number, string, bigint, UInt64, or UInt32.
   * @returns A new Int64 representing the quotient, with canonical zero representation.
   *
   * @remarks
   * This method performs the same division operation as {@link div},
   * but ensures that the result always has a canonical representation,
   * particularly for zero results.
   *
   * `x.divV2(y)` returns the floor of `x / y`, that is, the greatest
   * *`z`* such that *`z * y <= x`.
   * On negative numbers, this rounds towards zero.
   *
   * This method guarantees that all results, including zero, have a consistent
   * representation, eliminating potential ambiguities in zero handling.
   */
  divV2(y) {
    let y_ = _Int64.from(y);
    let { quotient } = this.magnitude.divMod(y_.magnitude);
    let sign3 = this.sgn.mul(y_.sgn);
    return _Int64.create(quotient, sign3);
  }
  /**
   * @deprecated Use {@link modV2()} instead.
   * This implementation is vulnerable whenever `this` is zero.
   * It allows the prover to return `y` instead of 0 as the result.
   */
  mod(y) {
    let y_ = UInt642.from(y);
    let rest = this.magnitude.divMod(y_).rest.value;
    rest = Provable.if(this.isPositive(), rest, y_.value.sub(rest));
    return new _Int64(new UInt642(rest.value));
  }
  /**
   * Calculates the integer remainder of this Int64 divided by the given value.
   *
   * The result `z` satisfies the following conditions:
   * 1. 0 <= z < |y|
   * 2. x - z is divisible by y
   *
   * Note: This method follows the "truncate toward zero" convention for negative numbers.
   *
   * @param y - The divisor. Will be converted to UInt64 if not already.
   * @returns A new Int64 instance representing the remainder.
   *
   * @example
   * ```ts
   * const x1 = Int64.from(17);
   * const y1 = UInt64.from(5);
   * console.log(x1.modV2(y1).toString()); // Output: 2
   * ```
   *
   * @throws {Error} Implicitly, if y is zero or negative.
   */
  modV2(y) {
    let y_ = UInt642.from(y);
    let rest = this.magnitude.divMod(y_).rest.value;
    let isNonNegative = this.magnitude.equals(UInt642.zero).or(this.sgn.isPositive());
    rest = Provable.if(isNonNegative, rest, y_.value.sub(rest));
    return new _Int64(new UInt642(rest.value));
  }
  /**
   * Checks if two values are equal.
   */
  equals(y) {
    let y_ = _Int64.from(y);
    return this.toField().equals(y_.toField());
  }
  /**
   * Asserts that two values are equal.
   */
  assertEquals(y, message) {
    let y_ = _Int64.from(y);
    this.toField().assertEquals(y_.toField(), message);
  }
  /**
   * @deprecated Use {@link isPositiveV2} instead.
   * The current implementation actually tests for non-negativity, but is wrong for the negative representation of 0.
   */
  isPositive() {
    return this.sgn.isPositive();
  }
  /**
   * Checks if the value is strictly positive (x > 0).
   *
   * @returns True if the value is greater than zero, false otherwise.
   *
   * @remarks
   * This method considers zero as non-positive. It ensures consistency
   * with the mathematical definition of "positive" as strictly greater than zero.
   * This differs from some other methods which may treat zero as non-negative.
   */
  isPositiveV2() {
    return this.magnitude.equals(UInt642.zero).not().and(this.sgn.isPositive());
  }
  // TODO add this when `checkV2` is enabled
  // then it will be the correct logic; right now it would be misleading
  /**
   * Checks if the value is non-negative (x >= 0).
   */
  // isNonNegativeV2() {
  //   return this.sgn.isPositive();
  // }
  // TODO add this when `checkV2` is enabled
  // then it will be the correct logic; right now it would be misleading
  /**
   * Checks if the value is negative (x < 0).
   */
  // isNegative() {
  //   return this.sgn.isNegative();
  // }
  // TODO enable this check method in v2, to force a unique representation of 0
  static checkV2({ magnitude, sgn }) {
    UInt642.check(magnitude);
    Sign3.check(sgn);
    magnitude.value.add(sgn.value).assertNotEquals(-1, "Int64: 0 must have positive sign");
  }
};
Int64.Unsafe = {
  /**
   * @deprecated Use {@link Int64.fromObjectV2} instead.
   */
  fromObject(obj) {
    return CircuitValue.fromObject.call(Int64, obj);
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", UInt642)
], Int64.prototype, "magnitude", void 0);
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Sign3)
], Int64.prototype, "sgn", void 0);
var UInt8 = class _UInt8 extends Struct({
  value: Field4
}) {
  /**
   * Create a {@link UInt8} from a bigint or number.
   * The max value of a {@link UInt8} is `2^8 - 1 = 255`.
   *
   * **Warning**: Cannot overflow past 255, an error is thrown if the result is greater than 255.
   */
  constructor(x) {
    if (x instanceof _UInt8)
      x = x.value.value;
    super({ value: Field4(x) });
    _UInt8.checkConstant(this.value);
  }
  /**
   * Add a {@link UInt8} to another {@link UInt8} without allowing overflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(3);
   * const sum = x.add(5);
   * sum.assertEquals(8);
   * ```
   *
   * @throws if the result is greater than 255.
   */
  add(y) {
    let z = this.value.add(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Subtract a {@link UInt8} from another {@link UInt8} without allowing underflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(8);
   * const difference = x.sub(5);
   * difference.assertEquals(3);
   * ```
   *
   * @throws if the result is less than 0.
   */
  sub(y) {
    let z = this.value.sub(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Multiply a {@link UInt8} by another {@link UInt8} without allowing overflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(3);
   * const product = x.mul(5);
   * product.assertEquals(15);
   * ```
   *
   * @throws if the result is greater than 255.
   */
  mul(y) {
    let z = this.value.mul(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Divide a {@link UInt8} by another {@link UInt8}.
   * This is integer division that rounds down.
   *
   * @example
   * ```ts
   * const x = UInt8.from(7);
   * const quotient = x.div(2);
   * quotient.assertEquals(3);
   * ```
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Get the remainder a {@link UInt8} of division of another {@link UInt8}.
   *
   * @example
   * ```ts
   * const x = UInt8.from(50);
   * const mod = x.mod(30);
   * mod.assertEquals(20);
   * ```
   */
  mod(y) {
    return this.divMod(y).remainder;
  }
  /**
   * Get the quotient and remainder of a {@link UInt8} divided by another {@link UInt8}:
   *
   * `x == y * q + r`, where `0 <= r < y`.
   *
   * @param y - a {@link UInt8} to get the quotient and remainder of another {@link UInt8}.
   *
   * @return The quotient `q` and remainder `r`.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt8.from(y).value.seal();
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return { quotient: _UInt8.from(q4), remainder: _UInt8.from(r2) };
    }
    let q3 = Provable.witness(Field4, () => Field4(x.toBigInt() / y_.toBigInt()));
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheck16(q3);
    rangeCheck16(r);
    let remainder = _UInt8.Unsafe.fromField(r);
    let quotient = _UInt8.Unsafe.fromField(q3);
    remainder.assertLessThan(y);
    return { quotient, remainder };
  }
  /**
   * Check if this {@link UInt8} is less than or equal to another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * UInt8.from(3).lessThanOrEqual(UInt8.from(5));
   * ```
   */
  lessThanOrEqual(y) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      return Bool4(this.toBigInt() <= y_.toBigInt());
    }
    return lessThanOrEqualGeneric(this.value, y_.value, 1n << 8n, rangeCheck8);
  }
  /**
   * Check if this {@link UInt8} is less than another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * UInt8.from(2).lessThan(UInt8.from(3));
   * ```
   */
  lessThan(y) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      return Bool4(this.toBigInt() < y_.toBigInt());
    }
    return lessThanGeneric(this.value, y_.value, 1n << 8n, rangeCheck8);
  }
  /**
   * Assert that this {@link UInt8} is less than another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThan(y, message) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y_.value.toBigInt()];
      return assert(x0 < y0, message ?? `UInt8.assertLessThan: expected ${x0} < ${y0}`);
    }
    try {
      assertLessThanGeneric(this.value, y_.value, rangeCheck16);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Assert that this {@link UInt8} is less than or equal to another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThanOrEqual(y, message) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      let [x0, y0] = [this.value.toBigInt(), y_.value.toBigInt()];
      return assert(x0 <= y0, message ?? `UInt8.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
    }
    try {
      assertLessThanOrEqualGeneric(this.value, y_.value, rangeCheck16);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Check if this {@link UInt8} is greater than another {@link UInt8}.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * // 5 > 3
   * UInt8.from(5).greaterThan(3);
   * ```
   */
  greaterThan(y) {
    return _UInt8.from(y).lessThan(this);
  }
  /**
   * Check if this {@link UInt8} is greater than or equal another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * // 3 >= 3
   * UInt8.from(3).greaterThanOrEqual(3);
   * ```
   */
  greaterThanOrEqual(y) {
    return _UInt8.from(y).lessThanOrEqual(this);
  }
  /**
   * Assert that this {@link UInt8} is greater than another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThan(y, message) {
    _UInt8.from(y).assertLessThan(this, message);
  }
  /**
   * Assert that this {@link UInt8} is greater than or equal to another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThanOrEqual(y, message) {
    _UInt8.from(y).assertLessThanOrEqual(this, message);
  }
  /**
   * Assert that this {@link UInt8} is equal another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertEquals(y, message) {
    let y_ = _UInt8.from(y);
    this.value.assertEquals(y_.value, message);
  }
  /**
   * Serialize the {@link UInt8} to a string, e.g. for printing.
   *
   * **Warning**: This operation is not provable.
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Serialize the {@link UInt8} to a number.
   *
   * **Warning**: This operation is not provable.
   */
  toNumber() {
    return Number(this.value.toBigInt());
  }
  /**
   * Serialize the {@link UInt8} to a bigint.
   *
   * **Warning**: This operation is not provable.
   */
  toBigInt() {
    return this.value.toBigInt();
  }
  /**
   * {@link Provable.check} for {@link UInt8}.
   * Proves that the input is in the [0, 255] range.
   */
  static check(x) {
    if (x instanceof Field4)
      x = { value: x };
    rangeCheck8(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 8]] };
  }
  /**
   * Turns a {@link UInt8} into a {@link UInt32}.
   */
  toUInt32() {
    return new UInt322(this.value.value);
  }
  /**
   * Turns a {@link UInt8} into a {@link UInt64}.
   */
  toUInt64() {
    return new UInt642(this.value.value);
  }
  /**
   * Creates a {@link UInt8} with a value of 255.
   */
  static MAXINT() {
    return new _UInt8((1n << BigInt(_UInt8.NUM_BITS)) - 1n);
  }
  /**
   * Creates a new {@link UInt8}.
   */
  static from(x) {
    if (x instanceof _UInt8)
      return x;
    if (x instanceof UInt642 || x instanceof UInt322 || x instanceof Field4) {
      let xx = x instanceof Field4 ? { value: x } : x;
      _UInt8.check(xx);
      return new _UInt8(xx.value.value);
    }
    return new _UInt8(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return;
    rangeCheck8(x);
  }
};
UInt8.NUM_BITS = 8;
UInt8.Unsafe = {
  /**
   * Create a {@link UInt8} from a {@link Field} without constraining its range.
   *
   * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 8 bits.\
   * Only use this if you know what you are doing, otherwise use the safe {@link UInt8.from}.
   */
  fromField(x) {
    return new UInt8(x.value);
  }
};

// dist/node/lib/util/arrays.js
function chunk(array, size) {
  assert2(array.length % size === 0, "invalid input length");
  return Array.from({ length: array.length / size }, (_, i) => array.slice(size * i, size * (i + 1)));
}
function chunkString(str, size) {
  return chunk([...str], size).map((c) => c.join(""));
}

// dist/node/lib/provable/bytes.js
var Bytes = class _Bytes {
  constructor(bytes) {
    let size = this.constructor.size;
    assert3(bytes.length <= size, `Expected at most ${size} bytes, got ${bytes.length}`);
    let padding2 = Array.from({ length: size - bytes.length }, () => new UInt8(0));
    this.bytes = bytes.concat(padding2);
  }
  /**
   * Coerce the input to {@link Bytes}.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static from(data) {
    if (data instanceof _Bytes)
      return data;
    if (this._size === void 0) {
      let Bytes_ = createBytes(data.length);
      return Bytes_.from(data);
    }
    return new this([...data].map(UInt8.from));
  }
  toBytes() {
    return Uint8Array.from(this.bytes.map((x) => x.toNumber()));
  }
  toFields() {
    return this.bytes.map((x) => x.value);
  }
  /**
   * Create {@link Bytes} from a string.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static fromString(s) {
    let bytes = new TextEncoder().encode(s);
    return this.from(bytes);
  }
  /**
   * Create random {@link Bytes} using secure builtin randomness.
   */
  static random() {
    let bytes = randomBytes(this.size);
    return this.from(bytes);
  }
  /**
   * Create {@link Bytes} from a hex string.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static fromHex(xs) {
    let bytes = chunkString(xs, 2).map((s) => parseInt(s, 16));
    return this.from(bytes);
  }
  /**
   * Convert {@link Bytes} to a hex string.
   */
  toHex() {
    return this.bytes.map((x) => x.toBigInt().toString(16).padStart(2, "0")).join("");
  }
  /**
   * Base64 encode bytes.
   */
  base64Encode() {
    const uint8Bytes = this.bytes;
    let plainBits = uint8Bytes.map((b2) => b2.value.toBits(8).reverse()).flat();
    const bitPadding = plainBits.length % 6 !== 0 ? 6 - plainBits.length % 6 : 0;
    plainBits.push(...Array(bitPadding).fill(new Bool3(false)));
    let encodedBytes = [];
    for (let i = 0; i < plainBits.length; i += 6) {
      let byteBits = plainBits.slice(i, i + 6).reverse();
      const indexTableByte = UInt8.Unsafe.fromField(Field3.fromBits(byteBits));
      encodedBytes.push(base64EncodeLookup(indexTableByte));
    }
    const paddingLength = uint8Bytes.length % 3 !== 0 ? 3 - uint8Bytes.length % 3 : 0;
    encodedBytes.push(...Array(paddingLength).fill(UInt8.from(61)));
    return _Bytes.from(encodedBytes);
  }
  /**
   * Decode Base64-encoded bytes.
   *
   * @param byteLength The length of the output decoded bytes.
   * @returns Decoded bytes as {@link Bytes}.
   *
   * @warning
   * Ensure the input Base64 string does not contain '=' characters in the middle,
   * as it can cause unexpected decoding results.
   */
  base64Decode(byteLength) {
    const encodedB64Bytes = this.bytes;
    const charLength = encodedB64Bytes.length;
    assert3(charLength % 4 === 0, "Input base64 byte length should be a multiple of 4!");
    let decodedB64Bytes = new Array(byteLength).fill(UInt8.from(0));
    let bitsIn = Array.from({ length: charLength / 4 }, () => []);
    let bitsOut = Array.from({ length: charLength / 4 }, () => Array.from({ length: 4 }, () => []));
    let idx = 0;
    for (let i = 0; i < charLength / 4; i++) {
      for (let j = 0; j < 4; j++) {
        const translated = base64DecodeLookup(encodedB64Bytes[4 * i + j]);
        bitsIn[i][j] = translated.toBits(6);
      }
      bitsOut[i][0] = [bitsIn[i][1][4], bitsIn[i][1][5], ...bitsIn[i][0]];
      for (let j = 0; j < 4; j++) {
        bitsOut[i][1][j] = bitsIn[i][2][j + 2];
        bitsOut[i][1][j + 4] = bitsIn[i][1][j];
      }
      bitsOut[i][2] = [...bitsIn[i][3], bitsIn[i][2][0], bitsIn[i][2][1]];
      for (let j = 0; j < 3; j++) {
        if (idx + j < byteLength) {
          decodedB64Bytes[idx + j] = UInt8.Unsafe.fromField(Field3.fromBits(bitsOut[i][j]));
        }
      }
      idx += 3;
    }
    return _Bytes.from(decodedB64Bytes);
  }
  /**
   * The size of the {@link Bytes}.
   */
  static get size() {
    assert3(this._size !== void 0, "Bytes not initialized");
    return this._size;
  }
  get length() {
    return this.bytes.length;
  }
  /**
   * `Provable<Bytes>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "Bytes not initialized");
    return this._provable;
  }
};
function createBytes(size) {
  var _a2;
  return _a2 = class Bytes_ extends Bytes {
  }, _a2._size = size, _a2._provable = provableFromClass(_a2, {
    bytes: Provable.Array(UInt8, size)
  }), _a2;
}
function base64DecodeLookup(input) {
  let isValidBase64Chars = new Field3(0);
  const le_Z = input.lessThan(91);
  const ge_A = input.greaterThan(64);
  const range_AZ = le_Z.and(ge_A);
  const sum_AZ = range_AZ.toField().mul(input.value.sub(65));
  isValidBase64Chars = isValidBase64Chars.add(range_AZ.toField());
  const le_z = input.lessThan(123);
  const ge_a = input.greaterThan(96);
  const range_az = le_z.and(ge_a);
  const sum_az = range_az.toField().mul(input.value.sub(71)).add(sum_AZ);
  isValidBase64Chars = isValidBase64Chars.add(range_az.toField());
  const le_9 = input.lessThan(58);
  const ge_0 = input.greaterThan(47);
  const range_09 = le_9.and(ge_0);
  const sum_09 = range_09.toField().mul(input.value.add(4)).add(sum_az);
  isValidBase64Chars = isValidBase64Chars.add(range_09.toField());
  const equal_plus = input.value.equals(43);
  const sum_plus = equal_plus.toField().mul(input.value.add(19)).add(sum_09);
  isValidBase64Chars = isValidBase64Chars.add(equal_plus.toField());
  const equal_slash = input.value.equals(47);
  const sum_slash = equal_slash.toField().mul(input.value.add(16)).add(sum_plus);
  isValidBase64Chars = isValidBase64Chars.add(equal_slash.toField());
  const equal_eqsign = input.value.equals(61);
  isValidBase64Chars = isValidBase64Chars.add(equal_eqsign.toField());
  isValidBase64Chars.assertEquals(1, "Please provide Base64-encoded bytes containing only alphanumeric characters and +/=");
  return sum_slash;
}
function base64EncodeLookup(input) {
  let isValidBase64Chars = new Field3(0);
  const le_Z = input.lessThanOrEqual(25);
  const range_AZ = le_Z;
  const sum_AZ = range_AZ.toField().mul(input.value.add(65));
  isValidBase64Chars = isValidBase64Chars.add(range_AZ.toField());
  const le_z = input.lessThanOrEqual(51);
  const ge_a = input.greaterThanOrEqual(26);
  const range_az = le_z.and(ge_a);
  const sum_az = range_az.toField().mul(input.value.add(71)).add(sum_AZ);
  isValidBase64Chars = isValidBase64Chars.add(range_az.toField());
  const le_9 = input.lessThanOrEqual(61);
  const ge_0 = input.greaterThanOrEqual(52);
  const range_09 = le_9.and(ge_0);
  const sum_09 = range_09.toField().mul(input.value.sub(4)).add(sum_az);
  isValidBase64Chars = isValidBase64Chars.add(range_09.toField());
  const equal_plus = input.value.equals(62);
  const sum_plus = equal_plus.toField().mul(input.value.sub(19)).add(sum_09);
  isValidBase64Chars = isValidBase64Chars.add(equal_plus.toField());
  const equal_slash = input.value.equals(63);
  const sum_slash = equal_slash.toField().mul(input.value.sub(16)).add(sum_plus);
  isValidBase64Chars = isValidBase64Chars.add(equal_slash.toField());
  isValidBase64Chars.assertEquals(1, "Invalid character detected: The input contains a byte that is not present in the BASE64 index table!");
  return UInt8.Unsafe.fromField(sum_slash);
}

// dist/node/lib/provable/wrapped-classes.js
function Bytes2(size) {
  return createBytes(size);
}
Bytes2.from = Bytes.from;
Bytes2.fromHex = Bytes.fromHex;
Bytes2.fromString = Bytes.fromString;

// dist/node/lib/provable/gadgets/bit-slices.js
function bytesToWord(wordBytes) {
  return wordBytes.reduce((acc, byte, idx) => {
    const shift = 1n << BigInt(8 * idx);
    return acc.add(byte.value.mul(shift));
  }, Field3.from(0));
}
function wordToBytes(word, bytesPerWord = 8) {
  let bytes = Provable.witness(Provable.Array(UInt8, bytesPerWord), () => {
    let w = word.toBigInt();
    return Array.from({ length: bytesPerWord }, (_, k) => UInt8.from(w >> BigInt(8 * k) & 0xffn));
  });
  bytesToWord(bytes).assertEquals(word);
  return bytes;
}
function wordsToBytes(words, bytesPerWord = 8) {
  return words.flatMap((w) => wordToBytes(w, bytesPerWord));
}
function bytesToWords(bytes, bytesPerWord = 8) {
  return chunk(bytes, bytesPerWord).map(bytesToWord);
}
function sliceField3([x0, x1, x2], { maxBits, chunkSize }) {
  let l_ = Number(l);
  assert3(maxBits <= 3 * l_, `expected max bits <= 3*${l_}, got ${maxBits}`);
  let result0 = sliceField(x0, Math.min(l_, maxBits), chunkSize);
  if (maxBits <= l_)
    return result0.chunks;
  maxBits -= l_;
  let result1 = sliceField(x1, Math.min(l_, maxBits), chunkSize, result0);
  if (maxBits <= l_)
    return result0.chunks.concat(result1.chunks);
  maxBits -= l_;
  let result2 = sliceField(x2, maxBits, chunkSize, result1);
  return result0.chunks.concat(result1.chunks, result2.chunks);
}
function sliceField(x, maxBits, chunkSize, leftover) {
  let bits = exists(maxBits, () => {
    let bits2 = bigIntToBits(x.toBigInt());
    if (bits2.length > maxBits)
      bits2 = bits2.slice(0, maxBits);
    if (bits2.length < maxBits)
      bits2 = bits2.concat(Array(maxBits - bits2.length).fill(false));
    return bits2.map(BigInt);
  });
  let chunks = [];
  let sum2 = Field3.from(0n);
  if (leftover !== void 0) {
    let { chunks: previous, leftoverSize: size } = leftover;
    let remainingChunk = Field3.from(0n);
    for (let i2 = 0; i2 < size; i2++) {
      let bit2 = bits[i2];
      bit2.assertBool();
      remainingChunk = remainingChunk.add(bit2.mul(1n << BigInt(i2)));
    }
    sum2 = remainingChunk = remainingChunk.seal();
    let chunk2 = previous[previous.length - 1];
    previous[previous.length - 1] = chunk2.add(remainingChunk.mul(1n << BigInt(chunkSize - size)));
  }
  let i = leftover?.leftoverSize ?? 0;
  for (; i < maxBits; i += chunkSize) {
    let chunk2 = Field3.from(0n);
    let size = Math.min(maxBits - i, chunkSize);
    for (let j = 0; j < size; j++) {
      let bit2 = bits[i + j];
      bit2.assertBool();
      chunk2 = chunk2.add(bit2.mul(1n << BigInt(j)));
    }
    chunk2 = chunk2.seal();
    sum2 = sum2.add(chunk2.mul(1n << BigInt(i)));
    chunks.push(chunk2);
  }
  sum2.assertEquals(x);
  let leftoverSize = i - maxBits;
  return { chunks, leftoverSize };
}

// dist/node/lib/provable/gadgets/sha256.js
var SHA256Constants = {
  // constants §4.2.2
  K: [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ],
  // initial hash values §5.3.3
  H: [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]
};
function padding(data) {
  let message = Bytes2.from(data);
  let l4 = message.length * 8;
  let k = Number(mod(448n - (BigInt(l4) + 1n), 512n));
  let lBinary = l4.toString(2);
  let paddingBits = ("1" + // append 1 bit
  "0".repeat(k) + // append k zero bits
  "0".repeat(64 - lBinary.length) + // append 64bit containing the length of the original message
  lBinary).match(/.{1,8}/g);
  let padding2 = paddingBits.map((x) => UInt8.from(BigInt("0b" + x)));
  let paddedMessage = message.bytes.concat(padding2);
  let chunks = [];
  for (let i = 0; i < paddedMessage.length; i += 4) {
    chunks.push(UInt322.Unsafe.fromField(bytesToWord(paddedMessage.slice(i, i + 4).reverse())));
  }
  return chunk(chunks, 16);
}
var SHA256 = {
  hash(data) {
    let messageBlocks = padding(data);
    let H = SHA256.initialState;
    const N = messageBlocks.length;
    for (let i = 0; i < N; i++) {
      const W = createMessageSchedule(messageBlocks[i]);
      H = sha256Compression(H, W);
    }
    return Bytes2.from(H.map((x) => wordToBytes(x.value, 4).reverse()).flat());
  },
  compression: sha256Compression,
  createMessageSchedule,
  get initialState() {
    return SHA256Constants.H.map((x) => UInt322.from(x));
  }
};
function Ch(x, y, z) {
  let xAndY = x.and(y).value;
  let xNotAndZ = x.not().and(z).value;
  let ch = xAndY.add(xNotAndZ).seal();
  return UInt322.Unsafe.fromField(ch);
}
function Maj(x, y, z) {
  let sum2 = x.value.add(y.value).add(z.value).seal();
  let xor4 = x.xor(y).xor(z).value;
  let maj = sum2.sub(xor4).div(2).seal();
  return UInt322.Unsafe.fromField(maj);
}
function SigmaZero(x) {
  return sigma(x, [2, 13, 22]);
}
function SigmaOne(x) {
  return sigma(x, [6, 11, 25]);
}
function DeltaZero(x) {
  return sigma(x, [3, 7, 18], true);
}
function DeltaOne(x) {
  return sigma(x, [10, 17, 19], true);
}
function ROTR(n, x) {
  return x.rotate(n, "right");
}
function SHR(n, x) {
  let val = x.rightShift(n);
  return val;
}
function sigmaSimple(u, bits, firstShifted = false) {
  let [r0, r1, r2] = bits;
  let rot0 = firstShifted ? SHR(r0, u) : ROTR(r0, u);
  let rot1 = ROTR(r1, u);
  let rot2 = ROTR(r2, u);
  return rot0.xor(rot1).xor(rot2);
}
function sigma(u, bits, firstShifted = false) {
  if (u.isConstant())
    return sigmaSimple(u, bits, firstShifted);
  let [r0, r1, r2] = bits;
  let x = u.value;
  let d0 = r0;
  let d1 = r1 - r0;
  let d2 = r2 - r1;
  let d3 = 32 - r2;
  let [x0, x1, x2, x3] = exists(4, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, d0),
      bitSlice(xx, r0, d1),
      bitSlice(xx, r1, d2),
      bitSlice(xx, r2, d3)
    ];
  });
  rangeCheck16(x0);
  rangeCheck16(x1);
  rangeCheck16(x2);
  rangeCheck16(x3);
  let x23 = x2.add(x3.mul(1 << d2)).seal();
  let x123 = x1.add(x23.mul(1 << d1)).seal();
  x0.add(x123.mul(1 << d0)).assertEquals(x);
  let xRotR0;
  if (!firstShifted) {
    xRotR0 = x123.add(x0.mul(1 << d1 + d2 + d3)).seal();
  } else {
    xRotR0 = x123;
    rangeCheck16(x0.mul(1 << 16 - d0).seal());
  }
  let x01 = x0.add(x1.mul(1 << d0)).seal();
  let xRotR1 = x23.add(x01.mul(1 << d2 + d3)).seal();
  let x012 = x01.add(x2.mul(1 << d0 + d1)).seal();
  let xRotR2 = x3.add(x012.mul(1 << d3)).seal();
  return UInt322.Unsafe.fromField(xRotR0).xor(UInt322.Unsafe.fromField(xRotR1)).xor(UInt322.Unsafe.fromField(xRotR2));
}
function sha256Compression(H, W) {
  let a2 = H[0];
  let b2 = H[1];
  let c = H[2];
  let d = H[3];
  let e = H[4];
  let f = H[5];
  let g = H[6];
  let h = H[7];
  for (let t = 0; t <= 63; t++) {
    const unreducedT1 = h.value.add(SigmaOne(e).value).add(Ch(e, f, g).value).add(SHA256Constants.K[t]).add(W[t].value).seal();
    const unreducedT2 = SigmaZero(a2).value.add(Maj(a2, b2, c).value);
    h = g;
    g = f;
    f = e;
    e = UInt322.Unsafe.fromField(divMod32(d.value.add(unreducedT1), 16).remainder);
    d = c;
    c = b2;
    b2 = a2;
    a2 = UInt322.Unsafe.fromField(divMod32(unreducedT2.add(unreducedT1), 16).remainder);
  }
  H[0] = H[0].addMod32(a2);
  H[1] = H[1].addMod32(b2);
  H[2] = H[2].addMod32(c);
  H[3] = H[3].addMod32(d);
  H[4] = H[4].addMod32(e);
  H[5] = H[5].addMod32(f);
  H[6] = H[6].addMod32(g);
  H[7] = H[7].addMod32(h);
  return H;
}
function createMessageSchedule(M) {
  const W = [];
  for (let t = 0; t <= 15; t++)
    W[t] = M[t];
  for (let t = 16; t <= 63; t++) {
    let unreduced = DeltaOne(W[t - 2]).value.add(W[t - 7].value).add(DeltaZero(W[t - 15]).value.add(W[t - 16].value));
    W[t] = UInt322.Unsafe.fromField(divMod32(unreduced, 16).remainder);
  }
  return W;
}

// dist/node/lib/provable/gadgets/lookup.js
function rangeCheck3x12(v0, v1, v2) {
  Gates.lookup(
    // table id
    Field3.from(1),
    v0,
    Field3.from(0),
    v1,
    Field3.from(0),
    v2,
    Field3.from(0)
  );
}

// dist/node/lib/provable/gadgets/gadgets.js
var Gadgets = {
  /**
   * Asserts that the input value is in the range [0, 2^64).
   *
   * This function proves that the provided field element can be represented with 64 bits.
   * If the field element exceeds 64 bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheck64(x); // successfully proves 64-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheck64(xLarge); // throws an error since input exceeds 64 bits
   * ```
   *
   * **Note**: Small "negative" field element inputs are interpreted as large integers close to the field size,
   * and don't pass the 64-bit check. If you want to prove that a value lies in the int64 range [-2^63, 2^63),
   * you could use `rangeCheck64(x.add(1n << 63n))`.
   *
   * _Advanced usage_: This returns the 4 highest limbs of x, in reverse order, i.e. [x52, x40, x28, x16].
   * This is useful if you want to do a range check for 52, 40, 28, or 16 bits instead of 64,
   * by constraining some of the returned limbs to be 0.
   */
  rangeCheck64(x) {
    return rangeCheck64(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^32).
   *
   * This function proves that the provided field element can be represented with 32 bits.
   * If the field element exceeds 32 bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   *
   * @throws Throws an error if the input value exceeds 32 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheck32(x); // successfully proves 32-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheck32(xLarge); // throws an error since input exceeds 32 bits
   * ```
   *
   * **Note**: Small "negative" field element inputs are interpreted as large integers close to the field size,
   * and don't pass the 32-bit check. If you want to prove that a value lies in the int32 range [-2^31, 2^31),
   * you could use `rangeCheck32(x.add(1n << 31n))`.
   */
  rangeCheck32(x) {
    return rangeCheck32(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^n). `n` must be a multiple of 16.
   *
   * This function proves that the provided field element can be represented with `n` bits.
   * If the field element exceeds `n` bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   * @param n - The number of bits to be considered for the range check.
   * @param message - Optional message to be displayed when the range check fails.
   *
   * @throws Throws an error if the input value exceeds `n` bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheckN(32, x); // successfully proves 32-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheckN(32, xLarge); // throws an error since input exceeds 32 bits
   * ```
   */
  rangeCheckN(n, x, message) {
    return rangeCheckN(n, x, message);
  },
  /**
   * Returns a boolean which being true proves that x is in the range [0, 2^n).
   *
   * **Beware**: The output being false does **not** prove that x is not in the range [0, 2^n).
   * This should not be viewed as a standalone provable method but as an advanced helper function
   * for gadgets which need a weakened form of range check.
   *
   * @param x - The value to be weakly range-checked.
   * @param n - The number of bits to be considered for the range check.
   *
   * @returns a Bool that is definitely only true if the input is in the range [0, 2^n),
   * but could also be false _even if_ the input is in the range [0, 2^n).
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * let definitelyInRange = Gadgets.isDefinitelyInRangeN(32, x); // could be true or false
   * ```
   */
  isDefinitelyInRangeN(n, x) {
    return isDefinitelyInRangeN(n, x);
  },
  /*
   * Asserts that the input value is in the range [0, 2^16).
   *
   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.
   */
  rangeCheck16(x) {
    return rangeCheck16(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^8).
   *
   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.
   */
  rangeCheck8(x) {
    return rangeCheck8(x);
  },
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * **Important:** The gadget assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the rotation.
   * To safely use `rotate64()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param field {@link Field} element to rotate.
   * @param bits amount of bits to rotate this {@link Field} element with.
   * @param direction left or right rotation direction.
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100));
   * const y = Gadgets.rotate64(x, 2, 'left'); // left rotation by 2 bits
   * const z = Gadgets.rotate64(x, 2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rotate64(xLarge, 32, "left"); // throws an error since input exceeds 64 bits
   * ```
   */
  rotate64(field, bits, direction = "left") {
    return rotate64(field, bits, direction);
  },
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 32-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * **Important:** The gadget assumes that its input is at most 32 bits in size.
   *
   * If the input exceeds 32 bits, the gadget is invalid and fails to prove correct execution of the rotation.
   * To safely use `rotate32()`, you need to make sure that the value passed in is range-checked to 32 bits;
   * for example, using {@link Gadgets.rangeCheck32}.
   *
   *
   * @param field {@link Field} element to rotate.
   * @param bits amount of bits to rotate this {@link Field} element with.
   * @param direction left or right rotation direction.
   *
   * @throws Throws an error if the input value exceeds 32 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100));
   * const y = Gadgets.rotate32(x, 2, 'left'); // left rotation by 2 bits
   * const z = Gadgets.rotate32(x, 2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rotate32(xLarge, 32, "left"); // throws an error since input exceeds 32 bits
   * ```
   */
  rotate32(field, bits, direction = "left") {
    return rotate32(field, bits, direction);
  },
  /**
   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively. Each XOR gate can verify 16 bit at most. If your input elements exceed 16 bit, another XOR gate will be added to the chain.
   *
   * The `length` parameter lets you define how many bits should be compared. `length` is rounded to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints.
   *
   * It is also important to mention that specifying a smaller `length` allows the verifier to infer the length of the original input data (e.g. smaller than 16 bit if only one XOR gate has been used).
   * A zkApp developer should consider these implications when choosing the `length` parameter and carefully weigh the trade-off between increased amount of constraints and security.
   *
   * **Important:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.
   *
   * For example, with `length = 2` (`paddedLength = 16`), `xor()` will fail for any input that is larger than `2**16`.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param a {@link Field} element to compare.
   * @param b {@link Field} element to compare.
   * @param length amount of bits to compare.
   *
   * @throws Throws an error if the input values exceed `2^paddedLength - 1`.
   *
   * @example
   * ```ts
   * let a = Field(0b0101);
   * let b = Field(0b0011);
   *
   * let c = Gadgets.xor(a, b, 4); // xor-ing 4 bits
   * c.assertEquals(0b0110);
   * ```
   */
  xor(a2, b2, length) {
    return xor2(a2, b2, length);
  },
  /**
   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate only operates over the amount
   * of bits specified by the `length` parameter.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * The `length` parameter lets you define how many bits to NOT.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints. The operation will fail if the length or the input value is larger than 254.
   *
   * NOT is implemented in two different ways. If the `checked` parameter is set to `true`
   * the {@link Gadgets.xor} gadget is reused with a second argument to be an
   * all one bitmask the same length. This approach needs as many rows as an XOR would need
   * for a single negation. If the `checked` parameter is set to `false`, NOT is
   * implemented as a subtraction of the input from the all one bitmask. This
   * implementation is returned by default if no `checked` parameter is provided.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // not-ing 4 bits with the unchecked version
   * let a = Field(0b0101);
   * let b = Gadgets.not(a,4,false);
   *
   * b.assertEquals(0b1010);
   *
   * // not-ing 4 bits with the checked version utilizing the xor gadget
   * let a = Field(0b0101);
   * let b = Gadgets.not(a,4,true);
   *
   * b.assertEquals(0b1010);
   * ```
   *
   * @param a - The value to apply NOT to. The operation will fail if the value is larger than 254.
   * @param length - The number of bits to be considered for the NOT operation.
   * @param checked - Optional boolean to determine if the checked or unchecked not implementation is used. If it
   * is set to `true` the {@link Gadgets.xor} gadget is reused. If it is set to `false`, NOT is implemented
   *  as a subtraction of the input from the all one bitmask. It is set to `false` by default if no parameter is provided.
   *
   * @throws Throws an error if the input value exceeds 254 bits.
   */
  not(a2, length, checked = false) {
    return not(a2, length, checked);
  },
  /**
   * Performs a left shift operation on the provided {@link Field} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.
   * Therefore, to safely use `leftShift()`, you need to make sure that the values passed in are range checked to 64 bits.
   * For example, this can be done with {@link Gadgets.rangeCheck64}.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.leftShift64(x, 2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * leftShift64(xLarge, 32); // throws an error since input exceeds 64 bits
   * ```
   */
  leftShift64(field, bits) {
    return leftShift64(field, bits);
  },
  /**
   * Performs a left shift operation on the provided {@link Field} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 32 bits in size.
   *
   * The output is range checked to 32 bits.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.leftShift32(x, 2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift32(field, bits) {
    return leftShift32(field, bits);
  },
  /**
   * Performs a right shift operation on the provided {@link Field} element.
   * This is similar to the `>>` shift operation in JavaScript, where bits are moved to the right.
   * The `rightShift64` function utilizes the rotation method internally to implement this operation.
   *
   * * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.
   * To safely use `rightShift64()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the right. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.rightShift64(x, 2); // right shift by 2 bits
   * y.assertEquals(0b000011); // 3 in binary
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * rightShift64(xLarge, 32); // throws an error since input exceeds 64 bits
   * ```
   */
  rightShift64(field, bits) {
    return rightShift64(field, bits);
  },
  /**
   * Bitwise AND gadget on {@link Field} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below (in the process it also invokes the {@link Gadgets.xor} gadget which will create additional constraints depending on `length`).
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   * The `length` parameter lets you define how many bits should be compared. `length` is rounded to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints.
   *
   * **Note:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.
   * For example, with `length = 2` (`paddedLength = 16`), `and()` will fail for any input that is larger than `2**16`.
   *
   * @example
   * ```typescript
   * let a = Field(3);    // ... 000011
   * let b = Field(5);    // ... 000101
   *
   * let c = Gadgets.and(a, b, 2);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(a2, b2, length) {
    return and(a2, b2, length);
  },
  /**
   * Multi-range check.
   *
   * Proves that x, y, z are all in the range [0, 2^88).
   *
   * This takes 4 rows, so it checks 88*3/4 = 66 bits per row. This is slightly more efficient
   * than 64-bit range checks, which can do 64 bits in 1 row.
   *
   * In particular, the 3x88-bit range check supports bigints up to 264 bits, which in turn is enough
   * to support foreign field multiplication with moduli up to 2^259.
   *
   * @example
   * ```ts
   * Gadgets.multiRangeCheck([x, y, z]);
   * ```
   *
   * @throws Throws an error if one of the input values exceeds 88 bits.
   */
  multiRangeCheck(limbs) {
    multiRangeCheck(limbs);
  },
  /**
   * Compact multi-range check
   *
   * This is a variant of {@link multiRangeCheck} where the first two variables are passed in
   * combined form xy = x + 2^88*y.
   *
   * The gadget
   * - splits up xy into x and y
   * - proves that xy = x + 2^88*y
   * - proves that x, y, z are all in the range [0, 2^88).
   *
   * The split form [x, y, z] is returned.
   *
   * @example
   * ```ts
   * let [x, y] = Gadgets.compactMultiRangeCheck([xy, z]);
   * ```
   *
   * @throws Throws an error if `xy` exceeds 2*88 = 176 bits, or if z exceeds 88 bits.
   */
  compactMultiRangeCheck(xy, z) {
    return compactMultiRangeCheck(xy, z);
  },
  /**
   * Checks that three {@link Field} elements are in the range [0, 2^12) (using only one row).
   *
   * Internally, this gadget relies on the 12-bit [range check table](https://github.com/o1-labs/proof-systems/blob/master/kimchi/src/circuits/lookup/tables/mod.rs).
   * All three inputs are checked to be included in that table.
   *
   * It's possible to use this as a range check for bit lengths n < 12, by passing in _two values_.
   * - the value to be checked, `x`, to prove that x in [0, 2^12)
   * - x scaled by 2^(12 - n), to prove that either x in [0, 2^n) or `x * 2^(12 - n)` overflows the field size (which is excluded by the first check)
   *
   * Note that both of these checks are necessary to prove x in [0, 2^n).
   *
   * You can find more details about lookups in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=lookup%20gate#lookup)
   *
   * @param v0 - The first {@link Field} element to be checked.
   * @param v1 - The second {@link Field} element to be checked.
   * @param v2 - The third {@link Field} element to be checked.
   *
   * @throws Throws an error if one of the input values exceeds 2^12.
   *
   * @example
   * ```typescript
   * let a = Field(4000);
   * rangeCheck3x12(a, Field(0), Field(0)); // works, since `a` is less than 12 bits
   *
   * let aScaled = a.mul(1 << 4); // scale `a`, to assert that it's less than 8 bits
   * rangeCheck3x12(a, aScaled, Field(0)); // throws an error, since  `a` is greater than 8 bits (and so `aScaled` is greater than 12 bits)
   * ```
   */
  rangeCheck3x12(v0, v1, v2) {
    return rangeCheck3x12(v0, v1, v2);
  },
  /**
   * Gadgets for foreign field operations.
   *
   * A _foreign field_ is a finite field different from the native field of the proof system.
   *
   * The `ForeignField` namespace exposes operations like modular addition and multiplication,
   * which work for any finite field of size less than 2^259.
   *
   * Foreign field elements are represented as 3 limbs of native field elements.
   * Each limb holds 88 bits of the total, in little-endian order.
   *
   * All `ForeignField` gadgets expect that their input limbs are constrained to the range [0, 2^88).
   * Range checks on outputs are added by the gadget itself.
   */
  ForeignField: {
    /**
     * Foreign field addition: `x + y mod f`
     *
     * The modulus `f` does not need to be prime.
     *
     * Inputs and outputs are 3-tuples of native Fields.
     * Each input limb is assumed to be in the range [0, 2^88), and the gadget is invalid if this is not the case.
     * The result limbs are guaranteed to be in the same range.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3, () => 9n);
     * let y = Provable.witness(Field3, () => 10n);
     *
     * // range check x and y
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     *
     * // compute x + y mod 17
     * let z = ForeignField.add(x, y, 17n);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = 9 + 10 mod 17
     * ```
     *
     * **Warning**: The gadget does not assume that inputs are reduced modulo f,
     * and does not prove that the result is reduced modulo f.
     * It only guarantees that the result is in the correct residue class.
     *
     * @param x left summand
     * @param y right summand
     * @param f modulus
     * @returns x + y mod f
     */
    add(x, y, f) {
      return ForeignField.add(x, y, f);
    },
    /**
     * Foreign field subtraction: `x - y mod f`
     *
     * See {@link Gadgets.ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x - y < -f`, where the result cannot be brought back to a positive number by adding `f` once.
     */
    sub(x, y, f) {
      return ForeignField.sub(x, y, f);
    },
    /**
     * Foreign field negation: `-x mod f = f - x`
     *
     * See {@link ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x > f`, where `f - x < 0`.
     */
    neg(x, f) {
      return ForeignField.negate(x, f);
    },
    /**
     * Foreign field sum: `xs[0] + signs[0] * xs[1] + ... + signs[n-1] * xs[n] mod f`
     *
     * This gadget takes a list of inputs and a list of signs (of size one less than the inputs),
     * and computes a chain of additions or subtractions, depending on the sign.
     * A sign is of type `1n | -1n`, where `1n` represents addition and `-1n` represents subtraction.
     *
     * **Note**: For 3 or more inputs, `sum()` uses fewer constraints than a sequence of `add()` and `sub()` calls,
     * because we can avoid range checks on intermediate results.
     *
     * See {@link Gadgets.ForeignField.add} for assumptions on inputs.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3, () => 4n);
     * let y = Provable.witness(Field3, () => 5n);
     * let z = Provable.witness(Field3, () => 10n);
     *
     * // range check x, y, z
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     * Gadgets.multiRangeCheck(z);
     *
     * // compute x + y - z mod 17
     * let sum = ForeignField.sum([x, y, z], [1n, -1n], 17n);
     *
     * Provable.log(sum); // ['16', '0', '0'] = limb representation of 16 = 4 + 5 - 10 mod 17
     * ```
     */
    sum(xs, signs, f) {
      return ForeignField.sum(xs, signs, f);
    },
    /**
     * Foreign field multiplication: `x * y mod f`
     *
     * The modulus `f` does not need to be prime, but has to be smaller than 2^259.
     *
     * **Assumptions**: In addition to the assumption that input limbs are in the range [0, 2^88), as in all foreign field gadgets,
     * this assumes an additional bound on the inputs: `x * y < 2^264 * p`, where p is the native modulus.
     * We usually assert this bound by proving that `x[2] < f[2] + 1`, where `x[2]` is the most significant limb of x.
     * To do this, we use an 88-bit range check on `2^88 - x[2] - (f[2] + 1)`, and same for y.
     * The implication is that x and y are _almost_ reduced modulo f.
     *
     * All of the above assumptions are checked by {@link Gadgets.ForeignField.assertAlmostReduced}.
     *
     * **Warning**: This gadget does not add the extra bound check on the result.
     * So, to use the result in another foreign field multiplication, you have to add the bound check on it yourself, again.
     *
     * @example
     * ```ts
     * // example modulus: secp256k1 prime
     * let f = (1n << 256n) - (1n << 32n) - 0b1111010001n;
     *
     * let x = Provable.witness(Field3, () => f - 1n);
     * let y = Provable.witness(Field3, () => f - 2n);
     *
     * // range check x, y and prove additional bounds x[2] <= f[2]
     * ForeignField.assertAlmostReduced([x, y], f);
     *
     * // compute x * y mod f
     * let z = ForeignField.mul(x, y, f);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = (-1)*(-2) mod f
     * ```
     */
    mul(x, y, f) {
      return ForeignField.mul(x, y, f);
    },
    /**
     * Foreign field inverse: `x^(-1) mod f`
     *
     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     */
    inv(x, f) {
      return ForeignField.inv(x, f);
    },
    /**
     * Foreign field division: `x * y^(-1) mod f`
     *
     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     *
     * @throws Different than {@link Gadgets.ForeignField.mul}, this fails on unreduced input `x`, because it checks that `x === (x/y)*y` and the right side will be reduced.
     */
    div(x, y, f) {
      return ForeignField.div(x, y, f);
    },
    /**
     * Optimized multiplication of sums in a foreign field, for example: `(x - y)*z = a + b + c mod f`
     *
     * Note: This is much more efficient than using {@link Gadgets.ForeignField.add} and {@link Gadgets.ForeignField.sub} separately to
     * compute the multiplication inputs and outputs, and then using {@link Gadgets.ForeignField.mul} to constrain the result.
     *
     * The sums passed into this method are "lazy sums" created with {@link Gadgets.ForeignField.Sum}.
     * You can also pass in plain {@link Field3} elements.
     *
     * **Assumptions**: The assumptions on the _summands_ are analogous to the assumptions described in {@link Gadgets.ForeignField.mul}:
     * - each summand's limbs are in the range [0, 2^88)
     * - summands that are part of a multiplication input satisfy `x[2] <= f[2]`
     *
     * @throws if the modulus is so large that the second assumption no longer suffices for validity of the multiplication.
     * For small sums and moduli < 2^256, this will not fail.
     *
     * @throws if the provided multiplication result is not correct modulo f.
     *
     * @example
     * ```ts
     * // range-check x, y, z, a, b, c
     * ForeignField.assertAlmostReduced([x, y, z], f);
     * Gadgets.multiRangeCheck(a);
     * Gadgets.multiRangeCheck(b);
     * Gadgets.multiRangeCheck(c);
     *
     * // create lazy input sums
     * let xMinusY = ForeignField.Sum(x).sub(y);
     * let aPlusBPlusC = ForeignField.Sum(a).add(b).add(c);
     *
     * // assert that (x - y)*z = a + b + c mod f
     * ForeignField.assertMul(xMinusY, z, aPlusBPlusC, f);
     * ```
     */
    assertMul(x, y, z, f) {
      return ForeignField.assertMul(x, y, z, f);
    },
    /**
     * Lazy sum of {@link Field3} elements, which can be used as input to {@link Gadgets.ForeignField.assertMul}.
     */
    Sum(x) {
      return ForeignField.Sum(x);
    },
    /**
     * Prove that each of the given {@link Field3} elements is "almost" reduced modulo f,
     * i.e., satisfies the assumptions required by {@link Gadgets.ForeignField.mul} and other gadgets:
     * - each limb is in the range [0, 2^88)
     * - the most significant limb is less or equal than the modulus, x[2] <= f[2]
     *
     * **Note**: This method is most efficient when the number of input elements is a multiple of 3.
     *
     * @throws if any of the assumptions is violated.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3, () => 4n);
     * let y = Provable.witness(Field3, () => 5n);
     * let z = Provable.witness(Field3, () => 10n);
     *
     * ForeignField.assertAlmostReduced([x, y, z], f);
     *
     * // now we can use x, y, z as inputs to foreign field multiplication
     * let xy = ForeignField.mul(x, y, f);
     * let xyz = ForeignField.mul(xy, z, f);
     *
     * // since xy is an input to another multiplication, we need to prove that it is almost reduced again!
     * ForeignField.assertAlmostReduced([xy], f); // TODO: would be more efficient to batch this with 2 other elements
     * ```
     */
    assertAlmostReduced(xs, f, { skipMrc = false } = {}) {
      ForeignField.assertAlmostReduced(xs, f, skipMrc);
    },
    /**
     * Prove that x < f for any constant f < 2^264, or for another `Field3` f.
     *
     * If f is a finite field modulus, this means that the given field element is fully reduced modulo f.
     * This is a stronger statement than {@link ForeignField.assertAlmostReduced}
     * and also uses more constraints; it should not be needed in most use cases.
     *
     * **Note**: This assumes that the limbs of x are in the range [0, 2^88), in contrast to
     * {@link ForeignField.assertAlmostReduced} which adds that check itself.
     *
     * @throws if x is greater or equal to f.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3, () => 0x1235n);
     *
     *  // range check limbs of x
     * Gadgets.multiRangeCheck(x);
     *
     * // prove that x is fully reduced mod f
     * Gadgets.ForeignField.assertLessThan(x, f);
     * ```
     */
    assertLessThan(x, f) {
      ForeignField.assertLessThan(x, f);
    },
    /**
     * Prove that x <= f for any constant f < 2^264, or for another `Field3` f.
     *
     * See {@link ForeignField.assertLessThan} for details and usage examples.
     */
    assertLessThanOrEqual(x, f) {
      ForeignField.assertLessThanOrEqual(x, f);
    }
  },
  /**
   * Helper methods to interact with 3-limb vectors of Fields.
   *
   * **Note:** This interface does not contain any provable methods.
   */
  Field3: Field32,
  /**
   * Division modulo 2^32. The operation decomposes a {@link Field} element in the range [0, 2^64) into two 32-bit limbs, `remainder` and `quotient`, using the following equation: `n = quotient * 2^32 + remainder`.
   *
   * **Note:** The gadget acts as a proof that the input is in the range [0, 2^64). If the input exceeds 64 bits, the gadget fails.
   *
   * Asserts that both `remainder` and `quotient` are in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.
   *
   * @example
   * ```ts
   * let n = Field((1n << 32n) + 8n)
   * let { remainder, quotient } = Gadgets.divMod32(n);
   * // remainder = 8, quotient = 1
   *
   * n.assertEquals(quotient.mul(1n << 32n).add(remainder));
   * ```
   */
  divMod32,
  /**
   * Addition modulo 2^32. The operation adds two {@link Field} elements in the range [0, 2^64] and returns the result modulo 2^32.
   *
   * Asserts that the result is in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.
   *
   * It uses {@link Gadgets.divMod32} internally by adding the two {@link Field} elements and then decomposing the result into `remainder` and `quotient` and returning the `remainder`.
   *
   * **Note:** The gadget assumes both inputs to be in the range [0, 2^64). When called with non-range-checked inputs, be aware that the sum `a + b` can overflow the native field and the gadget can succeed but return an invalid result.
   *
   * @example
   * ```ts
   * let a = Field(8n);
   * let b = Field(1n << 32n);
   *
   * Gadgets.addMod32(a, b).assertEquals(Field(8n));
   * ```
   *    */
  addMod32,
  /**
   * Implementation of the [SHA256 hash function.](https://en.wikipedia.org/wiki/SHA-2) Hash function with 256bit output.
   *
   * Applies the SHA2-256 hash function to a list of byte-sized elements.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]`, `bigint[]` or `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   *
   * @param data - {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest = Gadgets.SHA256.hash(preimage);
   * ```
   *
   */
  SHA256
};

// dist/node/lib/provable/foreign-field.js
var ForeignField2 = class _ForeignField {
  // static parameters
  static get Bigint() {
    assert3(this._Bigint !== void 0, "ForeignField class not initialized.");
    return this._Bigint;
  }
  static get modulus() {
    assert3(this._modulus !== void 0, "ForeignField class not initialized.");
    return this._modulus;
  }
  get modulus() {
    return this.constructor.modulus;
  }
  static get sizeInBits() {
    return this.modulus.toString(2).length;
  }
  get Constructor() {
    return this.constructor;
  }
  /**
   * Constructor for unreduced field elements.
   */
  static get Unreduced() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.unreduced;
  }
  /**
   * Constructor for field elements that are "almost reduced", i.e. lie in the range [0, 2^ceil(log2(p))).
   */
  static get AlmostReduced() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.almostReduced;
  }
  /**
   * Constructor for field elements that are fully reduced, i.e. lie in the range [0, p).
   */
  static get Canonical() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.canonical;
  }
  /**
   * Create a new {@link ForeignField} from a bigint, number, string or another ForeignField.
   * @example
   * ```ts
   * let x = new ForeignField(5);
   * ```
   */
  constructor(x) {
    const p3 = this.modulus;
    if (x instanceof _ForeignField) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      this.value = x;
      return;
    }
    this.value = Field32.from(mod(BigInt(x), p3));
  }
  static from(x) {
    if (x instanceof this)
      return x;
    return new this.Canonical(x);
  }
  /**
   * Checks whether this field element is a constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   */
  isConstant() {
    return Field32.isConstant(this.value);
  }
  /**
   * Convert this field element to a constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   *
   * **Warning**: This function is only useful in {@link Provable.witness} or {@link Provable.asProver} blocks,
   * that is, in situations where the prover computes a value outside provable code.
   */
  toConstant() {
    let constantLimbs = Tuple.map(this.value, (l4) => l4.toConstant());
    return new this.Constructor(constantLimbs);
  }
  /**
   * Convert this field element to a bigint.
   */
  toBigInt() {
    return Field32.toBigint(this.value);
  }
  /**
   * Assert that this field element lies in the range [0, 2^k),
   * where k = ceil(log2(p)) and p is the foreign field modulus.
   *
   * Returns the field element as a {@link AlmostForeignField}.
   *
   * For a more efficient version of this for multiple field elements, see {@link assertAlmostReduced}.
   *
   * Note: this does not ensure that the field elements is in the canonical range [0, p).
   * To assert that stronger property, there is {@link assertCanonical}.
   * You should typically use {@link assertAlmostReduced} though, because it is cheaper to prove and sufficient for
   * ensuring validity of all our non-native field arithmetic methods.
   */
  assertAlmostReduced() {
    let [x] = this.Constructor.assertAlmostReduced(this);
    return x;
  }
  /**
   * Assert that one or more field elements lie in the range [0, 2^k),
   * where k = ceil(log2(p)) and p is the foreign field modulus.
   *
   * This is most efficient than when checking a multiple of 3 field elements at once.
   */
  static assertAlmostReduced(...xs) {
    Gadgets.ForeignField.assertAlmostReduced(xs.map((x) => x.value), this.modulus, { skipMrc: true });
    return Tuple.map(xs, this.AlmostReduced.unsafeFrom);
  }
  /**
   * Assert that this field element is fully reduced,
   * i.e. lies in the range [0, p), where p is the foreign field modulus.
   *
   * Returns the field element as a {@link CanonicalForeignField}.
   */
  assertCanonical() {
    this.assertLessThan(this.modulus);
    return this.Constructor.Canonical.unsafeFrom(this);
  }
  // arithmetic with full constraints, for safe use
  /**
   * Finite field addition
   * @example
   * ```ts
   * x.add(2); // x + 2 mod p
   * ```
   */
  add(y) {
    return this.Constructor.sum([this, y], [1]);
  }
  /**
   * Finite field negation
   * @example
   * ```ts
   * x.neg(); // -x mod p = p - x
   * ```
   */
  neg() {
    let xNeg = Gadgets.ForeignField.neg(this.value, this.modulus);
    return new this.Constructor.AlmostReduced(xNeg);
  }
  /**
   * Finite field subtraction
   * @example
   * ```ts
   * x.sub(1); // x - 1 mod p
   * ```
   */
  sub(y) {
    return this.Constructor.sum([this, y], [-1]);
  }
  /**
   * Sum (or difference) of multiple finite field elements.
   *
   * @example
   * ```ts
   * let z = ForeignField.sum([3, 2, 1], [-1, 1]); // 3 - 2 + 1
   * z.assertEquals(2);
   * ```
   *
   * This method expects a list of ForeignField-like values, `x0,...,xn`,
   * and a list of "operations" `op1,...,opn` where every op is 1 or -1 (plus or minus),
   * and returns
   *
   * `x0 + op1*x1 + ... + opn*xn`
   *
   * where the sum is computed in finite field arithmetic.
   *
   * **Important:** For more than two summands, this is significantly more efficient
   * than chaining calls to {@link ForeignField.add} and {@link ForeignField.sub}.
   *
   */
  static sum(xs, operations) {
    const p3 = this.modulus;
    let fields2 = xs.map((x) => toLimbs(x, p3));
    let ops = operations.map((op) => op === 1 ? 1n : -1n);
    let z = Gadgets.ForeignField.sum(fields2, ops, p3);
    return new this.Unreduced(z);
  }
  assertEquals(y, message) {
    const p3 = this.modulus;
    try {
      if (this.isConstant() && isConstant7(y)) {
        let x = this.toBigInt();
        let y0 = mod(toBigInt(y), p3);
        if (x !== y0) {
          throw Error(`ForeignField.assertEquals(): ${x} != ${y0}`);
        }
        return new this.Constructor.Canonical(this.value);
      }
      Provable.assertEqual(this.Constructor, this, new this.Constructor(y));
      if (isConstant7(y) || y instanceof this.Constructor.Canonical) {
        return new this.Constructor.Canonical(this.value);
      } else if (y instanceof this.Constructor.AlmostReduced) {
        return new this.Constructor.AlmostReduced(this.value);
      } else {
        return this;
      }
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Assert that this field element is less than a constant c: `x < c`.
   *
   * The constant must satisfy `0 <= c < 2^264`, otherwise an error is thrown.
   *
   * @example
   * ```ts
   * x.assertLessThan(10);
   * ```
   */
  assertLessThan(c, message) {
    assert3(c >= 0 && c < 1n << l3, `ForeignField.assertLessThan(): expected c <= c < 2^264, got ${c}`);
    try {
      Gadgets.ForeignField.assertLessThan(this.value, toBigInt(c));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  // bit packing
  /**
   * Unpack a field element to its bits, as a {@link Bool}[] array.
   *
   * This method is provable!
   */
  toBits(length) {
    const sizeInBits2 = this.Constructor.sizeInBits;
    if (length === void 0)
      length = sizeInBits2;
    checkBitLength("ForeignField.toBits()", length, sizeInBits2);
    let [l0, l1, l22] = this.value;
    let limbSize = Number(l);
    let xBits = l0.toBits(Math.min(length, limbSize));
    length -= limbSize;
    if (length <= 0) {
      l1.assertEquals(0);
      l22.assertEquals(0);
      return xBits;
    }
    let yBits = l1.toBits(Math.min(length, limbSize));
    length -= limbSize;
    if (length <= 0) {
      l22.assertEquals(0);
      return [...xBits, ...yBits];
    }
    let zBits = l22.toBits(Math.min(length, limbSize));
    return [...xBits, ...yBits, ...zBits];
  }
  /**
   * Create a field element from its bits, as a `Bool[]` array.
   *
   * This method is provable!
   */
  static fromBits(bits) {
    let length = bits.length;
    checkBitLength("ForeignField.fromBits()", length, this.sizeInBits);
    let limbSize = Number(l);
    let l0 = Field3.fromBits(bits.slice(0 * limbSize, 1 * limbSize));
    let l1 = Field3.fromBits(bits.slice(1 * limbSize, 2 * limbSize));
    let l22 = Field3.fromBits(bits.slice(2 * limbSize, 3 * limbSize));
    return new this.AlmostReduced([l0, l1, l22]);
  }
  static random() {
    return new this.Canonical(this.Bigint.random());
  }
  /**
   * Instance version of `Provable<ForeignField>.toFields`, see {@link Provable.toFields}
   */
  toFields() {
    return this.value;
  }
  static check(_) {
    throw Error("ForeignField.check() not implemented: must use a subclass");
  }
  /**
   * `Provable<ForeignField>`, see {@link Provable}
   */
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
};
ForeignField2._Bigint = void 0;
ForeignField2._modulus = void 0;
ForeignField2._variants = void 0;
ForeignField2._provable = void 0;
var ForeignFieldWithMul = class extends ForeignField2 {
  /**
   * Finite field multiplication
   * @example
   * ```ts
   * x.mul(y); // x*y mod p
   * ```
   */
  mul(y) {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.mul(this.value, toLimbs(y, p3), p3);
    return new this.Constructor.Unreduced(z);
  }
  /**
   * Multiplicative inverse in the finite field
   * @example
   * ```ts
   * let z = x.inv(); // 1/x mod p
   * z.mul(x).assertEquals(1);
   * ```
   */
  inv() {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.inv(this.value, p3);
    return new this.Constructor.AlmostReduced(z);
  }
  /**
   * Division in the finite field, i.e. `x*y^(-1) mod p` where `y^(-1)` is the finite field inverse.
   * @example
   * ```ts
   * let z = x.div(y); // x/y mod p
   * z.mul(y).assertEquals(x);
   * ```
   */
  div(y) {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.div(this.value, toLimbs(y, p3), p3);
    return new this.Constructor.AlmostReduced(z);
  }
};
var UnreducedForeignField = class extends ForeignField2 {
  constructor() {
    super(...arguments);
    this.type = "Unreduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
  }
};
UnreducedForeignField._provable = void 0;
var AlmostForeignField = class extends ForeignFieldWithMul {
  constructor(x) {
    super(x);
    this.type = "AlmostReduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
    x.assertAlmostReduced();
  }
  /**
   * Coerce the input to an {@link AlmostForeignField} without additional assertions.
   *
   * **Warning:** Only use if you know what you're doing.
   */
  static unsafeFrom(x) {
    return new this(x.value);
  }
  /**
   * Check equality with a constant value.
   *
   * @example
   * ```ts
   * let isXZero = x.equals(0);
   * ```
   */
  equals(y) {
    return ForeignField.equals(this.value, BigInt(y), this.modulus);
  }
};
AlmostForeignField._provable = void 0;
var CanonicalForeignField = class extends ForeignFieldWithMul {
  constructor(x) {
    super(x);
    this.type = "FullyReduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
    x.assertCanonical();
  }
  /**
   * Coerce the input to a {@link CanonicalForeignField} without additional assertions.
   *
   * **Warning:** Only use if you know what you're doing.
   */
  static unsafeFrom(x) {
    return new this(x.value);
  }
  /**
   * Check equality with a ForeignField-like value.
   *
   * @example
   * ```ts
   * let isEqual = x.equals(y);
   * ```
   *
   * Note: This method only exists on canonical fields; on unreduced fields, it would be easy to
   * misuse, because not being exactly equal does not imply being unequal modulo p.
   */
  equals(y) {
    let [x0, x1, x2] = this.value;
    let [y0, y1, y2] = toLimbs(y, this.modulus);
    let x01 = x0.add(x1.mul(1n << l)).seal();
    let y01 = y0.add(y1.mul(1n << l)).seal();
    return x01.equals(y01).and(x2.equals(y2));
  }
};
CanonicalForeignField._provable = void 0;
function toLimbs(x, p3) {
  if (x instanceof ForeignField2)
    return x.value;
  return Field32.from(mod(BigInt(x), p3));
}
function toBigInt(x) {
  if (x instanceof ForeignField2)
    return x.toBigInt();
  return BigInt(x);
}
function isConstant7(x) {
  if (x instanceof ForeignField2)
    return x.isConstant();
  return true;
}
function createForeignField(modulus) {
  assert3(modulus > 0n, `ForeignField: modulus must be positive, got ${modulus}`);
  assert3(modulus < foreignFieldMax, `ForeignField: modulus exceeds the max supported size of 2^${foreignFieldMaxBits}`);
  let Bigint = createField(modulus);
  class UnreducedField extends UnreducedForeignField {
  }
  UnreducedField._Bigint = Bigint;
  UnreducedField._modulus = modulus;
  UnreducedField._provable = provable2(UnreducedField);
  UnreducedField.from = ForeignField2.from.bind(UnreducedField);
  UnreducedField.sum = ForeignField2.sum.bind(UnreducedField);
  UnreducedField.fromBits = ForeignField2.fromBits.bind(UnreducedField);
  class AlmostField extends AlmostForeignField {
  }
  AlmostField._Bigint = Bigint;
  AlmostField._modulus = modulus;
  AlmostField._provable = provable2(AlmostField);
  AlmostField.from = ForeignField2.from.bind(AlmostField);
  AlmostField.sum = ForeignField2.sum.bind(AlmostField);
  AlmostField.fromBits = ForeignField2.fromBits.bind(AlmostField);
  AlmostField.unsafeFrom = AlmostForeignField.unsafeFrom.bind(AlmostField);
  class CanonicalField extends CanonicalForeignField {
  }
  CanonicalField._Bigint = Bigint;
  CanonicalField._modulus = modulus;
  CanonicalField._provable = provable2(CanonicalField);
  CanonicalField.from = ForeignField2.from.bind(CanonicalField);
  CanonicalField.sum = ForeignField2.sum.bind(CanonicalField);
  CanonicalField.fromBits = ForeignField2.fromBits.bind(CanonicalField);
  CanonicalField.unsafeFrom = CanonicalForeignField.unsafeFrom.bind(CanonicalField);
  let variants = {
    unreduced: UnreducedField,
    almostReduced: AlmostField,
    canonical: CanonicalField
  };
  UnreducedField._variants = variants;
  AlmostField._variants = variants;
  CanonicalField._variants = variants;
  return UnreducedField;
}
var foreignFieldMaxBits = (BigInt(Fp.sizeInBits - 1) + 3n * l) / 2n;
var foreignFieldMax = 1n << foreignFieldMaxBits;
function provable2(Class) {
  return {
    toFields(x) {
      return x.value;
    },
    toAuxiliary() {
      return [];
    },
    sizeInFields() {
      return 3;
    },
    fromFields(fields2) {
      let limbs = TupleN.fromArray(3, fields2);
      return new Class(limbs);
    },
    check(x) {
      Class.check(x);
    },
    toValue(x) {
      return x.toBigInt();
    },
    fromValue(x) {
      return new Class(x);
    },
    // ugh
    toJSON(x) {
      return x.toBigInt().toString();
    },
    fromJSON(x) {
      return new Class(x);
    },
    empty() {
      return new Class(0n);
    },
    toInput(x) {
      let l_ = Number(l);
      return {
        packed: [
          [x.value[0], l_],
          [x.value[1], l_],
          [x.value[2], l_]
        ]
      };
    }
  };
}

// dist/node/lib/provable/gadgets/elliptic-curve.js
var import_js_sha2562 = require("js-sha256");

// dist/node/lib/provable/packed.js
var Packed = class _Packed {
  /**
   * Create a packed representation of `type`. You can then use `PackedType.pack(x)` to pack a value.
   */
  static create(type) {
    var _a2;
    let provable3 = ProvableType.get(type);
    let input = provable3.toInput(provable3.empty());
    let packedSize = countFields(input);
    return _a2 = class Packed_ extends _Packed {
      static empty() {
        return _a2.pack(provable3.empty());
      }
      static get provable() {
        assert3(this._provable !== void 0, "Packed not initialized");
        return this._provable;
      }
    }, _a2._innerProvable = provable3, _a2._provable = provableFromClass(_a2, {
      packed: fields(packedSize),
      value: Unconstrained
    }), _a2;
  }
  constructor(packed, value) {
    this.packed = packed;
    this.value = value;
  }
  /**
   * Pack a value.
   */
  static pack(x) {
    let type = this.innerProvable;
    let input = type.toInput(x);
    let packed = packToFields(input);
    let unconstrained = Unconstrained.witness(() => Provable.toConstant(type, x));
    return new this(packed, unconstrained);
  }
  /**
   * Unpack a value.
   */
  unpack() {
    let value = Provable.witness(this.Constructor.innerProvable, () => this.value.get());
    let input = this.Constructor.innerProvable.toInput(value);
    let packed = packToFields(input);
    for (let i = 0; i < this.packed.length; i++) {
      this.packed[i].assertEquals(packed[i]);
    }
    return value;
  }
  toFields() {
    return this.packed;
  }
  get Constructor() {
    return this.constructor;
  }
  static get innerProvable() {
    assert3(this._innerProvable !== void 0, "Packed not initialized");
    return this._innerProvable;
  }
};
function countFields(input) {
  let n = input.fields?.length ?? 0;
  let pendingBits = 0;
  for (let [, bits] of input.packed ?? []) {
    pendingBits += bits;
    if (pendingBits >= Field3.sizeInBits) {
      n++;
      pendingBits = bits;
    }
  }
  if (pendingBits > 0)
    n++;
  return n;
}
var Hashed = class _Hashed {
  /**
   * Create a hashed representation of `type`. You can then use `HashedType.hash(x)` to wrap a value in a `Hashed`.
   */
  static create(type, hash3) {
    var _a2;
    let provable3 = ProvableType.get(type);
    let _hash = hash3 ?? ((t) => Poseidon2.hashPacked(provable3, t));
    return _a2 = class Hashed_ extends _Hashed {
      static empty() {
        let empty4 = provable3.empty();
        return new this(_hash(empty4), Unconstrained.from(empty4));
      }
      static get provable() {
        assert3(this._provable !== void 0, "Hashed not initialized");
        return this._provable;
      }
    }, _a2._innerProvable = provable3, _a2._provable = provableFromClass(_a2, {
      hash: modifiedField({ empty: () => _hash(provable3.empty()) }),
      value: Unconstrained
    }), _a2._hash = _hash, _a2;
  }
  constructor(hash3, value) {
    this.hash = hash3;
    this.value = value;
  }
  static _hash(_) {
    assert3(false, "Hashed not initialized");
  }
  /**
   * Wrap a value, and represent it by its hash in provable code.
   *
   * ```ts
   * let hashed = HashedType.hash(value);
   * ```
   *
   * Optionally, if you already have the hash, you can pass it in and avoid recomputing it.
   */
  static hash(value, hash3) {
    hash3 ??= this._hash(value);
    let unconstrained = Unconstrained.witness(() => Provable.toConstant(this.innerProvable, value));
    return new this(hash3, unconstrained);
  }
  /**
   * Unwrap a value from its hashed variant.
   */
  unhash() {
    let value = Provable.witness(this.Constructor.innerProvable, () => this.value.get());
    let hash3 = this.Constructor._hash(value);
    this.hash.assertEquals(hash3);
    return value;
  }
  toFields() {
    return [this.hash];
  }
  get Constructor() {
    return this.constructor;
  }
  static get innerProvable() {
    assert3(this._innerProvable !== void 0, "Hashed not initialized");
    return this._innerProvable;
  }
};

// dist/node/lib/provable/gadgets/elliptic-curve.js
var EllipticCurve = {
  add: add2,
  double,
  negate: negate2,
  assertOnCurve,
  scale,
  assertInSubgroup,
  multiScalarMul
};
function add2(p1, p22, Curve) {
  let { x: x1, y: y1 } = p1;
  let { x: x2, y: y2 } = p22;
  let f = Curve.modulus;
  let [f0, f1, f2] = split(f);
  let [, , fx22] = split(f * 2n);
  if (Point.isConstant(p1) && Point.isConstant(p22)) {
    let p3 = affineAdd(Point.toBigint(p1), Point.toBigint(p22), f);
    return Point.from(p3);
  }
  assert3(Curve.modulus > l2Mask + 1n, "Base field moduli smaller than 2^176 are not supported");
  let witnesses = exists(9, () => {
    let [x1_, x2_, y1_, y2_] = Field32.toBigints(x1, x2, y1, y2);
    let denom = inverse(mod(x1_ - x2_, f), f) ?? 0n;
    let m3 = mod((y1_ - y2_) * denom, f);
    let x33 = mod(m3 * m3 - x1_ - x2_, f);
    let y33 = mod(m3 * (x1_ - x33) - y1_, f);
    return [...split(m3), ...split(x33), ...split(y33)];
  });
  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;
  let m = [m0, m1, m2];
  let x3 = [x30, x31, x32];
  let y3 = [y30, y31, y32];
  ForeignField.assertAlmostReduced([m, x3, y3], f);
  let deltaX = ForeignField.sub(x1, x2, f);
  let deltaX01 = deltaX[0].add(deltaX[1].mul(1n << l)).seal();
  assertNotVectorEquals([deltaX01, deltaX[2]], [0n, 0n]);
  assertNotVectorEquals([deltaX01, deltaX[2]], [f0 + (f1 << l), f2]);
  deltaX[2].assertNotEquals(fx22);
  let deltaY = ForeignField.Sum(y1).sub(y2);
  ForeignField.assertMul(deltaX, m, deltaY, f);
  let xSum = ForeignField.Sum(x1).add(x2).add(x3);
  ForeignField.assertMul(m, m, xSum, f);
  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);
  let ySum = ForeignField.Sum(y1).add(y3);
  ForeignField.assertMul(deltaX1X3, m, ySum, f);
  return { x: x3, y: y3 };
}
function double(p1, Curve) {
  let { x: x1, y: y1 } = p1;
  let f = Curve.modulus;
  if (Point.isConstant(p1)) {
    let p3 = affineDouble(Point.toBigint(p1), f);
    return Point.from(p3);
  }
  let witnesses = exists(9, () => {
    let [x1_, y1_] = Field32.toBigints(x1, y1);
    let denom = inverse(mod(2n * y1_, f), f) ?? 0n;
    let m3 = mod(3n * mod(x1_ ** 2n, f) * denom, f);
    let x33 = mod(m3 * m3 - 2n * x1_, f);
    let y33 = mod(m3 * (x1_ - x33) - y1_, f);
    return [...split(m3), ...split(x33), ...split(y33)];
  });
  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;
  let m = [m0, m1, m2];
  let x3 = [x30, x31, x32];
  let y3 = [y30, y31, y32];
  ForeignField.assertAlmostReduced([m, x3, y3], f);
  let x1x1 = ForeignField.mul(x1, x1, f);
  let y1Times2 = ForeignField.Sum(y1).add(y1);
  let x1x1Times3PlusA = ForeignField.Sum(x1x1).add(x1x1).add(x1x1);
  if (Curve.a !== 0n)
    x1x1Times3PlusA = x1x1Times3PlusA.add(Field32.from(Curve.a));
  ForeignField.assertMul(y1Times2, m, x1x1Times3PlusA, f);
  let xSum = ForeignField.Sum(x1).add(x1).add(x3);
  ForeignField.assertMul(m, m, xSum, f);
  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);
  let ySum = ForeignField.Sum(y1).add(y3);
  ForeignField.assertMul(deltaX1X3, m, ySum, f);
  return { x: x3, y: y3 };
}
function negate2({ x, y }, Curve) {
  return { x, y: ForeignField.negate(y, Curve.modulus) };
}
function assertOnCurve(p3, { modulus: f, a: a2, b: b2 }) {
  let { x, y } = p3;
  let x2 = ForeignField.mul(x, x, f);
  let y2 = ForeignField.mul(y, y, f);
  let y2MinusB = ForeignField.Sum(y2).sub(Field32.from(b2));
  let x2PlusA = ForeignField.Sum(x2);
  if (a2 !== 0n)
    x2PlusA = x2PlusA.add(Field32.from(a2));
  let message;
  if (Point.isConstant(p3)) {
    message = `assertOnCurve(): (${x}, ${y}) is not on the curve.`;
  }
  ForeignField.assertMul(x2PlusA, x, y2MinusB, f, message);
}
function scale(scalar, point, Curve, config = { mode: "assert-nonzero" }) {
  config.windowSize ??= Point.isConstant(point) ? 4 : 3;
  return multiScalarMul([scalar], [point], Curve, [config], config.mode);
}
function assertInSubgroup(p3, Curve) {
  if (!Curve.hasCofactor)
    return;
  scale(Field32.from(Curve.order), p3, Curve, { mode: "assert-zero" });
}
function equals2(p1, p22, Curve) {
  let xEquals = ForeignField.equals(p1.x, p22.x, Curve.modulus);
  let yEquals = ForeignField.equals(p1.y, p22.y, Curve.modulus);
  return xEquals.and(yEquals);
}
function verifyEcdsaGeneric(Curve, signature, msgHash, publicKey, multiScalarMul2, config = { G: { windowSize: 4 }, P: { windowSize: 4 } }) {
  if (EcdsaSignature.isConstant(signature) && Field32.isConstant(msgHash) && Point.isConstant(publicKey)) {
    let isValid = verifyEcdsaConstant(Curve, EcdsaSignature.toBigint(signature), Field32.toBigint(msgHash), Point.toBigint(publicKey));
    return new Bool3(isValid);
  }
  let { r, s } = signature;
  ForeignField.inv(r, Curve.order);
  let sInv = ForeignField.inv(s, Curve.order);
  let u1 = ForeignField.mul(msgHash, sInv, Curve.order);
  let u2 = ForeignField.mul(r, sInv, Curve.order);
  let G = Point.from(Curve.one);
  let R = multiScalarMul2([u1, u2], [G, publicKey], Curve, config && [config.G, config.P], "assert-nonzero", config?.ia);
  let Rx = ForeignField.mul(R.x, Field32.from(1n), Curve.order);
  ForeignField.assertLessThan(Rx, Curve.order);
  return Provable.equal(Field32, Rx, r);
}
function verifyEcdsa(Curve, signature, msgHash, publicKey, config = { G: { windowSize: 4 }, P: { windowSize: 4 } }) {
  return verifyEcdsaGeneric(Curve, signature, msgHash, publicKey, (scalars, points, Curve2, configs, mode, ia) => multiScalarMul(scalars, points, Curve2, configs, mode, ia, true), config);
}
function verifyEcdsaV2(Curve, signature, msgHash, publicKey, config = { G: { windowSize: 4 }, P: { windowSize: 3 } }) {
  return verifyEcdsaGeneric(Curve, signature, msgHash, publicKey, (scalars, points, Curve2, configs, mode, ia) => multiScalarMul(scalars, points, Curve2, configs, mode, ia, false), config);
}
function verifyEcdsaConstant(Curve, { r, s }, msgHash, publicKey) {
  let pk = Curve.from(publicKey);
  if (Curve.equal(pk, Curve.zero))
    return false;
  if (Curve.hasCofactor && !Curve.isInSubgroup(pk))
    return false;
  if (r < 1n || r >= Curve.order)
    return false;
  if (s < 1n || s >= Curve.order)
    return false;
  let sInv = Curve.Scalar.inverse(s);
  assert3(sInv !== void 0);
  let u1 = Curve.Scalar.mul(msgHash, sInv);
  let u2 = Curve.Scalar.mul(r, sInv);
  let R = Curve.add(Curve.scale(Curve.one, u1), Curve.scale(pk, u2));
  if (Curve.equal(R, Curve.zero))
    return false;
  return Curve.Scalar.equal(R.x, r);
}
function multiScalarMulConstant(scalars, points, Curve, mode = "assert-nonzero") {
  let n = points.length;
  assert3(scalars.length === n, "Points and scalars lengths must match");
  assertPositiveInteger(n, "Expected at least 1 point and scalar");
  let useGlv = Curve.hasEndomorphism;
  let s = scalars.map(Field32.toBigint);
  let P = points.map(Point.toBigint);
  let sum2 = Curve.zero;
  for (let i = 0; i < n; i++) {
    if (useGlv) {
      sum2 = Curve.add(sum2, Curve.Endo.scale(P[i], s[i]));
    } else {
      sum2 = Curve.add(sum2, Curve.scale(P[i], s[i]));
    }
  }
  if (mode === "assert-zero") {
    assert3(sum2.infinity, "scalar multiplication: expected zero result");
    return Point.from(Curve.zero);
  }
  assert3(!sum2.infinity, "scalar multiplication: expected non-zero result");
  return Point.from(sum2);
}
function multiScalarMul(scalars, points, Curve, tableConfigs = [], mode = "assert-nonzero", ia, hashed = true) {
  let n = points.length;
  assert3(scalars.length === n, "Points and scalars lengths must match");
  assertPositiveInteger(n, "Expected at least 1 point and scalar");
  let useGlv = Curve.hasEndomorphism;
  if (scalars.every(Field32.isConstant) && points.every(Point.isConstant)) {
    return multiScalarMulConstant(scalars, points, Curve, mode);
  }
  let windowSizes = points.map((_, i) => tableConfigs[i]?.windowSize ?? 1);
  let tables = points.map((P, i) => getPointTable(Curve, P, windowSizes[i], tableConfigs[i]?.multiples));
  let maxBits = Curve.Scalar.sizeInBits;
  if (useGlv) {
    maxBits = Curve.Endo.decomposeMaxBits;
    let n2 = 2 * n;
    let scalars2 = Array(n2);
    let points2 = Array(n2);
    let windowSizes2 = Array(n2);
    let tables2 = Array(n2);
    let mrcStack = [];
    for (let i = 0; i < n; i++) {
      let [s0, s1] = decomposeNoRangeCheck(Curve, scalars[i]);
      scalars2[2 * i] = s0.abs;
      scalars2[2 * i + 1] = s1.abs;
      let table = tables[i];
      let endoTable = table.map((P, i2) => {
        if (i2 === 0)
          return P;
        let [phiP, betaXBound] = endomorphism2(Curve, P);
        mrcStack.push(betaXBound);
        return phiP;
      });
      tables2[2 * i] = table.map((P) => negateIf(s0.isNegative, P, Curve.modulus));
      tables2[2 * i + 1] = endoTable.map((P) => negateIf(s1.isNegative, P, Curve.modulus));
      points2[2 * i] = tables2[2 * i][1];
      points2[2 * i + 1] = tables2[2 * i + 1][1];
      windowSizes2[2 * i] = windowSizes2[2 * i + 1] = windowSizes[i];
    }
    reduceMrcStack(mrcStack);
    points = points2;
    tables = tables2;
    scalars = scalars2;
    windowSizes = windowSizes2;
    n = n2;
  }
  let scalarChunks = scalars.map((s, i) => sliceField3(s, { maxBits, chunkSize: windowSizes[i] }));
  const HashedPoint = Hashed.create(Point);
  ia ??= initialAggregator(Curve);
  let sum2 = Point.from(ia);
  let hashedTables = [];
  if (hashed) {
    hashedTables = tables.map((table) => table.map((point) => HashedPoint.hash(point)));
  }
  for (let i = maxBits - 1; i >= 0; i--) {
    for (let j = 0; j < n; j++) {
      let windowSize = windowSizes[j];
      if (i % windowSize === 0) {
        let sj = scalarChunks[j][i / windowSize];
        let sjP;
        if (hashed) {
          sjP = windowSize === 1 ? points[j] : arrayGetGeneric(HashedPoint, hashedTables[j], sj).unhash();
        } else {
          sjP = windowSize === 1 ? points[j] : arrayGetGeneric(Point, tables[j], sj);
        }
        let added = add2(sum2, sjP, Curve);
        sum2 = Provable.if(sj.equals(0), Point, sum2, added);
      }
    }
    if (i === 0)
      break;
    sum2 = double(sum2, Curve);
  }
  let iaFinal = Curve.scale(Curve.fromNonzero(ia), 1n << BigInt(maxBits - 1));
  let isZero = equals2(sum2, iaFinal, Curve);
  if (mode === "assert-nonzero") {
    isZero.assertFalse();
    sum2 = add2(sum2, Point.from(Curve.negate(iaFinal)), Curve);
  } else {
    isZero.assertTrue();
    sum2 = Point.from(Curve.zero);
  }
  return sum2;
}
function negateIf(condition, P, f) {
  let y = Provable.if(Bool3.Unsafe.fromField(condition), Field32, ForeignField.negate(P.y, f), P.y);
  return { x: P.x, y };
}
function endomorphism2(Curve, P) {
  let beta = Field32.from(Curve.Endo.base);
  let betaX = ForeignField.mul(beta, P.x, Curve.modulus);
  return [{ x: betaX, y: P.y }, weakBound(betaX[2], Curve.modulus)];
}
function decomposeNoRangeCheck(Curve, s) {
  assert3(Curve.Endo.decomposeMaxBits < l2, "decomposed scalars assumed to be < 2*88 bits");
  let witnesses = exists(6, () => {
    let [s02, s12] = Curve.Endo.decompose(Field32.toBigint(s));
    let [s002, s012] = split(s02.abs);
    let [s102, s112] = split(s12.abs);
    return [
      s02.isNegative ? 1n : 0n,
      s002,
      s012,
      s12.isNegative ? 1n : 0n,
      s102,
      s112
    ];
  });
  let [s0Negative, s00, s01, s1Negative, s10, s11] = witnesses;
  let s0 = [s00, s01, Field3.from(0n)];
  let s1 = [s10, s11, Field3.from(0n)];
  s0Negative.assertBool();
  s1Negative.assertBool();
  let lambda = Provable.if(Bool3.Unsafe.fromField(s1Negative), Field32, Field32.from(Curve.Scalar.negate(Curve.Endo.scalar)), Field32.from(Curve.Endo.scalar));
  let rhs = Provable.if(Bool3.Unsafe.fromField(s0Negative), Field32, ForeignField.Sum(s).add(s0).finish(Curve.order), ForeignField.Sum(s).sub(s0).finish(Curve.order));
  ForeignField.assertMul(s1, lambda, rhs, Curve.order);
  return [
    { isNegative: s0Negative, abs: s0 },
    { isNegative: s1Negative, abs: s1 }
  ];
}
function signEcdsa(Curve, msgHash, privateKey) {
  let { Scalar: Scalar4 } = Curve;
  let k = Scalar4.random();
  let R = Curve.scale(Curve.one, k);
  let r = Scalar4.mod(R.x);
  let kInv = Scalar4.inverse(k);
  assert3(kInv !== void 0);
  let s = Scalar4.mul(kInv, Scalar4.add(msgHash, Scalar4.mul(r, privateKey)));
  return { r, s };
}
function getPointTable(Curve, P, windowSize, table) {
  assertPositiveInteger(windowSize, "invalid window size");
  let n = 1 << windowSize;
  assert3(table === void 0 || table.length === n, "invalid table");
  if (table !== void 0)
    return table;
  table = [Point.from(Curve.zero), P];
  if (n === 2)
    return table;
  let Pi = double(P, Curve);
  table.push(Pi);
  for (let i = 3; i < n; i++) {
    Pi = add2(Pi, P, Curve);
    table.push(Pi);
  }
  return table;
}
function initialAggregator(Curve) {
  let h = import_js_sha2562.sha256.create();
  h.update("initial-aggregator");
  h.update(bigIntToBytes(Curve.modulus));
  h.update(bigIntToBytes(Curve.order));
  h.update(bigIntToBytes(Curve.a));
  h.update(bigIntToBytes(Curve.b));
  let bytes = h.array();
  const F = Curve.Field;
  let x = F.mod(bytesToBigInt(bytes));
  return simpleMapToCurve(x, Curve);
}
function random(Curve) {
  let x = Curve.Field.random();
  return simpleMapToCurve(x, Curve);
}
function simpleMapToCurve(x, Curve) {
  const F = Curve.Field;
  let y = void 0;
  while (y === void 0) {
    x = F.add(x, 1n);
    let x3 = F.mul(F.square(x), x);
    let y2 = F.add(x3, F.mul(Curve.a, x) + Curve.b);
    y = F.sqrt(y2);
  }
  let p3 = { x, y, infinity: false };
  if (Curve.hasCofactor) {
    p3 = Curve.scale(p3, Curve.cofactor);
  }
  return p3;
}
function arrayGetGeneric(type, array, index) {
  type = ProvableType.get(type);
  let a2 = Provable.witness(type, () => array[Number(index)]);
  let aFields = type.toFields(a2);
  let size = type.sizeInFields();
  let arrays = array.map(type.toFields);
  for (let j = 0; j < size; j++) {
    let arrayFieldsJ = arrays.map((x) => x[j]);
    arrayGet(arrayFieldsJ, index).assertEquals(aFields[j]);
  }
  return a2;
}
var Point = {
  from({ x, y }) {
    return { x: Field32.from(x), y: Field32.from(y) };
  },
  toBigint({ x, y }) {
    return { x: Field32.toBigint(x), y: Field32.toBigint(y), infinity: false };
  },
  isConstant: (P) => Provable.isConstant(Point, P),
  /**
   * Random point on the curve.
   */
  random(Curve) {
    return Point.from(random(Curve));
  },
  provable: provable({ x: Field32, y: Field32 })
};
var EcdsaSignature = {
  from({ r, s }) {
    return { r: Field32.from(r), s: Field32.from(s) };
  },
  toBigint({ r, s }) {
    return { r: Field32.toBigint(r), s: Field32.toBigint(s) };
  },
  isConstant: (S) => Provable.isConstant(EcdsaSignature, S),
  /**
   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in
   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).
   */
  fromHex(rawSignature) {
    let prefix = rawSignature.slice(0, 2);
    let signature = rawSignature.slice(2, 130);
    if (prefix !== "0x" || signature.length < 128) {
      throw Error(`Signature.fromHex(): Invalid signature, expected hex string 0x... of length at least 130.`);
    }
    let r = BigInt(`0x${signature.slice(0, 64)}`);
    let s = BigInt(`0x${signature.slice(64)}`);
    return EcdsaSignature.from({ r, s });
  },
  provable: provable({ r: Field32, s: Field32 })
};
var Ecdsa = {
  sign: signEcdsa,
  verify: verifyEcdsa,
  verifyV2: verifyEcdsaV2,
  Signature: EcdsaSignature
};
function reduceMrcStack(xs) {
  let n = xs.length;
  let nRemaining = n % 3;
  let nFull = (n - nRemaining) / 3;
  for (let i = 0; i < nFull; i++) {
    multiRangeCheck([xs[3 * i], xs[3 * i + 1], xs[3 * i + 2]]);
  }
  let remaining = [Field3.from(0n), Field3.from(0n), Field3.from(0n)];
  for (let i = 0; i < nRemaining; i++) {
    remaining[i] = xs[3 * nFull + i];
  }
  multiRangeCheck(remaining);
}

// dist/node/lib/provable/crypto/foreign-curve.js
function toPoint({ x, y }) {
  return { x: x.value, y: y.value };
}
var ForeignCurve = class {
  /**
   * Create a new {@link ForeignCurve} from an object representing the (affine) x and y coordinates.
   *
   * @example
   * ```ts
   * let x = new ForeignCurve({ x: 1n, y: 1n });
   * ```
   *
   * **Important**: By design, there is no way for a `ForeignCurve` to represent the zero point.
   *
   * **Warning**: This fails for a constant input which does not represent an actual point on the curve.
   */
  constructor(g) {
    this.x = new this.Constructor.Field(g.x);
    this.y = new this.Constructor.Field(g.y);
    if (this.isConstant()) {
      this.assertOnCurve();
      this.assertInSubgroup();
    }
  }
  /**
   * Coerce the input to a {@link ForeignCurve}.
   */
  static from(g) {
    if (g instanceof this)
      return g;
    return new this(g);
  }
  /**
   * The constant generator point.
   */
  static get generator() {
    return new this(this.Bigint.one);
  }
  /**
   * The size of the curve's base field.
   */
  static get modulus() {
    return this.Bigint.modulus;
  }
  /**
   * The size of the curve's base field.
   */
  get modulus() {
    return this.Constructor.Bigint.modulus;
  }
  /**
   * Checks whether this curve point is constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   */
  isConstant() {
    return Provable.isConstant(this.Constructor, this);
  }
  /**
   * Convert this curve point to a point with bigint coordinates.
   */
  toBigint() {
    return this.Constructor.Bigint.fromNonzero({
      x: this.x.toBigInt(),
      y: this.y.toBigInt()
    });
  }
  /**
   * Elliptic curve addition.
   *
   * ```ts
   * let r = p.add(q); // r = p + q
   * ```
   *
   * **Important**: this is _incomplete addition_ and does not handle the degenerate cases:
   * - Inputs are equal, `g = h` (where you would use {@link double}).
   *   In this case, the result of this method is garbage and can be manipulated arbitrarily by a malicious prover.
   * - Inputs are inverses of each other, `g = -h`, so that the result would be the zero point.
   *   In this case, the proof fails.
   *
   * If you want guaranteed soundness regardless of the input, use {@link addSafe} instead.
   *
   * @throws if the inputs are inverses of each other.
   */
  add(h) {
    let Curve = this.Constructor.Bigint;
    let h_ = this.Constructor.from(h);
    let p3 = EllipticCurve.add(toPoint(this), toPoint(h_), Curve);
    return new this.Constructor(p3);
  }
  /**
   * Safe elliptic curve addition.
   *
   * This is the same as {@link add}, but additionally proves that the inputs are not equal.
   * Therefore, the method is guaranteed to either fail or return a valid addition result.
   *
   * **Beware**: this is more expensive than {@link add}, and is still incomplete in that
   * it does not succeed on equal or inverse inputs.
   *
   * @throws if the inputs are equal or inverses of each other.
   */
  addSafe(h) {
    let h_ = this.Constructor.from(h);
    let x1 = this.x.assertCanonical();
    let x2 = h_.x.assertCanonical();
    x1.equals(x2).assertFalse();
    return this.add(h_);
  }
  /**
   * Elliptic curve doubling.
   *
   * @example
   * ```ts
   * let r = p.double(); // r = 2 * p
   * ```
   */
  double() {
    let Curve = this.Constructor.Bigint;
    let p3 = EllipticCurve.double(toPoint(this), Curve);
    return new this.Constructor(p3);
  }
  /**
   * Elliptic curve negation.
   *
   * @example
   * ```ts
   * let r = p.negate(); // r = -p
   * ```
   */
  negate() {
    return new this.Constructor({ x: this.x, y: this.y.neg() });
  }
  /**
   * Elliptic curve scalar multiplication, where the scalar is represented as a {@link ForeignField} element.
   *
   * **Important**: this proves that the result of the scalar multiplication is not the zero point.
   *
   * @throws if the scalar multiplication results in the zero point; for example, if the scalar is zero.
   *
   * @example
   * ```ts
   * let r = p.scale(s); // r = s * p
   * ```
   */
  scale(scalar) {
    let Curve = this.Constructor.Bigint;
    let scalar_ = this.Constructor.Scalar.from(scalar);
    let p3 = EllipticCurve.scale(scalar_.value, toPoint(this), Curve);
    return new this.Constructor(p3);
  }
  static assertOnCurve(g) {
    EllipticCurve.assertOnCurve(toPoint(g), this.Bigint);
  }
  /**
   * Assert that this point lies on the elliptic curve, which means it satisfies the equation
   * `y^2 = x^3 + ax + b`
   */
  assertOnCurve() {
    this.Constructor.assertOnCurve(this);
  }
  static assertInSubgroup(g) {
    if (this.Bigint.hasCofactor) {
      EllipticCurve.assertInSubgroup(toPoint(g), this.Bigint);
    }
  }
  /**
   * Assert that this point lies in the subgroup defined by `order*P = 0`.
   *
   * Note: this is a no-op if the curve has cofactor equal to 1. Otherwise
   * it performs the full scalar multiplication `order*P` and is expensive.
   */
  assertInSubgroup() {
    this.Constructor.assertInSubgroup(this);
  }
  /**
   * Check that this is a valid element of the target subgroup of the curve:
   * - Check that the coordinates are valid field elements
   * - Use {@link assertOnCurve()} to check that the point lies on the curve
   * - If the curve has cofactor unequal to 1, use {@link assertInSubgroup()}.
   */
  static check(g) {
    this.Field.assertAlmostReduced(g.x, g.y);
    this.assertOnCurve(g);
    this.assertInSubgroup(g);
  }
  // dynamic subclassing infra
  get Constructor() {
    return this.constructor;
  }
  /**
   * Curve arithmetic on JS bigints.
   */
  static get Bigint() {
    assert3(this._Bigint !== void 0, "ForeignCurve not initialized");
    return this._Bigint;
  }
  /**
   * The base field of this curve as a {@link ForeignField}.
   */
  static get Field() {
    assert3(this._Field !== void 0, "ForeignCurve not initialized");
    return this._Field;
  }
  /**
   * The scalar field of this curve as a {@link ForeignField}.
   */
  static get Scalar() {
    assert3(this._Scalar !== void 0, "ForeignCurve not initialized");
    return this._Scalar;
  }
  /**
   * `Provable<ForeignCurve>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "ForeignCurve not initialized");
    return this._provable;
  }
};
var ForeignCurveV2 = class extends ForeignCurve {
  constructor(g) {
    super(g);
  }
  static check(g) {
    multiRangeCheck(g.x.value);
    multiRangeCheck(g.y.value);
    this.Field.assertAlmostReduced(g.x, g.y);
    this.assertOnCurve(g);
    this.assertInSubgroup(g);
  }
};
function createForeignCurve(params) {
  assert3(params.modulus > l2Mask + 1n, "Base field moduli smaller than 2^176 are not supported");
  const FieldUnreduced = createForeignField(params.modulus);
  const ScalarUnreduced = createForeignField(params.order);
  class Field5 extends FieldUnreduced.AlmostReduced {
  }
  class Scalar4 extends ScalarUnreduced.AlmostReduced {
  }
  const BigintCurve = createCurveAffine(params);
  class Curve extends ForeignCurve {
  }
  Curve._Bigint = BigintCurve;
  Curve._Field = Field5;
  Curve._Scalar = Scalar4;
  Curve._provable = provableFromClass(Curve, { x: Field5, y: Field5 });
  return Curve;
}
function createForeignCurveV2(params) {
  assert3(params.modulus > l2Mask + 1n, "Base field moduli smaller than 2^176 are not supported");
  const FieldUnreduced = createForeignField(params.modulus);
  const ScalarUnreduced = createForeignField(params.order);
  class Field5 extends FieldUnreduced.AlmostReduced {
  }
  class Scalar4 extends ScalarUnreduced.AlmostReduced {
  }
  const BigintCurve = createCurveAffine(params);
  class Curve extends ForeignCurveV2 {
  }
  Curve._Bigint = BigintCurve;
  Curve._Field = Field5;
  Curve._Scalar = Scalar4;
  Curve._provable = provableFromClass(Curve, { x: Field5, y: Field5 });
  return Curve;
}

// dist/node/lib/provable/crypto/keccak.js
var Keccak = {
  /**
   * Implementation of [NIST SHA-3](https://csrc.nist.gov/pubs/fips/202/final) Hash Function.
   * Supports output lengths of 256, 384, or 512 bits.
   *
   * Applies the SHA-3 hash function to a list of big-endian byte-sized {@link Field} elements, flexible to handle varying output lengths (256, 384, 512 bits) as specified.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   * Both input and output bytes are big-endian.
   *
   * @param len - Desired output length in bits. Valid options: 256, 384, 512.
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest256 = Keccak.nistSha3(256, preimage);
   * let digest384 = Keccak.nistSha3(384, preimage);
   * let digest512 = Keccak.nistSha3(512, preimage);
   * ```
   *
   */
  nistSha3(len, message) {
    return nistSha3(len, Bytes2.from(message));
  },
  /**
   * Ethereum-Compatible Keccak-256 Hash Function.
   * This is a specialized variant of {@link Keccak.preNist} configured for a 256-bit output length.
   *
   * Primarily used in Ethereum for hashing transactions, messages, and other types of payloads.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} of length 32. Both input and output bytes are big-endian.
   *
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest = Keccak.ethereum(preimage);
   * ```
   */
  ethereum(message) {
    return ethereum(Bytes2.from(message));
  },
  /**
   * Implementation of [pre-NIST Keccak](https://keccak.team/keccak.html) hash function.
   * Supports output lengths of 256, 384, or 512 bits.
   *
   * Keccak won the SHA-3 competition and was slightly altered before being standardized as SHA-3 by NIST in 2015.
   * This variant was used in Ethereum before the NIST standardization, by specifying `len` as 256 bits you can obtain the same hash function as used by Ethereum {@link Keccak.ethereum}.
   *
   * The function applies the pre-NIST Keccak hash function to a list of byte-sized {@link Field} elements and is flexible to handle varying output lengths (256, 384, 512 bits) as specified.
   *
   * {@link Keccak.preNist} accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   * Both input and output bytes are big-endian.
   *
   * @param len - Desired output length in bits. Valid options: 256, 384, 512.
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest256 = Keccak.preNist(256, preimage);
   * let digest384 = Keccak.preNist(384, preimage);
   * let digest512= Keccak.preNist(512, preimage);
   * ```
   *
   */
  preNist(len, message) {
    return preNist(len, Bytes2.from(message));
  }
};
var KECCAK_DIM = 5;
var KECCAK_ELL = 6;
var KECCAK_WORD = 2 ** KECCAK_ELL;
var BYTES_PER_WORD = KECCAK_WORD / 8;
var KECCAK_STATE_LENGTH_WORDS = KECCAK_DIM ** 2;
var KECCAK_STATE_LENGTH = KECCAK_STATE_LENGTH_WORDS * KECCAK_WORD;
var KECCAK_STATE_LENGTH_BYTES = KECCAK_STATE_LENGTH / 8;
var ROT_TABLE = [
  [0, 36, 3, 41, 18],
  [1, 44, 10, 45, 2],
  [62, 6, 43, 15, 61],
  [28, 55, 25, 21, 56],
  [27, 20, 39, 8, 14]
];
var ROUND_CONSTANTS = [
  0x0000000000000001n,
  0x0000000000008082n,
  0x800000000000808an,
  0x8000000080008000n,
  0x000000000000808bn,
  0x0000000080000001n,
  0x8000000080008081n,
  0x8000000000008009n,
  0x000000000000008an,
  0x0000000000000088n,
  0x0000000080008009n,
  0x000000008000000an,
  0x000000008000808bn,
  0x800000000000008bn,
  0x8000000000008089n,
  0x8000000000008003n,
  0x8000000000008002n,
  0x8000000000000080n,
  0x000000000000800an,
  0x800000008000000an,
  0x8000000080008081n,
  0x8000000000008080n,
  0x0000000080000001n,
  0x8000000080008008n
];
function bytesToPad(rate, length) {
  return rate - length % rate;
}
function pad(message, rate, nist) {
  const extraBytes = bytesToPad(rate, message.length);
  const first = nist ? 0x06n : 0x01n;
  const last = 0x80n;
  const pad2 = Array(extraBytes).fill(UInt8.from(0));
  pad2[0] = UInt8.from(first);
  pad2[extraBytes - 1] = pad2[extraBytes - 1].add(last);
  return [...message, ...pad2];
}
var theta = (state3) => {
  const stateA = state3;
  const stateC = stateA.map((row) => row.reduce(xor3));
  const stateD = Array.from({ length: KECCAK_DIM }, (_, i) => xor3(stateC[(i + KECCAK_DIM - 1) % KECCAK_DIM], Gadgets.rotate64(stateC[(i + 1) % KECCAK_DIM], 1, "left")));
  const stateE = stateA.map((row, index) => row.map((elem) => xor3(elem, stateD[index])));
  return stateE;
};
function piRho(state3) {
  const stateE = state3;
  const stateB = State.zeros();
  for (let i = 0; i < KECCAK_DIM; i++) {
    for (let j = 0; j < KECCAK_DIM; j++) {
      stateB[j][(2 * i + 3 * j) % KECCAK_DIM] = Gadgets.rotate64(stateE[i][j], ROT_TABLE[i][j], "left");
    }
  }
  return stateB;
}
function chi(state3) {
  const stateB = state3;
  const stateF = State.zeros();
  for (let i = 0; i < KECCAK_DIM; i++) {
    for (let j = 0; j < KECCAK_DIM; j++) {
      stateF[i][j] = xor3(stateB[i][j], Gadgets.and(
        // We can use unchecked NOT because the length of the input is constrained to be 64 bits thanks to the fact that it is the output of a previous Xor64
        Gadgets.not(stateB[(i + 1) % KECCAK_DIM][j], KECCAK_WORD, false),
        stateB[(i + 2) % KECCAK_DIM][j],
        KECCAK_WORD
      ));
    }
  }
  return stateF;
}
function iota(state3, rc) {
  const stateG = state3;
  stateG[0][0] = xor3(stateG[0][0], Field3.from(rc));
  return stateG;
}
function round(state3, rc) {
  const stateA = state3;
  const stateE = theta(stateA);
  const stateB = piRho(stateE);
  const stateF = chi(stateB);
  const stateD = iota(stateF, rc);
  return stateD;
}
function permutation(state3, rcs) {
  return rcs.reduce((state4, rc) => round(state4, rc), state3);
}
function absorb(paddedMessage, capacity, rate, rc) {
  assert2(rate + capacity === KECCAK_STATE_LENGTH_WORDS, `invalid rate or capacity (rate + capacity should be ${KECCAK_STATE_LENGTH_WORDS})`);
  assert2(paddedMessage.length % rate === 0, "invalid padded message length (should be multiple of rate)");
  let state3 = State.zeros();
  const zeros = Array(capacity).fill(Field3.from(0));
  for (let idx = 0; idx < paddedMessage.length; idx += rate) {
    const block = paddedMessage.slice(idx, idx + rate);
    const paddedBlock = block.concat(zeros);
    const blockState = State.fromWords(paddedBlock);
    const stateXor = State.xor(state3, blockState);
    state3 = permutation(stateXor, rc);
  }
  return state3;
}
function squeeze(state3, length, rate) {
  const squeezes = Math.floor(length / rate) + 1;
  assert2(squeezes === 1, "squeezes should be 1");
  const words = State.toWords(state3);
  const hashed = words.slice(0, length);
  return hashed;
}
function sponge(paddedMessage, length, capacity, rate) {
  assert2(paddedMessage.length % rate === 0, "Invalid padded message length");
  const state3 = absorb(paddedMessage, capacity, rate, ROUND_CONSTANTS);
  const hashed = squeeze(state3, length, rate);
  return hashed;
}
function hash(message, length, capacity, nistVersion) {
  assert2(capacity > 0, "capacity must be positive");
  assert2(capacity < KECCAK_STATE_LENGTH_BYTES, `capacity must be less than ${KECCAK_STATE_LENGTH_BYTES}`);
  assert2(length > 0, "length must be positive");
  assert2(capacity % BYTES_PER_WORD === 0, "length must be a multiple of 8");
  capacity /= BYTES_PER_WORD;
  assert2(length % BYTES_PER_WORD === 0, "length must be a multiple of 8");
  length /= BYTES_PER_WORD;
  const rate = KECCAK_STATE_LENGTH_WORDS - capacity;
  const paddedBytes = pad(message.bytes, rate * BYTES_PER_WORD, nistVersion);
  const padded = bytesToWords(paddedBytes);
  const hash3 = sponge(padded, length, capacity, rate);
  const hashBytes = wordsToBytes(hash3);
  return hashBytes;
}
function nistSha3(len, message) {
  let bytes = hash(message, len / 8, len / 4, true);
  return BytesOfBitlength[len].from(bytes);
}
function preNist(len, message) {
  let bytes = hash(message, len / 8, len / 4, false);
  return BytesOfBitlength[len].from(bytes);
}
function ethereum(message) {
  return preNist(256, message);
}
var State = {
  /**
   * Create a state of all zeros
   */
  zeros() {
    return Array.from(Array(KECCAK_DIM), (_) => Array(KECCAK_DIM).fill(Field3.from(0)));
  },
  /**
   * Flatten state to words
   */
  toWords(state3) {
    const words = Array(KECCAK_STATE_LENGTH_WORDS);
    for (let j = 0; j < KECCAK_DIM; j++) {
      for (let i = 0; i < KECCAK_DIM; i++) {
        words[KECCAK_DIM * j + i] = state3[i][j];
      }
    }
    return words;
  },
  /**
   * Compose words to state
   */
  fromWords(words) {
    const state3 = State.zeros();
    for (let j = 0; j < KECCAK_DIM; j++) {
      for (let i = 0; i < KECCAK_DIM; i++) {
        state3[i][j] = words[KECCAK_DIM * j + i];
      }
    }
    return state3;
  },
  /**
   * XOR two states together and return the result
   */
  xor(a2, b2) {
    assert2(a2.length === KECCAK_DIM && a2[0].length === KECCAK_DIM, `invalid \`a\` dimensions (should be ${KECCAK_DIM})`);
    assert2(b2.length === KECCAK_DIM && b2[0].length === KECCAK_DIM, `invalid \`b\` dimensions (should be ${KECCAK_DIM})`);
    return a2.map((row, i) => row.map((x, j) => xor3(x, b2[i][j])));
  }
};
var Bytes32 = class extends Bytes2(32) {
};
var Bytes48 = class extends Bytes2(48) {
};
var Bytes64 = class extends Bytes2(64) {
};
var BytesOfBitlength = {
  256: Bytes32,
  384: Bytes48,
  512: Bytes64
};
function xor3(x, y) {
  if (x.isConstant() && x.toBigInt() === 0n)
    return y;
  if (y.isConstant() && y.toBigInt() === 0n)
    return x;
  return Gadgets.xor(x, y, 64);
}

// dist/node/lib/provable/crypto/foreign-ecdsa.js
var EcdsaSignature2 = class {
  /**
   * Create a new {@link EcdsaSignature} from an object containing the scalars r and s.
   * @param signature
   */
  constructor(signature) {
    this.r = new this.Constructor.Curve.Scalar(signature.r);
    this.s = new this.Constructor.Curve.Scalar(signature.s);
  }
  /**
   * Coerce the input to a {@link EcdsaSignature}.
   */
  static from(signature) {
    if (signature instanceof this)
      return signature;
    return new this(signature);
  }
  /**
   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in
   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).
   */
  static fromHex(rawSignature) {
    let s = Ecdsa.Signature.fromHex(rawSignature);
    return new this(s);
  }
  /**
   * Convert this signature to an object with bigint fields.
   */
  toBigInt() {
    return { r: this.r.toBigInt(), s: this.s.toBigInt() };
  }
  /**
   * @deprecated There is a security vulnerability in this method. Use {@link verifyV2} instead.
   */
  verify(message, publicKey) {
    let msgHashBytes = Keccak.ethereum(message);
    let msgHash = keccakOutputToScalar(msgHashBytes, this.Constructor.Curve);
    return this.verifySignedHash(msgHash, publicKey);
  }
  /**
   * Verify the ECDSA signature given the message (an array of bytes) and public key (a {@link Curve} point).
   *
   * **Important:** This method returns a {@link Bool} which indicates whether the signature is valid.
   * So, to actually prove validity of a signature, you need to assert that the result is true.
   *
   * @throws if one of the signature scalars is zero or if the public key is not on the curve.
   *
   * @example
   * ```ts
   * // create classes for your curve
   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
   * class Scalar extends Secp256k1.Scalar {}
   * class Ecdsa extends createEcdsa(Secp256k1) {}
   *
   * let message = 'my message';
   * let messageBytes = new TextEncoder().encode(message);
   *
   * // outside provable code: create inputs
   * let privateKey = Scalar.random();
   * let publicKey = Secp256k1.generator.scale(privateKey);
   * let signature = Ecdsa.sign(messageBytes, privateKey.toBigInt());
   *
   * // ...
   * // in provable code: create input witnesses (or use method inputs, or constants)
   * let pk = Provable.witness(Secp256k1, () => publicKey);
   * let msg = Provable.witness(Provable.Array(Field, 9), () => messageBytes.map(Field));
   * let sig = Provable.witness(Ecdsa, () => signature);
   *
   * // verify signature
   * let isValid = sig.verify(msg, pk);
   * isValid.assertTrue('signature verifies');
   * ```
   */
  verifyV2(message, publicKey) {
    let msgHashBytes = Keccak.ethereum(message);
    let msgHash = keccakOutputToScalar(msgHashBytes, this.Constructor.Curve);
    return this.verifySignedHashV2(msgHash, publicKey);
  }
  /**
   * @deprecated There is a security vulnerability in this method. Use {@link verifySignedHashV2} instead.
   */
  verifySignedHash(msgHash, publicKey) {
    let msgHash_ = this.Constructor.Curve.Scalar.from(msgHash);
    let publicKey_ = this.Constructor.Curve.from(publicKey);
    return Ecdsa.verify(this.Constructor.Curve.Bigint, toObject(this), msgHash_.value, toPoint(publicKey_));
  }
  /**
   * Verify the ECDSA signature given the message hash (a {@link Scalar}) and public key (a {@link Curve} point).
   *
   * This is a building block of {@link EcdsaSignature.verify}, where the input message is also hashed.
   * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
   * choosing the hashing algorithm.
   */
  verifySignedHashV2(msgHash, publicKey) {
    let msgHash_ = this.Constructor.Curve.Scalar.from(msgHash);
    let publicKey_ = this.Constructor.Curve.from(publicKey);
    return Ecdsa.verifyV2(this.Constructor.Curve.Bigint, toObject(this), msgHash_.value, toPoint(publicKey_));
  }
  /**
   * Create an {@link EcdsaSignature} by signing a message with a private key.
   *
   * Note: This method is not provable, and only takes JS bigints as input.
   */
  static sign(message, privateKey) {
    let msgHashBytes = Keccak.ethereum(message);
    let msgHash = keccakOutputToScalar(msgHashBytes, this.Curve);
    return this.signHash(msgHash.toBigInt(), privateKey);
  }
  /**
   * Create an {@link EcdsaSignature} by signing a message hash with a private key.
   *
   * This is a building block of {@link EcdsaSignature.sign}, where the input message is also hashed.
   * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
   * choosing the hashing algorithm.
   *
   * Note: This method is not provable, and only takes JS bigints as input.
   */
  static signHash(msgHash, privateKey) {
    let { r, s } = Ecdsa.sign(this.Curve.Bigint, msgHash, privateKey);
    return new this({ r, s });
  }
  static check(signature) {
    this.Curve.Scalar.assertAlmostReduced(signature.r, signature.s);
  }
  // dynamic subclassing infra
  get Constructor() {
    return this.constructor;
  }
  /**
   * The {@link ForeignCurve} on which the ECDSA signature is defined.
   */
  static get Curve() {
    assert3(this._Curve !== void 0, "EcdsaSignature not initialized");
    return this._Curve;
  }
  /**
   * `Provable<EcdsaSignature>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "EcdsaSignature not initialized");
    return this._provable;
  }
};
var EcdsaSignatureV2 = class extends EcdsaSignature2 {
  constructor(signature) {
    super(signature);
  }
  static check(signature) {
    multiRangeCheck(signature.r.value);
    multiRangeCheck(signature.s.value);
    this.Curve.Scalar.assertAlmostReduced(signature.r, signature.s);
  }
};
function createEcdsa(curve) {
  let Curve0 = "b" in curve ? createForeignCurve(curve) : curve;
  class Curve extends Curve0 {
  }
  class Signature3 extends EcdsaSignature2 {
  }
  Signature3._Curve = Curve;
  Signature3._provable = provableFromClass(Signature3, {
    r: Curve.Scalar,
    s: Curve.Scalar
  });
  return Signature3;
}
function createEcdsaV2(curve) {
  let Curve0 = "b" in curve ? createForeignCurveV2(curve) : curve;
  class Curve extends Curve0 {
  }
  class Signature3 extends EcdsaSignatureV2 {
  }
  Signature3._Curve = Curve;
  Signature3._provable = provableFromClass(Signature3, {
    r: Curve.Scalar,
    s: Curve.Scalar
  });
  return Signature3;
}
function toObject(signature) {
  return { r: signature.r.value, s: signature.s.value };
}
function keccakOutputToScalar(hash3, Curve) {
  const L_n = Curve.Scalar.sizeInBits;
  assert3(L_n === 256, `Scalar sizes ${L_n} !== 256 not supported`);
  assert3(hash3.length === 32, `hash length ${hash3.length} !== 32 not supported`);
  assert3(l === 88n);
  let x2 = bytesToLimbBE(hash3.bytes.slice(0, 10));
  let x1 = bytesToLimbBE(hash3.bytes.slice(10, 21));
  let x0 = bytesToLimbBE(hash3.bytes.slice(21, 32));
  return new Curve.Scalar.AlmostReduced([x0, x1, x2]);
}
function bytesToLimbBE(bytes_) {
  let bytes = bytes_.map((x) => x.value);
  let n = bytes.length;
  let limb = bytes[0];
  for (let i = 1; i < n; i++) {
    limb = limb.mul(1n << 8n).add(bytes[i]);
  }
  return limb.seal();
}

// dist/node/lib/provable/scalar-field.js
var ScalarField = class _ScalarField extends createForeignField(Fq.modulus) {
  /**
   * Provable method to convert a {@link ScalarField} into a {@link Scalar}
   */
  toScalar() {
    return _ScalarField.toScalar(this);
  }
  static toScalar(field) {
    if (field.modulus !== Fq.modulus) {
      throw new Error("Only ForeignFields with Fq modulus are convertable into a scalar");
    }
    const field3 = field.value;
    const shiftedScalar = field3ToShiftedScalar(field3);
    return Scalar3.fromShiftedScalar(shiftedScalar);
  }
  /**
   * Converts this {@link Scalar} into a {@link ScalarField}
   */
  static fromScalar(s) {
    if (s.lowBit.isConstant() && s.high254.isConstant()) {
      return new _ScalarField(s.toBigInt());
    }
    const field = Provable.witness(_ScalarField, () => s.toBigInt());
    const foreignField = new _ScalarField(field);
    const scalar = foreignField.toScalar();
    Provable.assertEqual(Scalar3, s, scalar);
    return foreignField;
  }
};

// dist/node/lib/provable/crypto/hash.js
var Hash = {
  /**
   * Hashes the given field elements using [Poseidon](https://eprint.iacr.org/2019/458.pdf). Alias for `Poseidon.hash()`.
   *
   * ```ts
   * let hash = Hash.hash([a, b, c]);
   * ```
   *
   * **Important:** This is by far the most efficient hash function o1js has available in provable code.
   * Use it by default, if no compatibility concerns require you to use a different hash function.
   *
   * The Poseidon implementation operates over the native [Pallas base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/)
   * and uses parameters generated specifically for the [Mina](https://minaprotocol.com) blockchain.
   *
   * We use a `rate` of 2, which means that 2 field elements are hashed per permutation.
   * A permutation causes 11 rows in the constraint system.
   *
   * You can find the full set of Poseidon parameters [here](https://github.com/o1-labs/o1js-bindings/blob/main/crypto/constants.ts).
   */
  hash: Poseidon2.hash,
  /**
   * The [Poseidon](https://eprint.iacr.org/2019/458.pdf) hash function.
   *
   * See {@link Hash.hash} for details and usage examples.
   */
  Poseidon: Poseidon2,
  /**
   * The SHA2 hash function with an output length of 256 bits.
   */
  SHA2_256: {
    /**
     * Hashes the given bytes using SHA2-256.
     *
     * This is an alias for `Gadgets.SHA256.hash(bytes)`.\
     * See {@link Gadgets.SHA256.hash} for details and usage examples.
     */
    hash: Gadgets.SHA256.hash
  },
  /**
   * The SHA3 hash function with an output length of 256 bits.
   */
  SHA3_256: {
    /**
     * Hashes the given bytes using SHA3-256.
     *
     * This is an alias for `Keccak.nistSha3(256, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(256, bytes);
    }
  },
  /**
   * The SHA3 hash function with an output length of 384 bits.
   */
  SHA3_384: {
    /**
     * Hashes the given bytes using SHA3-384.
     *
     * This is an alias for `Keccak.nistSha3(384, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(384, bytes);
    }
  },
  /**
   * The SHA3 hash function with an output length of 512 bits.
   */
  SHA3_512: {
    /**
     * Hashes the given bytes using SHA3-512.
     *
     * This is an alias for `Keccak.nistSha3(512, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(512, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 256 bits.
   */
  Keccak256: {
    /**
     * Hashes the given bytes using Keccak-256.
     *
     * This is an alias for `Keccak.preNist(256, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(256, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 384 bits.
   */
  Keccak384: {
    /**
     * Hashes the given bytes using Keccak-384.
     *
     * This is an alias for `Keccak.preNist(384, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(384, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 512 bits.
   */
  Keccak512: {
    /**
     * Hashes the given bytes using Keccak-512.
     *
     * This is an alias for `Keccak.preNist(512, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(512, bytes);
    }
  }
};

// dist/node/lib/provable/crypto/signature.js
var import_tslib4 = require("tslib");

// dist/node/mina-signer/src/signature.js
var import_blakejs = require("blakejs");

// dist/node/mina-signer/src/poseidon-bigint.js
var HashInput2 = createHashInput();
var HashHelpers2 = createHashHelpers(Field, Poseidon);
var { hashWithPrefix: hashWithPrefix2 } = HashHelpers2;
var HashLegacy = createHashHelpers(Field, PoseidonLegacy);
function packToFields2({ fields: fields2 = [], packed = [] }) {
  if (packed.length === 0)
    return fields2;
  let packedBits = [];
  let currentPackedField = 0n;
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField * (1n << BigInt(size)) + field;
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields2.concat(packedBits);
}
function packToFieldsLegacy({ fields: fields2, bits }) {
  let packedFields = [];
  while (bits.length > 0) {
    let fieldBits = bits.splice(0, sizeInBits - 1);
    let field = Field.fromBits(fieldBits);
    packedFields.push(field);
  }
  return fields2.concat(packedFields);
}
var HashInputLegacy = {
  empty() {
    return { fields: [], bits: [] };
  },
  bits(bits) {
    return { fields: [], bits };
  },
  append(input1, input2) {
    return {
      fields: (input1.fields ?? []).concat(input2.fields ?? []),
      bits: (input1.bits ?? []).concat(input2.bits ?? [])
    };
  }
};

// dist/node/mina-signer/src/types.js
var NetworkId = {
  toString(network) {
    return typeof network === "string" ? network : network.custom;
  }
};

// dist/node/mina-signer/src/signature.js
var networkIdMainnet = 0x01n;
var networkIdTestnet = 0x00n;
var BinableSignature = withVersionNumber(record({ r: Field, s: Scalar }, ["r", "s"]), versionNumbers.signature);
var Signature = {
  ...BinableSignature,
  ...base58(BinableSignature, versionBytes.signature),
  toJSON({ r, s }) {
    return {
      field: Field.toJSON(r),
      scalar: Scalar.toJSON(s)
    };
  },
  fromJSON({ field, scalar }) {
    let r = Field.fromJSON(field);
    let s = Scalar.fromJSON(scalar);
    return { r, s };
  },
  dummy() {
    return { r: Field(1), s: Scalar(1) };
  }
};
function signFieldElement(message, privateKey, networkId) {
  return sign2({ fields: [message] }, privateKey, networkId);
}
function verifyFieldElement(signature, message, publicKey, networkId) {
  return verify2(signature, { fields: [message] }, publicKey, networkId);
}
function sign2(message, privateKey, networkId) {
  let publicKey = Group.scale(Group.generatorMina, privateKey);
  let kPrime = deriveNonce(message, publicKey, privateKey, networkId);
  if (Scalar.equal(kPrime, 0n))
    throw Error("sign: derived nonce is 0");
  let { x: rx, y: ry } = Group.scale(Group.generatorMina, kPrime);
  let k = Field.isEven(ry) ? kPrime : Scalar.negate(kPrime);
  let e = hashMessage(message, publicKey, rx, networkId);
  let s = Scalar.add(k, Scalar.mul(e, privateKey));
  return { r: rx, s };
}
function deriveNonce(message, publicKey, privateKey, networkId) {
  let { x, y } = publicKey;
  let d = Field(privateKey);
  let id2 = getNetworkIdHashInput(networkId);
  let input = HashInput2.append(message, {
    fields: [x, y, d],
    packed: [id2]
  });
  let packedInput = packToFields2(input);
  let inputBits = packedInput.map(Field.toBits).flat();
  let inputBytes = bitsToBytes(inputBits);
  let bytes = (0, import_blakejs.blake2b)(Uint8Array.from(inputBytes), void 0, 32);
  bytes[bytes.length - 1] &= 63;
  return Scalar.fromBytes([...bytes]);
}
function hashMessage(message, publicKey, r, networkId) {
  let { x, y } = publicKey;
  let input = HashInput2.append(message, { fields: [x, y, r] });
  return hashWithPrefix2(signaturePrefix(networkId), packToFields2(input));
}
function verify2(signature, message, publicKey, networkId) {
  let { r, s } = signature;
  let pk = PublicKey.toGroup(publicKey);
  let e = hashMessage(message, pk, r, networkId);
  let { scale: scale2, one, sub } = Pallas;
  let R = sub(scale2(one, s), scale2(Group.toProjective(pk), e));
  try {
    let { x: rx, y: ry } = Group.fromProjective(R);
    return Field.isEven(ry) && Field.equal(rx, r);
  } catch {
    return false;
  }
}
var numberToBytePadded = (b2) => b2.toString(2).padStart(8, "0");
function networkIdOfString(n) {
  let l4 = n.length;
  let acc = "";
  for (let i = l4 - 1; i >= 0; i--) {
    let b2 = n.charCodeAt(i);
    let padded = numberToBytePadded(b2);
    acc = acc.concat(padded);
  }
  return [BigInt("0b" + acc), acc.length];
}
function getNetworkIdHashInput(network) {
  let s = NetworkId.toString(network);
  switch (s) {
    case "mainnet":
      return [networkIdMainnet, 8];
    case "testnet":
      return [networkIdTestnet, 8];
    default:
      return networkIdOfString(s);
  }
}
var createCustomPrefix = (prefix) => {
  const maxLength = 20;
  const paddingChar = "*";
  let length = prefix.length;
  if (length <= maxLength) {
    let diff2 = maxLength - length;
    return prefix + paddingChar.repeat(diff2);
  } else {
    return prefix.substring(0, maxLength);
  }
};
var signaturePrefix = (network) => {
  let s = NetworkId.toString(network);
  switch (s) {
    case "mainnet":
      return prefixes.signatureMainnet;
    case "testnet":
      return prefixes.signatureTestnet;
    default:
      return createCustomPrefix(s + "Signature");
  }
};
var zkAppBodyPrefix = (network) => {
  let s = NetworkId.toString(network);
  switch (s) {
    case "mainnet":
      return prefixes.zkappBodyMainnet;
    case "testnet":
      return prefixes.zkappBodyTestnet;
    default:
      return createCustomPrefix(s + "ZkappBody");
  }
};

// dist/node/lib/provable/crypto/signature.js
var PrivateKey2 = class _PrivateKey extends CircuitValue {
  constructor(s) {
    super(s);
  }
  /**
   * Generate a random private key.
   *
   * You can obtain the associated public key via {@link toPublicKey}.
   * And generate signatures via {@link Signature.create}.
   *
   * Note: This uses node or browser built-in APIs to obtain cryptographically strong randomness,
   * and can be safely used to generate a real private key.
   *
   * @returns a new {@link PrivateKey}.
   */
  static random() {
    return new _PrivateKey(Scalar3.random());
  }
  /**
   * Create a random keypair `{ privateKey: PrivateKey, publicKey: PublicKey }`.
   *
   * Note: This uses node or browser built-in APIs to obtain cryptographically strong randomness,
   * and can be safely used to generate a real keypair.
   */
  static randomKeypair() {
    let privateKey = _PrivateKey.random();
    return { privateKey, publicKey: privateKey.toPublicKey() };
  }
  /**
   * Deserializes a list of bits into a {@link PrivateKey}.
   *
   * @param bs a list of {@link Bool}.
   * @returns a {@link PrivateKey}.
   */
  static fromBits(bs) {
    return new _PrivateKey(Scalar3.fromBits(bs));
  }
  /**
   * Convert this {@link PrivateKey} to a bigint
   */
  toBigInt() {
    return this.s.toBigInt();
  }
  /**
   * Create a {@link PrivateKey} from a bigint
   *
   * **Warning**: Private keys should be sampled from secure randomness with sufficient entropy.
   * Be careful that you don't use this method to create private keys that were sampled insecurely.
   */
  static fromBigInt(sk) {
    return new _PrivateKey(Scalar3.from(sk));
  }
  /**
   * Derives the associated public key.
   *
   * @returns a {@link PublicKey}.
   */
  toPublicKey() {
    return PublicKey2.fromPrivateKey(this);
  }
  /**
   * Decodes a base58 string into a {@link PrivateKey}.
   *
   * @returns a {@link PrivateKey}.
   */
  static fromBase58(privateKeyBase58) {
    let scalar = PrivateKey.fromBase58(privateKeyBase58);
    return new _PrivateKey(Scalar3.from(scalar));
  }
  /**
   * Encodes a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  toBase58() {
    return _PrivateKey.toBase58(this);
  }
  // static version, to operate on non-class versions of this type
  /**
   * Static method to encode a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  static toBase58(privateKey) {
    return PrivateKey.toBase58(privateKey.s.toBigInt());
  }
  static toValue(v) {
    return v.toBigInt();
  }
  static fromValue(v) {
    if (v instanceof _PrivateKey)
      return v;
    return _PrivateKey.fromBigInt(v);
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Scalar3)
], PrivateKey2.prototype, "s", void 0);
var PublicKey2 = class _PublicKey extends CircuitValue {
  /**
   * Returns the {@link Group} representation of this {@link PublicKey}.
   * @returns A {@link Group}
   */
  toGroup() {
    let { x, isOdd } = this;
    let y = x.square().mul(x).add(5).sqrt();
    let sameParity = y.isOdd().equals(isOdd).toField();
    let sign3 = sameParity.mul(2).sub(1);
    y = y.mul(sign3);
    return new Group3({ x, y });
  }
  /**
   * Creates a {@link PublicKey} from a {@link Group} element.
   * @returns a {@link PublicKey}.
   */
  static fromGroup({ x, y }) {
    return _PublicKey.fromObject({ x, isOdd: y.isOdd() });
  }
  /**
   * Derives a {@link PublicKey} from a {@link PrivateKey}.
   * @returns a {@link PublicKey}.
   */
  static fromPrivateKey({ s }) {
    return _PublicKey.fromGroup(Group3.generator.scale(s));
  }
  /**
   * Creates a {@link PublicKey} from a JSON structure element.
   * @returns a {@link PublicKey}.
   */
  static from(g) {
    return _PublicKey.fromObject({ x: Field4.from(g.x), isOdd: Bool4(g.isOdd) });
  }
  /**
   * Creates an empty {@link PublicKey}.
   * @returns an empty {@link PublicKey}
   */
  static empty() {
    return _PublicKey.from({ x: 0n, isOdd: false });
  }
  /**
   * Checks if a {@link PublicKey} is empty.
   * @returns a {@link Bool}
   */
  isEmpty() {
    return this.x.equals(0);
  }
  /**
   * Decodes a base58 encoded {@link PublicKey} into a {@link PublicKey}.
   * @returns a {@link PublicKey}
   */
  static fromBase58(publicKeyBase58) {
    let { x, isOdd } = PublicKey.fromBase58(publicKeyBase58);
    return _PublicKey.from({ x: Field4(x), isOdd: Bool4(!!isOdd) });
  }
  /**
   * Encodes a {@link PublicKey} in base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  toBase58() {
    return _PublicKey.toBase58(this);
  }
  /**
   * Static method to encode a {@link PublicKey} into base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  static toBase58({ x, isOdd }) {
    x = toConstantField(x, "toBase58", "pk", "public key");
    return PublicKey.toBase58({
      x: x.toBigInt(),
      isOdd: isOdd.toBoolean()
    });
  }
  /**
   * Serializes a {@link PublicKey} into its JSON representation.
   * @returns a JSON string
   */
  static toJSON(publicKey) {
    return publicKey.toBase58();
  }
  /**
   * Deserializes a JSON string into a {@link PublicKey}.
   * @returns a JSON string
   */
  static fromJSON(publicKey) {
    return _PublicKey.fromBase58(publicKey);
  }
  static toValue({ x, isOdd }) {
    return { x: x.toBigInt(), isOdd: isOdd.toBoolean() };
  }
  static fromValue({ x, isOdd }) {
    return _PublicKey.from({ x: Field4.from(x), isOdd: Bool4(isOdd) });
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field4)
], PublicKey2.prototype, "x", void 0);
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Bool4)
], PublicKey2.prototype, "isOdd", void 0);
var Signature2 = class _Signature extends CircuitValue {
  /**
   * Signs a message using a {@link PrivateKey}.
   * @returns a {@link Signature}
   */
  static create(privKey, msg) {
    let publicKey = PublicKey2.fromPrivateKey(privKey).toGroup();
    let d = privKey.s;
    let kPrime = Scalar3.from(deriveNonce({ fields: msg.map((f) => f.toBigInt()) }, { x: publicKey.x.toBigInt(), y: publicKey.y.toBigInt() }, d.toBigInt(), "testnet"));
    let { x: r, y: ry } = Group3.generator.scale(kPrime);
    let k = ry.isOdd().toBoolean() ? kPrime.neg() : kPrime;
    let h = hashWithPrefix(signaturePrefix("testnet"), msg.concat([publicKey.x, publicKey.y, r]));
    let e = Scalar3.fromField(h);
    let s = e.mul(d).add(k);
    return new _Signature(r, s);
  }
  /**
   * Verifies the {@link Signature} using a message and the corresponding {@link PublicKey}.
   * @returns a {@link Bool}
   */
  verify(publicKey, msg) {
    let point = publicKey.toGroup();
    let h = hashWithPrefix(signaturePrefix("testnet"), msg.concat([point.x, point.y, this.r]));
    let r = point.scale(h).neg().add(Group3.generator.scale(this.s));
    return r.x.equals(this.r).and(r.y.isEven());
  }
  /**
   * Decodes a base58 encoded signature into a {@link Signature}.
   */
  static fromBase58(signatureBase58) {
    let { r, s } = Signature.fromBase58(signatureBase58);
    return _Signature.fromObject({ r: Field4(r), s: Scalar3.from(s) });
  }
  /**
   * Encodes a {@link Signature} in base58 format.
   */
  toBase58() {
    let r = this.r.toBigInt();
    let s = this.s.toBigInt();
    return Signature.toBase58({ r, s });
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field4)
], Signature2.prototype, "r", void 0);
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Scalar3)
], Signature2.prototype, "s", void 0);

// dist/node/lib/proof-system/circuit.js
var import_reflect_metadata2 = require("reflect-metadata");
var Circuit = class {
  /**
   * Generates a proving key and a verification key for this circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * ```
   */
  static async generateKeypair() {
    let main = mainFromCircuitData(this._main);
    let publicInputSize = this._main.publicInputType.sizeInFields();
    await initializeBindings();
    return prettifyStacktracePromise(withThreadPool(async () => {
      let keypair = Snarky.circuit.compile(main, publicInputSize);
      return new Keypair(keypair);
    }));
  }
  /**
   * Proves a statement using the private input, public input, and the {@link Keypair} of the circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);
   * ```
   */
  static async prove(privateInput, publicInput, keypair) {
    let main = mainFromCircuitData(this._main, privateInput);
    let publicInputSize = this._main.publicInputType.sizeInFields();
    let publicInputFields = this._main.publicInputType.toFields(publicInput);
    await initializeBindings();
    return prettifyStacktracePromise(withThreadPool(async () => {
      let proof = Snarky.circuit.prove(main, publicInputSize, MlFieldConstArray.to(publicInputFields), keypair.value);
      return new Proof2(proof);
    }));
  }
  /**
   * Verifies a proof using the public input, the proof, and the initial {@link Keypair} of the circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);
   * const isValid = await MyCircuit.verify(publicInput, keypair.vk, proof);
   * ```
   */
  static async verify(publicInput, verificationKey, proof) {
    let publicInputFields = this._main.publicInputType.toFields(publicInput);
    await initializeBindings();
    return prettifyStacktracePromise(withThreadPool(async () => Snarky.circuit.verify(MlFieldConstArray.to(publicInputFields), proof.value, verificationKey.value)));
  }
};
var Keypair = class {
  constructor(value) {
    this.value = value;
  }
  verificationKey() {
    return new VerificationKey2(Snarky.circuit.keypair.getVerificationKey(this.value));
  }
  /**
   * Returns a low-level JSON representation of the {@link Circuit} from its {@link Keypair}:
   * a list of gates, each of which represents a row in a table, with certain coefficients and wires to other (row, column) pairs
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const json = MyProvable.witnessFromKeypair(keypair);
   * ```
   */
  constraintSystem() {
    try {
      return gatesFromJson(Snarky.circuit.keypair.getConstraintSystemJSON(this.value)).gates;
    } catch (error) {
      throw prettifyStacktrace(error);
    }
  }
};
var Proof2 = class {
  constructor(value) {
    this.value = value;
  }
};
var VerificationKey2 = class {
  constructor(value) {
    this.value = value;
  }
};
function public_(target, _key, index) {
  if (target._public === void 0) {
    target._public = [];
  }
  target._public.push(index);
}
function mainFromCircuitData(data, privateInput) {
  return function main(publicInputFields) {
    let id2 = snarkContext.enter({ inCheckedComputation: true });
    try {
      let publicInput = data.publicInputType.fromFields(MlFieldArray.from(publicInputFields));
      let privateInput_ = Provable.witness(data.privateInputType, () => privateInput);
      data.main(publicInput, privateInput_);
    } finally {
      snarkContext.leave(id2);
    }
  };
}
function circuitMain(target, propertyName, _descriptor) {
  const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyName);
  const numArgs = paramTypes.length;
  const publicIndexSet = new Set(target._public);
  const witnessIndexSet = /* @__PURE__ */ new Set();
  for (let i = 0; i < numArgs; ++i) {
    if (!publicIndexSet.has(i))
      witnessIndexSet.add(i);
  }
  target._main = {
    main(publicInput, privateInput) {
      let args = [];
      for (let i = 0; i < numArgs; ++i) {
        let nextInput = publicIndexSet.has(i) ? publicInput : privateInput;
        args.push(nextInput.shift());
      }
      return target[propertyName].apply(target, args);
    },
    publicInputType: provableFromTuple(Array.from(publicIndexSet).map((i) => paramTypes[i])),
    privateInputType: provableFromTuple(Array.from(witnessIndexSet).map((i) => paramTypes[i]))
  };
}
function provableFromTuple(inputTypes) {
  let types = inputTypes.map((t) => "provable" in t ? t.provable : t);
  return {
    sizeInFields: () => {
      return types.reduce((acc, type) => acc + type.sizeInFields(), 0);
    },
    toFields: (t) => {
      if (t.length !== types.length) {
        throw new Error(`typOfArray: Expected ${types.length}, got ${t.length}`);
      }
      let res = [];
      for (let i = 0; i < t.length; ++i) {
        res.push(...types[i].toFields(t[i]));
      }
      return res;
    },
    toAuxiliary() {
      return [];
    },
    fromFields: (xs) => {
      let offset = 0;
      let res = [];
      types.forEach((typ) => {
        const n = typ.sizeInFields();
        res.push(typ.fromFields(xs.slice(offset, offset + n)));
        offset += n;
      });
      return res;
    },
    check(xs) {
      types.forEach((typ, i) => typ.check(xs[i]));
    },
    toValue(x) {
      return types.map((typ, i) => typ.toValue(x[i]));
    },
    fromValue(x) {
      return types.map((typ, i) => typ.fromValue(x[i]));
    }
  };
}

// dist/node/bindings/mina-transaction/gen/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  Account: () => Account,
  AccountUpdate: () => AccountUpdate,
  ActionState: () => ActionState,
  Actions: () => Actions,
  AuthRequired: () => AuthRequired,
  BalanceChange: () => BalanceChange,
  Bool: () => Bool4,
  Events: () => Events,
  Field: () => Field4,
  Json: () => transaction_json_exports,
  MayUseToken: () => MayUseToken,
  PublicKey: () => PublicKey2,
  ReceiptChainHash: () => ReceiptChainHash,
  Sign: () => Sign3,
  StateHash: () => StateHash,
  TokenId: () => TokenId,
  TokenSymbol: () => TokenSymbol2,
  TransactionVersion: () => TransactionVersion,
  TypeMap: () => TypeMap,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  VerificationKeyHash: () => VerificationKeyHash,
  ZkappCommand: () => ZkappCommand,
  ZkappUri: () => ZkappUri,
  customTypes: () => customTypes,
  empty: () => empty2,
  provableFromLayout: () => provableFromLayout,
  toJSONEssential: () => toJSONEssential
});

// dist/node/lib/mina/events.js
function createEvents({ Field: Field5, Poseidon: Poseidon3 }) {
  function initialState() {
    return [Field5(0), Field5(0), Field5(0)];
  }
  function salt2(prefix) {
    return Poseidon3.update(initialState(), [prefixToField(Field5, prefix)]);
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Poseidon3.update(init, input)[0];
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  const Events4 = {
    empty() {
      let hash3 = emptyHashWithPrefix2("MinaZkappEventsEmpty");
      return { hash: hash3, data: [] };
    },
    pushEvent(events, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash3 = hashWithPrefix3(prefixes.events, [events.hash, eventHash]);
      return { hash: hash3, data: [event, ...events.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Events4.pushEvent, Events4.empty());
    },
    hash(events) {
      return Events4.fromList(events).hash;
    }
  };
  const EventsProvable = {
    ...Events4,
    ...dataAsHash({
      empty: Events4.empty,
      toValue(data) {
        return data.map((row) => row.map((e) => Field5.toBigint(e)));
      },
      fromValue(value) {
        return value.map((row) => row.map((e) => Field5(e)));
      },
      toJSON(data) {
        return data.map((row) => row.map((e) => Field5.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field5.fromJSON(e)));
        let hash3 = Events4.hash(data);
        return { data, hash: hash3 };
      },
      Field: Field5
    })
  };
  const Actions4 = {
    // same as events but w/ different hash prefixes
    empty() {
      let hash3 = emptyHashWithPrefix2("MinaZkappActionsEmpty");
      return { hash: hash3, data: [] };
    },
    pushEvent(actions, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash3 = hashWithPrefix3(prefixes.sequenceEvents, [
        actions.hash,
        eventHash
      ]);
      return { hash: hash3, data: [event, ...actions.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Actions4.pushEvent, Actions4.empty());
    },
    hash(events) {
      return this.fromList(events).hash;
    },
    // different than events
    emptyActionState() {
      return emptyHashWithPrefix2("MinaZkappActionStateEmptyElt");
    },
    updateSequenceState(state3, sequenceEventsHash) {
      return hashWithPrefix3(prefixes.sequenceEvents, [
        state3,
        sequenceEventsHash
      ]);
    }
  };
  const ActionsProvable = {
    ...Actions4,
    ...dataAsHash({
      empty: Actions4.empty,
      toValue(data) {
        return data.map((row) => row.map((e) => Field5.toBigint(e)));
      },
      fromValue(value) {
        return value.map((row) => row.map((e) => Field5(e)));
      },
      toJSON(data) {
        return data.map((row) => row.map((e) => Field5.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field5.fromJSON(e)));
        let hash3 = Actions4.hash(data);
        return { data, hash: hash3 };
      },
      Field: Field5
    })
  };
  return { Events: EventsProvable, Actions: ActionsProvable };
}
function dataAsHash({ empty: empty4, toValue, fromValue, toJSON, fromJSON, Field: Field5 }) {
  return {
    empty: empty4,
    sizeInFields() {
      return 1;
    },
    toFields({ hash: hash3 }) {
      return [hash3];
    },
    toAuxiliary(value) {
      return [value?.data ?? empty4().data];
    },
    fromFields([hash3], [data]) {
      return { data, hash: hash3 };
    },
    toValue({ data, hash: hash3 }) {
      return { data: toValue(data), hash: Field5.toBigint(hash3) };
    },
    fromValue({ data, hash: hash3 }) {
      return { data: fromValue(data), hash: Field5(hash3) };
    },
    toJSON({ data }) {
      return toJSON(data);
    },
    fromJSON(json) {
      return fromJSON(json);
    },
    check() {
    },
    toInput({ hash: hash3 }) {
      return { fields: [hash3] };
    }
  };
}

// dist/node/bindings/mina-transaction/derived-leaves.js
var tokenSymbolLength = 6;
function derivedLeafTypes({ Field: Field5, Bool: Bool5, HashHelpers: HashHelpers3, packToFields: packToFields3 }) {
  let { provable: provable3 } = createDerivers();
  const Encoding = fieldEncodings(Field5);
  const fieldBase = provable3(Field5);
  return {
    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field5(defaultTokenId)),
    StateHash: createEncodedField(fieldBase, Encoding.StateHash),
    TokenSymbol: createTokenSymbol(provable3({ field: Field5, symbol: String }), Field5),
    AuthRequired: createAuthRequired(provable3({
      constant: Bool5,
      signatureNecessary: Bool5,
      signatureSufficient: Bool5
    }), Bool5),
    ZkappUri: createZkappUri(Field5, HashHelpers3, packToFields3)
  };
}
function derivedLeafTypesSignable({ Field: Field5, Bool: Bool5, HashHelpers: HashHelpers3, packToFields: packToFields3 }) {
  let { signable: signable2 } = createDerivers();
  const Encoding = fieldEncodings(Field5);
  const fieldBase = signable2(Field5);
  return {
    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field5(defaultTokenId)),
    StateHash: createEncodedField(fieldBase, Encoding.StateHash),
    TokenSymbol: createTokenSymbol(signable2({ field: Field5, symbol: String }), Field5),
    AuthRequired: createAuthRequired(signable2({
      constant: Bool5,
      signatureNecessary: Bool5,
      signatureSufficient: Bool5
    }), Bool5),
    MayUseToken: signable2({ parentsOwnToken: Bool5, inheritFromParent: Bool5 }),
    Bool: Bool5,
    ZkappUri: createZkappUri(Field5, HashHelpers3, packToFields3)
  };
}
var defaultTokenId = 1;
function createEncodedField(base, encoding, empty4) {
  return {
    ...base,
    empty: empty4 !== void 0 ? () => empty4 : base.empty,
    toJSON(x) {
      return encoding.toBase58(x);
    },
    fromJSON(x) {
      return encoding.fromBase58(x);
    }
  };
}
function createTokenSymbol(base, Field5) {
  let self = {
    ...base,
    toInput({ field }) {
      return { packed: [[field, 48]] };
    },
    toJSON({ symbol }) {
      return symbol;
    },
    fromJSON(symbol) {
      let bytesLength = stringLengthInBytes(symbol);
      if (bytesLength > tokenSymbolLength)
        throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
      return { symbol, field: prefixToField(Field5, symbol) };
    }
  };
  return self;
}
function createAuthRequired(base, Bool5) {
  return {
    ...base,
    empty() {
      return {
        constant: Bool5(true),
        signatureNecessary: Bool5(false),
        signatureSufficient: Bool5(true)
      };
    },
    toJSON(x) {
      let c = Number(Bool5.toJSON(x.constant));
      let n = Number(Bool5.toJSON(x.signatureNecessary));
      let s = Number(Bool5.toJSON(x.signatureSufficient));
      switch (`${c}${n}${s}`) {
        case "110":
          return "Impossible";
        case "101":
          return "None";
        case "000":
          return "Proof";
        case "011":
          return "Signature";
        case "001":
          return "Either";
        default:
          throw Error("Unexpected permission");
      }
    },
    fromJSON(json) {
      let map = {
        Impossible: "110",
        None: "101",
        Proof: "000",
        Signature: "011",
        Either: "001"
      };
      let code = map[json];
      if (code === void 0)
        throw Error("Unexpected permission");
      let [constant, signatureNecessary, signatureSufficient] = code.split("").map((s) => Bool5(!!Number(s)));
      return { constant, signatureNecessary, signatureSufficient };
    }
  };
}
function createZkappUri(Field5, HashHelpers3, packToFields3) {
  function hashZkappUri(uri) {
    let bits = bytesToBits(stringToBytes(uri));
    bits.push(true);
    let input = {
      packed: bits.map((b2) => [Field5(Number(b2)), 1])
    };
    let packed = packToFields3(input);
    return HashHelpers3.hashWithPrefix(prefixes.zkappUri, packed);
  }
  return dataAsHash({
    empty() {
      let hash3 = HashHelpers3.hashWithPrefix(prefixes.zkappUri, [
        Field5(0),
        Field5(0)
      ]);
      return { data: "", hash: hash3 };
    },
    toValue(data) {
      return data;
    },
    fromValue(value) {
      return value;
    },
    toJSON(data) {
      return data;
    },
    fromJSON(json) {
      return { data: json, hash: hashZkappUri(json) };
    },
    Field: Field5
  });
}

// dist/node/bindings/mina-transaction/transaction-leaves.js
var { TokenId, StateHash, TokenSymbol: TokenSymbol2, AuthRequired, ZkappUri } = derivedLeafTypes({ Field: Field4, Bool: Bool4, HashHelpers, packToFields });
var { Events, Actions } = createEvents({ Field: Field4, Poseidon: Poseidon2 });
var ActionState = {
  ...provable(Field4),
  empty: Actions.emptyActionState
};
var VerificationKeyHash = {
  ...provable(Field4),
  empty: () => Field4(mocks.dummyVerificationKeyHash)
};
var ReceiptChainHash = {
  ...provable(Field4),
  empty: () => emptyHashWithPrefix("CodaReceiptEmpty")
};
var TransactionVersion = {
  ...provable(UInt322),
  empty: () => UInt322.from(protocolVersions.txnVersion)
};
var BalanceChange = Int64;
var MayUseToken = {
  ...provable({
    parentsOwnToken: Bool4,
    inheritFromParent: Bool4
  })
};

// dist/node/bindings/lib/from-layout.js
function SignableFromLayout(TypeMap3, customTypes3) {
  const Field5 = TypeMap3.Field;
  function layoutFold(spec, typeData, value) {
    return genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value);
  }
  function signableFromLayout2(typeData) {
    return {
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      empty() {
        return empty4(typeData);
      }
    };
  }
  function toJSON(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  function fromJSON(typeData, json) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes3[checkedTypeName].fromJSON(json);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      return json.map((json2) => fromJSON(arrayTypeData.inner, json2));
    }
    if (typeData.type === "option") {
      let optionTypeData = typeData;
      switch (optionTypeData.optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let isSome = TypeMap3.Bool.fromJSON(json !== null);
          let value;
          if (json !== null) {
            value = fromJSON(optionTypeData.inner, json);
          } else {
            value = empty4(optionTypeData.inner);
            if (optionTypeData.optionType === "closedInterval") {
              let innerInner = optionTypeData.inner.entries.lower;
              let innerType = TypeMap3[innerInner.type];
              value.lower = innerType.fromJSON(optionTypeData.rangeMin);
              value.upper = innerType.fromJSON(optionTypeData.rangeMax);
            }
          }
          return { isSome, value };
        }
        case "orUndefined": {
          return json === null ? void 0 : fromJSON(optionTypeData.inner, json);
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      for (let i = 0; i < keys.length; i++) {
        let typeEntry = entries[keys[i]];
        values[keys[i]] = fromJSON(typeEntry, json[keys[i]]);
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return primitiveTypeMap[typeData.type].fromJSON(json);
    }
    return TypeMap3[typeData.type].fromJSON(json);
  }
  function empty4(typeData) {
    return layoutFold({
      map(type) {
        return type.empty();
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value }, typeData2) {
        if (typeData2.optionType === "closedInterval") {
          let innerInner = typeData2.inner.entries.lower;
          let innerType = TypeMap3[innerInner.type];
          value.lower = innerType.fromJSON(typeData2.rangeMin);
          value.upper = innerType.fromJSON(typeData2.rangeMax);
        }
        return { isSome, value };
      },
      reduceOrUndefined() {
        return void 0;
      }
    }, typeData, void 0);
  }
  function toInput(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toInput(value2);
      },
      reduceArray(array) {
        let acc = { fields: [], packed: [] };
        for (let { fields: fields2, packed } of array) {
          if (fields2)
            acc.fields.push(...fields2);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceObject(keys, object) {
        let acc = { fields: [], packed: [] };
        for (let key of keys) {
          let { fields: fields2, packed } = object[key];
          if (fields2)
            acc.fields.push(...fields2);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return {
          fields: value2.fields,
          packed: isSome.packed.concat(value2.packed ?? [])
        };
      },
      reduceOrUndefined(_) {
        return {};
      }
    }, typeData, value);
  }
  function toJSONEssential3(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        if (array.length === 0 || array.every((x) => x === null))
          return null;
        return array;
      },
      reduceObject(_, object) {
        for (let key in object) {
          if (object[key] === null) {
            delete object[key];
          }
        }
        if (Object.keys(object).length === 0)
          return null;
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  return {
    signableFromLayout: signableFromLayout2,
    toInput,
    toJSON,
    fromJSON,
    empty: empty4,
    toJSONEssential: toJSONEssential3
  };
}
function ProvableFromLayout(TypeMap3, customTypes3) {
  const Field5 = TypeMap3.Field;
  const { toInput, toJSON, fromJSON, empty: empty4, toJSONEssential: toJSONEssential3 } = SignableFromLayout(TypeMap3, customTypes3);
  function layoutFold(spec, typeData, value) {
    return genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value);
  }
  function layoutMap(map, typeData, value) {
    return genericLayoutMap(TypeMap3, customTypes3, map, typeData, value);
  }
  function provableFromLayout2(typeData) {
    return {
      sizeInFields() {
        return sizeInFields(typeData);
      },
      toFields(value) {
        return toFields(typeData, value);
      },
      toAuxiliary(value) {
        return toAuxiliary(typeData, value);
      },
      fromFields(fields2, aux) {
        return fromFields(typeData, fields2, aux);
      },
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      check(value) {
        check(typeData, value);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      empty() {
        return empty4(typeData);
      },
      toValue(value) {
        return toValue(typeData, value);
      },
      fromValue(value) {
        return fromValue(typeData, value);
      }
    };
  }
  function toFields(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toFields(value2);
      },
      reduceArray(array) {
        return array.flat();
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).flat();
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return [isSome, value2].flat();
      },
      reduceOrUndefined(_) {
        return [];
      }
    }, typeData, value);
  }
  function toAuxiliary(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toAuxiliary(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]);
      },
      reduceFlaggedOption({ value: value2 }) {
        return value2;
      },
      reduceOrUndefined(value2) {
        return value2 === void 0 ? [false] : [true, value2];
      }
    }, typeData, value);
  }
  function sizeInFields(typeData) {
    let spec = {
      map(type) {
        return type.sizeInFields();
      },
      reduceArray(_, { inner, staticLength }) {
        let length = staticLength ?? NaN;
        return length * layoutFold(spec, inner);
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).reduce((x, y) => x + y);
      },
      reduceFlaggedOption({ isSome, value }) {
        return isSome + value;
      },
      reduceOrUndefined(_) {
        return 0;
      }
    };
    return layoutFold(spec, typeData);
  }
  function fromFields(typeData, fields2, aux) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes3[checkedTypeName].fromFields(fields2, aux);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let size = sizeInFields(arrayTypeData.inner);
      let length = aux.length;
      let value = [];
      for (let i = 0, offset = 0; i < length; i++, offset += size) {
        value[i] = fromFields(arrayTypeData.inner, fields2.slice(offset, offset + size), aux[i]);
      }
      return value;
    }
    if (typeData.type === "option") {
      let { optionType, inner } = typeData;
      switch (optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let [first, ...rest] = fields2;
          let isSome = TypeMap3.Bool.fromFields([first], []);
          let value = fromFields(inner, rest, aux);
          return { isSome, value };
        }
        case "orUndefined": {
          let [isDefined, value] = aux;
          return isDefined ? fromFields(inner, fields2, value) : void 0;
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      let offset = 0;
      for (let i = 0; i < keys.length; i++) {
        let typeEntry = entries[keys[i]];
        let size = sizeInFields(typeEntry);
        values[keys[i]] = fromFields(typeEntry, fields2.slice(offset, offset + size), aux[i]);
        offset += size;
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return primitiveTypeMap[typeData.type].fromFields(fields2, aux);
    }
    return TypeMap3[typeData.type].fromFields(fields2, aux);
  }
  function check(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.check(value2);
      },
      reduceArray() {
      },
      reduceObject() {
      },
      reduceFlaggedOption() {
      },
      reduceOrUndefined() {
      }
    }, typeData, value);
  }
  function toValue(typeData, value) {
    return layoutMap((type, value2) => type.toValue(value2), typeData, value);
  }
  function fromValue(typeData, value) {
    return layoutMap((type, value2) => type.fromValue(value2), typeData, value);
  }
  return { provableFromLayout: provableFromLayout2, toJSONEssential: toJSONEssential3, empty: empty4 };
}
function genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value) {
  let { checkedTypeName } = typeData;
  if (checkedTypeName) {
    return spec.map(customTypes3[checkedTypeName], value, checkedTypeName);
  }
  if (typeData.type === "array") {
    let arrayTypeData = typeData;
    let v = value;
    if (arrayTypeData.staticLength !== null && v === void 0) {
      v = Array(arrayTypeData.staticLength).fill(void 0);
    }
    let array = v?.map((x) => genericLayoutFold(TypeMap3, customTypes3, spec, arrayTypeData.inner, x)) ?? [];
    return spec.reduceArray(array, arrayTypeData);
  }
  if (typeData.type === "option") {
    let { optionType, inner } = typeData;
    switch (optionType) {
      case "closedInterval":
      case "flaggedOption":
        let v = value;
        return spec.reduceFlaggedOption({
          isSome: spec.map(TypeMap3.Bool, v?.isSome, "Bool"),
          value: genericLayoutFold(TypeMap3, customTypes3, spec, inner, v?.value)
        }, typeData);
      case "orUndefined":
        let mapped = value === void 0 ? void 0 : genericLayoutFold(TypeMap3, customTypes3, spec, inner, value);
        return spec.reduceOrUndefined(mapped, inner);
      default:
        throw Error("bug");
    }
  }
  if (typeData.type === "object") {
    let { keys, entries } = typeData;
    let v = value;
    let object = {};
    keys.forEach((key) => {
      object[key] = genericLayoutFold(TypeMap3, customTypes3, spec, entries[key], v?.[key]);
    });
    return spec.reduceObject(keys, object);
  }
  if (primitiveTypes.has(typeData.type)) {
    return spec.map(primitiveTypeMap[typeData.type], value, typeData.type);
  }
  return spec.map(TypeMap3[typeData.type], value, typeData.type);
}
function genericLayoutMap(TypeMap3, customTypes3, map, typeData, value) {
  return genericLayoutFold(TypeMap3, customTypes3, {
    map(type, value2) {
      return map(type, value2);
    },
    reduceArray(array) {
      return array;
    },
    reduceObject(_, object) {
      return object;
    },
    reduceFlaggedOption(option) {
      return option;
    },
    reduceOrUndefined(value2) {
      return value2;
    }
  }, typeData, value);
}

// dist/node/bindings/mina-transaction/gen/transaction-json.js
var transaction_json_exports = {};

// dist/node/bindings/mina-transaction/gen/js-layout.js
var jsLayout = {
  ZkappCommand: {
    type: "object",
    name: "ZkappCommand",
    docs: null,
    keys: ["feePayer", "accountUpdates", "memo"],
    entries: {
      feePayer: {
        type: "object",
        name: "ZkappFeePayer",
        docs: null,
        keys: ["body", "authorization"],
        entries: {
          body: {
            type: "object",
            name: "FeePayerBody",
            docs: null,
            keys: ["publicKey", "fee", "validUntil", "nonce"],
            entries: {
              publicKey: { type: "PublicKey" },
              fee: { type: "UInt64" },
              validUntil: {
                type: "option",
                optionType: "orUndefined",
                inner: { type: "UInt32" }
              },
              nonce: { type: "UInt32" }
            },
            docEntries: {
              publicKey: null,
              fee: null,
              validUntil: null,
              nonce: null
            }
          },
          authorization: { type: "string" }
        },
        docEntries: { body: null, authorization: null }
      },
      accountUpdates: {
        type: "array",
        inner: {
          type: "object",
          name: "ZkappAccountUpdate",
          docs: "An account update in a zkApp transaction",
          keys: ["body", "authorization"],
          entries: {
            body: {
              type: "object",
              name: "AccountUpdateBody",
              docs: null,
              keys: [
                "publicKey",
                "tokenId",
                "update",
                "balanceChange",
                "incrementNonce",
                "events",
                "actions",
                "callData",
                "callDepth",
                "preconditions",
                "useFullCommitment",
                "implicitAccountCreationFee",
                "mayUseToken",
                "authorizationKind"
              ],
              entries: {
                publicKey: { type: "PublicKey" },
                tokenId: { type: "TokenId" },
                update: {
                  type: "object",
                  name: "AccountUpdateModification",
                  docs: null,
                  keys: [
                    "appState",
                    "delegate",
                    "verificationKey",
                    "permissions",
                    "zkappUri",
                    "tokenSymbol",
                    "timing",
                    "votingFor"
                  ],
                  entries: {
                    appState: {
                      type: "array",
                      inner: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      staticLength: 8
                    },
                    delegate: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "PublicKey" }
                    },
                    verificationKey: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "VerificationKeyWithHash",
                        docs: null,
                        keys: ["data", "hash"],
                        entries: {
                          data: { type: "string" },
                          hash: { type: "Field" }
                        },
                        docEntries: { data: null, hash: null }
                      }
                    },
                    permissions: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Permissions",
                        docs: null,
                        keys: [
                          "editState",
                          "access",
                          "send",
                          "receive",
                          "setDelegate",
                          "setPermissions",
                          "setVerificationKey",
                          "setZkappUri",
                          "editActionState",
                          "setTokenSymbol",
                          "incrementNonce",
                          "setVotingFor",
                          "setTiming"
                        ],
                        entries: {
                          editState: { type: "AuthRequired" },
                          access: { type: "AuthRequired" },
                          send: { type: "AuthRequired" },
                          receive: { type: "AuthRequired" },
                          setDelegate: { type: "AuthRequired" },
                          setPermissions: { type: "AuthRequired" },
                          setVerificationKey: {
                            type: "object",
                            name: "VerificationKeyPermission",
                            docs: null,
                            keys: ["auth", "txnVersion"],
                            entries: {
                              auth: { type: "AuthRequired" },
                              txnVersion: {
                                type: "UInt32",
                                checkedType: { type: "UInt32" },
                                checkedTypeName: "TransactionVersion"
                              }
                            },
                            docEntries: { auth: null, txnVersion: null }
                          },
                          setZkappUri: { type: "AuthRequired" },
                          editActionState: { type: "AuthRequired" },
                          setTokenSymbol: { type: "AuthRequired" },
                          incrementNonce: { type: "AuthRequired" },
                          setVotingFor: { type: "AuthRequired" },
                          setTiming: { type: "AuthRequired" }
                        },
                        docEntries: {
                          editState: null,
                          access: null,
                          send: null,
                          receive: null,
                          setDelegate: null,
                          setPermissions: null,
                          setVerificationKey: null,
                          setZkappUri: null,
                          editActionState: null,
                          setTokenSymbol: null,
                          incrementNonce: null,
                          setVotingFor: null,
                          setTiming: null
                        }
                      }
                    },
                    zkappUri: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Events",
                          docs: null,
                          keys: ["data", "hash"],
                          entries: {
                            data: { type: "string" },
                            hash: { type: "Field" }
                          },
                          docEntries: { data: null, hash: null }
                        },
                        checkedTypeName: "ZkappUri"
                      }
                    },
                    tokenSymbol: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Anonymous",
                          docs: null,
                          keys: ["symbol", "field"],
                          entries: {
                            symbol: { type: "string" },
                            field: { type: "Field" }
                          },
                          docEntries: { symbol: "", field: "" }
                        },
                        checkedTypeName: "TokenSymbol"
                      }
                    },
                    timing: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Timing",
                        docs: null,
                        keys: [
                          "initialMinimumBalance",
                          "cliffTime",
                          "cliffAmount",
                          "vestingPeriod",
                          "vestingIncrement"
                        ],
                        entries: {
                          initialMinimumBalance: { type: "UInt64" },
                          cliffTime: { type: "UInt32" },
                          cliffAmount: { type: "UInt64" },
                          vestingPeriod: { type: "UInt32" },
                          vestingIncrement: { type: "UInt64" }
                        },
                        docEntries: {
                          initialMinimumBalance: null,
                          cliffTime: null,
                          cliffAmount: null,
                          vestingPeriod: null,
                          vestingIncrement: null
                        }
                      }
                    },
                    votingFor: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "Field",
                        checkedType: { type: "Field" },
                        checkedTypeName: "StateHash"
                      }
                    }
                  },
                  docEntries: {
                    appState: null,
                    delegate: null,
                    verificationKey: null,
                    permissions: null,
                    zkappUri: null,
                    tokenSymbol: null,
                    timing: null,
                    votingFor: null
                  }
                },
                balanceChange: {
                  type: "object",
                  name: "BalanceChange",
                  docs: null,
                  keys: ["magnitude", "sgn"],
                  entries: {
                    magnitude: { type: "UInt64" },
                    sgn: { type: "Sign" }
                  },
                  docEntries: { magnitude: null, sgn: null },
                  checkedType: { type: "BalanceChange" },
                  checkedTypeName: "BalanceChange"
                },
                incrementNonce: { type: "Bool" },
                events: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Events"
                },
                actions: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Actions"
                },
                callData: { type: "Field" },
                callDepth: { type: "number" },
                preconditions: {
                  type: "object",
                  name: "Preconditions",
                  docs: null,
                  keys: ["network", "account", "validWhile"],
                  entries: {
                    network: {
                      type: "object",
                      name: "NetworkPrecondition",
                      docs: null,
                      keys: [
                        "snarkedLedgerHash",
                        "blockchainLength",
                        "minWindowDensity",
                        "totalCurrency",
                        "globalSlotSinceGenesis",
                        "stakingEpochData",
                        "nextEpochData"
                      ],
                      entries: {
                        snarkedLedgerHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        blockchainLength: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        minWindowDensity: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        totalCurrency: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "CurrencyAmountInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        globalSlotSinceGenesis: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "GlobalSlotSinceGenesisInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        stakingEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        },
                        nextEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        }
                      },
                      docEntries: {
                        snarkedLedgerHash: null,
                        blockchainLength: null,
                        minWindowDensity: null,
                        totalCurrency: null,
                        globalSlotSinceGenesis: null,
                        stakingEpochData: null,
                        nextEpochData: null
                      }
                    },
                    account: {
                      type: "object",
                      name: "AccountPrecondition",
                      docs: null,
                      keys: [
                        "balance",
                        "nonce",
                        "receiptChainHash",
                        "delegate",
                        "state",
                        "actionState",
                        "provedState",
                        "isNew"
                      ],
                      entries: {
                        balance: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "BalanceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        nonce: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "NonceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        receiptChainHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        delegate: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "PublicKey" }
                        },
                        state: {
                          type: "array",
                          inner: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          staticLength: 8
                        },
                        actionState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: {
                            type: "Field",
                            checkedType: { type: "Field" },
                            checkedTypeName: "ActionState"
                          }
                        },
                        provedState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        },
                        isNew: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        }
                      },
                      docEntries: {
                        balance: null,
                        nonce: null,
                        receiptChainHash: null,
                        delegate: null,
                        state: null,
                        actionState: null,
                        provedState: null,
                        isNew: null
                      }
                    },
                    validWhile: {
                      type: "option",
                      optionType: "closedInterval",
                      rangeMin: "0",
                      rangeMax: "4294967295",
                      inner: {
                        type: "object",
                        name: "GlobalSlotSinceGenesisInterval",
                        docs: null,
                        keys: ["lower", "upper"],
                        entries: {
                          lower: { type: "UInt32" },
                          upper: { type: "UInt32" }
                        },
                        docEntries: { lower: null, upper: null }
                      }
                    }
                  },
                  docEntries: {
                    network: null,
                    account: null,
                    validWhile: null
                  }
                },
                useFullCommitment: { type: "Bool" },
                implicitAccountCreationFee: { type: "Bool" },
                mayUseToken: {
                  type: "object",
                  name: "MayUseToken",
                  docs: null,
                  keys: ["parentsOwnToken", "inheritFromParent"],
                  entries: {
                    parentsOwnToken: { type: "Bool" },
                    inheritFromParent: { type: "Bool" }
                  },
                  docEntries: {
                    parentsOwnToken: null,
                    inheritFromParent: null
                  },
                  checkedType: {
                    type: "object",
                    name: "Anonymous",
                    docs: null,
                    keys: ["parentsOwnToken", "inheritFromParent"],
                    entries: {
                      parentsOwnToken: { type: "Bool" },
                      inheritFromParent: { type: "Bool" }
                    },
                    docEntries: { parentsOwnToken: "", inheritFromParent: "" }
                  },
                  checkedTypeName: "MayUseToken"
                },
                authorizationKind: {
                  type: "object",
                  name: "AuthorizationKindStructured",
                  docs: null,
                  keys: ["isSigned", "isProved", "verificationKeyHash"],
                  entries: {
                    isSigned: { type: "Bool" },
                    isProved: { type: "Bool" },
                    verificationKeyHash: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "VerificationKeyHash"
                    }
                  },
                  docEntries: {
                    isSigned: null,
                    isProved: null,
                    verificationKeyHash: null
                  }
                }
              },
              docEntries: {
                publicKey: null,
                tokenId: null,
                update: null,
                balanceChange: null,
                incrementNonce: null,
                events: null,
                actions: null,
                callData: null,
                callDepth: null,
                preconditions: null,
                useFullCommitment: null,
                implicitAccountCreationFee: null,
                mayUseToken: null,
                authorizationKind: null
              }
            },
            authorization: {
              type: "object",
              name: "Control",
              docs: null,
              keys: ["proof", "signature"],
              entries: {
                proof: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                },
                signature: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                }
              },
              docEntries: { proof: null, signature: null }
            }
          },
          docEntries: { body: null, authorization: null }
        },
        staticLength: null
      },
      memo: { type: "string" }
    },
    docEntries: { feePayer: null, accountUpdates: null, memo: null }
  },
  AccountUpdate: {
    type: "object",
    name: "ZkappAccountUpdate",
    docs: "An account update in a zkApp transaction",
    keys: ["body", "authorization"],
    entries: {
      body: {
        type: "object",
        name: "AccountUpdateBody",
        docs: null,
        keys: [
          "publicKey",
          "tokenId",
          "update",
          "balanceChange",
          "incrementNonce",
          "events",
          "actions",
          "callData",
          "callDepth",
          "preconditions",
          "useFullCommitment",
          "implicitAccountCreationFee",
          "mayUseToken",
          "authorizationKind"
        ],
        entries: {
          publicKey: { type: "PublicKey" },
          tokenId: { type: "TokenId" },
          update: {
            type: "object",
            name: "AccountUpdateModification",
            docs: null,
            keys: [
              "appState",
              "delegate",
              "verificationKey",
              "permissions",
              "zkappUri",
              "tokenSymbol",
              "timing",
              "votingFor"
            ],
            entries: {
              appState: {
                type: "array",
                inner: {
                  type: "option",
                  optionType: "flaggedOption",
                  inner: { type: "Field" }
                },
                staticLength: 8
              },
              delegate: {
                type: "option",
                optionType: "flaggedOption",
                inner: { type: "PublicKey" }
              },
              verificationKey: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "VerificationKeyWithHash",
                  docs: null,
                  keys: ["data", "hash"],
                  entries: {
                    data: { type: "string" },
                    hash: { type: "Field" }
                  },
                  docEntries: { data: null, hash: null }
                }
              },
              permissions: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Permissions",
                  docs: null,
                  keys: [
                    "editState",
                    "access",
                    "send",
                    "receive",
                    "setDelegate",
                    "setPermissions",
                    "setVerificationKey",
                    "setZkappUri",
                    "editActionState",
                    "setTokenSymbol",
                    "incrementNonce",
                    "setVotingFor",
                    "setTiming"
                  ],
                  entries: {
                    editState: { type: "AuthRequired" },
                    access: { type: "AuthRequired" },
                    send: { type: "AuthRequired" },
                    receive: { type: "AuthRequired" },
                    setDelegate: { type: "AuthRequired" },
                    setPermissions: { type: "AuthRequired" },
                    setVerificationKey: {
                      type: "object",
                      name: "VerificationKeyPermission",
                      docs: null,
                      keys: ["auth", "txnVersion"],
                      entries: {
                        auth: { type: "AuthRequired" },
                        txnVersion: {
                          type: "UInt32",
                          checkedType: { type: "UInt32" },
                          checkedTypeName: "TransactionVersion"
                        }
                      },
                      docEntries: { auth: null, txnVersion: null }
                    },
                    setZkappUri: { type: "AuthRequired" },
                    editActionState: { type: "AuthRequired" },
                    setTokenSymbol: { type: "AuthRequired" },
                    incrementNonce: { type: "AuthRequired" },
                    setVotingFor: { type: "AuthRequired" },
                    setTiming: { type: "AuthRequired" }
                  },
                  docEntries: {
                    editState: null,
                    access: null,
                    send: null,
                    receive: null,
                    setDelegate: null,
                    setPermissions: null,
                    setVerificationKey: null,
                    setZkappUri: null,
                    editActionState: null,
                    setTokenSymbol: null,
                    incrementNonce: null,
                    setVotingFor: null,
                    setTiming: null
                  }
                }
              },
              zkappUri: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: { type: "string" },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "ZkappUri"
                }
              },
              tokenSymbol: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Anonymous",
                    docs: null,
                    keys: ["symbol", "field"],
                    entries: {
                      symbol: { type: "string" },
                      field: { type: "Field" }
                    },
                    docEntries: { symbol: "", field: "" }
                  },
                  checkedTypeName: "TokenSymbol"
                }
              },
              timing: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Timing",
                  docs: null,
                  keys: [
                    "initialMinimumBalance",
                    "cliffTime",
                    "cliffAmount",
                    "vestingPeriod",
                    "vestingIncrement"
                  ],
                  entries: {
                    initialMinimumBalance: { type: "UInt64" },
                    cliffTime: { type: "UInt32" },
                    cliffAmount: { type: "UInt64" },
                    vestingPeriod: { type: "UInt32" },
                    vestingIncrement: { type: "UInt64" }
                  },
                  docEntries: {
                    initialMinimumBalance: null,
                    cliffTime: null,
                    cliffAmount: null,
                    vestingPeriod: null,
                    vestingIncrement: null
                  }
                }
              },
              votingFor: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "Field",
                  checkedType: { type: "Field" },
                  checkedTypeName: "StateHash"
                }
              }
            },
            docEntries: {
              appState: null,
              delegate: null,
              verificationKey: null,
              permissions: null,
              zkappUri: null,
              tokenSymbol: null,
              timing: null,
              votingFor: null
            }
          },
          balanceChange: {
            type: "object",
            name: "BalanceChange",
            docs: null,
            keys: ["magnitude", "sgn"],
            entries: { magnitude: { type: "UInt64" }, sgn: { type: "Sign" } },
            docEntries: { magnitude: null, sgn: null },
            checkedType: { type: "BalanceChange" },
            checkedTypeName: "BalanceChange"
          },
          incrementNonce: { type: "Bool" },
          events: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Events"
          },
          actions: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Actions"
          },
          callData: { type: "Field" },
          callDepth: { type: "number" },
          preconditions: {
            type: "object",
            name: "Preconditions",
            docs: null,
            keys: ["network", "account", "validWhile"],
            entries: {
              network: {
                type: "object",
                name: "NetworkPrecondition",
                docs: null,
                keys: [
                  "snarkedLedgerHash",
                  "blockchainLength",
                  "minWindowDensity",
                  "totalCurrency",
                  "globalSlotSinceGenesis",
                  "stakingEpochData",
                  "nextEpochData"
                ],
                entries: {
                  snarkedLedgerHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  blockchainLength: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  minWindowDensity: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  totalCurrency: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "CurrencyAmountInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  globalSlotSinceGenesis: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "GlobalSlotSinceGenesisInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  stakingEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  },
                  nextEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  }
                },
                docEntries: {
                  snarkedLedgerHash: null,
                  blockchainLength: null,
                  minWindowDensity: null,
                  totalCurrency: null,
                  globalSlotSinceGenesis: null,
                  stakingEpochData: null,
                  nextEpochData: null
                }
              },
              account: {
                type: "object",
                name: "AccountPrecondition",
                docs: null,
                keys: [
                  "balance",
                  "nonce",
                  "receiptChainHash",
                  "delegate",
                  "state",
                  "actionState",
                  "provedState",
                  "isNew"
                ],
                entries: {
                  balance: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "BalanceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  nonce: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "NonceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  receiptChainHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  delegate: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "PublicKey" }
                  },
                  state: {
                    type: "array",
                    inner: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "Field" }
                    },
                    staticLength: 8
                  },
                  actionState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "ActionState"
                    }
                  },
                  provedState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  },
                  isNew: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  }
                },
                docEntries: {
                  balance: null,
                  nonce: null,
                  receiptChainHash: null,
                  delegate: null,
                  state: null,
                  actionState: null,
                  provedState: null,
                  isNew: null
                }
              },
              validWhile: {
                type: "option",
                optionType: "closedInterval",
                rangeMin: "0",
                rangeMax: "4294967295",
                inner: {
                  type: "object",
                  name: "GlobalSlotSinceGenesisInterval",
                  docs: null,
                  keys: ["lower", "upper"],
                  entries: {
                    lower: { type: "UInt32" },
                    upper: { type: "UInt32" }
                  },
                  docEntries: { lower: null, upper: null }
                }
              }
            },
            docEntries: { network: null, account: null, validWhile: null }
          },
          useFullCommitment: { type: "Bool" },
          implicitAccountCreationFee: { type: "Bool" },
          mayUseToken: {
            type: "object",
            name: "MayUseToken",
            docs: null,
            keys: ["parentsOwnToken", "inheritFromParent"],
            entries: {
              parentsOwnToken: { type: "Bool" },
              inheritFromParent: { type: "Bool" }
            },
            docEntries: { parentsOwnToken: null, inheritFromParent: null },
            checkedType: {
              type: "object",
              name: "Anonymous",
              docs: null,
              keys: ["parentsOwnToken", "inheritFromParent"],
              entries: {
                parentsOwnToken: { type: "Bool" },
                inheritFromParent: { type: "Bool" }
              },
              docEntries: { parentsOwnToken: "", inheritFromParent: "" }
            },
            checkedTypeName: "MayUseToken"
          },
          authorizationKind: {
            type: "object",
            name: "AuthorizationKindStructured",
            docs: null,
            keys: ["isSigned", "isProved", "verificationKeyHash"],
            entries: {
              isSigned: { type: "Bool" },
              isProved: { type: "Bool" },
              verificationKeyHash: {
                type: "Field",
                checkedType: { type: "Field" },
                checkedTypeName: "VerificationKeyHash"
              }
            },
            docEntries: {
              isSigned: null,
              isProved: null,
              verificationKeyHash: null
            }
          }
        },
        docEntries: {
          publicKey: null,
          tokenId: null,
          update: null,
          balanceChange: null,
          incrementNonce: null,
          events: null,
          actions: null,
          callData: null,
          callDepth: null,
          preconditions: null,
          useFullCommitment: null,
          implicitAccountCreationFee: null,
          mayUseToken: null,
          authorizationKind: null
        }
      },
      authorization: {
        type: "object",
        name: "Control",
        docs: null,
        keys: ["proof", "signature"],
        entries: {
          proof: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          },
          signature: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          }
        },
        docEntries: { proof: null, signature: null }
      }
    },
    docEntries: { body: null, authorization: null }
  },
  Account: {
    type: "object",
    name: "Account",
    docs: null,
    keys: [
      "publicKey",
      "tokenId",
      "tokenSymbol",
      "balance",
      "nonce",
      "receiptChainHash",
      "delegate",
      "votingFor",
      "timing",
      "permissions",
      "zkapp"
    ],
    entries: {
      publicKey: { type: "PublicKey" },
      tokenId: { type: "TokenId" },
      tokenSymbol: { type: "string" },
      balance: { type: "UInt64" },
      nonce: { type: "UInt32" },
      receiptChainHash: {
        type: "Field",
        checkedType: { type: "Field" },
        checkedTypeName: "ReceiptChainHash"
      },
      delegate: {
        type: "option",
        optionType: "orUndefined",
        inner: { type: "PublicKey" }
      },
      votingFor: { type: "Field" },
      timing: {
        type: "object",
        name: "AccountTiming",
        docs: null,
        keys: [
          "isTimed",
          "initialMinimumBalance",
          "cliffTime",
          "cliffAmount",
          "vestingPeriod",
          "vestingIncrement"
        ],
        entries: {
          isTimed: { type: "Bool" },
          initialMinimumBalance: { type: "UInt64" },
          cliffTime: { type: "UInt32" },
          cliffAmount: { type: "UInt64" },
          vestingPeriod: { type: "UInt32" },
          vestingIncrement: { type: "UInt64" }
        },
        docEntries: {
          isTimed: null,
          initialMinimumBalance: null,
          cliffTime: null,
          cliffAmount: null,
          vestingPeriod: null,
          vestingIncrement: null
        }
      },
      permissions: {
        type: "object",
        name: "Permissions",
        docs: null,
        keys: [
          "editState",
          "access",
          "send",
          "receive",
          "setDelegate",
          "setPermissions",
          "setVerificationKey",
          "setZkappUri",
          "editActionState",
          "setTokenSymbol",
          "incrementNonce",
          "setVotingFor",
          "setTiming"
        ],
        entries: {
          editState: { type: "AuthRequired" },
          access: { type: "AuthRequired" },
          send: { type: "AuthRequired" },
          receive: { type: "AuthRequired" },
          setDelegate: { type: "AuthRequired" },
          setPermissions: { type: "AuthRequired" },
          setVerificationKey: {
            type: "object",
            name: "VerificationKeyPermission",
            docs: null,
            keys: ["auth", "txnVersion"],
            entries: {
              auth: { type: "AuthRequired" },
              txnVersion: {
                type: "UInt32",
                checkedType: { type: "UInt32" },
                checkedTypeName: "TransactionVersion"
              }
            },
            docEntries: { auth: null, txnVersion: null }
          },
          setZkappUri: { type: "AuthRequired" },
          editActionState: { type: "AuthRequired" },
          setTokenSymbol: { type: "AuthRequired" },
          incrementNonce: { type: "AuthRequired" },
          setVotingFor: { type: "AuthRequired" },
          setTiming: { type: "AuthRequired" }
        },
        docEntries: {
          editState: null,
          access: null,
          send: null,
          receive: null,
          setDelegate: null,
          setPermissions: null,
          setVerificationKey: null,
          setZkappUri: null,
          editActionState: null,
          setTokenSymbol: null,
          incrementNonce: null,
          setVotingFor: null,
          setTiming: null
        }
      },
      zkapp: {
        type: "option",
        optionType: "orUndefined",
        inner: {
          type: "object",
          name: "ZkappAccount",
          docs: null,
          keys: [
            "appState",
            "verificationKey",
            "zkappVersion",
            "actionState",
            "lastActionSlot",
            "provedState",
            "zkappUri"
          ],
          entries: {
            appState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 8
            },
            verificationKey: {
              type: "option",
              optionType: "orUndefined",
              inner: {
                type: "object",
                name: "VerificationKeyWithHash",
                docs: null,
                keys: ["data", "hash"],
                entries: { data: { type: "string" }, hash: { type: "Field" } },
                docEntries: { data: null, hash: null }
              }
            },
            zkappVersion: { type: "UInt32" },
            actionState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 5
            },
            lastActionSlot: { type: "UInt32" },
            provedState: { type: "Bool" },
            zkappUri: { type: "string" }
          },
          docEntries: {
            appState: null,
            verificationKey: null,
            zkappVersion: null,
            actionState: null,
            lastActionSlot: null,
            provedState: null,
            zkappUri: null
          }
        }
      }
    },
    docEntries: {
      publicKey: null,
      tokenId: null,
      tokenSymbol: null,
      balance: null,
      nonce: null,
      receiptChainHash: null,
      delegate: null,
      votingFor: null,
      timing: null,
      permissions: null,
      zkapp: null
    }
  }
};

// dist/node/bindings/mina-transaction/gen/transaction.js
var TypeMap = {
  PublicKey: PublicKey2,
  UInt64: UInt642,
  UInt32: UInt322,
  TokenId,
  Field: Field4,
  AuthRequired,
  BalanceChange,
  Sign: Sign3,
  Bool: Bool4
};
var customTypes = {
  TransactionVersion,
  ZkappUri,
  TokenSymbol: TokenSymbol2,
  StateHash,
  BalanceChange,
  Events,
  Actions,
  ActionState,
  MayUseToken,
  VerificationKeyHash,
  ReceiptChainHash
};
var { provableFromLayout, toJSONEssential, empty: empty2 } = ProvableFromLayout(TypeMap, customTypes);
var ZkappCommand = provableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate = provableFromLayout(jsLayout.AccountUpdate);
var Account = provableFromLayout(jsLayout.Account);

// dist/node/bindings/mina-transaction/gen/transaction-bigint.js
var transaction_bigint_exports = {};
__export(transaction_bigint_exports, {
  Account: () => Account2,
  AccountUpdate: () => AccountUpdate2,
  ActionState: () => ActionState2,
  Actions: () => Actions2,
  AuthRequired: () => AuthRequired2,
  BalanceChange: () => BalanceChange2,
  Bool: () => Bool,
  Events: () => Events2,
  Field: () => Field,
  Json: () => transaction_json_exports,
  MayUseToken: () => MayUseToken2,
  PublicKey: () => PublicKey,
  ReceiptChainHash: () => ReceiptChainHash2,
  Sign: () => Sign,
  StateHash: () => StateHash2,
  TokenId: () => TokenId2,
  TokenSymbol: () => TokenSymbol3,
  TransactionVersion: () => TransactionVersion2,
  TypeMap: () => TypeMap2,
  UInt32: () => UInt32,
  UInt64: () => UInt64,
  VerificationKeyHash: () => VerificationKeyHash2,
  ZkappCommand: () => ZkappCommand2,
  ZkappUri: () => ZkappUri2,
  customTypes: () => customTypes2,
  empty: () => empty3,
  signableFromLayout: () => signableFromLayout,
  toJSONEssential: () => toJSONEssential2
});

// dist/node/bindings/mina-transaction/transaction-leaves-bigint.js
var { TokenId: TokenId2, StateHash: StateHash2, TokenSymbol: TokenSymbol3, AuthRequired: AuthRequired2, ZkappUri: ZkappUri2, MayUseToken: MayUseToken2 } = derivedLeafTypesSignable({ Field, Bool, HashHelpers: HashHelpers2, packToFields: packToFields2 });
var { Events: Events2, Actions: Actions2 } = createEvents({ Field, Poseidon });
var ActionState2 = {
  ...Field,
  empty: Actions2.emptyActionState
};
var VerificationKeyHash2 = {
  ...Field,
  empty: () => Field(mocks.dummyVerificationKeyHash)
};
var ReceiptChainHash2 = {
  ...Field,
  empty: () => HashHelpers2.emptyHashWithPrefix("CodaReceiptEmpty")
};
var TransactionVersion2 = {
  ...UInt32,
  empty: () => UInt32(protocolVersions.txnVersion)
};
var BalanceChange2 = signable({ magnitude: UInt64, sgn: Sign });

// dist/node/bindings/mina-transaction/gen/transaction-bigint.js
var TypeMap2 = {
  PublicKey,
  UInt64,
  UInt32,
  TokenId: TokenId2,
  Field,
  AuthRequired: AuthRequired2,
  BalanceChange: BalanceChange2,
  Sign,
  Bool
};
var customTypes2 = {
  TransactionVersion: TransactionVersion2,
  ZkappUri: ZkappUri2,
  TokenSymbol: TokenSymbol3,
  StateHash: StateHash2,
  BalanceChange: BalanceChange2,
  Events: Events2,
  Actions: Actions2,
  ActionState: ActionState2,
  MayUseToken: MayUseToken2,
  VerificationKeyHash: VerificationKeyHash2,
  ReceiptChainHash: ReceiptChainHash2
};
var { signableFromLayout, toJSONEssential: toJSONEssential2, empty: empty3 } = SignableFromLayout(TypeMap2, customTypes2);
var ZkappCommand2 = signableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate2 = signableFromLayout(jsLayout.AccountUpdate);
var Account2 = signableFromLayout(jsLayout.Account);

// dist/node/lib/provable/merkle-list.js
var emptyHash = Field4(0);
function WithHash(type) {
  return Struct({ previousHash: Field4, element: type });
}
function toConstant2(type, node) {
  return {
    previousHash: node.previousHash.toConstant(),
    element: Provable.toConstant(type, node.element)
  };
}
function MerkleListBase() {
  return class extends Struct({ hash: Field4, data: Unconstrained }) {
    static empty() {
      return { hash: emptyHash, data: Unconstrained.from([]) };
    }
  };
}
var MerkleList = class _MerkleList {
  constructor({ hash: hash3, data }) {
    this.hash = hash3;
    this.data = data;
  }
  isEmpty() {
    return this.hash.equals(this.Constructor.emptyHash);
  }
  /**
   * Push a new element to the list.
   */
  push(element) {
    let previousHash = this.hash;
    this.hash = this.nextHash(previousHash, element);
    this.data.updateAsProver((data) => [
      toConstant2(this.innerProvable, { previousHash, element }),
      ...data
    ]);
  }
  /**
   * Push a new element to the list, if the `condition` is true.
   */
  pushIf(condition, element) {
    let previousHash = this.hash;
    this.hash = Provable.if(condition, this.nextHash(previousHash, element), previousHash);
    this.data.updateAsProver((data) => condition.toBoolean() ? [toConstant2(this.innerProvable, { previousHash, element }), ...data] : data);
  }
  popWitness() {
    return Provable.witness(WithHash(this.innerProvable), () => {
      let [value, ...data] = this.data.get();
      let head = value ?? {
        previousHash: this.Constructor.emptyHash,
        element: this.innerProvable.empty()
      };
      this.data.set(data);
      return head;
    });
  }
  /**
   * Remove the last element from the list and return it.
   *
   * This proves that the list is non-empty, and fails otherwise.
   */
  popExn() {
    let { previousHash, element } = this.popWitness();
    let currentHash = this.nextHash(previousHash, element);
    this.hash.assertEquals(currentHash);
    this.hash = previousHash;
    return element;
  }
  /**
   * Remove the last element from the list and return it.
   *
   * If the list is empty, returns a dummy element.
   */
  pop() {
    let { previousHash, element } = this.popWitness();
    let isEmpty = this.isEmpty();
    let emptyHash2 = this.Constructor.emptyHash;
    let currentHash = this.nextHash(previousHash, element);
    currentHash = Provable.if(isEmpty, emptyHash2, currentHash);
    this.hash.assertEquals(currentHash);
    this.hash = Provable.if(isEmpty, emptyHash2, previousHash);
    let provable3 = this.innerProvable;
    return Provable.if(isEmpty, provable3, provable3.empty(), element);
  }
  /**
   * Return the last element, but only remove it if `condition` is true.
   *
   * If the list is empty, returns a dummy element.
   */
  popIf(condition) {
    let originalHash = this.hash;
    let element = this.pop();
    this.data.updateAsProver((data) => {
      let node = { previousHash: this.hash, element };
      return condition.toBoolean() ? data : [toConstant2(this.innerProvable, node), ...data];
    });
    this.hash = Provable.if(condition, this.hash, originalHash);
    return element;
  }
  /**
   * Low-level, minimal version of `pop()` which lets the _caller_ decide whether there is an element to pop.
   *
   * I.e. this proves:
   * - If the input condition is true, this returns the last element and removes it from the list.
   * - If the input condition is false, the list is unchanged and the return value is garbage.
   *
   * Note that if the caller passes `true` but the list is empty, this will fail.
   * If the caller passes `false` but the list is non-empty, this succeeds and just doesn't pop off an element.
   */
  popIfUnsafe(shouldPop) {
    let { previousHash, element } = Provable.witness(WithHash(this.innerProvable), () => {
      let dummy = {
        previousHash: this.hash,
        element: this.innerProvable.empty()
      };
      if (!shouldPop.toBoolean())
        return dummy;
      let [value, ...data] = this.data.get();
      this.data.set(data);
      return value ?? dummy;
    });
    let nextHash = this.nextHash(previousHash, element);
    let currentHash = Provable.if(shouldPop, nextHash, this.hash);
    this.hash.assertEquals(currentHash);
    this.hash = Provable.if(shouldPop, previousHash, this.hash);
    return element;
  }
  clone() {
    let data = Unconstrained.witness(() => [...this.data.get()]);
    return new this.Constructor({ hash: this.hash, data });
  }
  /**
   * Iterate through the list in a fixed number of steps any apply a given callback on each element.
   *
   * Proves that the iteration traverses the entire list.
   * Once past the last element, dummy elements will be passed to the callback.
   *
   * Note: There are no guarantees about the contents of dummy elements, so the callback is expected
   * to handle the `isDummy` flag separately.
   */
  forEach(length, callback) {
    let iter = this.startIterating();
    for (let i = 0; i < length; i++) {
      let { element, isDummy } = iter.Unsafe.next();
      callback(element, isDummy, i);
    }
    iter.assertAtEnd(`Expected MerkleList to have at most ${length} elements, but it has more.`);
  }
  startIterating() {
    let merkleArray = MerkleListIterator.createFromList(this.Constructor);
    return merkleArray.startIterating(this);
  }
  startIteratingFromLast() {
    let merkleArray = MerkleListIterator.createFromList(this.Constructor);
    return merkleArray.startIteratingFromLast(this);
  }
  toArrayUnconstrained() {
    return Unconstrained.witness(() => [...this.data.get()].reverse().map((x) => x.element));
  }
  lengthUnconstrained() {
    return Unconstrained.witness(() => this.data.get().length);
  }
  /**
   * Create a Merkle list type
   *
   * Optionally, you can tell `create()` how to do the hash that pushes a new list element, by passing a `nextHash` function.
   *
   * @example
   * ```ts
   * class MyList extends MerkleList.create(Field, (hash, x) =>
   *   Poseidon.hashWithPrefix('custom', [hash, x])
   * ) {}
   * ```
   */
  static create(type, nextHash = merkleListHash(ProvableType.get(type)), emptyHash_ = emptyHash) {
    let provable3 = ProvableType.get(type);
    class MerkleListTBase extends _MerkleList {
      static empty() {
        return new this({ hash: emptyHash_, data: Unconstrained.from([]) });
      }
      static from(array) {
        array = [...array].reverse();
        let { hash: hash3, data } = withHashes(array, nextHash, emptyHash_);
        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant2(provable3, x)));
        return new this({ data: unconstrained, hash: hash3 });
      }
      static fromReverse(array) {
        let { hash: hash3, data } = withHashes(array, nextHash, emptyHash_);
        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant2(provable3, x)));
        return new this({ data: unconstrained, hash: hash3 });
      }
      static get provable() {
        assert3(this._provable !== void 0, "MerkleList not initialized");
        return this._provable;
      }
      static set provable(_provable) {
        this._provable = _provable;
      }
    }
    MerkleListTBase._innerProvable = provable3;
    MerkleListTBase._provable = provableFromClass(MerkleListTBase, {
      hash: Field4,
      data: Unconstrained
    });
    MerkleListTBase._nextHash = nextHash;
    MerkleListTBase._emptyHash = emptyHash_;
    return class MerkleListT extends MerkleListTBase {
      static [Symbol.hasInstance](x) {
        return x instanceof MerkleListTBase;
      }
    };
  }
  get Constructor() {
    return this.constructor;
  }
  nextHash(hash3, value) {
    assert3(this.Constructor._nextHash !== void 0, "MerkleList not initialized");
    return this.Constructor._nextHash(hash3, value);
  }
  static get emptyHash() {
    assert3(this._emptyHash !== void 0, "MerkleList not initialized");
    return this._emptyHash;
  }
  get innerProvable() {
    assert3(this.Constructor._innerProvable !== void 0, "MerkleList not initialized");
    return this.Constructor._innerProvable;
  }
};
var MerkleListIterator = class _MerkleListIterator {
  constructor(value) {
    Object.assign(this, value);
  }
  assertAtStart() {
    return this.currentHash.assertEquals(this.Constructor.emptyHash);
  }
  isAtEnd() {
    return this.currentHash.equals(this.hash);
  }
  jumpToEnd() {
    this.currentIndex.setTo(Unconstrained.witness(() => 0));
    this.currentHash = this.hash;
  }
  jumpToEndIf(condition) {
    Provable.asProver(() => {
      if (condition.toBoolean()) {
        this.currentIndex.set(0);
      }
    });
    this.currentHash = Provable.if(condition, this.hash, this.currentHash);
  }
  assertAtEnd(message) {
    return this.currentHash.assertEquals(this.hash, message ?? "Merkle list iterator is not at the end");
  }
  isAtStart() {
    return this.currentHash.equals(this.Constructor.emptyHash);
  }
  jumpToStart() {
    this.currentIndex.setTo(Unconstrained.witness(() => this.data.get().length));
    this.currentHash = this.Constructor.emptyHash;
  }
  jumpToStartIf(condition) {
    Provable.asProver(() => {
      if (condition.toBoolean()) {
        this.currentIndex.set(this.data.get().length);
      }
    });
    this.currentHash = Provable.if(condition, this.Constructor.emptyHash, this.currentHash);
  }
  _index(direction, i) {
    i ??= this.currentIndex.get();
    if (direction === "next") {
      return Math.min(Math.max(i, -1), this.data.get().length - 1);
    } else {
      return Math.max(Math.min(i, this.data.get().length), 0);
    }
  }
  _updateIndex(direction) {
    this.currentIndex.updateAsProver(() => {
      let i = this._index(direction);
      return this._index(direction, direction === "next" ? i - 1 : i + 1);
    });
  }
  previous() {
    let { previousHash, element } = Provable.witness(WithHash(this.innerProvable), () => this.data.get()[this._index("previous")] ?? {
      previousHash: this.Constructor.emptyHash,
      element: this.innerProvable.empty()
    });
    let isDummy = this.isAtStart();
    let emptyHash2 = this.Constructor.emptyHash;
    let correctHash = this.nextHash(previousHash, element);
    let requiredHash = Provable.if(isDummy, emptyHash2, correctHash);
    this.currentHash.assertEquals(requiredHash);
    this._updateIndex("previous");
    this.currentHash = Provable.if(isDummy, emptyHash2, previousHash);
    return Provable.if(isDummy, this.innerProvable, this.innerProvable.empty(), element);
  }
  next() {
    let element = Provable.witness(this.innerProvable, () => this.data.get()[this._index("next")]?.element ?? this.innerProvable.empty());
    let isDummy = this.isAtEnd();
    let currentHash = this.nextHash(this.currentHash, element);
    this.currentHash = Provable.if(isDummy, this.hash, currentHash);
    this._updateIndex("next");
    return Provable.if(isDummy, this.innerProvable, this.innerProvable.empty(), element);
  }
  /**
   * Low-level APIs for advanced uses
   */
  get Unsafe() {
    let self = this;
    return {
      /**
       * Version of {@link previous} which doesn't guarantee anything about
       * the returned element in case the iterator is at the start.
       *
       * Instead, the `isDummy` flag is also returned so that this case can
       * be handled in a custom way.
       */
      previous() {
        let { previousHash, element } = Provable.witness(WithHash(self.innerProvable), () => self.data.get()[self._index("previous")] ?? {
          previousHash: self.Constructor.emptyHash,
          element: self.innerProvable.empty()
        });
        let isDummy = self.isAtStart();
        let emptyHash2 = self.Constructor.emptyHash;
        let correctHash = self.nextHash(previousHash, element);
        let requiredHash = Provable.if(isDummy, emptyHash2, correctHash);
        self.currentHash.assertEquals(requiredHash);
        self._updateIndex("previous");
        self.currentHash = Provable.if(isDummy, emptyHash2, previousHash);
        return { element, isDummy };
      },
      /**
       * Version of {@link next} which doesn't guarantee anything about
       * the returned element in case the iterator is at the end.
       *
       * Instead, the `isDummy` flag is also returned so that this case can
       * be handled in a custom way.
       */
      next() {
        let element = Provable.witness(self.innerProvable, () => {
          return self.data.get()[self._index("next")]?.element ?? self.innerProvable.empty();
        });
        let isDummy = self.isAtEnd();
        let currentHash = self.nextHash(self.currentHash, element);
        self.currentHash = Provable.if(isDummy, self.hash, currentHash);
        self._updateIndex("next");
        return { element, isDummy };
      }
    };
  }
  clone() {
    let data = Unconstrained.witness(() => [...this.data.get()]);
    let currentIndex = Unconstrained.witness(() => this.currentIndex.get());
    return new this.Constructor({
      data,
      hash: this.hash,
      currentHash: this.currentHash,
      currentIndex
    });
  }
  /**
   * Create a Merkle array type
   */
  static create(type, nextHash = merkleListHash(ProvableType.get(type)), emptyHash_ = emptyHash) {
    var _a2;
    let provable3 = ProvableType.get(type);
    return _a2 = class Iterator extends _MerkleListIterator {
      static from(array) {
        let { hash: hash3, data } = withHashes(array, nextHash, emptyHash_);
        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant2(provable3, x)));
        return this.startIterating({ data: unconstrained, hash: hash3 });
      }
      static fromLast(array) {
        array = [...array].reverse();
        let { hash: hash3, data } = withHashes(array, nextHash, emptyHash_);
        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant2(provable3, x)));
        return this.startIteratingFromLast({ data: unconstrained, hash: hash3 });
      }
      static startIterating({ data, hash: hash3 }) {
        return new this({
          data,
          hash: hash3,
          currentHash: emptyHash_,
          // note: for an empty list or any list which is "at the end", the currentIndex is -1
          currentIndex: Unconstrained.witness(() => data.get().length - 1)
        });
      }
      static startIteratingFromLast({ data, hash: hash3 }) {
        return new this({
          data,
          hash: hash3,
          currentHash: hash3,
          currentIndex: Unconstrained.from(0)
        });
      }
      static empty() {
        return this.from([]);
      }
      static get provable() {
        assert3(this._provable !== void 0, "MerkleListIterator not initialized");
        return this._provable;
      }
    }, _a2._innerProvable = ProvableType.get(provable3), _a2._provable = provableFromClass(_a2, {
      hash: Field4,
      data: Unconstrained,
      currentHash: Field4,
      currentIndex: Unconstrained
    }), _a2._nextHash = nextHash, _a2._emptyHash = emptyHash_, _a2;
  }
  static createFromList(merkleList) {
    return this.create(merkleList.prototype.innerProvable, merkleList._nextHash, merkleList.emptyHash);
  }
  get Constructor() {
    return this.constructor;
  }
  nextHash(hash3, value) {
    assert3(this.Constructor._nextHash !== void 0, "MerkleListIterator not initialized");
    return this.Constructor._nextHash(hash3, value);
  }
  static get emptyHash() {
    assert3(this._emptyHash !== void 0, "MerkleList not initialized");
    return this._emptyHash;
  }
  get innerProvable() {
    assert3(this.Constructor._innerProvable !== void 0, "MerkleListIterator not initialized");
    return this.Constructor._innerProvable;
  }
};
function genericHash(provable3, prefix, value) {
  let input = provable3.toInput(value);
  let packed = packToFields(input);
  return Poseidon2.hashWithPrefix(prefix, packed);
}
function merkleListHash(provable3, prefix = "") {
  return function nextHash(hash3, value) {
    let input = provable3.toInput(value);
    let packed = packToFields(input);
    return Poseidon2.hashWithPrefix(prefix, [hash3, ...packed]);
  };
}
function withHashes(data, nextHash, emptyHash2) {
  let n = data.length;
  let arrayWithHashes = Array(n);
  let currentHash = emptyHash2;
  for (let i = n - 1; i >= 0; i--) {
    arrayWithHashes[i] = { previousHash: currentHash, element: data[i] };
    currentHash = nextHash(currentHash, data[i]);
  }
  return { data: arrayWithHashes, hash: currentHash };
}

// dist/node/lib/provable/option.js
function Option(type) {
  let strictType = ProvableType.get(type);
  const PlainOption = provable({ isSome: Bool4, value: strictType });
  const RawOption = {
    ...PlainOption,
    toValue({ isSome, value }) {
      return isSome.toBoolean() ? strictType.toValue(value) : void 0;
    },
    fromValue(value) {
      if (value === void 0)
        return { isSome: Bool4(false), value: emptyValue(strictType) };
      if (typeof value === "object" && "isSome" in value)
        return PlainOption.fromValue(value);
      return { isSome: Bool4(true), value: strictType.fromValue(value) };
    }
  };
  const Super = Struct(RawOption);
  return class Option_ extends Super {
    orElse(defaultValue) {
      return Provable.if(this.isSome, strictType, this.value, strictType.fromValue(defaultValue));
    }
    assertSome(message) {
      this.isSome.assertTrue(message);
      return this.value;
    }
    static from(value) {
      return value === void 0 ? new Option_({ isSome: Bool4(false), value: emptyValue(strictType) }) : new Option_({
        isSome: Bool4(true),
        value: strictType.fromValue(value)
      });
    }
    static none() {
      return Option_.from(void 0);
    }
    static fromFields(fields2, aux) {
      return new Option_(Super.fromFields(fields2, aux));
    }
    static fromValue(value) {
      return new Option_(Super.fromValue(value));
    }
  };
}

// dist/node/lib/provable/merkle-tree.js
var MerkleTree = class _MerkleTree {
  /**
   * Creates a new, empty [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @param height The height of Merkle Tree.
   * @returns A new MerkleTree
   */
  constructor(height) {
    this.height = height;
    this.nodes = {};
    this.zeroes = new Array(height);
    this.zeroes[0] = Field4(0);
    for (let i = 1; i < height; i += 1) {
      this.zeroes[i] = Poseidon2.hash([this.zeroes[i - 1], this.zeroes[i - 1]]);
    }
  }
  /**
   * Return a new MerkleTree with the same contents as this one.
   */
  clone() {
    let newTree = new _MerkleTree(this.height);
    for (let [level, nodes] of Object.entries(this.nodes)) {
      newTree.nodes[level] = { ...nodes };
    }
    return newTree;
  }
  /**
   * Returns a node which lives at a given index and level.
   * @param level Level of the node.
   * @param index Index of the node.
   * @returns The data of the node.
   */
  getNode(level, index) {
    return this.nodes[level]?.[index.toString()] ?? this.zeroes[level];
  }
  /**
   * Returns a leaf at a given index.
   * @param index Index of the leaf.
   * @returns The data of the leaf.
   */
  getLeaf(key) {
    return this.getNode(0, key);
  }
  /**
   * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @returns The root of the Merkle Tree.
   */
  getRoot() {
    return this.getNode(this.height - 1, 0n);
  }
  // TODO: this allows to set a node at an index larger than the size. OK?
  setNode(level, index, value) {
    (this.nodes[level] ??= {})[index.toString()] = value;
  }
  // TODO: if this is passed an index bigger than the max, it will set a couple of out-of-bounds nodes but not affect the real Merkle root. OK?
  /**
   * Sets the value of a leaf node at a given index to a given value.
   * @param index Position of the leaf node.
   * @param leaf New value.
   */
  setLeaf(index, leaf) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    this.setNode(0, index, leaf);
    let currIndex = index;
    for (let level = 1; level < this.height; level++) {
      currIndex /= 2n;
      const left = this.getNode(level - 1, currIndex * 2n);
      const right = this.getNode(level - 1, currIndex * 2n + 1n);
      this.setNode(level, currIndex, Poseidon2.hash([left, right]));
    }
  }
  /**
   * Returns the witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the leaf at the given index.
   * @param index Position of the leaf node.
   * @returns The witness that belongs to the leaf.
   */
  getWitness(index) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    const witness2 = [];
    for (let level = 0; level < this.height - 1; level++) {
      const isLeft = index % 2n === 0n;
      const sibling = this.getNode(level, isLeft ? index + 1n : index - 1n);
      witness2.push({ isLeft, sibling });
      index /= 2n;
    }
    return witness2;
  }
  // TODO: this will always return true if the merkle tree was constructed normally; seems to be only useful for testing. remove?
  /**
   * Checks if the witness that belongs to the leaf at the given index is a valid witness.
   * @param index Position of the leaf node.
   * @returns True if the witness for the leaf node is valid.
   */
  validate(index) {
    const path = this.getWitness(index);
    let hash3 = this.getNode(0, index);
    for (const node of path) {
      hash3 = Poseidon2.hash(node.isLeft ? [hash3, node.sibling] : [node.sibling, hash3]);
    }
    return hash3.toString() === this.getRoot().toString();
  }
  // TODO: should this take an optional offset? should it fail if the array is too long?
  /**
   * Fills all leaves of the tree.
   * @param leaves Values to fill the leaves with.
   */
  fill(leaves) {
    leaves.forEach((value, index) => {
      this.setLeaf(BigInt(index), value);
    });
  }
  /**
   * Returns the amount of leaf nodes.
   * @returns Amount of leaf nodes.
   */
  get leafCount() {
    return 2n ** BigInt(this.height - 1);
  }
};
var BaseMerkleWitness = class extends CircuitValue {
  height() {
    return this.constructor.height;
  }
  /**
   * Takes a {@link Witness} and turns it into a circuit-compatible Witness.
   * @param witness Witness.
   * @returns A circuit-compatible Witness.
   */
  constructor(witness2) {
    super();
    let height = witness2.length + 1;
    if (height !== this.height()) {
      throw Error(`Length of witness ${height}-1 doesn't match static tree height ${this.height()}.`);
    }
    this.path = witness2.map((item) => item.sibling);
    this.isLeft = witness2.map((item) => Bool4(item.isLeft));
  }
  /**
   * Calculates a root depending on the leaf value.
   * @param leaf Value of the leaf node that belongs to this Witness.
   * @returns The calculated root.
   */
  calculateRoot(leaf) {
    let hash3 = leaf;
    let n = this.height();
    for (let i = 1; i < n; ++i) {
      let isLeft = this.isLeft[i - 1];
      const [left, right] = conditionalSwap(isLeft, hash3, this.path[i - 1]);
      hash3 = Poseidon2.hash([left, right]);
    }
    return hash3;
  }
  /**
   * Calculates the index of the leaf node that belongs to this Witness.
   * @returns Index of the leaf.
   */
  calculateIndex() {
    let powerOfTwo = Field4(1);
    let index = Field4(0);
    let n = this.height();
    for (let i = 1; i < n; ++i) {
      index = Provable.if(this.isLeft[i - 1], index, index.add(powerOfTwo));
      powerOfTwo = powerOfTwo.mul(2);
    }
    return index;
  }
};
function MerkleWitness(height) {
  class MerkleWitness_ extends BaseMerkleWitness {
  }
  MerkleWitness_.height = height;
  arrayProp(Field4, height - 1)(MerkleWitness_.prototype, "path");
  arrayProp(Bool4, height - 1)(MerkleWitness_.prototype, "isLeft");
  return MerkleWitness_;
}
function conditionalSwap(b2, x, y) {
  let m = b2.toField().mul(x.sub(y));
  const x_ = y.add(m);
  const y_ = x.sub(m);
  return [x_, y_];
}

// dist/node/lib/provable/merkle-tree-indexed.js
function IndexedMerkleMap(height) {
  var _a2;
  assert3(height > 0, "height must be positive");
  assert3(height < 53, "height must be less than 53, so that we can use 64-bit floats to represent indices.");
  return _a2 = class IndexedMerkleMap extends IndexedMerkleMapBase {
    get height() {
      return height;
    }
  }, _a2.provable = provableFromClass(_a2, provableBase), _a2;
}
var provableBase = {
  root: Field4,
  length: Field4,
  data: Unconstrained.withEmpty({
    nodes: [],
    sortedLeaves: []
  })
};
var IndexedMerkleMapBase = class _IndexedMerkleMapBase {
  // static data defining constraints
  get height() {
    throw Error("Height must be defined in a subclass");
  }
  /**
   * Creates a new, empty Indexed Merkle Map.
   */
  constructor() {
    let height = this.height;
    let nodes = Array(height);
    for (let level = 0; level < height; level++) {
      nodes[level] = [];
    }
    let firstLeaf = _IndexedMerkleMapBase._firstLeaf;
    let firstNode = Leaf.hashNode(firstLeaf).toBigInt();
    let root = Nodes.setLeaf(nodes, 0, firstNode);
    this.root = Field4(root);
    this.length = Field4(1);
    this.data = Unconstrained.from({ nodes, sortedLeaves: [firstLeaf] });
  }
  /**
   * Clone the entire Merkle map.
   *
   * This method is provable.
   */
  clone() {
    let cloned = new this.constructor();
    cloned.root = this.root;
    cloned.length = this.length;
    cloned.data.updateAsProver(() => {
      let { nodes, sortedLeaves } = this.data.get();
      return {
        nodes: nodes.map((row) => [...row]),
        sortedLeaves: [...sortedLeaves]
      };
    });
    return cloned;
  }
  /**
   * Overwrite the entire Merkle map with another one.
   *
   * This method is provable.
   */
  overwrite(other) {
    this.overwriteIf(true, other);
  }
  /**
   * Overwrite the entire Merkle map with another one, if the condition is true.
   *
   * This method is provable.
   */
  overwriteIf(condition, other) {
    condition = Bool4(condition);
    this.root = Provable.if(condition, other.root, this.root);
    this.length = Provable.if(condition, other.length, this.length);
    this.data.updateAsProver(() => Bool4(condition).toBoolean() ? other.clone().data.get() : this.data.get());
  }
  /**
   * Insert a new leaf `(key, value)`.
   *
   * Proves that `key` doesn't exist yet.
   */
  insert(key, value) {
    key = Field4(key);
    value = Field4(value);
    let index = this.length;
    let indexBits = index.toBits(this.height - 1);
    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);
    let lowPath = this._proveInclusion(low, "Invalid low node (root)");
    assertStrictlyBetween(low.key, key, low.nextKey, "Key already exists in the tree");
    let newLow = { ...low, nextKey: key };
    this.root = this._proveUpdate(newLow, lowPath);
    this._setLeafUnconstrained(true, newLow);
    let leaf = Leaf.nextAfter(newLow, index, {
      key,
      value,
      nextKey: low.nextKey
    });
    let path = this._proveEmpty(indexBits);
    this.root = this._proveUpdate(leaf, path);
    this.length = this.length.add(1);
    this._setLeafUnconstrained(false, leaf);
  }
  /**
   * Update an existing leaf `(key, value)`.
   *
   * Proves that the `key` exists.
   *
   * Returns the previous value.
   */
  update(key, value) {
    key = Field4(key);
    value = Field4(value);
    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);
    let path = this._proveInclusion(self, "Key does not exist in the tree");
    self.key.assertEquals(key, "Invalid leaf (key)");
    let newSelf = { ...self, value };
    this.root = this._proveUpdate(newSelf, path);
    this._setLeafUnconstrained(true, newSelf);
    return self.value;
  }
  /**
   * Perform _either_ an insertion or update, depending on whether the key exists.
   *
   * Note: This method is handling both the `insert()` and `update()` case at the same time, so you
   * can use it if you don't know whether the key exists or not.
   *
   * However, this comes at an efficiency cost, so prefer to use `insert()` or `update()` if you know whether the key exists.
   *
   * Returns the previous value, as an option (which is `None` if the key didn't exist before).
   */
  set(key, value) {
    key = Field4(key);
    value = Field4(value);
    let { low, self } = Provable.witness(LeafPair, () => this._findLeaf(key));
    let lowPath = this._proveInclusion(low, "Invalid low node (root)");
    assertBetween(low.key, key, low.nextKey, "Invalid low node (key)");
    let keyExists = low.nextKey.equals(key);
    let index = Provable.witness(Field4, () => self.index.get());
    index = Provable.if(keyExists, index, this.length);
    let indexBits = index.toBits(this.height - 1);
    let newLow = { ...low, nextKey: key };
    this.root = this._proveUpdate(newLow, lowPath);
    this._setLeafUnconstrained(true, newLow);
    let path = this._proveInclusionOrEmpty(keyExists, indexBits, self, "Invalid leaf (root)");
    assert3(keyExists.implies(self.key.equals(key)), "Invalid leaf (key)");
    let newLeaf = Leaf.nextAfter(newLow, index, {
      key,
      value,
      nextKey: Provable.if(keyExists, self.nextKey, low.nextKey)
    });
    this.root = this._proveUpdate(newLeaf, path);
    this.length = Provable.if(keyExists, this.length, this.length.add(1));
    this._setLeafUnconstrained(keyExists, newLeaf);
    return new OptionField({ isSome: keyExists, value: self.value });
  }
  /**
   * Perform an insertion or update, if the enabling condition is true.
   *
   * If the condition is false, we instead set the 0 key to the value 0.
   * This is the initial value and for typical uses of `IndexedMerkleMap`, it is guaranteed to be a no-op because the 0 key is never used.
   *
   * **Warning**: Only use this method if you are sure that the 0 key is not used in your application.
   * Otherwise, you might accidentally overwrite a valid key-value pair.
   */
  setIf(condition, key, value) {
    return this.set(Provable.if(Bool4(condition), Field4(key), Field4(0n)), Provable.if(Bool4(condition), Field4(value), Field4(0n)));
  }
  /**
   * Get a value from a key.
   *
   * Proves that the key already exists in the map yet and fails otherwise.
   */
  get(key) {
    key = Field4(key);
    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);
    this._proveInclusion(self, "Key does not exist in the tree");
    self.key.assertEquals(key, "Invalid leaf (key)");
    return self.value;
  }
  /**
   * Get a value from a key.
   *
   * Returns an option which is `None` if the key doesn't exist. (In that case, the option's value is unconstrained.)
   *
   * Note that this is more flexible than `get()` and allows you to handle the case where the key doesn't exist.
   * However, it uses about twice as many constraints for that reason.
   */
  getOption(key) {
    key = Field4(key);
    let { low, self } = Provable.witness(LeafPair, () => this._findLeaf(key));
    this._proveInclusion(low, "Invalid low node (root)");
    assertBetween(low.key, key, low.nextKey, "Invalid low node (key)");
    let keyExists = low.nextKey.equals(key);
    this._proveInclusionIf(keyExists, self, "Invalid leaf (root)");
    assert3(keyExists.implies(self.key.equals(key)), "Invalid leaf (key)");
    return new OptionField({ isSome: keyExists, value: self.value });
  }
  // methods to check for inclusion for a key without being concerned about the value
  /**
   * Prove that the given key exists in the map.
   */
  assertIncluded(key, message) {
    key = Field4(key);
    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);
    this._proveInclusion(self, message ?? "Key does not exist in the tree");
    self.key.assertEquals(key, "Invalid leaf (key)");
  }
  /**
   * Prove that the given key does not exist in the map.
   */
  assertNotIncluded(key, message) {
    key = Field4(key);
    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);
    this._proveInclusion(low, "Invalid low node (root)");
    assertStrictlyBetween(low.key, key, low.nextKey, message ?? "Key already exists in the tree");
  }
  /**
   * Check whether the given key exists in the map.
   */
  isIncluded(key) {
    key = Field4(key);
    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);
    this._proveInclusion(low, "Invalid low node (root)");
    assertBetween(low.key, key, low.nextKey, "Invalid low node (key)");
    return low.nextKey.equals(key);
  }
  // helper methods
  /**
   * Helper method to prove inclusion of a leaf in the tree.
   */
  _proveInclusion(leaf, message) {
    let node = Leaf.hashNode(leaf);
    let { root, path } = this._computeRoot(node, leaf.index);
    root.assertEquals(this.root, message ?? "Leaf is not included in the tree");
    return path;
  }
  /**
   * Helper method to conditionally prove inclusion of a leaf in the tree.
   */
  _proveInclusionIf(condition, leaf, message) {
    let node = Leaf.hashNode(leaf);
    let { root } = this._computeRoot(node, leaf.index);
    assert3(condition.implies(root.equals(this.root)), message ?? "Leaf is not included in the tree");
  }
  /**
   * Helper method to prove inclusion of an empty leaf in the tree.
   *
   * This validates the path against the current root, so that we can use it to insert a new leaf.
   */
  _proveEmpty(index) {
    let node = Field4(0n);
    let { root, path } = this._computeRoot(node, index);
    root.assertEquals(this.root, "Leaf is not empty");
    return path;
  }
  /**
   * Helper method to conditionally prove inclusion of a leaf in the tree.
   *
   * If the condition is false, we prove that the tree contains an empty leaf instead.
   */
  _proveInclusionOrEmpty(condition, index, leaf, message) {
    let node = Provable.if(condition, Leaf.hashNode(leaf), Field4(0n));
    let { root, path } = this._computeRoot(node, index);
    root.assertEquals(this.root, message ?? "Leaf is not included in the tree");
    return path;
  }
  /**
   * Helper method to update the root against a previously validated path.
   *
   * Returns the new root.
   */
  _proveUpdate(leaf, path) {
    let node = Leaf.hashNode(leaf);
    let { root } = this._computeRoot(node, path.index, path.witness);
    return root;
  }
  /**
   * Helper method to compute the root given a leaf node and its index.
   *
   * The index can be given as a `Field` or as an array of bits.
   */
  _computeRoot(node, index, witness2) {
    let indexBits = index instanceof Unconstrained ? Provable.witness(Provable.Array(Bool4, this.height - 1), () => Field4(index.get()).toBits(this.height - 1)) : index;
    let witness_ = witness2 ?? Provable.witnessFields(this.height - 1, () => {
      let witness3 = [];
      let index2 = Number(Field4.fromBits(indexBits));
      let { nodes } = this.data.get();
      for (let level = 0; level < this.height - 1; level++) {
        let i = index2 % 2 === 0 ? index2 + 1 : index2 - 1;
        let sibling = Nodes.getNode(nodes, level, i, false);
        witness3.push(sibling);
        index2 >>= 1;
      }
      return witness3;
    });
    assert3(indexBits.length === this.height - 1, "Invalid index size");
    assert3(witness_.length === this.height - 1, "Invalid witness size");
    for (let level = 0; level < this.height - 1; level++) {
      let isRight = indexBits[level];
      let sibling = witness_[level];
      let [right, left] = conditionalSwap(isRight, node, sibling);
      node = Poseidon2.hash([left, right]);
    }
    return { root: node, path: { witness: witness_, index: indexBits } };
  }
  /**
   * Given a key, returns both the low node and the leaf that contains the key.
   *
   * If the key does not exist, a dummy value is returned for the leaf.
   *
   * Can only be called outside provable code.
   */
  _findLeaf(key_) {
    let key = typeof key_ === "bigint" ? key_ : key_.toBigInt();
    assert3(key >= 0n, "key must be positive");
    let leaves = this.data.get().sortedLeaves;
    if (key === 0n)
      return {
        low: Leaf.fromStored(leaves[leaves.length - 1], leaves.length - 1),
        self: Leaf.fromStored(leaves[0], 0)
      };
    let { lowIndex, foundValue } = bisectUnique(key, (i) => leaves[i].key, leaves.length);
    let iLow = foundValue ? lowIndex - 1 : lowIndex;
    let low = Leaf.fromStored(leaves[iLow], iLow);
    let iSelf = foundValue ? lowIndex : 0;
    let selfBase = foundValue ? leaves[lowIndex] : Leaf.toStored(Leaf.empty());
    let self = Leaf.fromStored(selfBase, iSelf);
    return { low, self };
  }
  /**
   * Update or append a leaf in our internal data structures
   */
  _setLeafUnconstrained(leafExists, leaf) {
    Provable.asProver(() => {
      let { nodes, sortedLeaves } = this.data.get();
      let i = leaf.index.get();
      Nodes.setLeaf(nodes, i, Leaf.hashNode(leaf).toBigInt());
      let leafValue = Leaf.toStored(leaf);
      let iSorted = leaf.sortedIndex.get();
      if (Bool4(leafExists).toBoolean()) {
        sortedLeaves[iSorted % sortedLeaves.length] = leafValue;
      } else {
        sortedLeaves.splice(iSorted, 0, leafValue);
      }
    });
  }
};
IndexedMerkleMapBase.provable = void 0;
IndexedMerkleMapBase._firstLeaf = {
  key: 0n,
  value: 0n,
  // the 0 key encodes the minimum and maximum at the same time
  // so, if a second node is inserted, it will get `nextKey = 0`, and thus point to the first node
  nextKey: 0n,
  index: 0
};
var Nodes;
(function(Nodes2) {
  function setLeaf(nodes, index, leaf) {
    nodes[0][index] = leaf;
    let height = nodes.length;
    for (let level = 0; level < height - 1; level++) {
      let isLeft = index % 2 === 0;
      index = Math.floor(index / 2);
      let left = getNode(nodes, level, index * 2, isLeft);
      let right = getNode(nodes, level, index * 2 + 1, !isLeft);
      nodes[level + 1][index] = Poseidon.hash([left, right]);
    }
    return getNode(nodes, height - 1, 0, true);
  }
  Nodes2.setLeaf = setLeaf;
  function getNode(nodes, level, index, nonEmpty) {
    let node = nodes[level]?.[index];
    if (node === void 0) {
      if (nonEmpty)
        throw Error(`node at level=${level}, index=${index} was expected to be known, but isn't.`);
      node = empty4(level);
    }
    return node;
  }
  Nodes2.getNode = getNode;
  const emptyNodes = [0n];
  function empty4(level) {
    for (let i = emptyNodes.length; i <= level; i++) {
      let zero2 = emptyNodes[i - 1];
      emptyNodes[i] = Poseidon.hash([zero2, zero2]);
    }
    return emptyNodes[level];
  }
  Nodes2.empty = empty4;
})(Nodes || (Nodes = {}));
var BaseLeaf = class extends Struct({
  key: Field4,
  value: Field4,
  nextKey: Field4
}) {
};
var Leaf = class extends Struct({
  value: Field4,
  key: Field4,
  nextKey: Field4,
  // auxiliary data that tells us where the leaf is stored
  index: Unconstrained.withEmpty(0),
  sortedIndex: Unconstrained.withEmpty(0)
}) {
  /**
   * Compute a leaf node: the hash of a leaf that becomes part of the Merkle tree.
   */
  static hashNode(leaf) {
    return Poseidon2.hashPacked(BaseLeaf, BaseLeaf.fromValue(leaf));
  }
  /**
   * Create a new leaf, given its low node and index.
   */
  static nextAfter(low, index, leaf) {
    return {
      key: leaf.key,
      value: leaf.value,
      nextKey: leaf.nextKey,
      index: Unconstrained.witness(() => Number(index)),
      sortedIndex: Unconstrained.witness(() => low.sortedIndex.get() + 1)
    };
  }
  // convert to/from internally stored format
  static toStored(leaf) {
    return {
      key: leaf.key.toBigInt(),
      value: leaf.value.toBigInt(),
      nextKey: leaf.nextKey.toBigInt(),
      index: leaf.index.get()
    };
  }
  static fromStored(leaf, sortedIndex) {
    return { ...leaf, sortedIndex };
  }
};
var LeafPair = class extends Struct({ low: Leaf, self: Leaf }) {
};
var OptionField = class extends Option(Field4) {
};
function bisectUnique(target, getValue, length) {
  let [iLow, iHigh] = [0, length - 1];
  if (getValue(iLow) > target)
    return { lowIndex: -1, foundValue: false };
  if (getValue(iHigh) < target)
    return { lowIndex: iHigh, foundValue: false };
  while (iHigh !== iLow) {
    let iMid = Math.ceil((iLow + iHigh) / 2);
    if (getValue(iMid) <= target) {
      iLow = iMid;
    } else {
      iHigh = iMid - 1;
    }
  }
  return { lowIndex: iLow, foundValue: getValue(iLow) === target };
}
function assertStrictlyBetween(low, x, high, message) {
  x.assertNotEquals(0n, message ?? "0 is not in any strict range");
  low.assertLessThan(x, message);
  let highIsZero = high.equals(0n);
  let xSafe = Provable.witness(Field4, () => highIsZero.toBoolean() ? 0n : x);
  let highSafe = Provable.witness(Field4, () => highIsZero.toBoolean() ? 1n : high);
  xSafe.assertLessThan(highSafe, message);
  assert3(xSafe.equals(x).or(highIsZero), message);
  assert3(highSafe.equals(high).or(highIsZero), message);
}
function assertBetween(low, x, high, message) {
  let xIsZero = x.equals(0n);
  let lowSafe = Provable.witness(Field4, () => xIsZero.toBoolean() ? 0n : low);
  let xSafe1 = Provable.witness(Field4, () => xIsZero.toBoolean() ? 1n : x);
  lowSafe.assertLessThan(xSafe1, message);
  assert3(lowSafe.equals(low).or(xIsZero), message);
  assert3(xSafe1.equals(x).or(xIsZero), message);
  let highIsZero = high.equals(0n);
  let xSafe0 = Provable.witness(Field4, () => highIsZero.toBoolean() ? 0n : x);
  xSafe0.assertLessThanOrEqual(high, message);
  assert3(xSafe0.equals(x).or(highIsZero), message);
}

// dist/node/lib/mina/mina.js
var mina_exports = {};
__export(mina_exports, {
  LocalBlockchain: () => LocalBlockchain,
  Network: () => Network2,
  TestPublicKey: () => TestPublicKey,
  Transaction: () => Transaction,
  activeInstance: () => activeInstance,
  currentSlot: () => currentSlot,
  currentTransaction: () => currentTransaction,
  faucet: () => faucet,
  fetchActions: () => fetchActions,
  fetchEvents: () => fetchEvents,
  filterGroups: () => filterGroups,
  getAccount: () => getAccount,
  getActions: () => getActions,
  getBalance: () => getBalance,
  getNetworkConstants: () => getNetworkConstants,
  getNetworkId: () => getNetworkId,
  getNetworkState: () => getNetworkState,
  getProofsEnabled: () => getProofsEnabled,
  hasAccount: () => hasAccount,
  sender: () => sender,
  setActiveInstance: () => setActiveInstance,
  transaction: () => transaction,
  waitForFunding: () => waitForFunding
});

// dist/node/lib/mina/mina-instance.js
var defaultAccountCreationFee = 1e9;
var defaultNetworkConstants = {
  genesisTimestamp: UInt642.from(0),
  slotTime: UInt642.from(3 * 60 * 1e3),
  accountCreationFee: UInt642.from(defaultAccountCreationFee)
};
var ZkappStateLength = 8;
var activeInstance = {
  getNetworkConstants: () => defaultNetworkConstants,
  currentSlot: noActiveInstance,
  hasAccount: noActiveInstance,
  getAccount: noActiveInstance,
  getNetworkState: noActiveInstance,
  sendTransaction: noActiveInstance,
  transaction: noActiveInstance,
  fetchEvents: noActiveInstance,
  fetchActions: noActiveInstance,
  getActions: noActiveInstance,
  proofsEnabled: true,
  getNetworkId: () => "testnet"
};
function setActiveInstance(m) {
  activeInstance = m;
}
function noActiveInstance() {
  throw Error("Must call Mina.setActiveInstance first");
}
function currentSlot() {
  return activeInstance.currentSlot();
}
function getAccount(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId);
}
function hasAccount(publicKey, tokenId) {
  return activeInstance.hasAccount(publicKey, tokenId);
}
function getNetworkId() {
  return activeInstance.getNetworkId();
}
function getNetworkConstants() {
  return activeInstance.getNetworkConstants();
}
function getNetworkState() {
  return activeInstance.getNetworkState();
}
function getBalance(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId).balance;
}
async function fetchEvents(publicKey, tokenId, filterOptions = {}) {
  return await activeInstance.fetchEvents(publicKey, tokenId, filterOptions);
}
async function fetchActions(publicKey, actionStates, tokenId) {
  return await activeInstance.fetchActions(publicKey, actionStates, tokenId);
}
function getActions(publicKey, actionStates, tokenId) {
  return activeInstance.getActions(publicKey, actionStates, tokenId);
}
function getProofsEnabled() {
  return activeInstance.proofsEnabled;
}

// dist/node/lib/mina/precondition.js
var NetworkPrecondition = {
  ignoreAll() {
    let stakingEpochData = {
      ledger: { hash: ignore(Field4(0)), totalCurrency: ignore(uint64()) },
      seed: ignore(Field4(0)),
      startCheckpoint: ignore(Field4(0)),
      lockCheckpoint: ignore(Field4(0)),
      epochLength: ignore(uint32())
    };
    let nextEpochData = cloneCircuitValue(stakingEpochData);
    return {
      snarkedLedgerHash: ignore(Field4(0)),
      blockchainLength: ignore(uint32()),
      minWindowDensity: ignore(uint32()),
      totalCurrency: ignore(uint64()),
      globalSlotSinceGenesis: ignore(uint32()),
      stakingEpochData,
      nextEpochData
    };
  }
};
function ignore(dummy) {
  return { isSome: Bool4(false), value: dummy };
}
var uint32 = () => ({ lower: UInt322.from(0), upper: UInt322.MAXINT() });
var uint64 = () => ({ lower: UInt642.from(0), upper: UInt642.MAXINT() });
var AccountPrecondition = {
  ignoreAll() {
    let appState = [];
    for (let i = 0; i < ZkappStateLength; ++i) {
      appState.push(ignore(Field4(0)));
    }
    return {
      balance: ignore(uint64()),
      nonce: ignore(uint32()),
      receiptChainHash: ignore(Field4(0)),
      delegate: ignore(PublicKey2.empty()),
      state: appState,
      actionState: ignore(Actions.emptyActionState()),
      provedState: ignore(Bool4(false)),
      isNew: ignore(Bool4(false))
    };
  }
};
var GlobalSlotPrecondition = {
  ignoreAll() {
    return ignore(uint32());
  }
};
var Preconditions = {
  ignoreAll() {
    return {
      account: AccountPrecondition.ignoreAll(),
      network: NetworkPrecondition.ignoreAll(),
      validWhile: GlobalSlotPrecondition.ignoreAll()
    };
  }
};
function preconditions(accountUpdate, isSelf) {
  initializePreconditions(accountUpdate, isSelf);
  return {
    account: Account3(accountUpdate),
    network: Network(accountUpdate),
    currentSlot: CurrentSlot(accountUpdate)
  };
}
function Network(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.network;
  let context = getPreconditionContextExn(accountUpdate);
  let network = preconditionClass(layout, "network", accountUpdate, context);
  let timestamp = {
    get() {
      let slot = network.globalSlotSinceGenesis.get();
      return globalSlotToTimestamp(slot);
    },
    getAndRequireEquals() {
      let slot = network.globalSlotSinceGenesis.getAndRequireEquals();
      return globalSlotToTimestamp(slot);
    },
    requireEquals(value) {
      let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
      let slot = timestampToGlobalSlot(value, `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},
i.e., the genesis timestamp plus an integer number of slots.`);
      return network.globalSlotSinceGenesis.requireEquals(slot);
    },
    requireEqualsIf(condition, value) {
      let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
      let slot = timestampToGlobalSlot(value, `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},
i.e., the genesis timestamp plus an integer number of slots.`);
      return network.globalSlotSinceGenesis.requireEqualsIf(condition, slot);
    },
    requireBetween(lower, upper) {
      let [slotLower, slotUpper] = timestampToGlobalSlotRange(lower, upper);
      return network.globalSlotSinceGenesis.requireBetween(slotLower, slotUpper);
    },
    requireNothing() {
      return network.globalSlotSinceGenesis.requireNothing();
    }
  };
  return { ...network, timestamp };
}
function Account3(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.account;
  let context = getPreconditionContextExn(accountUpdate);
  let identity = (x) => x;
  let update = {
    delegate: {
      ...preconditionSubclass(accountUpdate, "account.delegate", PublicKey2, context),
      ...updateSubclass(accountUpdate, "delegate", identity)
    },
    verificationKey: updateSubclass(accountUpdate, "verificationKey", identity),
    permissions: updateSubclass(accountUpdate, "permissions", identity),
    zkappUri: updateSubclass(accountUpdate, "zkappUri", ZkappUri.fromJSON),
    tokenSymbol: updateSubclass(accountUpdate, "tokenSymbol", TokenSymbol.from),
    timing: updateSubclass(accountUpdate, "timing", identity),
    votingFor: updateSubclass(accountUpdate, "votingFor", identity)
  };
  return {
    ...preconditionClass(layout, "account", accountUpdate, context),
    ...update
  };
}
function updateSubclass(accountUpdate, key, transform) {
  return {
    set(value) {
      accountUpdate.body.update[key].isSome = Bool4(true);
      accountUpdate.body.update[key].value = transform(value);
    }
  };
}
function CurrentSlot(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  return {
    requireBetween(lower, upper) {
      context.constrained.add("validWhile");
      let property = accountUpdate.body.preconditions.validWhile;
      ensureConsistentPrecondition(property, Bool4(true), { lower, upper }, "validWhile");
      property.isSome = Bool4(true);
      property.value.lower = lower;
      property.value.upper = upper;
    }
  };
}
var unimplementedPreconditions = [
  // unimplemented because its not checked in the protocol
  "network.stakingEpochData.seed",
  "network.nextEpochData.seed"
];
var baseMap = { UInt64: UInt642, UInt32: UInt322, Field: Field4, Bool: Bool4, PublicKey: PublicKey2, ActionState };
function getProvableType(layout) {
  let typeName = layout.checkedTypeName ?? layout.type;
  let type = baseMap[typeName];
  assert2(type !== void 0, `Unknown precondition base type ${typeName}`);
  return type;
}
function preconditionClass(layout, baseKey, accountUpdate, context) {
  if (layout.type === "option") {
    if (layout.optionType === "closedInterval") {
      let baseType = getProvableType(layout.inner.entries.lower);
      return preconditionSubClassWithRange(accountUpdate, baseKey, baseType, context);
    } else if (layout.optionType === "flaggedOption") {
      let baseType = getProvableType(layout.inner);
      return preconditionSubclass(accountUpdate, baseKey, baseType, context);
    }
  } else if (layout.type === "array") {
    return {};
  } else if (layout.type === "object") {
    return Object.fromEntries(layout.keys.map((key) => {
      let value = layout.entries[key];
      return [
        key,
        preconditionClass(value, `${baseKey}.${key}`, accountUpdate, context)
      ];
    }));
  } else
    throw Error("bug");
}
function preconditionSubClassWithRange(accountUpdate, longKey, fieldType, context) {
  return {
    ...preconditionSubclass(accountUpdate, longKey, fieldType, context),
    requireBetween(lower, upper) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      let newValue = { lower, upper };
      ensureConsistentPrecondition(property, Bool4(true), newValue, longKey);
      property.isSome = Bool4(true);
      property.value = newValue;
    }
  };
}
function defaultLower(fieldType) {
  assert2(fieldType === UInt322 || fieldType === UInt642);
  return fieldType.zero;
}
function defaultUpper(fieldType) {
  assert2(fieldType === UInt322 || fieldType === UInt642);
  return fieldType.MAXINT();
}
function preconditionSubclass(accountUpdate, longKey, fieldType, context) {
  if (fieldType === void 0) {
    throw Error(`this.${longKey}: fieldType undefined`);
  }
  let obj = {
    get() {
      if (unimplementedPreconditions.includes(longKey)) {
        let self = context.isSelf ? "this" : "accountUpdate";
        throw Error(`${self}.${longKey}.get() is not implemented yet.`);
      }
      let { read, vars } = context;
      read.add(longKey);
      return vars[longKey] ??= getVariable(accountUpdate, longKey, fieldType);
    },
    getAndRequireEquals() {
      let value = obj.get();
      obj.requireEquals(value);
      return value;
    },
    requireEquals(value) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      if ("isSome" in property) {
        let isInterval = "lower" in property.value && "upper" in property.value;
        let newValue = isInterval ? { lower: value, upper: value } : value;
        ensureConsistentPrecondition(property, Bool4(true), newValue, longKey);
        property.isSome = Bool4(true);
        property.value = newValue;
      } else {
        setPath(accountUpdate.body.preconditions, longKey, value);
      }
    },
    requireEqualsIf(condition, value) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      assert2("isSome" in property);
      if ("lower" in property.value && "upper" in property.value) {
        let lower = Provable.if(condition, fieldType, value, defaultLower(fieldType));
        let upper = Provable.if(condition, fieldType, value, defaultUpper(fieldType));
        ensureConsistentPrecondition(property, condition, { lower, upper }, longKey);
        property.isSome = condition;
        property.value.lower = lower;
        property.value.upper = upper;
      } else {
        let newValue = Provable.if(condition, fieldType, value, fieldType.empty());
        ensureConsistentPrecondition(property, condition, newValue, longKey);
        property.isSome = condition;
        property.value = newValue;
      }
    },
    requireNothing() {
      let property = getPath(accountUpdate.body.preconditions, longKey);
      if ("isSome" in property) {
        property.isSome = Bool4(false);
        if ("lower" in property.value && "upper" in property.value) {
          property.value.lower = defaultLower(fieldType);
          property.value.upper = defaultUpper(fieldType);
        } else {
          property.value = fieldType.empty();
        }
      }
      context.constrained.add(longKey);
    }
  };
  return obj;
}
function getVariable(accountUpdate, longKey, fieldType) {
  return Provable.witness(fieldType, () => {
    let [accountOrNetwork, ...rest] = longKey.split(".");
    let key = rest.join(".");
    let value;
    if (accountOrNetwork === "account") {
      let account = getAccountPreconditions(accountUpdate.body);
      value = account[key];
    } else if (accountOrNetwork === "network") {
      let networkState = activeInstance.getNetworkState();
      value = getPath(networkState, key);
    } else if (accountOrNetwork === "validWhile") {
      let networkState = activeInstance.getNetworkState();
      value = networkState.globalSlotSinceGenesis;
    } else {
      throw Error("impossible");
    }
    return value;
  });
}
function globalSlotToTimestamp(slot) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  return UInt642.from(slot).mul(slotTime).add(genesisTimestamp);
}
function timestampToGlobalSlot(timestamp, message) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  let { quotient: slot, rest } = timestamp.sub(genesisTimestamp).divMod(slotTime);
  rest.value.assertEquals(Field4(0), message);
  return slot.toUInt32();
}
function timestampToGlobalSlotRange(tsLower, tsUpper) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  let tsLowerInt = Int64.from(tsLower).sub(genesisTimestamp).add(slotTime).sub(1);
  let lowerCapped = Provable.if(tsLowerInt.isPositive(), UInt642, tsLowerInt.magnitude, UInt642.from(0));
  let slotLower = lowerCapped.div(slotTime).toUInt32Clamped();
  let slotUpper = tsUpper.sub(genesisTimestamp).div(slotTime).toUInt32Clamped();
  return [slotLower, slotUpper];
}
function getAccountPreconditions(body) {
  let { publicKey, tokenId } = body;
  let hasAccount2 = activeInstance.hasAccount(publicKey, tokenId);
  if (!hasAccount2) {
    return {
      balance: UInt642.zero,
      nonce: UInt322.zero,
      receiptChainHash: emptyReceiptChainHash(),
      actionState: Actions.emptyActionState(),
      delegate: publicKey,
      provedState: Bool4(false),
      isNew: Bool4(true)
    };
  }
  let account = activeInstance.getAccount(publicKey, tokenId);
  return {
    balance: account.balance,
    nonce: account.nonce,
    receiptChainHash: account.receiptChainHash,
    actionState: account.zkapp?.actionState?.[0] ?? Actions.emptyActionState(),
    delegate: account.delegate ?? account.publicKey,
    provedState: account.zkapp?.provedState ?? Bool4(false),
    isNew: Bool4(false)
  };
}
function initializePreconditions(accountUpdate, isSelf) {
  preconditionContexts.set(accountUpdate, {
    read: /* @__PURE__ */ new Set(),
    constrained: /* @__PURE__ */ new Set(),
    vars: {},
    isSelf
  });
}
function cleanPreconditionsCache(accountUpdate) {
  let context = preconditionContexts.get(accountUpdate);
  if (context !== void 0)
    context.vars = {};
}
function assertPreconditionInvariants(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  let self = context.isSelf ? "this" : "accountUpdate";
  let dummyPreconditions = Preconditions.ignoreAll();
  for (let preconditionPath of context.read) {
    if (context.constrained.has(preconditionPath))
      continue;
    let precondition = getPath(accountUpdate.body.preconditions, preconditionPath);
    let dummy = getPath(dummyPreconditions, preconditionPath);
    if (!circuitValueEquals(precondition, dummy))
      continue;
    let hasRequireBetween = isRangeCondition(precondition);
    let shortPath = preconditionPath.split(".").pop();
    let errorMessage = `You used \`${self}.${preconditionPath}.get()\` without adding a precondition that links it to the actual ${shortPath}.
Consider adding this line to your code:
${self}.${preconditionPath}.requireEquals(${self}.${preconditionPath}.get());${hasRequireBetween ? `
You can also add more flexible preconditions with \`${self}.${preconditionPath}.requireBetween(...)\`.` : ""}`;
    throw Error(errorMessage);
  }
}
function getPreconditionContextExn(accountUpdate) {
  let c = preconditionContexts.get(accountUpdate);
  if (c === void 0)
    throw Error("bug: precondition context not found");
  return c;
}
function ensureConsistentPrecondition(property, newIsSome, value, name) {
  if (!property.isSome.isConstant() || property.isSome.toBoolean()) {
    let errorMessage = `
Precondition Error: Precondition Error: Attempting to set a precondition that is already set for '${name}'.
'${name}' represents the field or value you're trying to set a precondition for.
Preconditions must be set only once to avoid overwriting previous assertions. 
For example, do not use 'requireBetween()' or 'requireEquals()' multiple times on the same field.

Recommendation:
Ensure that preconditions for '${name}' are set in a single place and are not overwritten. If you need to update a precondition,
consider refactoring your code to consolidate all assertions for '${name}' before setting the precondition.

Example of Correct Usage:
// Incorrect Usage:
timestamp.requireBetween(newUInt32(0n), newUInt32(2n));
timestamp.requireBetween(newUInt32(1n), newUInt32(3n));

// Correct Usage:
timestamp.requireBetween(new UInt32(1n), new UInt32(2n));
`;
    property.isSome.assertEquals(newIsSome, errorMessage);
    if ("lower" in property.value && "upper" in property.value) {
      property.value.lower.assertEquals(value.lower, errorMessage);
      property.value.upper.assertEquals(value.lower, errorMessage);
    } else {
      property.value.assertEquals(value, errorMessage);
    }
  }
}
var preconditionContexts = /* @__PURE__ */ new WeakMap();
function isRangeCondition(condition) {
  return "isSome" in condition && "lower" in condition.value;
}
function getPath(obj, path) {
  let pathArray = path.split(".").reverse();
  while (pathArray.length > 0) {
    let key = pathArray.pop();
    obj = obj[key];
  }
  return obj;
}
function setPath(obj, path, value) {
  let pathArray = path.split(".");
  let key = pathArray.pop();
  getPath(obj, pathArray.join("."))[key] = value;
}

// dist/node/mina-signer/src/memo.js
function fromString(memo) {
  let length = stringLengthInBytes(memo);
  if (length > 32)
    throw Error("Memo.fromString: string too long");
  return `${String.fromCharCode(length)}${memo}` + "\0".repeat(32 - length);
}
function toString(memo) {
  let totalLength = stringLengthInBytes(memo);
  if (totalLength !== 34) {
    throw Error(`Memo.toString: length ${totalLength} does not equal 34`);
  }
  if (memo[0] !== "") {
    throw Error("Memo.toString: expected memo to start with 0x01 byte");
  }
  let length = memo.charCodeAt(1);
  if (length > 32)
    throw Error("Memo.toString: invalid length encoding");
  let bytes = stringToBytes(memo).slice(2, 2 + length);
  return stringFromBytes(bytes);
}
function hash2(memo) {
  let bits = Memo.toBits(memo);
  let fields2 = packToFieldsLegacy(HashInputLegacy.bits(bits));
  return hashWithPrefix2(prefixes.zkappMemo, fields2);
}
var SIZE = 34;
var Binable = defineBinable({
  toBytes(memo) {
    return stringToBytes(memo);
  },
  readBytes(bytes, start) {
    let end = start + SIZE;
    let memo = stringFromBytes(bytes.slice(start, end));
    return [memo, end];
  }
});
var Memo = {
  fromString,
  toString,
  hash: hash2,
  ...withBits(Binable, SIZE * 8),
  ...base58(Binable, versionBytes.userCommandMemo),
  sizeInBytes: SIZE,
  empty() {
    return Memo.fromString("");
  },
  toValidString(memo = "") {
    if (stringLengthInBytes(memo) > 32)
      throw Error("Memo: string too long");
    return memo;
  }
};

// dist/node/lib/mina/base58-encodings.js
var { TokenId: TokenId3, ReceiptChainHash: ReceiptChainHash3, EpochSeed, LedgerHash, StateHash: StateHash3 } = fieldEncodings(Field4);

// dist/node/mina-signer/src/sign-zkapp-command.js
function verifyAccountUpdateSignature(update, transactionCommitments2, networkId) {
  if (update.authorization.signature === void 0)
    return false;
  let { publicKey, useFullCommitment } = update.body;
  let { commitment, fullCommitment } = transactionCommitments2;
  let usedCommitment = useFullCommitment ? fullCommitment : commitment;
  let signature = Signature.fromBase58(update.authorization.signature);
  return verifyFieldElement(signature, usedCommitment, publicKey, networkId);
}
function transactionCommitments(zkappCommand, networkId) {
  if (!isCallDepthValid(zkappCommand)) {
    throw Error("zkapp command: invalid call depth");
  }
  let callForest = accountUpdatesToCallForest(zkappCommand.accountUpdates);
  let commitment = callForestHash(callForest, networkId);
  let memoHash = Memo.hash(Memo.fromBase58(zkappCommand.memo));
  let feePayerDigest = feePayerHash(zkappCommand.feePayer, networkId);
  let fullCommitment = hashWithPrefix2(prefixes.accountUpdateCons, [
    memoHash,
    feePayerDigest,
    commitment
  ]);
  return { commitment, fullCommitment };
}
function accountUpdatesToCallForest(updates, callDepth = 0) {
  let remainingUpdates = callDepth > 0 ? updates : [...updates];
  let forest = [];
  while (remainingUpdates.length > 0) {
    let accountUpdate = remainingUpdates[0];
    if (accountUpdate.body.callDepth < callDepth)
      return forest;
    remainingUpdates.shift();
    let children = accountUpdatesToCallForest(remainingUpdates, callDepth + 1);
    forest.push({ accountUpdate, children });
  }
  return forest;
}
function accountUpdateHash(update, networkId) {
  assertAuthorizationKindValid(update);
  let input = AccountUpdate2.toInput(update);
  let fields2 = packToFields2(input);
  return hashWithPrefix2(zkAppBodyPrefix(networkId), fields2);
}
function callForestHash(forest, networkId) {
  return callForestHashGeneric(forest, accountUpdateHash, hashWithPrefix2, 0n, networkId);
}
function callForestHashGeneric(forest, hash3, hashWithPrefix3, emptyHash2, networkId) {
  let stackHash = emptyHash2;
  for (let callTree of [...forest].reverse()) {
    let calls = callForestHashGeneric(callTree.children, hash3, hashWithPrefix3, emptyHash2, networkId);
    let treeHash = hash3(callTree.accountUpdate, networkId);
    let nodeHash = hashWithPrefix3(prefixes.accountUpdateNode, [
      treeHash,
      calls
    ]);
    stackHash = hashWithPrefix3(prefixes.accountUpdateCons, [
      nodeHash,
      stackHash
    ]);
  }
  return stackHash;
}
function feePayerHash(feePayer, networkId) {
  let accountUpdate = accountUpdateFromFeePayer(feePayer);
  return accountUpdateHash(accountUpdate, networkId);
}
function accountUpdateFromFeePayer({ body: { fee, nonce, publicKey, validUntil }, authorization: signature }) {
  let { body } = AccountUpdate2.empty();
  body.publicKey = publicKey;
  body.balanceChange = { magnitude: fee, sgn: Sign(-1) };
  body.incrementNonce = Bool(true);
  body.preconditions.network.globalSlotSinceGenesis = {
    isSome: Bool(true),
    value: { lower: UInt32(0), upper: validUntil ?? UInt32.maxValue }
  };
  body.preconditions.account.nonce = {
    isSome: Bool(true),
    value: { lower: nonce, upper: nonce }
  };
  body.useFullCommitment = Bool(true);
  body.implicitAccountCreationFee = Bool(true);
  body.authorizationKind = {
    isProved: Bool(false),
    isSigned: Bool(true),
    verificationKeyHash: Field(mocks.dummyVerificationKeyHash)
  };
  return { body, authorization: { signature } };
}
function isCallDepthValid(zkappCommand) {
  let callDepths = zkappCommand.accountUpdates.map((a2) => a2.body.callDepth);
  let current = callDepths.shift() ?? 0;
  if (current !== 0)
    return false;
  for (let callDepth of callDepths) {
    if (callDepth < 0)
      return false;
    if (callDepth - current > 1)
      return false;
    current = callDepth;
  }
  return true;
}
function assertAuthorizationKindValid(accountUpdate) {
  let { isSigned, isProved, verificationKeyHash } = accountUpdate.body.authorizationKind;
  if (isProved && isSigned)
    throw Error("Invalid authorization kind: Only one of `isProved` and `isSigned` may be true.");
  if (!isProved && verificationKeyHash !== Field(mocks.dummyVerificationKeyHash))
    throw Error(`Invalid authorization kind: If \`isProved\` is false, verification key hash must be ${mocks.dummyVerificationKeyHash}, got ${verificationKeyHash}`);
}

// dist/node/lib/mina/transaction-context.js
var currentTransaction = Context.create();

// dist/node/lib/mina/smart-contract-base.js
var SmartContractBase = class {
};
function isSmartContract(object) {
  return object instanceof SmartContractBase;
}

// dist/node/lib/mina/smart-contract-context.js
var smartContractContext = Context.create({
  default: null
});
function accountUpdateLayout() {
  let layout = smartContractContext.get()?.selfLayout;
  layout ??= currentTransaction()?.layout;
  return layout;
}
function contract(expectedConstructor) {
  let ctx = smartContractContext.get();
  assert(ctx !== null, "This method must be called within a contract method");
  if (expectedConstructor !== void 0) {
    assert(ctx.this.constructor === expectedConstructor, `This method must be called on a ${expectedConstructor.name} contract`);
  }
  return ctx.this;
}

// dist/node/lib/provable/types/auxiliary.js
var RandomId = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: (v = Math.random()) => [v],
  fromFields: (_, [v]) => v,
  check: () => {
  },
  toValue: (x) => x,
  fromValue: (x) => x,
  toInput: () => ({}),
  empty: () => Math.random()
};

// dist/node/lib/mina/account-update.js
var _a;
var _b;
var TransactionVersion3 = {
  current: () => UInt322.from(protocolVersions.txnVersion)
};
var zkAppProver = Prover();
var MayUseToken3 = {
  type: MayUseToken,
  No: {
    parentsOwnToken: Bool4(false),
    inheritFromParent: Bool4(false)
  },
  ParentsOwnToken: {
    parentsOwnToken: Bool4(true),
    inheritFromParent: Bool4(false)
  },
  InheritFromParent: {
    parentsOwnToken: Bool4(false),
    inheritFromParent: Bool4(true)
  },
  isNo: ({ body: { mayUseToken: { parentsOwnToken, inheritFromParent } } }) => parentsOwnToken.or(inheritFromParent).not(),
  isParentsOwnToken: (a2) => a2.body.mayUseToken.parentsOwnToken,
  isInheritFromParent: (a2) => a2.body.mayUseToken.inheritFromParent
};
var Events3 = {
  ...Events,
  pushEvent(events, event) {
    events = Events.pushEvent(events, event);
    Provable.asProver(() => {
      events.data[0] = events.data[0].map((e) => Field4(Field4.toBigint(e)));
    });
    return events;
  }
};
var Actions3 = {
  ...Actions,
  pushEvent(actions, action) {
    actions = Actions.pushEvent(actions, action);
    Provable.asProver(() => {
      actions.data[0] = actions.data[0].map((e) => Field4(Field4.toBigint(e)));
    });
    return actions;
  }
};
var True = () => Bool4(true);
var False = () => Bool4(false);
var VerificationKeyPermission = class _VerificationKeyPermission {
  constructor(auth, txnVersion) {
    this.auth = auth;
    this.txnVersion = txnVersion;
  }
  // TODO this class could be made incompatible with a plain object (breaking change)
  // private _ = undefined;
  static withCurrentVersion(perm) {
    return new _VerificationKeyPermission(perm, TransactionVersion3.current());
  }
};
var Permission = {
  /**
   * Modification is impossible.
   */
  impossible: () => ({
    constant: True(),
    signatureNecessary: True(),
    signatureSufficient: False()
  }),
  /**
   * Modification is always permitted
   */
  none: () => ({
    constant: True(),
    signatureNecessary: False(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs only
   */
  proof: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: False()
  }),
  /**
   * Modification is permitted by signatures only, using the private key of the zkapp account
   */
  signature: () => ({
    constant: False(),
    signatureNecessary: True(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs or signatures
   */
  proofOrSignature: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: True()
  }),
  /**
   * Special Verification key permissions.
   *
   * The difference to normal permissions is that `Permission.proof` and `Permission.impossible` are replaced by less restrictive permissions:
   * - `impossible` is replaced by `impossibleDuringCurrentVersion`
   * - `proof` is replaced by `proofDuringCurrentVersion`
   *
   * The issue is that a future hardfork which changes the proof system could mean that old verification keys can no longer
   * be used to verify proofs in the new proof system, and the zkApp would have to be redeployed to adapt the verification key.
   *
   * Having either `impossible` or `proof` would mean that these zkApps can't be upgraded after this hypothetical hardfork, and would become unusable.
   *
   * Such a future hardfork would manifest as an increment in the "transaction version" of zkApps, which you can check with {@link TransactionVersion.current()}.
   *
   * The `impossibleDuringCurrentVersion` and `proofDuringCurrentVersion` have an additional `txnVersion` field.
   * These permissions follow the same semantics of not upgradable, or only upgradable with proofs,
   * _as long as_ the current transaction version is the same as the one on the permission.
   *
   * Once the current transaction version is higher than the one on the permission, the permission is treated as `signature`,
   * and the zkApp can be redeployed with a signature of the original account owner.
   */
  VerificationKey: {
    /**
     * Modification is impossible, as long as the network accepts the current {@link TransactionVersion}.
     *
     * After a hardfork that increments the transaction version, the permission is treated as `signature`.
     */
    impossibleDuringCurrentVersion: () => VerificationKeyPermission.withCurrentVersion(Permission.impossible()),
    /**
     * Modification is always permitted
     */
    none: () => VerificationKeyPermission.withCurrentVersion(Permission.none()),
    /**
     * Modification is permitted by zkapp proofs only; as long as the network accepts the current {@link TransactionVersion}.
     *
     * After a hardfork that increments the transaction version, the permission is treated as `signature`.
     */
    proofDuringCurrentVersion: () => VerificationKeyPermission.withCurrentVersion(Permission.proof()),
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => VerificationKeyPermission.withCurrentVersion(Permission.signature()),
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => VerificationKeyPermission.withCurrentVersion(Permission.proofOrSignature())
  }
};
var Permissions = {
  ...Permission,
  /**
   * Default permissions are:
   *
   *   {@link Permissions.editState} = {@link Permission.proof}
   *
   *   {@link Permissions.send} = {@link Permission.signature}
   *
   *   {@link Permissions.receive} = {@link Permission.none}
   *
   *   {@link Permissions.setDelegate} = {@link Permission.signature}
   *
   *   {@link Permissions.setPermissions} = {@link Permission.signature}
   *
   *   {@link Permissions.setVerificationKey} = {@link Permission.signature}
   *
   *   {@link Permissions.setZkappUri} = {@link Permission.signature}
   *
   *   {@link Permissions.editActionState} = {@link Permission.proof}
   *
   *   {@link Permissions.setTokenSymbol} = {@link Permission.signature}
   *
   */
  default: () => ({
    editState: Permission.proof(),
    send: Permission.proof(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.VerificationKey.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.proof(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  initial: () => ({
    editState: Permission.signature(),
    send: Permission.signature(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.VerificationKey.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.signature(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  dummy: () => ({
    editState: Permission.none(),
    send: Permission.none(),
    receive: Permission.none(),
    access: Permission.none(),
    setDelegate: Permission.none(),
    setPermissions: Permission.none(),
    setVerificationKey: Permission.VerificationKey.none(),
    setZkappUri: Permission.none(),
    editActionState: Permission.none(),
    setTokenSymbol: Permission.none(),
    incrementNonce: Permission.none(),
    setVotingFor: Permission.none(),
    setTiming: Permission.none()
  }),
  allImpossible: () => ({
    editState: Permission.impossible(),
    send: Permission.impossible(),
    receive: Permission.impossible(),
    access: Permission.impossible(),
    setDelegate: Permission.impossible(),
    setPermissions: Permission.impossible(),
    setVerificationKey: Permission.VerificationKey.impossibleDuringCurrentVersion(),
    setZkappUri: Permission.impossible(),
    editActionState: Permission.impossible(),
    setTokenSymbol: Permission.impossible(),
    incrementNonce: Permission.impossible(),
    setVotingFor: Permission.impossible(),
    setTiming: Permission.impossible()
  }),
  fromString: (permission) => {
    switch (permission) {
      case "None":
        return Permission.none();
      case "Either":
        return Permission.proofOrSignature();
      case "Proof":
        return Permission.proof();
      case "Signature":
        return Permission.signature();
      case "Impossible":
        return Permission.impossible();
      default:
        throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);
    }
  },
  fromJSON: (permissions) => {
    return Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
      k,
      Permissions.fromString(typeof v === "string" ? v : v.auth)
    ]));
  }
};
var Body = {
  /**
   * A body that doesn't change the underlying account record
   */
  keepAll(publicKey, tokenId, mayUseToken) {
    let { body } = transaction_exports.AccountUpdate.empty();
    body.publicKey = publicKey;
    if (tokenId) {
      body.tokenId = tokenId;
      body.mayUseToken = Provable.if(tokenId.equals(TokenId4.default), AccountUpdate3.MayUseToken.type, AccountUpdate3.MayUseToken.No, AccountUpdate3.MayUseToken.ParentsOwnToken);
    }
    if (mayUseToken) {
      body.mayUseToken = mayUseToken;
    }
    return body;
  },
  dummy() {
    return transaction_exports.AccountUpdate.empty().body;
  }
};
var FeePayerBody = {
  keepAll(publicKey, nonce) {
    return {
      publicKey,
      nonce,
      fee: UInt642.zero,
      validUntil: void 0
    };
  }
};
var AccountId = provable({ tokenOwner: PublicKey2, parentTokenId: Field4 });
var TokenId4 = {
  ...transaction_exports.TokenId,
  ...TokenId3,
  get default() {
    return Field4(1);
  },
  derive(tokenOwner, parentTokenId = Field4(1)) {
    let input = AccountId.toInput({ tokenOwner, parentTokenId });
    return hashWithPrefix(prefixes.deriveTokenId, packToFields(input));
  }
};
var AccountUpdate3 = class _AccountUpdate {
  constructor(body, authorization = {}, isSelf = false) {
    this.label = "";
    this.lazyAuthorization = void 0;
    this.id = Math.random();
    this.body = body;
    this.authorization = authorization;
    let { account, network, currentSlot: currentSlot2 } = preconditions(this, isSelf);
    this.account = account;
    this.network = network;
    this.currentSlot = currentSlot2;
    this.isSelf = isSelf;
  }
  /**
   * Clones the {@link AccountUpdate}.
   */
  static clone(accountUpdate) {
    let body = cloneCircuitValue(accountUpdate.body);
    let authorization = cloneCircuitValue(accountUpdate.authorization);
    let cloned = new _AccountUpdate(body, authorization, accountUpdate.isSelf);
    cloned.lazyAuthorization = accountUpdate.lazyAuthorization;
    cloned.id = accountUpdate.id;
    cloned.label = accountUpdate.label;
    return cloned;
  }
  get tokenId() {
    return this.body.tokenId;
  }
  send({ to, amount }) {
    let receiver;
    if (to instanceof _AccountUpdate) {
      receiver = to;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else if (isSmartContract(to)) {
      receiver = to.self;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else {
      receiver = _AccountUpdate.defaultAccountUpdate(to, this.body.tokenId);
      receiver.label = `${this.label ?? "Unlabeled"}.send()`;
      this.approve(receiver);
    }
    this.body.balanceChange = this.body.balanceChange.sub(amount);
    receiver.body.balanceChange = receiver.body.balanceChange.add(amount);
    return receiver;
  }
  /**
   * Makes another {@link AccountUpdate} a child of this one.
   *
   * The parent-child relationship means that the child becomes part of the "statement"
   * of the parent, and goes into the commitment that is authorized by either a signature
   * or a proof.
   *
   * For a proof in particular, child account updates are contained in the public input
   * of the proof that authorizes the parent account update.
   */
  approve(child) {
    if (child instanceof AccountUpdateForest) {
      accountUpdateLayout()?.setChildren(this, child);
      return;
    }
    if (child instanceof _AccountUpdate) {
      child.body.callDepth = this.body.callDepth + 1;
    }
    accountUpdateLayout()?.disattach(child);
    accountUpdateLayout()?.pushChild(this, child);
  }
  get balance() {
    let accountUpdate = this;
    return {
      addInPlace(x) {
        accountUpdate.body.balanceChange = accountUpdate.body.balanceChange.add(x);
      },
      subInPlace(x) {
        accountUpdate.body.balanceChange = accountUpdate.body.balanceChange.sub(x);
      }
    };
  }
  get balanceChange() {
    return this.body.balanceChange;
  }
  set balanceChange(x) {
    this.body.balanceChange = x;
  }
  get update() {
    return this.body.update;
  }
  static setValue(maybeValue, value) {
    maybeValue.isSome = Bool4(true);
    maybeValue.value = value;
  }
  /**
   * Constrain a property to lie between lower and upper bounds.
   *
   * @param property The property to constrain
   * @param lower The lower bound
   * @param upper The upper bound
   *
   * Example: To constrain the account balance of a SmartContract to lie between
   * 0 and 20 MINA, you can use
   *
   * ```ts
   * \@method onlyRunsWhenBalanceIsLow() {
   *   let lower = UInt64.zero;
   *   let upper = UInt64.from(20e9);
   *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
   *   // ...
   * }
   * ```
   */
  static assertBetween(property, lower, upper) {
    property.isSome = Bool4(true);
    property.value.lower = lower;
    property.value.upper = upper;
  }
  // TODO: assertGreaterThan, assertLowerThan?
  /**
   * Fix a property to a certain value.
   *
   * @param property The property to constrain
   * @param value The value it is fixed to
   *
   * Example: To fix the account nonce of a SmartContract to 0, you can use
   *
   * ```ts
   * \@method onlyRunsWhenNonceIsZero() {
   *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
   *   // ...
   * }
   * ```
   */
  static assertEquals(property, value) {
    property.isSome = Bool4(true);
    if ("lower" in property.value && "upper" in property.value) {
      property.value.lower = value;
      property.value.upper = value;
    } else {
      property.value = value;
    }
  }
  get publicKey() {
    return this.body.publicKey;
  }
  /**
   * Use this command if this account update should be signed by the account
   * owner, instead of not having any authorization.
   *
   * If you use this and are not relying on a wallet to sign your transaction,
   * then you should use the following code before sending your transaction:
   *
   * ```ts
   * let tx = await Mina.transaction(...); // create transaction as usual, using `requireSignature()` somewhere
   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!
   * ```
   *
   * Note that an account's {@link Permissions} determine which updates have to
   * be (can be) authorized by a signature.
   */
  requireSignature() {
    let { nonce, isSameAsFeePayer } = _AccountUpdate.getSigningInfo(this);
    this.body.useFullCommitment = isSameAsFeePayer;
    this.body.implicitAccountCreationFee = Bool4(false);
    let doIncrementNonce = isSameAsFeePayer.not();
    this.body.incrementNonce = doIncrementNonce;
    let lower = Provable.if(doIncrementNonce, UInt322, nonce, UInt322.zero);
    let upper = Provable.if(doIncrementNonce, UInt322, nonce, UInt322.MAXINT());
    this.body.preconditions.account.nonce.isSome = doIncrementNonce;
    this.body.preconditions.account.nonce.value.lower = lower;
    this.body.preconditions.account.nonce.value.upper = upper;
    Authorization.setLazySignature(this);
  }
  static signFeePayerInPlace(feePayer) {
    feePayer.body.nonce = this.getNonce(feePayer);
    feePayer.authorization = dummySignature();
    feePayer.lazyAuthorization = { kind: "lazy-signature" };
  }
  static getNonce(accountUpdate) {
    return _AccountUpdate.getSigningInfo(accountUpdate).nonce;
  }
  static getSigningInfo(accountUpdate) {
    return memoizeWitness(_AccountUpdate.signingInfo, () => _AccountUpdate.getSigningInfoUnchecked(accountUpdate));
  }
  static getSigningInfoUnchecked(update) {
    let publicKey = update.body.publicKey;
    let tokenId = update instanceof _AccountUpdate ? update.body.tokenId : TokenId4.default;
    let nonce = Number(getAccountPreconditions(update.body).nonce.toString());
    let isFeePayer = currentTransaction()?.sender?.equals(publicKey);
    let isSameAsFeePayer = !!isFeePayer?.and(tokenId.equals(TokenId4.default)).toBoolean();
    if (isSameAsFeePayer)
      nonce++;
    let layout = currentTransaction()?.layout;
    layout?.forEachPredecessor(update, (otherUpdate) => {
      let shouldIncreaseNonce = otherUpdate.publicKey.equals(publicKey).and(otherUpdate.tokenId.equals(tokenId)).and(otherUpdate.body.incrementNonce);
      if (shouldIncreaseNonce.toBoolean())
        nonce++;
    });
    return {
      nonce: UInt322.from(nonce),
      isSameAsFeePayer: Bool4(isSameAsFeePayer)
    };
  }
  toJSON() {
    return transaction_exports.AccountUpdate.toJSON(this);
  }
  static toJSON(a2) {
    return transaction_exports.AccountUpdate.toJSON(a2);
  }
  static fromJSON(json) {
    let accountUpdate = transaction_exports.AccountUpdate.fromJSON(json);
    return new _AccountUpdate(accountUpdate.body, accountUpdate.authorization);
  }
  hash() {
    let input = transaction_exports.AccountUpdate.toInput(this);
    return hashWithPrefix(zkAppBodyPrefix(activeInstance.getNetworkId()), packToFields(input));
  }
  toPublicInput({ accountUpdates }) {
    let accountUpdate = this.hash();
    let descendants = [];
    let callDepth = this.body.callDepth;
    let i = accountUpdates.findIndex((a2) => a2.id === this.id);
    assert(i !== -1, "Account update not found in transaction");
    for (i++; i < accountUpdates.length; i++) {
      let update = accountUpdates[i];
      if (update.body.callDepth <= callDepth)
        break;
      descendants.push(update);
    }
    let forest = accountUpdatesToCallForest(descendants, callDepth + 1);
    let calls = callForestHashGeneric(forest, (a2) => a2.hash(), Poseidon2.hashWithPrefix, emptyHash, activeInstance.getNetworkId());
    return { accountUpdate, calls };
  }
  toPrettyLayout() {
    let node = accountUpdateLayout()?.get(this);
    assert(node !== void 0, "AccountUpdate not found in layout");
    node.children.print();
  }
  extractTree() {
    let layout = accountUpdateLayout();
    let hash3 = layout?.get(this)?.final?.hash;
    let id2 = this.id;
    let children = layout?.finalizeAndRemove(this) ?? AccountUpdateForest.empty();
    let accountUpdate = HashedAccountUpdate.hash(this, hash3);
    return new AccountUpdateTree({ accountUpdate, id: id2, children });
  }
  /**
   * @deprecated Use {@link AccountUpdate.default} instead.
   */
  static defaultAccountUpdate(address, tokenId) {
    return _AccountUpdate.default(address, tokenId);
  }
  /**
   * Create an account update from a public key and an optional token id.
   *
   * **Important**: This method is different from `AccountUpdate.create()`, in that it really just creates the account update object.
   * It does not attach the update to the current transaction or smart contract.
   * Use this method for lower-level operations with account updates.
   */
  static default(address, tokenId) {
    return new _AccountUpdate(Body.keepAll(address, tokenId));
  }
  static dummy() {
    let dummy = new _AccountUpdate(Body.dummy());
    dummy.label = "Dummy";
    return dummy;
  }
  isDummy() {
    return this.body.publicKey.isEmpty();
  }
  static defaultFeePayer(address, nonce) {
    let body = FeePayerBody.keepAll(address, nonce);
    return {
      body,
      authorization: dummySignature(),
      lazyAuthorization: { kind: "lazy-signature" }
    };
  }
  static dummyFeePayer() {
    let body = FeePayerBody.keepAll(PublicKey2.empty(), UInt322.zero);
    return { body, authorization: dummySignature() };
  }
  /**
   * Creates an account update. If this is inside a transaction, the account
   * update becomes part of the transaction. If this is inside a smart contract
   * method, the account update will not only become part of the transaction,
   * but also becomes available for the smart contract to modify, in a way that
   * becomes part of the proof.
   */
  static create(publicKey, tokenId) {
    let accountUpdate = _AccountUpdate.defaultAccountUpdate(publicKey, tokenId);
    let insideContract = smartContractContext.get();
    if (insideContract) {
      let self = insideContract.this.self;
      self.approve(accountUpdate);
      accountUpdate.label = `${self.label || "Unlabeled"} > AccountUpdate.create()`;
    } else {
      currentTransaction()?.layout.pushTopLevel(accountUpdate);
      accountUpdate.label = `Mina.transaction() > AccountUpdate.create()`;
    }
    return accountUpdate;
  }
  /**
   * Create an account update that is added to the transaction only if a condition is met.
   *
   * See {@link AccountUpdate.create} for more information. In this method, you can pass in
   * a condition that determines whether the account update should be added to the transaction.
   */
  static createIf(condition, publicKey, tokenId) {
    return _AccountUpdate.create(
      // if the condition is false, we use an empty public key, which causes the account update to be ignored
      // as a dummy when building the transaction
      Provable.if(condition, publicKey, PublicKey2.empty()),
      tokenId
    );
  }
  /**
   * Attach account update to the current transaction
   * -- if in a smart contract, to its children
   */
  static attachToTransaction(accountUpdate) {
    let insideContract = smartContractContext.get();
    if (insideContract) {
      let selfUpdate = insideContract.this.self;
      if (selfUpdate === accountUpdate)
        return;
      insideContract.this.self.approve(accountUpdate);
    } else {
      if (!currentTransaction.has())
        return;
      currentTransaction.get().layout.pushTopLevel(accountUpdate);
    }
  }
  /**
   * Disattach an account update from where it's currently located in the transaction
   */
  static unlink(accountUpdate) {
    accountUpdateLayout()?.disattach(accountUpdate);
  }
  /**
   * Creates an account update, like {@link AccountUpdate.create}, but also
   * makes sure this account update will be authorized with a signature.
   *
   * If you use this and are not relying on a wallet to sign your transaction,
   * then you should use the following code before sending your transaction:
   *
   * ```ts
   * let tx = await Mina.transaction(...); // create transaction as usual, using `createSigned()` somewhere
   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!
   * ```
   *
   * Note that an account's {@link Permissions} determine which updates have to
   * be (can be) authorized by a signature.
   */
  static createSigned(publicKey, tokenId) {
    let accountUpdate = _AccountUpdate.create(publicKey, tokenId);
    accountUpdate.label = accountUpdate.label.replace(".create()", ".createSigned()");
    accountUpdate.requireSignature();
    return accountUpdate;
  }
  /**
   * Use this method to pay the account creation fee for another account (or, multiple accounts using the optional second argument).
   *
   * Beware that you _don't_ need to specify the account that is created!
   * Instead, the protocol will automatically identify that accounts need to be created,
   * and require that the net balance change of the transaction covers the account creation fee.
   *
   * @param feePayer the address of the account that pays the fee
   * @param numberOfAccounts the number of new accounts to fund (default: 1)
   * @returns they {@link AccountUpdate} for the account which pays the fee
   */
  static fundNewAccount(feePayer, numberOfAccounts = 1) {
    let accountUpdate = _AccountUpdate.createSigned(feePayer);
    accountUpdate.label = "AccountUpdate.fundNewAccount()";
    let fee = activeInstance.getNetworkConstants().accountCreationFee;
    fee = fee.mul(numberOfAccounts);
    accountUpdate.balance.subInPlace(fee);
    return accountUpdate;
  }
  static toAuxiliary(a2) {
    let aux = transaction_exports.AccountUpdate.toAuxiliary(a2);
    let lazyAuthorization = a2 && a2.lazyAuthorization;
    let id2 = a2?.id ?? Math.random();
    let label = a2?.label ?? "";
    return [{ lazyAuthorization, id: id2, label }, aux];
  }
  static empty() {
    return _AccountUpdate.dummy();
  }
  static fromFields(fields2, [other, aux]) {
    let accountUpdate = transaction_exports.AccountUpdate.fromFields(fields2, aux);
    return Object.assign(new _AccountUpdate(accountUpdate.body, accountUpdate.authorization), other);
  }
  static fromValue(value) {
    if (value instanceof _AccountUpdate)
      return value;
    let accountUpdate = transaction_exports.AccountUpdate.fromValue(value);
    return new _AccountUpdate(accountUpdate.body, accountUpdate.authorization);
  }
  static witness(type, compute, { skipCheck = false } = {}) {
    let accountUpdateType = skipCheck ? { ...provable(_AccountUpdate), check() {
    } } : _AccountUpdate;
    let combinedType = provable({
      accountUpdate: accountUpdateType,
      result: type
    });
    return Provable.witnessAsync(combinedType, compute);
  }
  /**
   * Returns a JSON representation of only the fields that differ from the
   * default {@link AccountUpdate}.
   */
  toPretty() {
    function short(s) {
      return ".." + s.slice(-4);
    }
    let jsonUpdate = toJSONEssential(jsLayout.AccountUpdate, this);
    let body = jsonUpdate.body;
    delete body.callData;
    body.publicKey = short(body.publicKey);
    if (body.balanceChange?.magnitude === "0")
      delete body.balanceChange;
    if (body.tokenId === TokenId4.toBase58(TokenId4.default)) {
      delete body.tokenId;
    } else {
      body.tokenId = short(body.tokenId);
    }
    if (body.callDepth === 0)
      delete body.callDepth;
    if (body.incrementNonce === false)
      delete body.incrementNonce;
    if (body.useFullCommitment === false)
      delete body.useFullCommitment;
    if (body.implicitAccountCreationFee === false)
      delete body.implicitAccountCreationFee;
    if (body.events?.length === 0)
      delete body.events;
    if (body.actions?.length === 0)
      delete body.actions;
    if (body.preconditions?.account) {
      body.preconditions.account = JSON.stringify(body.preconditions.account);
    }
    if (body.preconditions?.network) {
      body.preconditions.network = JSON.stringify(body.preconditions.network);
    }
    if (body.preconditions?.validWhile) {
      body.preconditions.validWhile = JSON.stringify(body.preconditions.validWhile);
    }
    if (jsonUpdate.authorization?.proof) {
      jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);
    }
    if (jsonUpdate.authorization?.signature) {
      jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);
    }
    if (body.update?.verificationKey) {
      body.update.verificationKey = JSON.stringify({
        data: short(body.update.verificationKey.data),
        hash: short(body.update.verificationKey.hash)
      });
    }
    for (let key of ["permissions", "appState", "timing"]) {
      if (body.update?.[key]) {
        body.update[key] = JSON.stringify(body.update[key]);
      }
    }
    for (let key of ["events", "actions"]) {
      if (body[key]) {
        body[key] = JSON.stringify(body[key]);
      }
    }
    if (body.authorizationKind?.isProved === false) {
      delete body.authorizationKind?.verificationKeyHash;
    }
    if (body.authorizationKind?.isProved === false && body.authorizationKind?.isSigned === false) {
      delete body.authorizationKind;
    }
    if (jsonUpdate.authorization !== void 0 || body.authorizationKind?.isProved === true || body.authorizationKind?.isSigned === true) {
      body.authorization = jsonUpdate.authorization;
    }
    body.mayUseToken = {
      parentsOwnToken: this.body.mayUseToken.parentsOwnToken.toBoolean(),
      inheritFromParent: this.body.mayUseToken.inheritFromParent.toBoolean()
    };
    let pretty = { ...body };
    let withId = false;
    if (withId)
      pretty = { id: Math.floor(this.id * 1e3), ...pretty };
    if (this.label)
      pretty = { label: this.label, ...pretty };
    return pretty;
  }
};
AccountUpdate3.Actions = Actions3;
AccountUpdate3.Events = Events3;
AccountUpdate3.signingInfo = provable({
  isSameAsFeePayer: Bool4,
  nonce: UInt322
});
AccountUpdate3.sizeInFields = transaction_exports.AccountUpdate.sizeInFields;
AccountUpdate3.toFields = transaction_exports.AccountUpdate.toFields;
AccountUpdate3.toInput = transaction_exports.AccountUpdate.toInput;
AccountUpdate3.check = transaction_exports.AccountUpdate.check;
AccountUpdate3.toValue = transaction_exports.AccountUpdate.toValue;
AccountUpdate3.MayUseToken = MayUseToken3;
function hashAccountUpdate(update) {
  return genericHash(AccountUpdate3, zkAppBodyPrefix(activeInstance.getNetworkId()), update);
}
var HashedAccountUpdate = class extends Hashed.create(AccountUpdate3, hashAccountUpdate) {
};
var AccountUpdateTreeBase = StructNoJson({
  id: RandomId,
  accountUpdate: HashedAccountUpdate,
  children: MerkleListBase()
});
var AccountUpdateForest = class extends (_b = MerkleList.create(AccountUpdateTreeBase, merkleListHash2)) {
  push(update) {
    return super.push(update instanceof AccountUpdate3 ? AccountUpdateTree.from(update) : update);
  }
  pushIf(condition, update) {
    return super.pushIf(condition, update instanceof AccountUpdate3 ? AccountUpdateTree.from(update) : update);
  }
  static fromFlatArray(updates) {
    let simpleForest = accountUpdatesToCallForest(updates);
    return this.fromSimpleForest(simpleForest);
  }
  toFlatArray(mutate = true, depth = 0) {
    return _a.toFlatArray(this, mutate, depth);
  }
  static toFlatArray(forest, mutate = true, depth = 0) {
    let flat = [];
    for (let { element: tree } of forest.data.get()) {
      let update = tree.accountUpdate.value.get();
      if (mutate)
        update.body.callDepth = depth;
      flat.push(update);
      flat.push(...this.toFlatArray(tree.children, mutate, depth + 1));
    }
    return flat;
  }
  static fromSimpleForest(simpleForest) {
    let nodes = simpleForest.map((node) => {
      let accountUpdate = HashedAccountUpdate.hash(node.accountUpdate);
      let children = _a.fromSimpleForest(node.children);
      return { accountUpdate, children, id: node.accountUpdate.id };
    });
    return _a.fromReverse(nodes);
  }
  // TODO this comes from paranoia and might be removed later
  static assertConstant(forest) {
    Provable.asProver(() => {
      forest.data.get().forEach(({ element: tree }) => {
        assert(Provable.isConstant(AccountUpdate3, tree.accountUpdate.value.get()), "account update not constant");
        _a.assertConstant(tree.children);
      });
    });
  }
  // fix static methods
  static empty() {
    return _a.provable.empty();
  }
  static from(array) {
    return new _a(super.from(array));
  }
  static fromReverse(array) {
    return new _a(super.fromReverse(array));
  }
};
_a = AccountUpdateForest;
AccountUpdateForest.provable = provableExtends(_a, Reflect.get(_b, "provable", _a));
var AccountUpdateTree = class _AccountUpdateTree extends StructNoJson({
  id: RandomId,
  accountUpdate: HashedAccountUpdate,
  children: AccountUpdateForest
}) {
  /**
   * Create a tree of account updates which only consists of a root.
   */
  static from(update, hash3) {
    if (update instanceof _AccountUpdateTree)
      return update;
    return new _AccountUpdateTree({
      accountUpdate: HashedAccountUpdate.hash(update, hash3),
      id: update.id,
      children: AccountUpdateForest.empty()
    });
  }
  /**
   * Add an {@link AccountUpdate} or {@link AccountUpdateTree} to the children of this tree's root.
   *
   * See {@link AccountUpdate.approve}.
   */
  approve(update, hash3) {
    accountUpdateLayout()?.disattach(update);
    if (update instanceof AccountUpdate3) {
      this.children.pushIf(update.isDummy().not(), _AccountUpdateTree.from(update, hash3));
    } else {
      this.children.push(update);
    }
  }
  // fix Struct type
  static fromFields(fields2, aux) {
    return new _AccountUpdateTree(super.fromFields(fields2, aux));
  }
  static empty() {
    return new _AccountUpdateTree(super.empty());
  }
};
function merkleListHash2(forestHash, tree) {
  return hashCons(forestHash, hashNode(tree));
}
function hashNode(tree) {
  return Poseidon2.hashWithPrefix(prefixes.accountUpdateNode, [
    tree.accountUpdate.hash,
    tree.children.hash
  ]);
}
function hashCons(forestHash, nodeHash) {
  return Poseidon2.hashWithPrefix(prefixes.accountUpdateCons, [
    nodeHash,
    forestHash
  ]);
}
var UnfinishedForest = class _UnfinishedForest {
  isFinal() {
    return this.final !== void 0;
  }
  isMutable() {
    return this.mutable !== void 0;
  }
  constructor(mutable, final) {
    assert(final === void 0 !== (mutable === void 0), "final or mutable");
    this.final = final;
    this.mutable = mutable;
  }
  static empty() {
    return new _UnfinishedForest([]);
  }
  setFinal(final) {
    return Object.assign(this, { final, mutable: void 0 });
  }
  finalize() {
    if (this.isFinal())
      return this.final;
    assert(this.isMutable(), "final or mutable");
    let nodes = this.mutable.map(UnfinishedTree.finalize);
    let finalForest = AccountUpdateForest.empty();
    for (let { isDummy, ...tree } of [...nodes].reverse()) {
      finalForest.pushIf(isDummy.not(), tree);
    }
    this.setFinal(finalForest);
    return finalForest;
  }
  witnessHash() {
    let final = Provable.witness(AccountUpdateForest, () => this.finalize());
    return this.setFinal(final);
  }
  push(node) {
    if (node.siblings === this)
      return;
    assert(node.siblings === void 0, "Cannot push node that already has a parent.");
    node.siblings = this;
    assert(this.isMutable(), "Cannot push to an immutable forest");
    this.mutable.push(node);
  }
  remove(node) {
    assert(this.isMutable(), "Cannot remove from an immutable forest");
    let index = this.mutable.findIndex((n) => n.id === node.id);
    if (index === -1)
      return;
    node.siblings = void 0;
    this.mutable.splice(index, 1);
  }
  setToForest(forest) {
    if (this.isMutable()) {
      assert(this.mutable.length === 0, "Replacing a mutable forest that has existing children might be a mistake.");
    }
    return this.setFinal(new AccountUpdateForest(forest));
  }
  static fromForest(forest) {
    return _UnfinishedForest.empty().setToForest(forest);
  }
  toFlatArray(mutate = true, depth = 0) {
    if (this.isFinal())
      return this.final.toFlatArray(mutate, depth);
    assert(this.isMutable(), "final or mutable");
    let flatUpdates = [];
    for (let node of this.mutable) {
      if (node.isDummy.toBoolean())
        continue;
      let update = node.mutable ?? node.final.value.get();
      if (mutate)
        update.body.callDepth = depth;
      let children = node.children.toFlatArray(mutate, depth + 1);
      flatUpdates.push(update, ...children);
    }
    return flatUpdates;
  }
  toConstantInPlace() {
    if (this.isFinal()) {
      this.final.hash = this.final.hash.toConstant();
      return;
    }
    assert(this.isMutable(), "final or mutable");
    for (let node of this.mutable) {
      if (node.mutable !== void 0) {
        node.mutable = Provable.toConstant(AccountUpdate3, node.mutable);
      } else {
        node.final.hash = node.final.hash.toConstant();
      }
      node.isDummy = Provable.toConstant(Bool4, node.isDummy);
      node.children.toConstantInPlace();
    }
  }
  print() {
    let indent = 0;
    let layout = "";
    let toPretty = (a2) => {
      if (a2.isFinal()) {
        layout += " ".repeat(indent) + " ( finalized forest )\n";
        return;
      }
      assert(a2.isMutable(), "final or mutable");
      indent += 2;
      for (let tree of a2.mutable) {
        let label = tree.mutable?.label || "<no label>";
        if (tree.final !== void 0) {
          Provable.asProver(() => label = tree.final.value.get().label);
        }
        layout += " ".repeat(indent) + `( ${label} )
`;
        toPretty(tree.children);
      }
      indent -= 2;
    };
    toPretty(this);
    console.log(layout);
  }
};
var UnfinishedTree = {
  create(update) {
    if (update instanceof AccountUpdate3) {
      return {
        mutable: update,
        id: update.id,
        isDummy: update.isDummy(),
        children: UnfinishedForest.empty()
      };
    }
    return {
      final: update.accountUpdate,
      id: update.id,
      isDummy: Bool4(false),
      children: UnfinishedForest.fromForest(update.children)
    };
  },
  setTo(node, update) {
    if (update instanceof AccountUpdate3) {
      if (node.final !== void 0) {
        Object.assign(node, {
          mutable: update,
          final: void 0,
          children: UnfinishedForest.empty()
        });
      }
    } else if (node.mutable !== void 0) {
      Object.assign(node, {
        mutable: void 0,
        final: update.accountUpdate,
        children: UnfinishedForest.fromForest(update.children)
      });
    }
  },
  finalize(node) {
    let accountUpdate = node.final ?? HashedAccountUpdate.hash(node.mutable);
    let children = node.children.finalize();
    return { accountUpdate, id: node.id, isDummy: node.isDummy, children };
  },
  isUnfinished(input) {
    return "final" in input || "mutable" in input;
  }
};
var AccountUpdateLayout = class {
  constructor(root) {
    this.map = /* @__PURE__ */ new Map();
    root ??= AccountUpdate3.dummy();
    let rootTree = {
      mutable: root,
      id: root.id,
      isDummy: Bool4(false),
      children: UnfinishedForest.empty()
    };
    this.map.set(root.id, rootTree);
    this.root = rootTree;
  }
  get(update) {
    return this.map.get(update.id);
  }
  getOrCreate(update) {
    if (UnfinishedTree.isUnfinished(update)) {
      if (!this.map.has(update.id)) {
        this.map.set(update.id, update);
      }
      return update;
    }
    let node = this.map.get(update.id);
    if (node !== void 0) {
      UnfinishedTree.setTo(node, update);
      return node;
    }
    node = UnfinishedTree.create(update);
    this.map.set(update.id, node);
    return node;
  }
  pushChild(parent, child) {
    let parentNode = this.getOrCreate(parent);
    let childNode = this.getOrCreate(child);
    parentNode.children.push(childNode);
  }
  pushTopLevel(child) {
    this.pushChild(this.root, child);
  }
  setChildren(parent, children) {
    let parentNode = this.getOrCreate(parent);
    parentNode.children.setToForest(children);
  }
  setTopLevel(children) {
    this.setChildren(this.root, children);
  }
  disattach(update) {
    let node = this.get(update);
    node?.siblings?.remove(node);
    return node;
  }
  finalizeAndRemove(update) {
    let node = this.get(update);
    if (node === void 0)
      return;
    this.disattach(update);
    return node.children.finalize();
  }
  finalizeChildren() {
    let final = this.root.children.finalize();
    this.final = final;
    AccountUpdateForest.assertConstant(final);
    return final;
  }
  toFlatList({ mutate }) {
    return this.root.children.toFlatArray(mutate);
  }
  forEachPredecessor(update, callback) {
    let updates = this.toFlatList({ mutate: false });
    for (let otherUpdate of updates) {
      if (otherUpdate.id === update.id)
        return;
      callback(otherUpdate);
    }
  }
  toConstantInPlace() {
    this.root.children.toConstantInPlace();
  }
};
var ZkappCommand3 = {
  toPretty(transaction2) {
    let feePayer = ZkappCommand3.toJSON(transaction2).feePayer;
    feePayer.body.publicKey = ".." + feePayer.body.publicKey.slice(-4);
    feePayer.body.authorization = ".." + feePayer.authorization.slice(-4);
    if (feePayer.body.validUntil === null)
      delete feePayer.body.validUntil;
    return [
      { label: "feePayer", ...feePayer.body },
      ...transaction2.accountUpdates.map((a2) => a2.toPretty())
    ];
  },
  fromJSON(json) {
    let { feePayer } = transaction_exports.ZkappCommand.fromJSON({
      feePayer: json.feePayer,
      accountUpdates: [],
      memo: json.memo
    });
    let memo = Memo.toString(Memo.fromBase58(json.memo));
    let accountUpdates = json.accountUpdates.map(AccountUpdate3.fromJSON);
    return { feePayer, accountUpdates, memo };
  },
  toJSON({ feePayer, accountUpdates, memo }) {
    memo = Memo.toBase58(Memo.fromString(memo));
    return transaction_exports.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
  }
};
var Authorization = {
  hasLazyProof(accountUpdate) {
    return accountUpdate.lazyAuthorization?.kind === "lazy-proof";
  },
  hasAny(accountUpdate) {
    let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
    return !!(lazyAuth || "proof" in auth || "signature" in auth);
  },
  setSignature(accountUpdate, signature) {
    accountUpdate.authorization = { signature };
    accountUpdate.lazyAuthorization = void 0;
  },
  setProof(accountUpdate, proof) {
    accountUpdate.authorization = { proof };
    accountUpdate.lazyAuthorization = void 0;
    return accountUpdate;
  },
  setLazySignature(accountUpdate) {
    accountUpdate.body.authorizationKind.isSigned = Bool4(true);
    accountUpdate.body.authorizationKind.isProved = Bool4(false);
    accountUpdate.body.authorizationKind.verificationKeyHash = Field4(mocks.dummyVerificationKeyHash);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { kind: "lazy-signature" };
  },
  setLazyNone(accountUpdate) {
    accountUpdate.body.authorizationKind.isSigned = Bool4(false);
    accountUpdate.body.authorizationKind.isProved = Bool4(false);
    accountUpdate.body.authorizationKind.verificationKeyHash = Field4(mocks.dummyVerificationKeyHash);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { kind: "lazy-none" };
  }
};
function addMissingSignatures(zkappCommand, privateKeys) {
  let additionalPublicKeys = privateKeys.map((sk) => sk.toPublicKey());
  let { commitment, fullCommitment } = transactionCommitments({
    ...transaction_exports.ZkappCommand.toValue(zkappCommand),
    // TODO: represent memo in encoded form already?
    memo: Memo.toBase58(Memo.fromString(zkappCommand.memo))
  }, activeInstance.getNetworkId());
  function addFeePayerSignature(accountUpdate) {
    let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
    if (lazyAuthorization === void 0)
      return { body, authorization };
    let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
    if (i === -1) {
      return { body, authorization: dummySignature() };
    }
    let privateKey = privateKeys[i];
    let signature = signFieldElement(fullCommitment, privateKey.toBigInt(), activeInstance.getNetworkId());
    return { body, authorization: Signature.toBase58(signature) };
  }
  function addSignature(accountUpdate) {
    accountUpdate = AccountUpdate3.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-signature") {
      return accountUpdate;
    }
    let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
    if (i === -1) {
      Authorization.setSignature(accountUpdate, dummySignature());
      return accountUpdate;
    }
    let privateKey = privateKeys[i];
    let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    let signature = signFieldElement(transactionCommitment, privateKey.toBigInt(), activeInstance.getNetworkId());
    Authorization.setSignature(accountUpdate, Signature.toBase58(signature));
    return accountUpdate;
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  return {
    feePayer: addFeePayerSignature(feePayer),
    accountUpdates: accountUpdates.map(addSignature),
    memo
  };
}
function dummySignature() {
  return Signature.toBase58(Signature.dummy());
}
var ZkappPublicInput = provablePure({ accountUpdate: Field4, calls: Field4 });
async function addMissingProofs(zkappCommand, { proofsEnabled = true }) {
  let { feePayer, accountUpdates, memo } = zkappCommand;
  let accountUpdatesProved = [];
  let proofs = [];
  for (let i = 0; i < accountUpdates.length; i++) {
    let { accountUpdateProved, proof } = await addProof(zkappCommand, i, proofsEnabled);
    accountUpdatesProved.push(accountUpdateProved);
    proofs.push(proof);
  }
  return {
    zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
    proofs
  };
}
async function addProof(transaction2, index, proofsEnabled) {
  let accountUpdate = transaction2.accountUpdates[index];
  accountUpdate = AccountUpdate3.clone(accountUpdate);
  if (accountUpdate.lazyAuthorization?.kind !== "lazy-proof") {
    return {
      accountUpdateProved: accountUpdate,
      proof: void 0
    };
  }
  if (!proofsEnabled) {
    Authorization.setProof(accountUpdate, await dummyBase64Proof());
    return {
      accountUpdateProved: accountUpdate,
      proof: void 0
    };
  }
  let lazyProof = accountUpdate.lazyAuthorization;
  let prover = getZkappProver(lazyProof);
  let proverData = { transaction: transaction2, accountUpdate, index };
  let proof = await createZkappProof(prover, lazyProof, proverData);
  let accountUpdateProved = Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof.proof));
  return { accountUpdateProved, proof };
}
async function createZkappProof(prover, { methodName, args, previousProofs, ZkappClass, memoized, blindingValue }, { transaction: transaction2, accountUpdate, index }) {
  let publicInput = accountUpdate.toPublicInput(transaction2);
  let publicInputFields = MlFieldConstArray.to(ZkappPublicInput.toFields(publicInput));
  let [, , proof] = await zkAppProver.run([accountUpdate.publicKey, accountUpdate.tokenId, ...args], { transaction: transaction2, accountUpdate, index }, async () => {
    let id2 = memoizationContext.enter({
      memoized,
      currentIndex: 0,
      blindingValue
    });
    try {
      return await prover(publicInputFields, MlArray.to(previousProofs));
    } catch (err) {
      console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);
      throw err;
    } finally {
      memoizationContext.leave(id2);
    }
  });
  let maxProofsVerified = ZkappClass._maxProofsVerified;
  const Proof3 = ZkappClass.Proof();
  return new Proof3({
    publicInput,
    publicOutput: void 0,
    proof,
    maxProofsVerified
  });
}
function getZkappProver({ methodName, ZkappClass }) {
  if (ZkappClass._provers === void 0)
    throw Error(`Cannot prove execution of ${methodName}(), no prover found. Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
  let provers = ZkappClass._provers;
  let methodError = `Error when computing proofs: Method ${methodName} not found. Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
  if (ZkappClass._methods === void 0)
    throw Error(methodError);
  let i = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
  if (i === -1)
    throw Error(methodError);
  return provers[i];
}

// dist/node/lib/mina/fetch.js
var import_isomorphic_fetch = require("isomorphic-fetch");

// dist/node/lib/mina/account.js
var Account4 = transaction_exports.Account;
function newAccount(accountId2) {
  let account = Account4.empty();
  account.publicKey = accountId2.publicKey;
  account.tokenId = accountId2.tokenId ?? transaction_exports.TokenId.empty();
  account.permissions = Permissions.initial();
  return account;
}
function parseFetchedAccount(account) {
  const { publicKey, nonce, zkappState, balance, permissions, timing: { cliffAmount, cliffTime, initialMinimumBalance, vestingIncrement, vestingPeriod }, delegateAccount, receiptChainHash, actionState, token, tokenSymbol, verificationKey, provedState, zkappUri } = account;
  let hasZkapp = zkappState !== null || verificationKey !== null || actionState !== null || zkappUri !== null || provedState;
  let partialAccount = {
    publicKey: PublicKey2.fromBase58(publicKey),
    tokenId: TokenId3.fromBase58(token),
    tokenSymbol: tokenSymbol ?? void 0,
    balance: balance && UInt642.from(balance.total),
    nonce: UInt322.from(nonce),
    receiptChainHash: receiptChainHash && ReceiptChainHash3.fromBase58(receiptChainHash) || void 0,
    delegate: (delegateAccount && PublicKey2.fromBase58(delegateAccount.publicKey)) ?? void 0,
    votingFor: void 0,
    // TODO
    timing: cliffAmount && cliffTime && initialMinimumBalance && vestingIncrement && vestingPeriod && {
      isTimed: Bool4(true),
      cliffAmount: UInt642.from(cliffAmount),
      cliffTime: UInt322.from(cliffTime),
      initialMinimumBalance: UInt642.from(initialMinimumBalance),
      vestingIncrement: UInt642.from(vestingIncrement),
      vestingPeriod: UInt322.from(vestingPeriod)
    } || void 0,
    permissions: (permissions && Permissions.fromJSON(permissions)) ?? Permissions.initial(),
    zkapp: hasZkapp ? {
      appState: (zkappState && zkappState.map(Field4)) ?? void 0,
      verificationKey: (verificationKey && {
        data: verificationKey.verificationKey,
        hash: Field4(verificationKey.hash)
      }) ?? void 0,
      zkappVersion: void 0,
      // TODO
      actionState: (actionState && actionState.map(Field4)) ?? void 0,
      lastActionSlot: void 0,
      // TODO
      provedState: provedState !== null ? Bool4(provedState) : void 0,
      zkappUri: zkappUri !== null ? zkappUri : void 0
    } : void 0
  };
  return fillPartialAccount(partialAccount);
}
function fillPartialAccount(account) {
  return genericLayoutFold(TypeMap, customTypes, {
    map(type, value) {
      if (value !== void 0)
        return value;
      return type.empty();
    },
    reduceArray(array) {
      return array;
    },
    reduceObject(_, record2) {
      return record2;
    },
    reduceFlaggedOption() {
      throw Error("not relevant");
    },
    reduceOrUndefined(value) {
      return value;
    }
  }, jsLayout.Account, account);
}

// dist/node/lib/mina/graphql.js
function removeJsonQuotes(json) {
  let cleaned = JSON.stringify(JSON.parse(json), null, 2);
  return cleaned.replace(/\"(\S+)\"\s*:/gm, "$1:");
}
var transactionStatusQuery = (txId) => `query {
    transactionStatus(zkappTransaction:"${txId}")
  }`;
var getEventsQuery = (publicKey, tokenId, filterOptions) => {
  const { to, from } = filterOptions ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (to !== void 0) {
    input += `, to: ${to}`;
  }
  if (from !== void 0) {
    input += `, from: ${from}`;
  }
  return `{
  events(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
      height
      globalSlotSinceGenesis
      stateHash
      parentHash
      chainStatus
    }
    eventData {
      transactionInfo {
        hash
        memo
        status
      }
      data
    }
  }
}`;
};
var getActionsQuery = (publicKey, actionStates, tokenId, _filterOptions) => {
  const { fromActionState, endActionState } = actionStates ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (fromActionState !== void 0) {
    input += `, fromActionState: "${fromActionState}"`;
  }
  if (endActionState !== void 0) {
    input += `, endActionState: "${endActionState}"`;
  }
  return `{
  actions(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
    }
    actionState {
      actionStateOne
      actionStateTwo
    }
    actionData {
      accountUpdateId
      data
    }
  }
}`;
};
var genesisConstantsQuery = `{
    genesisConstants {
      genesisTimestamp
      coinbase
      accountCreationFee
    }
    daemonStatus {
      consensusConfiguration {
        epochDuration
        k
        slotDuration
        slotsPerEpoch
      }
    }
  }`;
var lastBlockQuery = `{
  bestChain(maxLength: 1) {
    protocolState {
      blockchainState {
        snarkedLedgerHash
        stagedLedgerHash
        date
        utcDate
        stagedLedgerProofEmitted
      }
      previousStateHash
      consensusState {
        blockHeight
        slotSinceGenesis
        slot
        nextEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        stakingEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        epochCount
        minWindowDensity
        totalCurrency
        epoch
      }
    }
  }
}`;
var lastBlockQueryFailureCheck = (length) => `{
  bestChain(maxLength: ${length}) {
    transactions {
      zkappCommands {
        hash
        failureReason {
          failures
          index
        }
      }
    }
    stateHash
    protocolState {
      consensusState {
        blockHeight
        epoch
        slotSinceGenesis
      }
      previousStateHash
    }
  }
}`;
function sendZkappQuery(json) {
  return `mutation {
  sendZkapp(input: {
    zkappCommand: ${removeJsonQuotes(json)}
  }) {
    zkapp {
      hash
      id
      failureReason {
        failures
        index
      }
      zkappCommand {
        memo
        feePayer {
          body {
            publicKey
          }
        }
        accountUpdates {
          body {
            publicKey
            useFullCommitment
            incrementNonce
          }
        }
      }
    }
  }
}
`;
}
var accountQuery = (publicKey, tokenId) => `{
  account(publicKey: "${publicKey}", token: "${tokenId}") {
    publicKey
    token
    nonce
    balance { total }
    tokenSymbol
    receiptChainHash
    timing {
      initialMinimumBalance
      cliffTime
      cliffAmount
      vestingPeriod
      vestingIncrement
    }
    permissions {
      editState
      access
      send
      receive
      setDelegate
      setPermissions
      setVerificationKey {
        auth
        txnVersion
      }
      setZkappUri
      editActionState
      setTokenSymbol
      incrementNonce
      setVotingFor
      setTiming
    }
    delegateAccount { publicKey }
    votingFor
    zkappState
    verificationKey {
      verificationKey
      hash
    }
    actionState
    provedState
    zkappUri
  }
}
`;

// dist/node/lib/mina/fetch.js
var networkConfig = {
  minaEndpoint: "",
  minaFallbackEndpoints: [],
  archiveEndpoint: "",
  archiveFallbackEndpoints: [],
  lightnetAccountManagerEndpoint: ""
};
function checkForValidUrl(url2) {
  try {
    new URL(url2);
    return true;
  } catch (e) {
    return false;
  }
}
function setGraphqlEndpoints([graphqlEndpoint, ...fallbackEndpoints]) {
  setGraphqlEndpoint(graphqlEndpoint);
  setMinaGraphqlFallbackEndpoints(fallbackEndpoints);
}
function setGraphqlEndpoint(graphqlEndpoint) {
  if (!checkForValidUrl(graphqlEndpoint)) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);
  }
  networkConfig.minaEndpoint = graphqlEndpoint;
}
function setMinaGraphqlFallbackEndpoints(graphqlEndpoints) {
  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);
  }
  networkConfig.minaFallbackEndpoints = graphqlEndpoints;
}
function setArchiveGraphqlEndpoint(graphqlEndpoint) {
  if (!checkForValidUrl(graphqlEndpoint)) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);
  }
  networkConfig.archiveEndpoint = graphqlEndpoint;
}
function setArchiveGraphqlFallbackEndpoints(graphqlEndpoints) {
  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);
  }
  networkConfig.archiveFallbackEndpoints = graphqlEndpoints;
}
function setLightnetAccountManagerEndpoint(endpoint) {
  if (!checkForValidUrl(endpoint)) {
    throw new Error(`Invalid account manager endpoint: ${endpoint}. Please specify a valid URL.`);
  }
  networkConfig.lightnetAccountManagerEndpoint = endpoint;
}
async function fetchAccount(accountInfo, graphqlEndpoint = networkConfig.minaEndpoint, { timeout = defaultTimeout } = {}) {
  let publicKeyBase58 = accountInfo.publicKey instanceof PublicKey2 ? accountInfo.publicKey.toBase58() : accountInfo.publicKey;
  let tokenIdBase58 = typeof accountInfo.tokenId === "string" || !accountInfo.tokenId ? accountInfo.tokenId : TokenId4.toBase58(accountInfo.tokenId);
  return await fetchAccountInternal({ publicKey: publicKeyBase58, tokenId: tokenIdBase58 }, graphqlEndpoint, {
    timeout
  });
}
async function fetchAccountInternal(accountInfo, graphqlEndpoint = networkConfig.minaEndpoint, config) {
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(accountQuery(publicKey, tokenId ?? TokenId4.toBase58(TokenId4.default)), graphqlEndpoint, networkConfig.minaFallbackEndpoints, config);
  if (error !== void 0)
    return { account: void 0, error };
  let fetchedAccount = response?.data?.account;
  if (!fetchedAccount) {
    return {
      account: void 0,
      error: {
        statusCode: 404,
        statusText: `fetchAccount: Account with public key ${publicKey} does not exist.`
      }
    };
  }
  let account = parseFetchedAccount(fetchedAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
  return {
    account,
    error: void 0
  };
}
var defaultTimeout = 5 * 60 * 1e3;
var accountCache = {};
var networkCache = {};
var actionsCache = {};
var accountsToFetch = {};
var networksToFetch = {};
var actionsToFetch = {};
var genesisConstantsCache = {};
var emptyKey = PublicKey2.empty().toBase58();
function markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint) {
  let publicKeyBase58 = publicKey.toBase58();
  if (publicKeyBase58 === emptyKey)
    return;
  let tokenBase58 = TokenId4.toBase58(tokenId);
  accountsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    graphqlEndpoint
  };
}
function markNetworkToBeFetched(graphqlEndpoint) {
  networksToFetch[graphqlEndpoint] = { graphqlEndpoint };
}
function markActionsToBeFetched(publicKey, tokenId, graphqlEndpoint, actionStates = {}) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId4.toBase58(tokenId);
  let { fromActionState, endActionState } = actionStates;
  let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
  let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
  actionsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    actionStates: {
      fromActionState: fromActionStateBase58,
      endActionState: endActionStateBase58
    },
    graphqlEndpoint
  };
}
async function fetchMissingData(graphqlEndpoint, archiveEndpoint) {
  let promises = Object.entries(accountsToFetch).map(async ([key, { publicKey, tokenId }]) => {
    let response = await fetchAccountInternal({ publicKey, tokenId }, graphqlEndpoint);
    if (response.error === void 0)
      delete accountsToFetch[key];
  });
  let actionPromises = Object.entries(actionsToFetch).map(async ([key, { publicKey, actionStates, tokenId }]) => {
    let response = await fetchActions2({ publicKey, actionStates, tokenId }, archiveEndpoint);
    if (!("error" in response) || response.error === void 0)
      delete actionsToFetch[key];
  });
  promises.push(...actionPromises);
  let network = Object.entries(networksToFetch).find(([, network2]) => {
    return network2.graphqlEndpoint === graphqlEndpoint;
  });
  if (network !== void 0) {
    promises.push((async () => {
      try {
        await fetchLastBlock(graphqlEndpoint);
        await fetchGenesisConstants(graphqlEndpoint);
        delete networksToFetch[network[0]];
      } catch {
      }
    })());
  }
  await Promise.all(promises);
}
function getCachedAccount(publicKey, tokenId, graphqlEndpoint = networkConfig.minaEndpoint) {
  return accountCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.account;
}
function getCachedNetwork(graphqlEndpoint = networkConfig.minaEndpoint) {
  return networkCache[graphqlEndpoint]?.network;
}
function getCachedActions(publicKey, tokenId, graphqlEndpoint = networkConfig.archiveEndpoint) {
  return actionsCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.actions;
}
function getCachedGenesisConstants(graphqlEndpoint = networkConfig.minaEndpoint) {
  return genesisConstantsCache[graphqlEndpoint];
}
function addCachedAccount(partialAccount, graphqlEndpoint = networkConfig.minaEndpoint) {
  let account = fillPartialAccount(partialAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
}
function addCachedAccountInternal(account, graphqlEndpoint) {
  accountCache[accountCacheKey(account.publicKey, account.tokenId, graphqlEndpoint)] = {
    account,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function addCachedActions({ publicKey, tokenId }, actions, graphqlEndpoint) {
  actionsCache[`${publicKey};${tokenId};${graphqlEndpoint}`] = {
    actions,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function accountCacheKey(publicKey, tokenId, graphqlEndpoint) {
  return `${publicKey.toBase58()};${TokenId4.toBase58(tokenId)};${graphqlEndpoint}`;
}
async function fetchLastBlock(graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQuery, graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let lastBlock = resp?.data?.bestChain?.[0];
  if (lastBlock === void 0) {
    throw Error("Failed to fetch latest network state.");
  }
  let network = parseFetchedBlock(lastBlock);
  networkCache[graphqlEndpoint] = {
    network,
    graphqlEndpoint,
    timestamp: Date.now()
  };
  return network;
}
async function fetchLatestBlockZkappStatus(blockLength, graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQueryFailureCheck(blockLength), graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(`Error making GraphQL request: ${error.statusText}`);
  let bestChain = resp?.data;
  if (bestChain === void 0) {
    throw Error("Failed to fetch the latest zkApp transaction status. The response data is undefined.");
  }
  return bestChain;
}
async function checkZkappTransaction(transactionHash, blockLength = 20) {
  let bestChainBlocks = await fetchLatestBlockZkappStatus(blockLength);
  for (let block of bestChainBlocks.bestChain) {
    for (let zkappCommand of block.transactions.zkappCommands) {
      if (zkappCommand.hash === transactionHash) {
        if (zkappCommand.failureReason !== null) {
          let failureReason = zkappCommand.failureReason.reverse().map((failure) => {
            return [failure.failures.map((failureItem) => failureItem)];
          });
          return {
            success: false,
            failureReason
          };
        } else {
          return {
            success: true,
            failureReason: null
          };
        }
      }
    }
  }
  return {
    success: false,
    failureReason: null
  };
}
function parseFetchedBlock({ protocolState: { blockchainState: { snarkedLedgerHash, utcDate }, consensusState: { blockHeight, minWindowDensity, totalCurrency, slot, slotSinceGenesis, nextEpochData, stakingEpochData } } }) {
  return {
    snarkedLedgerHash: LedgerHash.fromBase58(snarkedLedgerHash),
    // TODO: use date or utcDate?
    blockchainLength: UInt322.from(blockHeight),
    minWindowDensity: UInt322.from(minWindowDensity),
    totalCurrency: UInt642.from(totalCurrency),
    globalSlotSinceGenesis: UInt322.from(slotSinceGenesis),
    nextEpochData: parseEpochData(nextEpochData),
    stakingEpochData: parseEpochData(stakingEpochData)
  };
}
function parseEpochData({ ledger: { hash: hash3, totalCurrency }, seed, startCheckpoint, lockCheckpoint, epochLength }) {
  return {
    ledger: {
      hash: LedgerHash.fromBase58(hash3),
      totalCurrency: UInt642.from(totalCurrency)
    },
    seed: EpochSeed.fromBase58(seed),
    startCheckpoint: StateHash3.fromBase58(startCheckpoint),
    lockCheckpoint: StateHash3.fromBase58(lockCheckpoint),
    epochLength: UInt322.from(epochLength)
  };
}
async function fetchTransactionStatus(txId, graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(transactionStatusQuery(txId), graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let txStatus = resp?.data?.transactionStatus;
  if (txStatus === void 0 || txStatus === null) {
    throw Error(`Failed to fetch transaction status. TransactionId: ${txId}`);
  }
  return txStatus;
}
function sendZkapp(json, graphqlEndpoint = networkConfig.minaEndpoint, { timeout = defaultTimeout } = {}) {
  return makeGraphqlRequest(sendZkappQuery(json), graphqlEndpoint, networkConfig.minaFallbackEndpoints, {
    timeout
  });
}
async function fetchEvents2(accountInfo, graphqlEndpoint = networkConfig.archiveEndpoint, filterOptions = {}) {
  if (!graphqlEndpoint)
    throw Error("fetchEvents: Specified GraphQL endpoint is undefined. When using events, you must set the archive node endpoint in Mina.Network(). Please ensure your Mina.Network() configuration includes an archive node endpoint.");
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getEventsQuery(publicKey, tokenId ?? TokenId4.toBase58(TokenId4.default), filterOptions), graphqlEndpoint, networkConfig.archiveFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let fetchedEvents = response?.data.events;
  if (fetchedEvents === void 0) {
    throw Error(`Failed to fetch events data. Account: ${publicKey} Token: ${tokenId}`);
  }
  return fetchedEvents.map((event) => {
    let events = event.eventData.map(({ data, transactionInfo }) => {
      return {
        data,
        transactionInfo
      };
    });
    return {
      events,
      blockHeight: UInt322.from(event.blockInfo.height),
      blockHash: event.blockInfo.stateHash,
      parentBlockHash: event.blockInfo.parentHash,
      globalSlot: UInt322.from(event.blockInfo.globalSlotSinceGenesis),
      chainStatus: event.blockInfo.chainStatus
    };
  });
}
async function fetchActions2(accountInfo, graphqlEndpoint = networkConfig.archiveEndpoint) {
  if (!graphqlEndpoint)
    throw Error("fetchActions: Specified GraphQL endpoint is undefined. When using actions, you must set the archive node endpoint in Mina.Network(). Please ensure your Mina.Network() configuration includes an archive node endpoint.");
  const { publicKey, actionStates, tokenId = TokenId4.toBase58(TokenId4.default) } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getActionsQuery(publicKey, actionStates, tokenId), graphqlEndpoint, networkConfig.archiveFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let fetchedActions = response?.data.actions;
  if (fetchedActions === void 0) {
    return {
      error: {
        statusCode: 404,
        statusText: `fetchActions: Account with public key ${publicKey} with tokenId ${tokenId} does not exist.`
      }
    };
  }
  let actionsList = [];
  if (fetchedActions.length !== 0 && fetchedActions[0].actionState.actionStateOne === actionStates.fromActionState) {
    fetchedActions = fetchedActions.slice(1);
  }
  fetchedActions.forEach((actionBlock) => {
    let { actionData } = actionBlock;
    let latestActionState = Field4(actionBlock.actionState.actionStateTwo);
    let actionState = actionBlock.actionState.actionStateOne;
    if (actionData.length === 0)
      throw Error(`No action data was found for the account ${publicKey} with the latest action state ${actionState}`);
    let actionsByAccountUpdate = [];
    let currentAccountUpdateId = "none";
    let currentActions;
    actionData.forEach(({ accountUpdateId, data }) => {
      if (accountUpdateId === currentAccountUpdateId) {
        currentActions.push(data);
      } else {
        currentAccountUpdateId = accountUpdateId;
        currentActions = [data];
        actionsByAccountUpdate.push(currentActions);
      }
    });
    for (let actions of actionsByAccountUpdate) {
      latestActionState = updateActionState(actions, latestActionState);
      actionsList.push({ actions, hash: latestActionState.toString() });
    }
    const finalActionState = latestActionState.toString();
    const expectedActionState = actionState;
    if (finalActionState !== expectedActionState) {
      throw new Error(`Failed to derive correct actions hash for ${publicKey}.
        Derived hash: ${finalActionState}, expected hash: ${expectedActionState}).
        All action hashes derived: ${JSON.stringify(actionsList, null, 2)}
        Please try a different Archive Node API endpoint.
        `);
    }
  });
  addCachedActions({ publicKey, tokenId }, actionsList, graphqlEndpoint);
  return actionsList;
}
async function fetchGenesisConstants(graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(genesisConstantsQuery, graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  const genesisConstants = resp?.data?.genesisConstants;
  const consensusConfiguration = resp?.data?.daemonStatus?.consensusConfiguration;
  if (genesisConstants === void 0 || consensusConfiguration === void 0) {
    throw Error("Failed to fetch genesis constants.");
  }
  const data = {
    genesisTimestamp: genesisConstants.genesisTimestamp,
    coinbase: Number(genesisConstants.coinbase),
    accountCreationFee: Number(genesisConstants.accountCreationFee),
    epochDuration: Number(consensusConfiguration.epochDuration),
    k: Number(consensusConfiguration.k),
    slotDuration: Number(consensusConfiguration.slotDuration),
    slotsPerEpoch: Number(consensusConfiguration.slotsPerEpoch)
  };
  genesisConstantsCache[graphqlEndpoint] = data;
  return data;
}
var Lightnet;
(function(Lightnet2) {
  async function acquireKeyPair(options = {}) {
    const { isRegularAccount = true, lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/acquire-account?isRegularAccount=${isRegularAccount}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return {
          publicKey: PublicKey2.fromBase58(data.pk),
          privateKey: PrivateKey2.fromBase58(data.sk)
        };
      }
    }
    throw new Error("Failed to acquire the key pair");
  }
  Lightnet2.acquireKeyPair = acquireKeyPair;
  async function releaseKeyPair(options) {
    const { publicKey, lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/release-account`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        pk: publicKey
      })
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return data.message;
      }
    }
    return null;
  }
  Lightnet2.releaseKeyPair = releaseKeyPair;
  async function listAcquiredKeyPairs(options) {
    const { lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/list-acquired-accounts`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return data.map((account) => ({
          publicKey: PublicKey2.fromBase58(account.pk),
          privateKey: PrivateKey2.fromBase58(account.sk)
        }));
      }
    }
    return null;
  }
  Lightnet2.listAcquiredKeyPairs = listAcquiredKeyPairs;
})(Lightnet || (Lightnet = {}));
function updateActionState(actions, actionState) {
  let actionHash = Actions3.fromJSON(actions).hash;
  return Actions3.updateSequenceState(actionState, actionHash);
}
async function makeGraphqlRequest(query, graphqlEndpoint = networkConfig.minaEndpoint, fallbackEndpoints, { timeout = defaultTimeout } = {}) {
  if (graphqlEndpoint === "none")
    throw Error("Should have made a graphql request, but don't know to which endpoint. Try calling `setGraphqlEndpoint` first.");
  let timeouts = [];
  const clearTimeouts = () => {
    timeouts.forEach((t) => clearTimeout(t));
    timeouts = [];
  };
  const makeRequest = async (url2) => {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeout);
    timeouts.push(timer);
    let body = JSON.stringify({ operationName: null, query, variables: {} });
    try {
      let response = await fetch(url2, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body,
        signal: controller.signal
      });
      return checkResponseStatus(response);
    } finally {
      clearTimeouts();
    }
  };
  let timeoutErrors = [];
  let urls = [graphqlEndpoint, ...fallbackEndpoints];
  for (let i = 0; i < urls.length; i += 2) {
    let url1 = urls[i];
    let url2 = urls[i + 1];
    if (url2 === void 0) {
      try {
        return await makeRequest(url1);
      } catch (error) {
        return [void 0, inferError(error)];
      }
    }
    try {
      return await Promise.race([makeRequest(url1), makeRequest(url2)]);
    } catch (unknownError) {
      let error = inferError(unknownError);
      if (error.statusCode === 408) {
        timeoutErrors.push({ url1, url2, error });
      } else {
        return [void 0, error];
      }
    }
  }
  const statusText = timeoutErrors.map(({ url1, url2, error }) => `Request to ${url1} and ${url2} timed out. Error: ${error}`).join("\n");
  return [void 0, { statusCode: 408, statusText }];
}
async function checkResponseStatus(response) {
  if (response.ok) {
    let jsonResponse = await response.json();
    if (jsonResponse.errors && jsonResponse.errors.length > 0) {
      return [
        void 0,
        {
          statusCode: response.status,
          statusText: jsonResponse.errors.map((error) => error.message).join("\n")
        }
      ];
    } else if (jsonResponse.data === void 0) {
      return [
        void 0,
        {
          statusCode: response.status,
          statusText: `GraphQL response data is undefined`
        }
      ];
    }
    return [jsonResponse, void 0];
  } else {
    return [
      void 0,
      {
        statusCode: response.status,
        statusText: response.statusText
      }
    ];
  }
}
function inferError(error) {
  let errorMessage = JSON.stringify(error);
  if (error instanceof AbortSignal) {
    return { statusCode: 408, statusText: `Request Timeout: ${errorMessage}` };
  } else {
    return {
      statusCode: 500,
      statusText: `Unknown Error: ${errorMessage}`
    };
  }
}

// dist/node/lib/mina/errors.js
var ErrorHandlers = {
  Invalid_fee_excess({ transaction: { accountUpdates }, isFeePayer, accountCreationFee }) {
    if (isFeePayer)
      return;
    let balances = accountUpdates.map(({ body }) => {
      if (body.tokenId.equals(TokenId4.default).toBoolean()) {
        return Number(body.balanceChange.toString()) * 1e-9;
      }
    });
    let sum2 = balances.reduce((a2 = 0, b2 = 0) => a2 + b2) ?? 0;
    return `Invalid fee excess.
This means that balance changes in your transaction do not sum up to the amount of fees needed.
Here's the list of balance changes:

${balances.map((balance, i) => {
      return `Account update #${i + 1}) ${balance === void 0 ? "not a MINA account" : `${balance.toFixed(2)} MINA`}`;
    }).join(`
`)}

Total change: ${sum2.toFixed(2)} MINA

If there are no new accounts created in your transaction, then this sum should be equal to 0.00 MINA.
If you are creating new accounts -- by updating accounts that didn't exist yet --
then keep in mind the ${(Number(accountCreationFee) * 1e-9).toFixed(2)} MINA account creation fee, and make sure that the sum equals
${(-Number(accountCreationFee) * 1e-9).toFixed(2)} times the number of newly created accounts.`;
  }
};
function invalidTransactionError(transaction2, errors, additionalContext) {
  let errorMessages = [];
  let rawErrors = JSON.stringify(errors);
  let n = transaction2.accountUpdates.length;
  if (errors.length > n) {
    let errorsForFeePayer = errors.shift() ?? [];
    for (let [error] of errorsForFeePayer) {
      let message = ErrorHandlers[error]?.({
        transaction: transaction2,
        accountUpdateIndex: NaN,
        isFeePayer: true,
        ...additionalContext
      });
      if (message)
        errorMessages.push(message);
    }
  }
  for (let i = 0; i < errors.length; i++) {
    let errorsForUpdate = errors[i];
    for (let [error] of errorsForUpdate) {
      let message = ErrorHandlers[error]?.({
        transaction: transaction2,
        accountUpdateIndex: i,
        isFeePayer: false,
        ...additionalContext
      });
      if (message)
        errorMessages.push(message);
    }
  }
  if (errorMessages.length > 1) {
    return [
      "There were multiple errors when applying your transaction:",
      ...errorMessages.map((msg, i) => `${i + 1}.) ${msg}`),
      `Raw list of errors: ${rawErrors}`
    ].join("\n\n");
  }
  if (errorMessages.length === 1) {
    return `${errorMessages[0]}

Raw list of errors: ${rawErrors}`;
  }
  return rawErrors;
}

// dist/node/lib/mina/transaction.js
var Transaction;
(function(Transaction2) {
  function fromJSON(json) {
    let transaction2 = ZkappCommand3.fromJSON(json);
    return newTransaction(transaction2, activeInstance.proofsEnabled);
  }
  Transaction2.fromJSON = fromJSON;
})(Transaction || (Transaction = {}));
function toTransactionPromise(getPromise) {
  const pending = getPromise().then();
  return Object.assign(pending, {
    sign(...args) {
      return toTransactionPromise(() => pending.then((v) => v.sign(...args)));
    },
    send() {
      return toPendingTransactionPromise(() => pending.then((v) => v.send()));
    },
    prove() {
      return toTransactionPromise(() => pending.then((v) => v.prove()));
    },
    proofs() {
      return pending.then((v) => v.proofs);
    }
  });
}
function toPendingTransactionPromise(getPromise) {
  const pending = getPromise().then();
  return Object.assign(pending, {
    wait(...args) {
      return pending.then((v) => v.wait(...args));
    }
  });
}
async function createTransaction(feePayer, f, numberOfRuns, { fetchMode = "cached", isFinalRunOutsideCircuit = true, proofsEnabled = true } = {}) {
  if (currentTransaction.has()) {
    throw new Error("Cannot start new transaction within another transaction");
  }
  let feePayerSpec;
  if (feePayer === void 0) {
    feePayerSpec = {};
  } else if (feePayer instanceof PublicKey2) {
    feePayerSpec = { sender: feePayer };
  } else {
    feePayerSpec = feePayer;
  }
  let { sender: sender2, fee, memo = "", nonce } = feePayerSpec;
  let transactionId = currentTransaction.enter({
    sender: sender2,
    layout: new AccountUpdateLayout(),
    fetchMode,
    isFinalRunOutsideCircuit,
    numberOfRuns
  });
  try {
    if (fetchMode === "test") {
      await Provable.runUnchecked(async () => {
        await assertPromise(f());
        Provable.asProver(() => {
          let tx = currentTransaction.get();
          tx.layout.toConstantInPlace();
        });
      });
    } else {
      await assertPromise(f());
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let accountUpdates = currentTransaction.get().layout.toFlatList({ mutate: true });
  try {
    for (let accountUpdate of accountUpdates) {
      assertPreconditionInvariants(accountUpdate);
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let feePayerAccountUpdate;
  if (sender2 !== void 0) {
    let nonce_;
    let senderAccount = getAccount2(sender2, TokenId4.default);
    if (nonce === void 0) {
      nonce_ = senderAccount.nonce;
    } else {
      nonce_ = UInt322.from(nonce);
      senderAccount.nonce = nonce_;
      addCachedAccount(senderAccount);
    }
    feePayerAccountUpdate = AccountUpdate3.defaultFeePayer(sender2, nonce_);
    if (fee !== void 0) {
      feePayerAccountUpdate.body.fee = fee instanceof UInt642 ? fee : UInt642.from(String(fee));
    }
  } else {
    feePayerAccountUpdate = AccountUpdate3.dummyFeePayer();
  }
  let transaction2 = {
    accountUpdates,
    feePayer: feePayerAccountUpdate,
    memo
  };
  currentTransaction.leave(transactionId);
  return newTransaction(transaction2, proofsEnabled);
}
function newTransaction(transaction2, proofsEnabled) {
  let self = {
    transaction: transaction2,
    sign(privateKeys) {
      self.transaction = addMissingSignatures(self.transaction, privateKeys);
      return self;
    },
    prove() {
      return toTransactionPromise(async () => {
        let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {
          proofsEnabled
        });
        self.transaction = zkappCommand;
        return Object.assign(self, {
          proofs
        });
      });
    },
    toJSON() {
      let json = ZkappCommand3.toJSON(self.transaction);
      return JSON.stringify(json);
    },
    toPretty() {
      return ZkappCommand3.toPretty(self.transaction);
    },
    toGraphqlQuery() {
      return sendZkappQuery(self.toJSON());
    },
    send() {
      return toPendingTransactionPromise(async () => {
        const pendingTransaction = await sendTransaction(self);
        if (pendingTransaction.errors.length > 0) {
          throw Error(`Transaction failed with errors:
- ${pendingTransaction.errors.join("\n- ")}`);
        }
        return pendingTransaction;
      });
    },
    async safeSend() {
      const pendingTransaction = await sendTransaction(self);
      if (pendingTransaction.errors.length > 0) {
        return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);
      }
      return pendingTransaction;
    }
  };
  return self;
}
function transaction(senderOrF, fOrUndefined) {
  let sender2;
  let f;
  if (fOrUndefined !== void 0) {
    sender2 = senderOrF;
    f = fOrUndefined;
  } else {
    sender2 = void 0;
    f = senderOrF;
  }
  return activeInstance.transaction(sender2, f);
}
async function sendTransaction(txn) {
  return await activeInstance.sendTransaction(txn);
}
function getAccount2(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId);
}
function createRejectedTransaction({ transaction: transaction2, data, toJSON, toPretty, hash: hash3 }, errors) {
  return {
    status: "rejected",
    errors,
    transaction: transaction2,
    toJSON,
    toPretty,
    hash: hash3,
    data
  };
}
function createIncludedTransaction({ transaction: transaction2, data, toJSON, toPretty, hash: hash3 }) {
  return {
    status: "included",
    transaction: transaction2,
    toJSON,
    toPretty,
    hash: hash3,
    data
  };
}

// dist/node/lib/mina/constants.js
var TransactionCost;
(function(TransactionCost2) {
  TransactionCost2.PROOF_COST = 10.26;
  TransactionCost2.SIGNED_PAIR_COST = 10.08;
  TransactionCost2.SIGNED_SINGLE_COST = 9.14;
  TransactionCost2.COST_LIMIT = 69.45;
})(TransactionCost || (TransactionCost = {}));
var TransactionLimits;
(function(TransactionLimits2) {
  TransactionLimits2.MAX_ACTION_ELEMENTS = 100;
  TransactionLimits2.MAX_EVENT_ELEMENTS = 100;
})(TransactionLimits || (TransactionLimits = {}));

// dist/node/lib/mina/transaction-validation.js
function reportGetAccountError(publicKey, tokenId) {
  if (tokenId === TokenId4.toBase58(TokenId4.default)) {
    return `getAccount: Could not find account for public key ${publicKey}`;
  } else {
    return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;
  }
}
function defaultNetworkState() {
  let epochData = {
    ledger: { hash: Field4(0), totalCurrency: UInt642.zero },
    seed: Field4(0),
    startCheckpoint: Field4(0),
    lockCheckpoint: Field4(0),
    epochLength: UInt322.zero
  };
  return {
    snarkedLedgerHash: Field4(0),
    blockchainLength: UInt322.zero,
    minWindowDensity: UInt322.zero,
    totalCurrency: UInt642.zero,
    globalSlotSinceGenesis: UInt322.zero,
    stakingEpochData: epochData,
    nextEpochData: cloneCircuitValue(epochData)
  };
}
function verifyTransactionLimits({ accountUpdates }) {
  let eventElements = { events: 0, actions: 0 };
  let authKinds = accountUpdates.map((update) => {
    eventElements.events += countEventElements(update.body.events);
    eventElements.actions += countEventElements(update.body.actions);
    let { isSigned, isProved, verificationKeyHash } = update.body.authorizationKind;
    return {
      isSigned: isSigned.toBoolean(),
      isProved: isProved.toBoolean(),
      verificationKeyHash: verificationKeyHash.toString()
    };
  });
  authKinds.unshift({
    isSigned: true,
    isProved: false,
    verificationKeyHash: ""
  });
  let authTypes = filterGroups(authKinds);
  let totalTimeRequired = TransactionCost.PROOF_COST * authTypes.proof + TransactionCost.SIGNED_PAIR_COST * authTypes.signedPair + TransactionCost.SIGNED_SINGLE_COST * authTypes.signedSingle;
  let isWithinCostLimit = totalTimeRequired < TransactionCost.COST_LIMIT;
  let isWithinEventsLimit = eventElements.events <= TransactionLimits.MAX_EVENT_ELEMENTS;
  let isWithinActionsLimit = eventElements.actions <= TransactionLimits.MAX_ACTION_ELEMENTS;
  let error = "";
  if (!isWithinCostLimit) {
    error += `Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.
Each transaction needs to be processed by the snark workers on the network.
Certain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.

${JSON.stringify(authTypes)}


`;
  }
  if (!isWithinEventsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much event data. The maximum allowed number of field elements in events is ${TransactionLimits.MAX_EVENT_ELEMENTS}, but you tried to emit ${eventElements.events}.

`;
  }
  if (!isWithinActionsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much action data. The maximum allowed number of field elements in actions is ${TransactionLimits.MAX_ACTION_ELEMENTS}, but you tried to emit ${eventElements.actions}.

`;
  }
  if (error)
    throw Error("Error during transaction sending:\n\n" + error);
}
function countEventElements({ data }) {
  return data.reduce((acc, ev) => acc + ev.length, 0);
}
function filterGroups(xs) {
  let pairs = filterPairs(xs);
  xs = pairs.xs;
  let singleCount = 0;
  let proofCount = 0;
  xs.forEach((t) => {
    if (t.isProved)
      proofCount++;
    else
      singleCount++;
  });
  return {
    signedPair: pairs.pairs,
    signedSingle: singleCount,
    proof: proofCount
  };
}
async function verifyAccountUpdate(account, accountUpdate, publicInput, transactionCommitments2, proofsEnabled, networkId) {
  if (accountUpdate.body.callDepth === 0 && !AccountUpdate3.MayUseToken.isNo(accountUpdate).toBoolean()) {
    throw Error("Top-level account update can not use or pass on token permissions. Make sure that\naccountUpdate.body.mayUseToken = AccountUpdate.MayUseToken.No;");
  }
  let perm = account.permissions;
  if (accountUpdate.authorization === dummySignature()) {
    let pk = PublicKey2.toBase58(accountUpdate.body.publicKey);
    throw Error(`verifyAccountUpdate: Detected a missing signature for (${pk}), private key was missing.`);
  }
  function includesChange(val) {
    if (Array.isArray(val)) {
      return !val.every((v) => v === null);
    } else {
      return val !== null;
    }
  }
  function permissionForUpdate(key) {
    switch (key) {
      case "appState":
        return perm.editState;
      case "delegate":
        return perm.setDelegate;
      case "verificationKey":
        return perm.setVerificationKey.auth;
      case "permissions":
        return perm.setPermissions;
      case "zkappUri":
        return perm.setZkappUri;
      case "tokenSymbol":
        return perm.setTokenSymbol;
      case "timing":
        return perm.setTiming;
      case "votingFor":
        return perm.setVotingFor;
      case "actions":
        return perm.editActionState;
      case "incrementNonce":
        return perm.incrementNonce;
      case "send":
        return perm.send;
      case "receive":
        return perm.receive;
      default:
        throw Error(`Invalid permission for field ${key}: does not exist.`);
    }
  }
  let accountUpdateJson = accountUpdate.toJSON();
  const update = accountUpdateJson.body.update;
  let errorTrace = "";
  let isValidProof = false;
  let isValidSignature = false;
  if (!proofsEnabled)
    isValidProof = true;
  if (accountUpdate.authorization.proof && proofsEnabled) {
    try {
      let publicInputFields = ZkappPublicInput.toFields(publicInput);
      let proof = {
        maxProofsVerified: 2,
        proof: accountUpdate.authorization.proof,
        publicInput: publicInputFields.map((f) => f.toString()),
        publicOutput: []
      };
      let verificationKey = account.zkapp?.verificationKey?.data;
      assert3(verificationKey !== void 0, "Account does not have a verification key");
      isValidProof = await verify(proof, verificationKey);
      if (!isValidProof) {
        throw Error(`Invalid proof for account update
${JSON.stringify(update)}`);
      }
    } catch (error) {
      errorTrace += "\n\n" + error.stack;
      isValidProof = false;
    }
  }
  if (accountUpdate.authorization.signature) {
    try {
      isValidSignature = verifyAccountUpdateSignature(transaction_bigint_exports.AccountUpdate.fromJSON(accountUpdateJson), transactionCommitments2, networkId);
    } catch (error) {
      errorTrace += "\n\n" + error.stack;
      isValidSignature = false;
    }
  }
  let verified = false;
  function checkPermission(p0, field) {
    let p3 = transaction_exports.AuthRequired.toJSON(p0);
    if (p3 === "None")
      return;
    if (p3 === "Impossible") {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}'`);
    }
    if (p3 === "Signature" || p3 === "Either") {
      verified ||= isValidSignature;
    }
    if (p3 === "Proof" || p3 === "Either") {
      verified ||= isValidProof;
    }
    if (!verified) {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}', but the required authorization was not provided or is invalid.
        ${errorTrace !== "" ? "Error trace: " + errorTrace : ""}

`);
    }
  }
  Object.entries(update).forEach(([key, value]) => {
    if (includesChange(value)) {
      let p3 = permissionForUpdate(key);
      checkPermission(p3, key);
    }
  });
  if (accountUpdate.body.actions.data.length > 0) {
    let p3 = permissionForUpdate("actions");
    checkPermission(p3, "actions");
  }
  if (accountUpdate.body.incrementNonce.toBoolean()) {
    let p3 = permissionForUpdate("incrementNonce");
    checkPermission(p3, "incrementNonce");
  }
  if (errorTrace && !verified) {
    throw Error(`One or more proofs were invalid and no other form of authorization was provided.
${errorTrace}`);
  }
}
var isPair = (a2, b2) => !a2.isProved && !b2.isProved;
function filterPairs(xs) {
  if (xs.length <= 1)
    return { xs, pairs: 0 };
  if (isPair(xs[0], xs[1])) {
    let rec = filterPairs(xs.slice(2));
    return { xs: rec.xs, pairs: rec.pairs + 1 };
  } else {
    let rec = filterPairs(xs.slice(1));
    return { xs: [xs[0]].concat(rec.xs), pairs: rec.pairs };
  }
}

// dist/node/lib/mina/transaction-logic/apply.js
function applyAccountUpdate(account, update) {
  account.publicKey.assertEquals(update.publicKey);
  account.tokenId.assertEquals(update.tokenId, "token id mismatch");
  let json = Account4.toJSON(account);
  account = Account4.fromJSON(json);
  if (update.update.permissions.isSome.toBoolean()) {
    account.permissions = update.update.permissions.value;
  }
  return account;
}

// dist/node/lib/mina/transaction-logic/ledger.js
var SimpleLedger = class _SimpleLedger {
  constructor() {
    this.accounts = /* @__PURE__ */ new Map();
  }
  static create() {
    return new _SimpleLedger();
  }
  exists({ publicKey, tokenId = transaction_exports.TokenId.empty() }) {
    return this.accounts.has(accountId({ publicKey, tokenId }));
  }
  store(account) {
    this.accounts.set(accountId(account), account);
  }
  load({ publicKey, tokenId = transaction_exports.TokenId.empty() }) {
    let id2 = accountId({ publicKey, tokenId });
    let account = this.accounts.get(id2);
    return account;
  }
  apply(update) {
    let id2 = accountId(update.body);
    let account = this.accounts.get(id2);
    account ??= newAccount(update.body);
    let updated = applyAccountUpdate(account, update);
    this.accounts.set(id2, updated);
  }
};
function accountId(account) {
  let id2 = account.publicKey.x.toBigInt();
  id2 <<= 1n;
  id2 |= BigInt(account.publicKey.isOdd.toBoolean());
  id2 <<= BigInt(Field3.sizeInBits);
  id2 |= account.tokenId.toBigInt();
  return id2;
}

// dist/node/lib/ml/conversion.js
var Ml = {
  constFromField,
  constToField,
  varFromField,
  varToField,
  fromScalar,
  toScalar,
  fromPrivateKey,
  toPrivateKey,
  fromPublicKey,
  toPublicKey,
  fromPublicKeyVar,
  toPublicKeyVar
};
function constFromField(x) {
  return x.toConstant().value[1];
}
function constToField(x) {
  return Field4(x);
}
function varFromField(x) {
  return x.value;
}
function varToField(x) {
  return Field4(x);
}
function fromScalar(s) {
  return [0, s.toBigInt()];
}
function toScalar(s) {
  return Scalar3.from(s[1]);
}
function fromPrivateKey(sk) {
  return fromScalar(sk.s);
}
function toPrivateKey(sk) {
  return new PrivateKey2(Scalar3.from(sk[1]));
}
function fromPublicKey(pk) {
  return MlPair(pk.x.toConstant().value[1], MlBool(pk.isOdd.toBoolean()));
}
function toPublicKey([, x, isOdd]) {
  return PublicKey2.from({
    x: Field4(x),
    isOdd: Bool4(MlBool.from(isOdd))
  });
}
function fromPublicKeyVar(pk) {
  return MlPair(pk.x.value, pk.isOdd.toField().value);
}
function toPublicKeyVar([, x, isOdd]) {
  return PublicKey2.from({ x: Field4(x), isOdd: Bool4(isOdd) });
}

// dist/node/lib/mina/local-blockchain.js
function TestPublicKey(key) {
  return Object.assign(PublicKey2.fromPrivateKey(key), { key });
}
(function(TestPublicKey2) {
  function random2(count = 1) {
    if (count === 1)
      return TestPublicKey2(PrivateKey2.random());
    return Array.from({ length: count }, () => TestPublicKey2(PrivateKey2.random()));
  }
  TestPublicKey2.random = random2;
  function fromBase582(base582) {
    return TestPublicKey2(PrivateKey2.fromBase58(base582));
  }
  TestPublicKey2.fromBase58 = fromBase582;
})(TestPublicKey || (TestPublicKey = {}));
async function LocalBlockchain({ proofsEnabled = true, enforceTransactionLimits = true } = {}) {
  await initializeBindings();
  const slotTime = 3 * 60 * 1e3;
  const startTime = Date.now();
  const genesisTimestamp = UInt642.from(startTime);
  const ledger = Ledger.create();
  let networkState = defaultNetworkState();
  function addAccount(publicKey, balance) {
    try {
      ledger.addAccount(Ml.fromPublicKey(publicKey), balance);
    } catch (error) {
      throw prettifyStacktrace(error);
    }
  }
  let testAccounts = [];
  for (let i = 0; i < 10; ++i) {
    let MINA = 10n ** 9n;
    const largeValue = 1000n * MINA;
    const testAccount = TestPublicKey.random();
    addAccount(testAccount, largeValue.toString());
    testAccounts.push(testAccount);
  }
  const events = {};
  const actions = {};
  const originalProofsEnabled = proofsEnabled;
  return {
    getNetworkId: () => "testnet",
    proofsEnabled,
    getNetworkConstants() {
      return {
        ...defaultNetworkConstants,
        genesisTimestamp
      };
    },
    currentSlot() {
      return UInt322.from(Math.ceil(((/* @__PURE__ */ new Date()).valueOf() - startTime) / slotTime));
    },
    hasAccount(publicKey, tokenId = TokenId4.default) {
      return !!ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));
    },
    getAccount(publicKey, tokenId = TokenId4.default) {
      let accountJson = ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));
      if (accountJson === void 0) {
        throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId4.toBase58(tokenId)));
      }
      return transaction_exports.Account.fromJSON(accountJson);
    },
    getNetworkState() {
      return networkState;
    },
    sendTransaction(txn) {
      return toPendingTransactionPromise(async () => {
        let zkappCommandJson = ZkappCommand3.toJSON(txn.transaction);
        let commitments = transactionCommitments(transaction_bigint_exports.ZkappCommand.fromJSON(zkappCommandJson), this.getNetworkId());
        if (enforceTransactionLimits)
          verifyTransactionLimits(txn.transaction);
        let simpleLedger = SimpleLedger.create();
        for (const update of txn.transaction.accountUpdates) {
          let authIsProof = !!update.authorization.proof;
          let kindIsProof = update.body.authorizationKind.isProved.toBoolean();
          if (kindIsProof && !authIsProof) {
            throw Error(`The actual authorization does not match the expected authorization kind. Did you forget to invoke \`await tx.prove();\`?`);
          }
          let account = simpleLedger.load(update.body);
          if (account === void 0) {
            let accountJson = ledger.getAccount(Ml.fromPublicKey(update.body.publicKey), Ml.constFromField(update.body.tokenId));
            if (accountJson !== void 0) {
              let storedAccount = Account4.fromJSON(accountJson);
              simpleLedger.store(storedAccount);
              account = storedAccount;
            }
          }
          if (account !== void 0) {
            let publicInput = update.toPublicInput(txn.transaction);
            await verifyAccountUpdate(account, update, publicInput, commitments, this.proofsEnabled, this.getNetworkId());
            simpleLedger.apply(update);
          }
        }
        let status = "pending";
        const errors = [];
        try {
          ledger.applyJsonTransaction(JSON.stringify(zkappCommandJson), defaultNetworkConstants.accountCreationFee.toString(), JSON.stringify(networkState));
        } catch (err) {
          status = "rejected";
          try {
            const errorMessages = JSON.parse(err.message);
            const formattedError = invalidTransactionError(txn.transaction, errorMessages, {
              accountCreationFee: defaultNetworkConstants.accountCreationFee.toString()
            });
            errors.push(formattedError);
          } catch (parseError) {
            const fallbackErrorMessage = err.message || parseError.message || "Unknown error occurred";
            errors.push(fallbackErrorMessage);
          }
        }
        txn.transaction.accountUpdates.forEach((p3, i) => {
          let pJson = zkappCommandJson.accountUpdates[i];
          let addr = pJson.body.publicKey;
          let tokenId = pJson.body.tokenId;
          events[addr] ??= {};
          if (p3.body.events.data.length > 0) {
            events[addr][tokenId] ??= [];
            let updatedEvents = p3.body.events.data.map((data) => {
              return {
                data,
                transactionInfo: {
                  transactionHash: "",
                  transactionStatus: "",
                  transactionMemo: ""
                }
              };
            });
            events[addr][tokenId].push({
              events: updatedEvents,
              blockHeight: networkState.blockchainLength,
              globalSlot: networkState.globalSlotSinceGenesis,
              // The following fields are fetched from the Mina network. For now, we mock these values out
              // since networkState does not contain these fields.
              blockHash: "",
              parentBlockHash: "",
              chainStatus: ""
            });
          }
          let storedActions = actions[addr]?.[tokenId];
          let latestActionState_ = storedActions?.[storedActions.length - 1]?.hash;
          let latestActionState = latestActionState_ !== void 0 ? Field4(latestActionState_) : Actions3.emptyActionState();
          actions[addr] ??= {};
          if (p3.body.actions.data.length > 0) {
            let newActionState = Actions3.updateSequenceState(latestActionState, p3.body.actions.hash);
            actions[addr][tokenId] ??= [];
            actions[addr][tokenId].push({
              actions: pJson.body.actions,
              hash: newActionState.toString()
            });
          }
        });
        let test = await Test();
        const hash3 = test.transactionHash.hashZkAppCommand(txn.toJSON());
        const pendingTransaction = {
          status,
          errors,
          transaction: txn.transaction,
          hash: hash3,
          toJSON: txn.toJSON,
          toPretty: txn.toPretty
        };
        const wait = async (_options) => {
          const pendingTransaction2 = await safeWait(_options);
          if (pendingTransaction2.status === "rejected") {
            throw Error(`Transaction failed with errors:
${pendingTransaction2.errors.join("\n")}`);
          }
          return pendingTransaction2;
        };
        const safeWait = async (_options) => {
          if (status === "rejected") {
            return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);
          }
          return createIncludedTransaction(pendingTransaction);
        };
        return {
          ...pendingTransaction,
          wait,
          safeWait
        };
      });
    },
    transaction(sender2, f) {
      return toTransactionPromise(async () => {
        let tx = await createTransaction(sender2, f, 0, {
          isFinalRunOutsideCircuit: false,
          proofsEnabled: this.proofsEnabled,
          fetchMode: "test"
        });
        let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
        return await createTransaction(sender2, f, 1, {
          isFinalRunOutsideCircuit: !hasProofs,
          proofsEnabled: this.proofsEnabled
        });
      });
    },
    applyJsonTransaction(json) {
      return ledger.applyJsonTransaction(json, defaultNetworkConstants.accountCreationFee.toString(), JSON.stringify(networkState));
    },
    async fetchEvents(publicKey, tokenId = TokenId4.default) {
      const reversedEvents = (events?.[publicKey.toBase58()]?.[TokenId4.toBase58(tokenId)] ?? []).reverse();
      return reversedEvents;
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId4.default) {
      return this.getActions(publicKey, actionStates, tokenId);
    },
    getActions(publicKey, actionStates, tokenId = TokenId4.default) {
      let currentActions = actions?.[publicKey.toBase58()]?.[TokenId4.toBase58(tokenId)] ?? [];
      let { fromActionState, endActionState } = actionStates ?? {};
      let emptyState = Actions3.emptyActionState();
      if (endActionState?.equals(emptyState).toBoolean())
        return [];
      let start = fromActionState?.equals(emptyState).toBoolean() ? void 0 : fromActionState?.toString();
      let end = endActionState?.toString();
      let startIndex = 0;
      if (start) {
        let i = currentActions.findIndex((e) => e.hash === start);
        if (i === -1)
          throw Error(`getActions: fromActionState not found.`);
        startIndex = i + 1;
      }
      let endIndex;
      if (end) {
        let i = currentActions.findIndex((e) => e.hash === end);
        if (i === -1)
          throw Error(`getActions: endActionState not found.`);
        endIndex = i + 1;
      }
      return currentActions.slice(startIndex, endIndex);
    },
    addAccount,
    /**
     * An array of 10 test accounts that have been pre-filled with
     * 30000000000 units of currency.
     */
    testAccounts,
    setGlobalSlot(slot) {
      networkState.globalSlotSinceGenesis = UInt322.from(slot);
    },
    incrementGlobalSlot(increment) {
      networkState.globalSlotSinceGenesis = networkState.globalSlotSinceGenesis.add(increment);
    },
    setBlockchainLength(height) {
      networkState.blockchainLength = height;
    },
    setTotalCurrency(currency) {
      networkState.totalCurrency = currency;
    },
    setProofsEnabled(newProofsEnabled) {
      this.proofsEnabled = newProofsEnabled;
    },
    resetProofsEnabled() {
      this.proofsEnabled = originalProofsEnabled;
    }
  };
}

// dist/node/lib/mina/mina.js
setActiveInstance({
  ...activeInstance,
  transaction(sender2, f) {
    return toTransactionPromise(() => createTransaction(sender2, f, 0));
  }
});
function Network2(options) {
  let minaNetworkId = "testnet";
  let minaGraphqlEndpoint;
  let archiveEndpoint;
  let lightnetAccountManagerEndpoint;
  if (options && typeof options === "string") {
    minaGraphqlEndpoint = options;
    setGraphqlEndpoint(minaGraphqlEndpoint);
  } else if (options && typeof options === "object") {
    if (options.networkId) {
      minaNetworkId = options.networkId;
    }
    if (!options.mina)
      throw new Error("Network: malformed input. Please provide an object with 'mina' endpoint.");
    if (Array.isArray(options.mina) && options.mina.length !== 0) {
      minaGraphqlEndpoint = options.mina[0];
      setGraphqlEndpoint(minaGraphqlEndpoint);
      setMinaGraphqlFallbackEndpoints(options.mina.slice(1));
    } else if (typeof options.mina === "string") {
      minaGraphqlEndpoint = options.mina;
      setGraphqlEndpoint(minaGraphqlEndpoint);
    }
    if (options.archive !== void 0) {
      if (Array.isArray(options.archive) && options.archive.length !== 0) {
        archiveEndpoint = options.archive[0];
        setArchiveGraphqlEndpoint(archiveEndpoint);
        setArchiveGraphqlFallbackEndpoints(options.archive.slice(1));
      } else if (typeof options.archive === "string") {
        archiveEndpoint = options.archive;
        setArchiveGraphqlEndpoint(archiveEndpoint);
      }
    }
    if (options.lightnetAccountManager !== void 0 && typeof options.lightnetAccountManager === "string") {
      lightnetAccountManagerEndpoint = options.lightnetAccountManager;
      setLightnetAccountManagerEndpoint(lightnetAccountManagerEndpoint);
    }
  } else {
    throw new Error("Network: malformed input. Please provide a string or an object with 'mina' and 'archive' endpoints.");
  }
  return {
    getNetworkId: () => minaNetworkId,
    getNetworkConstants() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(minaGraphqlEndpoint);
        const genesisConstants = getCachedGenesisConstants(minaGraphqlEndpoint);
        return genesisConstants !== void 0 ? genesisToNetworkConstants(genesisConstants) : defaultNetworkConstants;
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        const genesisConstants = getCachedGenesisConstants(minaGraphqlEndpoint);
        if (genesisConstants !== void 0)
          return genesisToNetworkConstants(genesisConstants);
      }
      return defaultNetworkConstants;
    },
    currentSlot() {
      throw Error("currentSlot() is not implemented yet for remote blockchains.");
    },
    hasAccount(publicKey, tokenId = TokenId4.default) {
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        return !!getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
      }
      return false;
    },
    getAccount(publicKey, tokenId = TokenId4.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markAccountToBeFetched(publicKey, tokenId, minaGraphqlEndpoint);
        let account = getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
        return account ?? dummyAccount(publicKey);
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let account = getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
        if (account !== void 0)
          return account;
      }
      throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId4.toBase58(tokenId))}
Graphql endpoint: ${minaGraphqlEndpoint}`);
    },
    getNetworkState() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(minaGraphqlEndpoint);
        let network = getCachedNetwork(minaGraphqlEndpoint);
        return network ?? defaultNetworkState();
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let network = getCachedNetwork(minaGraphqlEndpoint);
        if (network !== void 0)
          return network;
      }
      throw Error(`getNetworkState: Could not fetch network state from graphql endpoint ${minaGraphqlEndpoint} outside of a transaction.`);
    },
    sendTransaction(txn) {
      return toPendingTransactionPromise(async () => {
        verifyTransactionLimits(txn.transaction);
        let [response, error] = await sendZkapp(txn.toJSON());
        let errors = [];
        if (response === void 0 && error !== void 0) {
          errors = [JSON.stringify(error)];
        } else if (response && response.errors && response.errors.length > 0) {
          response?.errors.forEach((e) => errors.push(JSON.stringify(e)));
        }
        const status = errors.length === 0 ? "pending" : "rejected";
        let mlTest = await Test();
        const hash3 = mlTest.transactionHash.hashZkAppCommand(txn.toJSON());
        const pendingTransaction = {
          status,
          data: response?.data,
          errors,
          transaction: txn.transaction,
          hash: hash3,
          toJSON: txn.toJSON,
          toPretty: txn.toPretty
        };
        const pollTransactionStatus = async (transactionHash, maxAttempts, interval, attempts = 0) => {
          let res;
          try {
            res = await checkZkappTransaction(transactionHash);
            if (res.success) {
              return createIncludedTransaction(pendingTransaction);
            } else if (res.failureReason) {
              const error2 = invalidTransactionError(txn.transaction, res.failureReason, {
                accountCreationFee: defaultNetworkConstants.accountCreationFee.toString()
              });
              return createRejectedTransaction(pendingTransaction, [error2]);
            }
          } catch (error2) {
            return createRejectedTransaction(pendingTransaction, [
              error2.message
            ]);
          }
          if (maxAttempts && attempts >= maxAttempts) {
            return createRejectedTransaction(pendingTransaction, [
              `Exceeded max attempts.
TransactionId: ${transactionHash}
Attempts: ${attempts}
Last received status: ${res}`
            ]);
          }
          await new Promise((resolve2) => setTimeout(resolve2, interval));
          return pollTransactionStatus(transactionHash, maxAttempts, interval, attempts + 1);
        };
        const poll = async (maxAttempts = 45, interval = 2e4) => {
          return pollTransactionStatus(hash3, maxAttempts, interval);
        };
        const wait = async (options2) => {
          const pendingTransaction2 = await safeWait(options2);
          if (pendingTransaction2.status === "rejected") {
            throw Error(`Transaction failed with errors:
${pendingTransaction2.errors.join("\n")}`);
          }
          return pendingTransaction2;
        };
        const safeWait = async (options2) => {
          if (status === "rejected") {
            return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);
          }
          return await poll(options2?.maxAttempts, options2?.interval);
        };
        return {
          ...pendingTransaction,
          wait,
          safeWait
        };
      });
    },
    transaction(sender2, f) {
      return toTransactionPromise(async () => {
        let tx = await createTransaction(sender2, f, 0, {
          fetchMode: "test",
          isFinalRunOutsideCircuit: false
        });
        await fetchMissingData(minaGraphqlEndpoint, archiveEndpoint);
        let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
        return await createTransaction(sender2, f, 1, {
          fetchMode: "cached",
          isFinalRunOutsideCircuit: !hasProofs
        });
      });
    },
    async fetchEvents(publicKey, tokenId = TokenId4.default, filterOptions = {}) {
      let pubKey = publicKey.toBase58();
      let token = TokenId4.toBase58(tokenId);
      return fetchEvents2({ publicKey: pubKey, tokenId: token }, archiveEndpoint, filterOptions);
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId4.default) {
      let pubKey = publicKey.toBase58();
      let token = TokenId4.toBase58(tokenId);
      let { fromActionState, endActionState } = actionStates ?? {};
      let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
      let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
      return fetchActions2({
        publicKey: pubKey,
        actionStates: {
          fromActionState: fromActionStateBase58,
          endActionState: endActionStateBase58
        },
        tokenId: token
      }, archiveEndpoint);
    },
    getActions(publicKey, actionStates, tokenId = TokenId4.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markActionsToBeFetched(publicKey, tokenId, archiveEndpoint, actionStates);
        let actions = getCachedActions(publicKey, tokenId);
        return actions ?? [];
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let actions = getCachedActions(publicKey, tokenId);
        if (actions !== void 0)
          return actions;
      }
      throw Error(`getActions: Could not find actions for the public key ${publicKey}`);
    },
    proofsEnabled: true
  };
}
function sender() {
  let tx = currentTransaction();
  if (tx === void 0)
    throw Error(`The sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
  let sender2 = currentTransaction()?.sender;
  if (sender2 === void 0)
    throw Error(`The sender is not available, because the transaction block was created without the optional \`sender\` argument.
Here's an example for how to pass in the sender and make it available:

Mina.transaction(sender, // <-- pass in sender's public key here
() => {
  // methods can use this.sender
});
`);
  return sender2;
}
function dummyAccount(pubkey) {
  let dummy = transaction_exports.Account.empty();
  if (pubkey)
    dummy.publicKey = pubkey;
  return dummy;
}
async function waitForFunding(address) {
  let attempts = 0;
  let maxAttempts = 30;
  let interval = 3e4;
  const executePoll = async (resolve2, reject) => {
    let { account } = await fetchAccount({ publicKey: address });
    attempts++;
    if (account) {
      return resolve2();
    } else if (maxAttempts && attempts === maxAttempts) {
      return reject(new Error(`Exceeded max attempts`));
    } else {
      setTimeout(executePoll, interval, resolve2, reject);
    }
  };
  return new Promise(executePoll);
}
async function faucet(pub, network = "berkeley-qanet") {
  let address = pub.toBase58();
  let response = await fetch("https://faucet.minaprotocol.com/api/v1/faucet", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      network,
      address
    })
  });
  response = await response.json();
  if (response.status.toString() !== "success") {
    throw new Error(`Error funding account ${address}, got response status: ${response.status}, text: ${response.statusText}`);
  }
  await waitForFunding(address);
}
function genesisToNetworkConstants(genesisConstants) {
  return {
    genesisTimestamp: UInt642.from(Date.parse(genesisConstants.genesisTimestamp)),
    slotTime: UInt642.from(genesisConstants.slotDuration),
    accountCreationFee: UInt642.from(genesisConstants.accountCreationFee)
  };
}

// dist/node/lib/mina/zkapp.js
var import_tslib5 = require("tslib");
var import_reflect_metadata3 = require("reflect-metadata");

// dist/node/bindings/lib/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  Bijective: () => Bijective,
  bytesFromFields: () => bytesFromFields,
  bytesToFields: () => bytesToFields,
  stringFromFields: () => stringFromFields,
  stringToFields: () => stringToFields
});
function stringToFields(message) {
  let bytes = new TextEncoder().encode(message);
  return bytesToFields(bytes);
}
function stringFromFields(fields2) {
  let bytes = bytesFromFields(fields2);
  return new TextDecoder().decode(bytes);
}
var STOP = 1;
function bytesToFields(bytes) {
  let fields2 = [];
  let currentBigInt = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    currentBigInt += BigInt(byte) << bitPosition;
    bitPosition += 8n;
    if (bitPosition === 248n) {
      fields2.push(Field4(currentBigInt.toString()));
      currentBigInt = 0n;
      bitPosition = 0n;
    }
  }
  currentBigInt += BigInt(STOP) << bitPosition;
  fields2.push(Field4(currentBigInt.toString()));
  return fields2;
}
function bytesFromFields(fields2) {
  let lastChunk = fields2.pop();
  if (lastChunk === void 0)
    return new Uint8Array();
  let lastChunkBytes = bytesOfConstantField(lastChunk);
  let i = lastChunkBytes.lastIndexOf(STOP, 30);
  if (i === -1)
    throw Error("Error (bytesFromFields): Invalid encoding.");
  let bytes = new Uint8Array(fields2.length * 31 + i);
  bytes.set(lastChunkBytes.subarray(0, i), fields2.length * 31);
  i = 0;
  for (let field of fields2) {
    bytes.set(bytesOfConstantField(field).subarray(0, 31), i);
    i += 31;
  }
  fields2.push(lastChunk);
  return bytes;
}
var p2 = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q2 = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var bytesPerBigInt = 32;
var bytesBase = 256n ** BigInt(bytesPerBigInt);
var Bijective = {
  Fp: {
    toBytes: (fields2) => toBytesBijective(fields2, p2),
    fromBytes: (bytes) => toFieldsBijective(bytes, p2),
    toString(fields2) {
      return new TextDecoder().decode(toBytesBijective(fields2, p2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, p2);
    }
  },
  Fq: {
    toBytes: (fields2) => toBytesBijective(fields2, q2),
    fromBytes: (bytes) => toFieldsBijective(bytes, q2),
    toString(fields2) {
      return new TextDecoder().decode(toBytesBijective(fields2, q2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, q2);
    }
  }
};
function toBytesBijective(fields2, p3) {
  let fieldsBigInts = fields2.map((x) => x.toBigInt());
  let bytesBig = changeBase(fieldsBigInts, p3, bytesBase);
  let bytes = bigIntArrayToBytes(bytesBig, bytesPerBigInt);
  return bytes;
}
function toFieldsBijective(bytes, p3) {
  let bytesBig = bytesToBigIntArray(bytes, bytesPerBigInt);
  let fieldsBigInts = changeBase(bytesBig, bytesBase, p3);
  let fields2 = fieldsBigInts.map(Field4);
  return fields2;
}
function bytesOfConstantField(field) {
  return Uint8Array.from(Field4.toBytes(field));
}
function bigIntToBytes2(x, length) {
  let bytes = [];
  for (; x > 0; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  let array = new Uint8Array(bytes);
  if (length === void 0)
    return array;
  if (array.length > length)
    throw Error(`bigint doesn't fit into ${length} bytes.`);
  let sizedArray = new Uint8Array(length);
  sizedArray.set(array);
  return sizedArray;
}
function bytesToBigIntArray(bytes, bytesPerBigInt2) {
  let bigints = [];
  for (let i = 0; i < bytes.byteLength; i += bytesPerBigInt2) {
    bigints.push(bytesToBigInt(bytes.subarray(i, i + bytesPerBigInt2)));
  }
  return bigints;
}
function bigIntArrayToBytes(bigints, bytesPerBigInt2) {
  let bytes = new Uint8Array(bigints.length * bytesPerBigInt2);
  let offset = 0;
  for (let b2 of bigints) {
    bytes.set(bigIntToBytes2(b2, bytesPerBigInt2), offset);
    offset += bytesPerBigInt2;
  }
  let i = bytes.byteLength - 1;
  for (; i >= 0; i--) {
    if (bytes[i] !== 0)
      break;
  }
  return bytes.slice(0, i + 1);
}

// dist/node/lib/mina/state.js
function State2(defaultValue) {
  return createState(defaultValue);
}
function state2(type) {
  let stateType = ProvableType.get(type);
  return function(target, key, _descriptor) {
    const ZkappClass = target.constructor;
    if (reservedPropNames.has(key)) {
      throw Error(`Property name ${key} is reserved.`);
    }
    let sc = smartContracts.get(ZkappClass);
    if (sc === void 0) {
      sc = { states: [], layout: void 0 };
      smartContracts.set(ZkappClass, sc);
    }
    sc.states.push([key, stateType]);
    Object.defineProperty(target, key, {
      get() {
        return this._?.[key];
      },
      set(v) {
        if (v._contract !== void 0)
          throw Error("A State should only be assigned once to a SmartContract");
        if (this._?.[key])
          throw Error("A @state should only be assigned once");
        v._contract = {
          key,
          stateType,
          instance: this,
          class: ZkappClass,
          wasConstrained: false,
          wasRead: false,
          cachedVariable: void 0
        };
        (this._ ??= {})[key] = v;
      }
    });
  };
}
function declareState(SmartContract2, states) {
  for (let key in states) {
    let CircuitValue2 = states[key];
    state2(CircuitValue2)(SmartContract2.prototype, key);
  }
}
function createState(defaultValue) {
  return {
    _contract: void 0,
    defaultValue,
    set(state3) {
      if (this._contract === void 0)
        throw Error("set can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state3);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i) => {
        let appStateSlot = accountUpdate.body.update.appState[layout.offset + i];
        AccountUpdate3.setValue(appStateSlot, x);
      });
    },
    requireEquals(state3) {
      if (this._contract === void 0)
        throw Error("requireEquals can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state3);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i) => {
        let precondition = accountUpdate.body.preconditions.account.state[layout.offset + i];
        ensureConsistentPrecondition(precondition, Bool4(true), x, this._contract?.key);
        AccountUpdate3.assertEquals(precondition, x);
      });
      this._contract.wasConstrained = true;
    },
    requireEqualsIf(condition, state3) {
      if (this._contract === void 0)
        throw Error("requireEqualsIf can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state3);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((stateField, i) => {
        let value = Provable.if(condition, stateField, Field4(0));
        ensureConsistentPrecondition(accountUpdate.body.preconditions.account.state[layout.offset + i], condition, value, this._contract?.key);
        let state4 = accountUpdate.body.preconditions.account.state[layout.offset + i];
        state4.isSome = condition;
        state4.value = value;
      });
      this._contract.wasConstrained = true;
    },
    requireNothing() {
      if (this._contract === void 0)
        throw Error("requireNothing can only be called when the State is assigned to a SmartContract @state.");
      this._contract.wasConstrained = true;
    },
    get() {
      if (this._contract === void 0)
        throw Error("get can only be called when the State is assigned to a SmartContract @state.");
      if (this._contract.cachedVariable !== void 0 && // `inCheckedComputation() === true` here always implies being inside a wrapped smart contract method,
      // which will ensure that the cache is cleaned up before & after each method run.
      Provable.inCheckedComputation()) {
        this._contract.wasRead = true;
        return this._contract.cachedVariable;
      }
      let layout = getLayoutPosition(this._contract);
      let contract2 = this._contract;
      let inProver_ = Provable.inProver();
      let stateFieldsType = Provable.Array(Field4, layout.length);
      let stateAsFields = Provable.witness(stateFieldsType, () => {
        let account;
        try {
          account = getAccount(contract2.instance.address, contract2.instance.self.body.tokenId);
        } catch (err) {
          if (inProver_) {
            throw err;
          }
          let message = `${contract2.key}.get() failed, either:
1. We can't find this zkapp account in the ledger
2. Because the zkapp account was not found in the cache. Try calling \`await fetchAccount(zkappAddress)\` first.
If none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!`;
          if (err.message) {
            err.message = message + `

${err.message}`;
            throw err;
          } else {
            throw Error(message);
          }
        }
        if (account.zkapp?.appState === void 0) {
          return Array(layout.length).fill(Field4(0));
        } else {
          let stateAsFields2 = [];
          for (let i = 0; i < layout.length; ++i) {
            stateAsFields2.push(account.zkapp.appState[layout.offset + i]);
          }
          return stateAsFields2;
        }
      });
      let state3 = this._contract.stateType.fromFields(stateAsFields);
      if (Provable.inCheckedComputation())
        this._contract.stateType.check?.(state3);
      this._contract.wasRead = true;
      this._contract.cachedVariable = state3;
      return state3;
    },
    getAndRequireEquals() {
      let state3 = this.get();
      this.requireEquals(state3);
      return state3;
    },
    async fetch() {
      if (this._contract === void 0)
        throw Error("fetch can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let address = this._contract.instance.address;
      let account;
      if (networkConfig.minaEndpoint === "") {
        account = getAccount(address, TokenId4.default);
      } else {
        ({ account } = await fetchAccount({
          publicKey: address,
          tokenId: TokenId4.toBase58(TokenId4.default)
        }));
      }
      if (account === void 0)
        return void 0;
      let stateAsFields;
      if (account.zkapp?.appState === void 0) {
        stateAsFields = Array(layout.length).fill(Field4(0));
      } else {
        stateAsFields = [];
        for (let i = 0; i < layout.length; i++) {
          stateAsFields.push(account.zkapp.appState[layout.offset + i]);
        }
      }
      return this._contract.stateType.fromFields(stateAsFields);
    },
    fromAppState(appState) {
      if (this._contract === void 0)
        throw Error("fromAppState() can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = [];
      for (let i = 0; i < layout.length; ++i) {
        stateAsFields.push(appState[layout.offset + i]);
      }
      return this._contract.stateType.fromFields(stateAsFields);
    }
  };
}
function getLayoutPosition({ key, class: contractClass }) {
  let layout = getLayout(contractClass);
  let stateLayout = layout.get(key);
  if (stateLayout === void 0) {
    throw new Error(`state ${key} not found`);
  }
  return stateLayout;
}
function getLayout(scClass) {
  let sc = smartContracts.get(scClass);
  if (sc === void 0)
    return /* @__PURE__ */ new Map();
  if (sc.layout === void 0) {
    let layout = /* @__PURE__ */ new Map();
    sc.layout = layout;
    let offset = 0;
    sc.states.forEach(([key, stateType]) => {
      let length = stateType.sizeInFields();
      layout.set(key, { offset, length });
      offset += length;
    });
    if (offset > 8) {
      throw Error(`Found ${offset} on-chain state field elements on ${scClass.name}. Currently, only a total of 8 field elements of state are supported.`);
    }
  }
  return sc.layout;
}
var smartContracts = /* @__PURE__ */ new WeakMap();
var reservedPropNames = /* @__PURE__ */ new Set(["_methods", "_"]);
function assertStatePrecondition(sc) {
  try {
    for (let [key, context] of getStateContexts(sc)) {
      if (!context?.wasRead || context.wasConstrained)
        continue;
      let errorMessage = `You used \`this.${key}.get()\` without adding a precondition that links it to the actual on-chain state.
Consider adding this line to your code:
this.${key}.requireEquals(this.${key}.get());`;
      throw Error(errorMessage);
    }
  } finally {
    cleanStatePrecondition(sc);
  }
}
function cleanStatePrecondition(sc) {
  for (let [, context] of getStateContexts(sc)) {
    if (context === void 0)
      continue;
    context.wasRead = false;
    context.wasConstrained = false;
    context.cachedVariable = void 0;
  }
}
function getStateContexts(sc) {
  let scClass = sc.constructor;
  let scInfo = smartContracts.get(scClass);
  if (scInfo === void 0)
    return [];
  return scInfo.states.map(([key]) => [key, sc[key]?._contract]);
}

// dist/node/lib/mina/actions/reducer.js
var Reducer = Object.defineProperty(function(reducer) {
  return reducer;
}, "initialActionState", { get: Actions3.emptyActionState });
function getReducer(contract2) {
  let reducer = (contract2._ ??= {}).reducer;
  if (reducer === void 0)
    throw Error(`You are trying to use a reducer without having declared its type.
Make sure to add a property \`reducer\` on ${contract2.constructor.name}, for example:
class ${contract2.constructor.name} extends SmartContract {
  reducer = Reducer({ actionType: Field });
}`);
  return {
    dispatch(action) {
      let accountUpdate = contract2.self;
      let eventFields = reducer.actionType.toFields(action);
      accountUpdate.body.actions = Actions3.pushEvent(accountUpdate.body.actions, eventFields);
    },
    reduce(actionLists, stateType, reduce, state3, { maxUpdatesWithActions = 32, maxActionsPerUpdate = 1, skipActionStatePrecondition = false } = {}) {
      Provable.asProver(() => {
        if (actionLists.data.get().length > maxUpdatesWithActions) {
          throw Error(`reducer.reduce: Exceeded the maximum number of lists of actions, ${maxUpdatesWithActions}.
  Use the optional \`maxUpdatesWithActions\` argument to increase this number.`);
        }
      });
      if (!skipActionStatePrecondition) {
        contract2.account.actionState.requireEquals(actionLists.hash);
      }
      const listIter = actionLists.startIterating();
      for (let i = 0; i < maxUpdatesWithActions; i++) {
        let { element: merkleActions, isDummy } = listIter.Unsafe.next();
        let actionIter = merkleActions.startIterating();
        let newState = state3;
        if (maxActionsPerUpdate === 1) {
          let action = Provable.witness(reducer.actionType, () => actionIter.data.get()[0]?.element ?? actionIter.innerProvable.empty());
          let emptyHash2 = actionIter.Constructor.emptyHash;
          let finalHash = actionIter.nextHash(emptyHash2, action);
          finalHash = Provable.if(isDummy, emptyHash2, finalHash);
          actionIter.hash.assertEquals(finalHash);
          newState = reduce(newState, action);
        } else {
          for (let j = 0; j < maxActionsPerUpdate; j++) {
            let { element: action, isDummy: isDummy2 } = actionIter.Unsafe.next();
            newState = Provable.if(isDummy2, stateType, newState, reduce(newState, action));
          }
          actionIter.assertAtEnd();
        }
        state3 = Provable.if(isDummy, stateType, state3, newState);
      }
      listIter.assertAtEnd();
      return state3;
    },
    forEach(actionLists, callback, config) {
      const stateType = provable(null);
      this.reduce(actionLists, stateType, (_, action) => {
        callback(action);
        return null;
      }, null, config);
    },
    getActions(config) {
      const Action = reducer.actionType;
      const emptyHash2 = Actions3.empty().hash;
      const nextHash = (hash3, action) => Actions3.pushEvent({ hash: hash3, data: [] }, Action.toFields(action)).hash;
      class ActionList2 extends MerkleList.create(Action, nextHash, emptyHash2) {
      }
      class MerkleActions2 extends MerkleList.create(
        ActionList2,
        (hash3, actions2) => Actions3.updateSequenceState(hash3, actions2.hash),
        // if no "start" action hash was specified, this means we are fetching the entire history of actions, which started from the empty action state hash
        // otherwise we are only fetching a part of the history, which starts at `fromActionState`
        // TODO does this show that `emptyHash` should be part of the instance, not the class? that would make the provable representation bigger though
        config?.fromActionState ?? Actions3.emptyActionState()
      ) {
      }
      let actions = Provable.witness(MerkleActions2, () => {
        let actionFields = getActions(contract2.address, config, contract2.tokenId);
        let actions2 = actionFields.map((event) => event.actions.map((action) => reducer.actionType.fromFields(action.map(Field4))));
        return MerkleActions2.from(actions2.map((a2) => ActionList2.fromReverse(a2)));
      });
      if (config?.endActionState !== void 0) {
        actions.hash.assertEquals(config.endActionState);
      }
      return actions;
    },
    async fetchActions(config) {
      let result = await fetchActions(contract2.address, config, contract2.tokenId);
      if ("error" in result) {
        throw Error(JSON.stringify(result));
      }
      return result.map((event) => (
        // putting our string-Fields back into the original action type
        event.actions.map((action) => reducer.actionType.fromFields(action.map(Field4)))
      ));
    }
  };
}

// dist/node/lib/mina/zkapp.js
var _SmartContract_executionState;
var _SmartContract__senderState;
var reservedPropNames2 = /* @__PURE__ */ new Set(["_methods", "_"]);
function method(target, methodName, descriptor, returnType) {
  const ZkappClass = target.constructor;
  if (reservedPropNames2.has(methodName)) {
    throw Error(`Property name ${methodName} is reserved.`);
  }
  if (typeof target[methodName] !== "function") {
    throw Error(`@method decorator was applied to \`${methodName}\`, which is not a function.`);
  }
  let paramTypes = Reflect.getMetadata("design:paramtypes", target, methodName);
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = ZkappPublicInput;
  SelfProof2.publicOutputType = Empty;
  SelfProof2.tag = () => ZkappClass;
  let internalMethodEntry = sortMethodArguments(ZkappClass.name, methodName, paramTypes, SelfProof2);
  let methodEntry = sortMethodArguments(ZkappClass.name, methodName, [PublicKey2, Field4, ...paramTypes], SelfProof2);
  if (returnType !== void 0) {
    internalMethodEntry.returnType = returnType;
    methodEntry.returnType = returnType;
  }
  ZkappClass._methods ??= [];
  ZkappClass._methods.push(methodEntry);
  ZkappClass._maxProofsVerified ??= 0;
  ZkappClass._maxProofsVerified = Math.max(ZkappClass._maxProofsVerified, methodEntry.proofArgs.length);
  let func = descriptor.value;
  descriptor.value = wrapMethod(func, ZkappClass, internalMethodEntry);
}
method.returns = function(returnType) {
  return function decorateMethod(target, methodName, descriptor) {
    return method(target, methodName, descriptor, ProvableType.get(returnType));
  };
};
function wrapMethod(method2, ZkappClass, methodIntf) {
  let methodName = methodIntf.methodName;
  let noPromiseError = `Expected \`${ZkappClass.name}.${methodName}()\` to return a promise.`;
  return async function wrappedMethod(...actualArgs) {
    cleanStatePrecondition(this);
    actualArgs.forEach((arg) => {
      if (arg instanceof AccountUpdate3) {
        AccountUpdate3.unlink(arg);
      }
    });
    let insideContract = smartContractContext.get();
    if (!insideContract) {
      const { id: id3, context } = SmartContractContext.enter(this, selfAccountUpdate(this, methodName));
      try {
        if (inCompile() || inProver() || inAnalyze()) {
          let proverData = inProver() ? zkAppProver.getData() : void 0;
          let txId = currentTransaction.enter({
            sender: proverData?.transaction.feePayer.body.publicKey,
            // TODO could pass an update with the fee payer's content here? probably not bc it's not accessed
            layout: new AccountUpdateLayout(),
            fetchMode: inProver() ? "cached" : "test",
            isFinalRunOutsideCircuit: false,
            numberOfRuns: void 0
          });
          try {
            let publicInput = actualArgs.shift();
            let accountUpdate = this.self;
            let blindingValue = Provable.witness(Field4, getBlindingValue);
            let memoCtx = memoizationContext() ?? {
              memoized: [],
              currentIndex: 0
            };
            let id4 = memoizationContext.enter({ ...memoCtx, blindingValue });
            let result;
            try {
              let clonedArgs = actualArgs.map(cloneCircuitValue);
              result = await assertPromise(method2.apply(this, clonedArgs), noPromiseError);
            } finally {
              memoizationContext.leave(id4);
            }
            let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);
            accountUpdate.body.callData = Poseidon2.hash(callDataFields);
            ProofAuthorization.setKind(accountUpdate);
            debugPublicInput(accountUpdate);
            let calls = context.selfLayout.finalizeChildren();
            checkPublicInput(publicInput, accountUpdate, calls);
            assertPreconditionInvariants(accountUpdate);
            cleanPreconditionsCache(accountUpdate);
            assertStatePrecondition(this);
            return result;
          } finally {
            currentTransaction.leave(txId);
          }
        } else if (!currentTransaction.has()) {
          let result = await assertPromise(method2.apply(this, actualArgs), noPromiseError);
          assertPreconditionInvariants(this.self);
          cleanPreconditionsCache(this.self);
          assertStatePrecondition(this);
          return result;
        } else {
          let accountUpdate = context.selfUpdate;
          let clonedArgs = cloneCircuitValue(actualArgs);
          let blindingValue = getBlindingValue();
          let memoContext = { memoized: [], currentIndex: 0, blindingValue };
          let memoId = memoizationContext.enter(memoContext);
          let result;
          try {
            result = await assertPromise(method2.apply(this, actualArgs.map((a2, i) => {
              let arg = methodIntf.allArgs[i];
              if (arg.type === "witness") {
                let type = methodIntf.witnessArgs[arg.index];
                return Provable.witness(type, () => a2);
              }
              return a2;
            })), noPromiseError);
          } finally {
            memoizationContext.leave(memoId);
          }
          let { memoized } = memoContext;
          assertStatePrecondition(this);
          let callDataFields = computeCallData(methodIntf, clonedArgs, result, blindingValue);
          accountUpdate.body.callData = Poseidon2.hash(callDataFields);
          if (!Authorization.hasAny(accountUpdate)) {
            ProofAuthorization.setLazyProof(accountUpdate, {
              methodName: methodIntf.methodName,
              args: clonedArgs,
              // proofs actually don't have to be cloned
              previousProofs: getPreviousProofsForProver(actualArgs, methodIntf),
              ZkappClass,
              memoized,
              blindingValue
            }, currentTransaction.get().layout);
          }
          if (inCheckedComputation()) {
            Provable.asProver(() => {
              accountUpdate = Provable.toConstant(AccountUpdate3, accountUpdate);
              context.selfLayout.toConstantInPlace();
            });
          }
          let txLayout = currentTransaction.get().layout;
          txLayout.pushTopLevel(accountUpdate);
          txLayout.setChildren(accountUpdate, context.selfLayout.finalizeChildren());
          return result;
        }
      } finally {
        smartContractContext.leave(id3);
      }
    }
    let parentAccountUpdate = insideContract.this.self;
    let { id: id2, context: innerContext } = SmartContractContext.enter(this, selfAccountUpdate(this, methodName));
    try {
      let blindingValue = getBlindingValue();
      let runCalledContract = async () => {
        let constantArgs = methodArgumentsToConstant(methodIntf, actualArgs);
        let constantBlindingValue = blindingValue.toConstant();
        let accountUpdate2 = this.self;
        accountUpdate2.body.callDepth = parentAccountUpdate.body.callDepth + 1;
        let memoContext = {
          memoized: [],
          currentIndex: 0,
          blindingValue: constantBlindingValue
        };
        let memoId = memoizationContext.enter(memoContext);
        let result2;
        try {
          result2 = await assertPromise(method2.apply(this, constantArgs.map(cloneCircuitValue)), noPromiseError);
        } finally {
          memoizationContext.leave(memoId);
        }
        let { memoized } = memoContext;
        assertStatePrecondition(this);
        if (result2 !== void 0) {
          let { returnType } = methodIntf;
          assert3(returnType !== void 0, "Bug: returnType is undefined but the method result isn't.");
          result2 = Provable.toConstant(returnType, result2);
        }
        let callDataFields2 = computeCallData(methodIntf, constantArgs, result2, constantBlindingValue);
        accountUpdate2.body.callData = hashConstant(callDataFields2);
        if (!Authorization.hasAny(accountUpdate2)) {
          ProofAuthorization.setLazyProof(accountUpdate2, {
            methodName: methodIntf.methodName,
            args: constantArgs,
            previousProofs: getPreviousProofsForProver(constantArgs, methodIntf),
            ZkappClass,
            memoized,
            blindingValue: constantBlindingValue
          }, currentTransaction()?.layout ?? new AccountUpdateLayout());
        }
        let children2 = innerContext.selfLayout.finalizeChildren();
        return {
          accountUpdate: accountUpdate2,
          result: { result: result2 ?? null, children: children2 }
        };
      };
      let { accountUpdate, result: { result, children } } = await AccountUpdate3.witness(provable({
        result: methodIntf.returnType ?? provable(null),
        children: AccountUpdateForest
      }), runCalledContract, { skipCheck: true });
      innerContext.selfUpdate = accountUpdate;
      accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;
      insideContract.selfLayout.pushTopLevel(accountUpdate);
      insideContract.selfLayout.setChildren(accountUpdate, children);
      accountUpdate.body.publicKey.assertEquals(this.address);
      accountUpdate.body.tokenId.assertEquals(this.self.body.tokenId);
      assert3(accountUpdate.body.authorizationKind.isProved, "callee is proved");
      let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);
      let callData = Poseidon2.hash(callDataFields);
      accountUpdate.body.callData.assertEquals(callData);
      return result;
    } finally {
      smartContractContext.leave(id2);
    }
  };
}
function checkPublicInput({ accountUpdate, calls }, self, selfCalls) {
  accountUpdate.assertEquals(self.hash());
  calls.assertEquals(selfCalls.hash);
}
function computeCallData(methodIntf, argumentValues, returnValue, blindingValue) {
  let { returnType, methodName } = methodIntf;
  let args = methodArgumentTypesAndValues(methodIntf, argumentValues);
  let input = { fields: [], packed: [] };
  for (let { type, value } of args) {
    if (isHashable(type)) {
      input = HashInput.append(input, type.toInput(value));
    } else {
      input.fields.push(...[Field4(type.sizeInFields()), ...type.toFields(value)]);
    }
  }
  const totalArgFields = packToFields(input);
  let totalArgSize = Field4(args.map(({ type }) => type.sizeInFields()).reduce((s, t) => s + t, 0));
  let returnSize = Field4(returnType?.sizeInFields() ?? 0);
  input = { fields: [], packed: [] };
  if (isHashable(returnType)) {
    input = HashInput.append(input, returnType.toInput(returnValue));
  } else {
    input.fields.push(...returnType?.toFields(returnValue) ?? []);
  }
  let returnFields = packToFields(input);
  let methodNameFields = stringToFields(methodName);
  return [
    // we have to encode the sizes of arguments / return value, so that fields can't accidentally shift
    // from one argument to another, or from arguments to the return value, or from the return value to the method name
    totalArgSize,
    ...totalArgFields,
    returnSize,
    ...returnFields,
    // we don't have to encode the method name size because the blinding value is fixed to one field element,
    // so method name fields can't accidentally become the blinding value and vice versa
    ...methodNameFields,
    blindingValue
  ];
}
var SmartContract = class extends SmartContractBase {
  /**
   * Returns a Proof type that belongs to this {@link SmartContract}.
   */
  static Proof() {
    var _a2;
    let Contract = this;
    return _a2 = class extends Proof {
    }, _a2.publicInputType = ZkappPublicInput, _a2.publicOutputType = Empty, _a2.tag = () => Contract, _a2;
  }
  constructor(address, tokenId) {
    super();
    _SmartContract_executionState.set(this, void 0);
    _SmartContract__senderState.set(this, void 0);
    this.sender = {
      self: this,
      /**
       * The public key of the current transaction's sender account.
       *
       * Throws an error if not inside a transaction, or the sender wasn't passed in.
       *
       * **Warning**: The fact that this public key equals the current sender is not part of the proof.
       * A malicious prover could use any other public key without affecting the validity of the proof.
       */
      getUnconstrained() {
        if (!currentTransaction.has()) {
          throw Error(`this.sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
        }
        let transactionId = currentTransaction.id();
        if ((0, import_tslib5.__classPrivateFieldGet)(this.self, _SmartContract__senderState, "f")?.transactionId === transactionId) {
          return (0, import_tslib5.__classPrivateFieldGet)(this.self, _SmartContract__senderState, "f").sender;
        } else {
          let sender2 = Provable.witness(PublicKey2, () => sender());
          (0, import_tslib5.__classPrivateFieldSet)(this.self, _SmartContract__senderState, { transactionId, sender: sender2 }, "f");
          return sender2;
        }
      },
      getAndRequireSignature() {
        let sender2 = this.getUnconstrained();
        AccountUpdate3.createSigned(sender2);
        return sender2;
      }
    };
    this.events = {};
    this.address = address;
    this.tokenId = tokenId ?? TokenId4.default;
    Object.defineProperty(this, "reducer", {
      set(reducer) {
        (this._ ??= {}).reducer = reducer;
      },
      get() {
        return getReducer(this);
      }
    });
  }
  /**
   * Compile your smart contract.
   *
   * This generates both the prover functions, needed to create proofs for running `@method`s,
   * and the verification key, needed to deploy your zkApp.
   *
   * Although provers and verification key are returned by this method, they are also cached internally and used when needed,
   * so you don't actually have to use the return value of this function.
   *
   * Under the hood, "compiling" means calling into the lower-level [Pickles and Kimchi libraries](https://o1-labs.github.io/proof-systems/kimchi/overview.html) to
   * create multiple prover & verifier indices (one for each smart contract method as part of a "step circuit" and one for the "wrap circuit" which recursively wraps
   * it so that proofs end up in the original finite field). These are fairly expensive operations, so **expect compiling to take at least 20 seconds**,
   * up to several minutes if your circuit is large or your hardware is not optimal for these operations.
   */
  static async compile({ cache: cache2 = Cache.FileSystemDefault, forceRecompile = false } = {}) {
    let methodIntfs = this._methods ?? [];
    let methods = methodIntfs.map(({ methodName }) => {
      return async (publicInput, publicKey, tokenId, ...args) => {
        let instance = new this(publicKey, tokenId);
        await instance[methodName](publicInput, ...args);
      };
    });
    let methodsMeta = await this.analyzeMethods();
    let gates = methodIntfs.map((intf) => methodsMeta[intf.methodName].gates);
    let { verificationKey, provers, verify: verify3 } = await compileProgram({
      publicInputType: ZkappPublicInput,
      publicOutputType: Empty,
      methodIntfs,
      methods,
      gates,
      proofSystemTag: this,
      cache: cache2,
      forceRecompile
    });
    this._provers = provers;
    this._verificationKey = verificationKey;
    return { verificationKey, provers, verify: verify3 };
  }
  /**
   * Computes a hash of your smart contract, which will reliably change _whenever one of your method circuits changes_.
   * This digest is quick to compute. it is designed to help with deciding whether a contract should be re-compiled or
   * a cached verification key can be used.
   * @returns the digest, as a hex string
   */
  static async digest() {
    let methodData = await this.analyzeMethods();
    let hash3 = hashConstant(Object.values(methodData).map((d) => Field4(BigInt("0x" + d.digest))));
    return hash3.toBigInt().toString(16);
  }
  /**
   * Deploys a {@link SmartContract}.
   *
   * ```ts
   * let tx = await Mina.transaction(sender, async () => {
   *   AccountUpdate.fundNewAccount(sender);
   *   await zkapp.deploy();
   * });
   * tx.sign([senderKey, zkAppKey]);
   * ```
   */
  async deploy({ verificationKey } = {}) {
    let accountUpdate = this.newSelf("deploy");
    verificationKey ??= this.constructor._verificationKey;
    if (verificationKey === void 0) {
      if (!getProofsEnabled()) {
        await initializeBindings();
        let [, data2, hash4] = Pickles.dummyVerificationKey();
        verificationKey = { data: data2, hash: Field4(hash4) };
      } else {
        throw Error(`\`${this.constructor.name}.deploy()\` was called but no verification key was found.
Try calling \`await ${this.constructor.name}.compile()\` first, this will cache the verification key in the background.`);
      }
    }
    let { hash: hash_, data } = verificationKey;
    let hash3 = Field4.from(hash_);
    accountUpdate.account.verificationKey.set({ hash: hash3, data });
    accountUpdate.account.permissions.set(Permissions.default());
    accountUpdate.requireSignature();
    AccountUpdate3.attachToTransaction(accountUpdate);
    let shouldInit = !hasAccount(this.address) || getAccount(this.address).zkapp?.verificationKey === void 0;
    if (!shouldInit)
      return;
    else
      await this.init();
    let initUpdate = this.self;
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, {
      transactionId: (0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract_executionState, "f").transactionId,
      accountUpdate
    }, "f");
    let isFirstRun = currentTransaction()?.numberOfRuns === 0;
    if (!isFirstRun)
      return;
    Provable.asProver(() => {
      if (initUpdate.update.appState.some(({ isSome }) => !isSome.toBoolean())) {
        console.warn(`WARNING: the \`init()\` method was called without overwriting the entire state. This means that your zkApp will lack
the \`provedState === true\` status which certifies that the current state was verifiably produced by proofs (and not arbitrarily set by the zkApp developer).
To make sure the entire state is reset, consider adding this line to the beginning of your \`init()\` method:
super.init();
`);
      }
    });
  }
  // TODO make this a @method and create a proof during `zk deploy` (+ add mechanism to skip this)
  /**
   * `SmartContract.init()` will be called only when a {@link SmartContract} will be first deployed, not for redeployment.
   * This method can be overridden as follows
   * ```
   * class MyContract extends SmartContract {
   *  init() {
   *    super.init();
   *    this.account.permissions.set(...);
   *    this.x.set(Field(1));
   *  }
   * }
   * ```
   */
  init() {
    this.account.provedState.requireEquals(Bool4(false));
    let accountUpdate = this.self;
    for (let i = 0; i < ZkappStateLength; i++) {
      AccountUpdate3.setValue(accountUpdate.body.update.appState[i], Field4(0));
    }
    let stateKeys = getLayout(this.constructor).keys();
    for (let key of stateKeys) {
      let state3 = this[key];
      if (state3 !== void 0 && state3.defaultValue !== void 0) {
        state3.set(state3.defaultValue);
      }
    }
    AccountUpdate3.attachToTransaction(accountUpdate);
  }
  /**
   * Use this command if the account update created by this SmartContract should be signed by the account owner,
   * instead of authorized with a proof.
   *
   * Note that the smart contract's {@link Permissions} determine which updates have to be (can be) authorized by a signature.
   *
   * If you only want to avoid creating proofs for quicker testing, we advise you to
   * use `LocalBlockchain({ proofsEnabled: false })` instead of `requireSignature()`. Setting
   * `proofsEnabled` to `false` allows you to test your transactions with the same authorization flow as in production,
   * with the only difference being that quick mock proofs are filled in instead of real proofs.
   */
  requireSignature() {
    this.self.requireSignature();
  }
  /**
   * Use this command if the account update created by this SmartContract should have no authorization on it,
   * instead of being authorized with a proof.
   *
   * WARNING: This is a method that should rarely be useful. If you want to disable proofs for quicker testing, take a look
   * at `LocalBlockchain({ proofsEnabled: false })`, which causes mock proofs to be created and doesn't require changing the
   * authorization flow.
   */
  skipAuthorization() {
    Authorization.setLazyNone(this.self);
  }
  /**
   * Returns the current {@link AccountUpdate} associated to this {@link SmartContract}.
   */
  get self() {
    let inTransaction = currentTransaction.has();
    let inSmartContract = smartContractContext.get();
    if (!inTransaction && !inSmartContract) {
      return selfAccountUpdate(this);
    }
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    if (inSmartContract && inSmartContract.this === this) {
      let accountUpdate2 = inSmartContract.selfUpdate;
      (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { accountUpdate: accountUpdate2, transactionId }, "f");
      return accountUpdate2;
    }
    let executionState = (0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract_executionState, "f");
    if (executionState !== void 0 && executionState.transactionId === transactionId) {
      return executionState.accountUpdate;
    }
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  /**
   * Same as `SmartContract.self` but explicitly creates a new {@link AccountUpdate}.
   */
  newSelf(methodName) {
    let inTransaction = currentTransaction.has();
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    let accountUpdate = selfAccountUpdate(this, methodName);
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  /**
   * Current account of the {@link SmartContract}.
   */
  get account() {
    return this.self.account;
  }
  /**
   * Current network state of the {@link SmartContract}.
   */
  get network() {
    return this.self.network;
  }
  /**
   * Current global slot on the network. This is the slot at which this transaction is included in a block. Since we cannot know this value
   * at the time of transaction construction, this only has the `assertBetween()` method but no `get()` (impossible to implement)
   * or `assertEquals()` (confusing, because the developer can't know the exact slot at which this will be included either)
   */
  get currentSlot() {
    return this.self.currentSlot;
  }
  /**
   * Approve an account update or tree / forest of updates. Doing this means you include the account update in the zkApp's public input,
   * which allows you to read and use its content in a proof, make assertions about it, and modify it.
   *
   * ```ts
   * `@method` myApprovingMethod(update: AccountUpdate) {
   *   this.approve(update);
   *
   *   // read balance on the account (for example)
   *   let balance = update.account.balance.getAndRequireEquals();
   * }
   * ```
   *
   * Under the hood, "approving" just means that the account update is made a child of the zkApp in the
   * tree of account updates that forms the transaction. Similarly, if you pass in an {@link AccountUpdateTree},
   * the entire tree will become a subtree of the zkApp's account update.
   *
   * Passing in a forest is a bit different, because it means you set the entire children of the zkApp's account update
   * at once. `approve()` will fail if the zkApp's account update already has children, to prevent you from accidentally
   * excluding important information from the public input.
   */
  approve(update) {
    this.self.approve(update);
  }
  send(args) {
    return this.self.send(args);
  }
  /**
   * Balance of this {@link SmartContract}.
   */
  get balance() {
    return this.self.balance;
  }
  // TODO: not able to type event such that it is inferred correctly so far
  /**
   * Conditionally emits an event.
   *
   * Events will be emitted as a part of the transaction and can be collected by archive nodes.
   */
  emitEventIf(condition, type, event) {
    let accountUpdate = this.self;
    let eventTypes = Object.keys(this.events);
    if (eventTypes.length === 0)
      throw Error(`emitEvent: You are trying to emit an event without having declared the types of your events.
Make sure to add a property \`events\` on ${this.constructor.name}, for example: 
class ${this.constructor.name} extends SmartContract {
  events = { 'my-event': Field }
}`);
    let eventNumber = eventTypes.sort().indexOf(type);
    if (eventNumber === -1)
      throw Error(`emitEvent: Unknown event type "${type}". The declared event types are: ${eventTypes.join(", ")}.`);
    let eventType = this.events[type];
    let eventFields;
    if (eventTypes.length === 1) {
      eventFields = eventType.toFields(event);
    } else {
      eventFields = [Field4(eventNumber), ...eventType.toFields(event)];
    }
    let newEvents = Events3.pushEvent(accountUpdate.body.events, eventFields);
    accountUpdate.body.events = Provable.if(condition, Events3, newEvents, accountUpdate.body.events);
  }
  /**
   * Emits an event. Events will be emitted as a part of the transaction and can be collected by archive nodes.
   */
  emitEvent(type, event) {
    this.emitEventIf(Bool4(true), type, event);
  }
  /**
   * Asynchronously fetches events emitted by this {@link SmartContract} and returns an array of events with their corresponding types.
   * @async
   * @param [start=UInt32.from(0)] - The start height of the events to fetch.
   * @param end - The end height of the events to fetch. If not provided, fetches events up to the latest height.
   * @returns A promise that resolves to an array of objects, each containing the event type and event data for the specified range.
   * @throws If there is an error fetching events from the Mina network.
   * @example
   * const startHeight = UInt32.from(1000);
   * const endHeight = UInt32.from(2000);
   * const events = await myZkapp.fetchEvents(startHeight, endHeight);
   * console.log(events);
   */
  async fetchEvents(start = UInt322.from(0), end) {
    let events = (await fetchEvents(this.address, this.self.body.tokenId, {
      from: start,
      to: end
    })).filter((eventData) => {
      let height = UInt322.from(eventData.blockHeight);
      return end === void 0 ? start.lessThanOrEqual(height).toBoolean() : start.lessThanOrEqual(height).toBoolean() && height.lessThanOrEqual(end).toBoolean();
    }).map((event) => {
      return event.events.map((eventData) => {
        let { events: events2, ...rest } = event;
        return {
          ...rest,
          event: eventData
        };
      });
    }).flat();
    let sortedEventTypes = Object.keys(this.events).sort();
    return events.map((eventData) => {
      if (sortedEventTypes.length === 1) {
        let type = sortedEventTypes[0];
        let event = this.events[type].fromFields(eventData.event.data.map((f) => Field4(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      } else {
        let eventObjectIndex = Number(eventData.event.data[0]);
        let type = sortedEventTypes[eventObjectIndex];
        let eventProps = eventData.event.data.slice(1);
        let event = this.events[type].fromFields(eventProps.map((f) => Field4(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      }
    });
  }
  static runOutsideCircuit(run) {
    if (currentTransaction()?.isFinalRunOutsideCircuit || inProver())
      Provable.asProver(run);
  }
  // TODO: this could also be used to quickly perform any invariant checks on account updates construction
  /**
   * This function is run internally before compiling a smart contract, to collect metadata about what each of your
   * smart contract methods does.
   *
   * For external usage, this function can be handy because calling it involves running all methods in the same "mode" as `compile()` does,
   * so it serves as a quick-to-run check for whether your contract can be compiled without errors, which can greatly speed up iterating.
   *
   * `analyzeMethods()` will also return the number of `rows` of each of your method circuits (i.e., the number of constraints in the underlying proof system),
   * which is a good indicator for circuit size and the time it will take to create proofs.
   * To inspect the created circuit in detail, you can look at the returned `gates`.
   *
   * Note: If this function was already called before, it will short-circuit and just return the metadata collected the first time.
   *
   * @returns an object, keyed by method name, each entry containing:
   *  - `rows` the size of the constraint system created by this method
   *  - `digest` a digest of the method circuit
   *  - `actions` the number of actions the method dispatches
   *  - `gates` the constraint system, represented as an array of gates
   */
  static async analyzeMethods({ printSummary = false } = {}) {
    let ZkappClass = this;
    let methodMetadata = ZkappClass._methodMetadata ??= {};
    let methodIntfs = ZkappClass._methods ?? [];
    if (!methodIntfs.every((m) => m.methodName in methodMetadata) && !inAnalyze()) {
      let id2;
      let insideSmartContract = !!smartContractContext.get();
      if (insideSmartContract)
        id2 = smartContractContext.enter(null);
      try {
        for (let methodIntf of methodIntfs) {
          let accountUpdate;
          let { rows, digest, gates, summary } = await analyzeMethod(ZkappPublicInput, methodIntf, async (publicInput, publicKey, tokenId, ...args) => {
            let instance = new ZkappClass(publicKey, tokenId);
            let result = await instance[methodIntf.methodName](publicInput, ...args);
            accountUpdate = (0, import_tslib5.__classPrivateFieldGet)(instance, _SmartContract_executionState, "f").accountUpdate;
            return result;
          });
          methodMetadata[methodIntf.methodName] = {
            actions: accountUpdate.body.actions.data.length,
            rows,
            digest,
            gates
          };
          if (printSummary)
            console.log(methodIntf.methodName, summary());
        }
      } finally {
        if (insideSmartContract)
          smartContractContext.leave(id2);
      }
    }
    return methodMetadata;
  }
};
_SmartContract_executionState = /* @__PURE__ */ new WeakMap(), _SmartContract__senderState = /* @__PURE__ */ new WeakMap();
function selfAccountUpdate(zkapp, methodName) {
  let body = Body.keepAll(zkapp.address, zkapp.tokenId);
  let update = new AccountUpdate3(body, {}, true);
  update.label = methodName ? `${zkapp.constructor.name}.${methodName}()` : `${zkapp.constructor.name}, no method`;
  return update;
}
var SmartContractContext = {
  enter(self, selfUpdate) {
    let context = {
      this: self,
      selfUpdate,
      selfLayout: new AccountUpdateLayout(selfUpdate)
    };
    let id2 = smartContractContext.enter(context);
    return { id: id2, context };
  }
};
function declareMethods(SmartContract2, methodArguments) {
  for (let key in methodArguments) {
    let argumentTypes = methodArguments[key];
    let target = SmartContract2.prototype;
    Reflect.metadata("design:paramtypes", argumentTypes)(target, key);
    let descriptor = Object.getOwnPropertyDescriptor(target, key);
    method(SmartContract2.prototype, key, descriptor);
    Object.defineProperty(target, key, descriptor);
  }
}
var ProofAuthorization = {
  setKind({ body, id: id2 }, priorAccountUpdates) {
    body.authorizationKind.isSigned = Bool4(false);
    body.authorizationKind.isProved = Bool4(true);
    let hash3 = Provable.witness(Field4, () => {
      let proverData = zkAppProver.getData();
      let isProver = proverData !== void 0;
      assert3(isProver || priorAccountUpdates !== void 0, "Called `setKind()` outside the prover without passing in `priorAccountUpdates`.");
      let myAccountUpdateId = isProver ? proverData.accountUpdate.id : id2;
      let priorAccountUpdatesFlat = priorAccountUpdates?.toFlatList({
        mutate: false
      });
      priorAccountUpdatesFlat ??= proverData.transaction.accountUpdates;
      priorAccountUpdatesFlat = priorAccountUpdatesFlat.filter((a2) => a2.id !== myAccountUpdateId);
      let accountUpdate = [...priorAccountUpdatesFlat].reverse().find((body_) => body_.update.verificationKey.isSome.and(body_.tokenId.equals(body.tokenId)).and(body_.publicKey.equals(body.publicKey)).toBoolean());
      if (accountUpdate !== void 0) {
        return accountUpdate.body.update.verificationKey.value.hash;
      }
      try {
        let account = getAccount(body.publicKey, body.tokenId);
        return account.zkapp?.verificationKey?.hash ?? Field4(0);
      } catch {
        return Field4(0);
      }
    });
    body.authorizationKind.verificationKeyHash = hash3;
  },
  setLazyProof(accountUpdate, proof, priorAccountUpdates) {
    this.setKind(accountUpdate, priorAccountUpdates);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...proof, kind: "lazy-proof" };
  }
};
var DEBUG_PUBLIC_INPUT_CHECK = false;
function debugPublicInput(accountUpdate) {
  if (!DEBUG_PUBLIC_INPUT_CHECK)
    return;
  Provable.asProver(() => {
    diffRecursive(accountUpdate, zkAppProver.getData());
  });
}
function diffRecursive(prover, inputData) {
  let { transaction: transaction2, index, accountUpdate: input } = inputData;
  diff(transaction2, index, prover.toPretty(), input.toPretty());
  let proverChildren = accountUpdateLayout()?.get(prover)?.children.mutable;
  if (proverChildren === void 0)
    return;
  let inputChildren = [];
  let callDepth = input.body.callDepth;
  for (let i = index; i < transaction2.accountUpdates.length; i++) {
    let update = transaction2.accountUpdates[i];
    if (update.body.callDepth <= callDepth)
      break;
    if (update.body.callDepth === callDepth + 1)
      inputChildren.push(update);
  }
  let nChildren = inputChildren.length;
  for (let i = 0; i < nChildren; i++) {
    let inputChild = inputChildren[i];
    let child = proverChildren[i].mutable;
    if (!child)
      return;
    diffRecursive(child, { transaction: transaction2, index, accountUpdate: inputChild });
  }
}
function diff(transaction2, index, prover, input) {
  delete prover.id;
  delete prover.callDepth;
  delete input.id;
  delete input.callDepth;
  if (JSON.stringify(prover) !== JSON.stringify(input)) {
    console.log("transaction:", ZkappCommand3.toPretty(transaction2));
    console.log("index", index);
    console.log("inconsistent account updates:");
    console.log("update created by the prover:");
    console.log(prover);
    console.log("update created in transaction block:");
    console.log(input);
  }
}

// dist/node/lib/mina/token/forest-iterator.js
var AccountUpdateIterator = MerkleListIterator.create(AccountUpdateForest.prototype.innerProvable, AccountUpdateForest._nextHash, AccountUpdateForest.emptyHash);
var Layer = class extends Struct({
  forest: AccountUpdateIterator,
  mayUseToken: AccountUpdate3.MayUseToken.type
}) {
};
var ParentLayers = MerkleList.create(Layer);
var MayUseToken4 = AccountUpdate3.MayUseToken;
var TokenAccountUpdateIterator = class _TokenAccountUpdateIterator {
  constructor(forest, mayUseToken, selfToken) {
    this.currentLayer = { forest, mayUseToken };
    this.unfinishedParentLayers = ParentLayers.empty();
    this.selfToken = selfToken;
  }
  static create(forest, selfToken) {
    return new _TokenAccountUpdateIterator(AccountUpdateIterator.startIteratingFromLast(forest), MayUseToken4.ParentsOwnToken, selfToken);
  }
  /**
   * Make a single step along a tree of account updates.
   *
   * This function is guaranteed to visit each account update in the tree that uses the token
   * exactly once, when called repeatedly.
   *
   * The method makes a best effort to avoid visiting account updates that are not using the token,
   * and in particular, to avoid returning dummy updates.
   * However, neither can be ruled out. We're returning { update, usesThisToken: Bool } and let the
   * caller handle the irrelevant case where `usesThisToken` is false.
   */
  next() {
    let { accountUpdate, children } = this.currentLayer.forest.previous();
    let childForest = AccountUpdateIterator.startIteratingFromLast(children);
    let childLayer = {
      forest: childForest,
      mayUseToken: MayUseToken4.InheritFromParent
    };
    let update = accountUpdate.unhash();
    let usesThisToken = update.tokenId.equals(this.selfToken);
    let canAccessThisToken = Provable.equal(MayUseToken4.type, update.body.mayUseToken, this.currentLayer.mayUseToken);
    let isSelf = TokenId4.derive(update.publicKey, update.tokenId).equals(this.selfToken);
    let skipSubtree = canAccessThisToken.not().or(isSelf);
    childForest.jumpToStartIf(skipSubtree);
    let currentForest = this.currentLayer.forest;
    let currentLayerFinished = currentForest.isAtStart();
    let childLayerFinished = childForest.isAtStart();
    this.unfinishedParentLayers.pushIf(currentLayerFinished.not(), this.currentLayer);
    let currentOrParentLayer = this.unfinishedParentLayers.popIf(childLayerFinished);
    this.currentLayer = Provable.if(childLayerFinished, Layer, currentOrParentLayer, childLayer);
    return { accountUpdate: update, usesThisToken };
  }
  assertFinished(message) {
    assert3(this.currentLayer.forest.isAtStart(), message ?? "TokenAccountUpdateIterator not finished");
  }
};

// dist/node/lib/mina/token/token-methods.js
function tokenMethods(self) {
  return {
    /**
     * Mints token balance to `address`. Returns the mint account update.
     */
    mint({ address, amount }) {
      let id2 = TokenId4.derive(self.publicKey, self.tokenId);
      let receiver = getApprovedUpdate(self, id2, address, "token.mint()");
      receiver.balance.addInPlace(amount);
      return receiver;
    },
    /**
     * Burn token balance on `address`. Returns the burn account update.
     */
    burn({ address, amount }) {
      let id2 = TokenId4.derive(self.publicKey, self.tokenId);
      let sender2 = getApprovedUpdate(self, id2, address, "token.burn()");
      sender2.balance.subInPlace(amount);
      sender2.body.useFullCommitment = Bool4(true);
      Authorization.setLazySignature(sender2);
      return sender2;
    },
    /**
     * Move token balance from `from` to `to`. Returns the `to` account update.
     */
    send({ from, to, amount }) {
      let id2 = TokenId4.derive(self.publicKey, self.tokenId);
      let sender2 = getApprovedUpdate(self, id2, from, "token.send() (sender)");
      sender2.balance.subInPlace(amount);
      sender2.body.useFullCommitment = Bool4(true);
      Authorization.setLazySignature(sender2);
      let receiver = getApprovedUpdate(self, id2, to, "token.send() (receiver)");
      receiver.balance.addInPlace(amount);
      return receiver;
    }
  };
}
function getApprovedUpdate(self, tokenId, child, label) {
  if (isSmartContract(child)) {
    child = child.self;
  }
  if (child instanceof AccountUpdate3) {
    child.tokenId.assertEquals(tokenId);
    self.approve(child);
  }
  if (child instanceof PublicKey2) {
    child = AccountUpdate3.defaultAccountUpdate(child, tokenId);
    self.approve(child);
  }
  if (!child.label)
    child.label = `${self.label ?? "Unlabeled"}.${label}`;
  return child;
}

// dist/node/lib/mina/token/token-contract.js
var TokenContract = class extends SmartContract {
  /**
   * Deploys a {@link TokenContract}.
   *
   * In addition to base smart contract deployment, this adds two steps:
   * - set the `access` permission to `proofOrSignature()`, to prevent against unauthorized token operations
   *   - not doing this would imply that anyone can bypass token contract authorization and simply mint themselves tokens
   * - require the zkapp account to be new, using the `isNew` precondition.
   *   this guarantees that the access permission is set from the very start of the existence of this account.
   *   creating the zkapp account before deployment would otherwise be a security vulnerability that is too easy to introduce.
   *
   * Note that because of the `isNew` precondition, the zkapp account must not be created prior to calling `deploy()`.
   *
   * If the contract needs to be re-deployed, you can switch off this behaviour by overriding the `isNew` precondition:
   * ```ts
   * async deploy() {
   *   await super.deploy();
   *   // DON'T DO THIS ON THE INITIAL DEPLOYMENT!
   *   this.account.isNew.requireNothing();
   * }
   * ```
   */
  async deploy(args) {
    await super.deploy(args);
    this.account.permissions.set({
      ...Permissions.default(),
      access: Permissions.proofOrSignature()
    });
    this.account.isNew.requireEquals(Bool4(true));
  }
  /**
   * Returns the `tokenId` of the token managed by this contract.
   */
  deriveTokenId() {
    return TokenId4.derive(this.address, this.tokenId);
  }
  /**
   * Helper methods to use from within a token contract.
   */
  get internal() {
    return tokenMethods(this.self);
  }
  /**
   * Iterate through the account updates in `updates` and apply `callback` to each.
   *
   * This method is provable and is suitable as a base for implementing `approveUpdates()`.
   */
  forEachUpdate(updates, callback) {
    let iterator = TokenAccountUpdateIterator.create(updates, this.deriveTokenId());
    for (let i = 0; i < this.constructor.MAX_ACCOUNT_UPDATES; i++) {
      let { accountUpdate, usesThisToken } = iterator.next();
      callback(accountUpdate, usesThisToken);
    }
    iterator.assertFinished(`Number of account updates to approve exceed the supported limit of ${this.constructor.MAX_ACCOUNT_UPDATES}.
`);
    this.approve(updates);
  }
  /**
   * Use `forEachUpdate()` to prove that the total balance change of child account updates is zero.
   *
   * This is provided out of the box as it is both a good example, and probably the most common implementation, of `approveBase()`.
   */
  checkZeroBalanceChange(updates) {
    let totalBalanceChange = Int64.zero;
    this.forEachUpdate(updates, (accountUpdate, usesToken) => {
      totalBalanceChange = totalBalanceChange.add(Provable.if(usesToken, accountUpdate.balanceChange, Int64.zero));
    });
    totalBalanceChange.assertEquals(0);
  }
  /**
   * Approve a single account update (with arbitrarily many children).
   */
  async approveAccountUpdate(accountUpdate) {
    let forest = toForest([accountUpdate]);
    await this.approveBase(forest);
  }
  /**
   * Approve a list of account updates (with arbitrarily many children).
   */
  async approveAccountUpdates(accountUpdates) {
    let forest = toForest(accountUpdates);
    await this.approveBase(forest);
  }
  // TRANSFERABLE API - simple wrapper around Approvable API
  /**
   * Transfer `amount` of tokens from `from` to `to`.
   */
  async transfer(from, to, amount) {
    let tokenId = this.deriveTokenId();
    if (from instanceof PublicKey2) {
      from = AccountUpdate3.defaultAccountUpdate(from, tokenId);
      from.requireSignature();
      from.label = `${this.constructor.name}.transfer() (from)`;
    }
    if (to instanceof PublicKey2) {
      to = AccountUpdate3.defaultAccountUpdate(to, tokenId);
      to.label = `${this.constructor.name}.transfer() (to)`;
    }
    from.balanceChange = Int64.from(amount).neg();
    to.balanceChange = Int64.from(amount);
    let forest = toForest([from, to]);
    await this.approveBase(forest);
  }
};
TokenContract.MAX_ACCOUNT_UPDATES = 20;
var TokenContractV2 = class extends TokenContract {
};
TokenContractV2.MAX_ACCOUNT_UPDATES = 9;
function toForest(updates) {
  let trees = updates.map((a2) => a2 instanceof AccountUpdate3 ? a2.extractTree() : a2);
  return AccountUpdateForest.fromReverse(trees);
}

// dist/node/lib/provable/crypto/encryption.js
var encryption_exports = {};
__export(encryption_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
function encrypt(message, otherPublicKey) {
  let privateKey = Provable.witness(Scalar3, () => Scalar3.random());
  let publicKey = Group3.generator.scale(privateKey);
  let sharedSecret = otherPublicKey.toGroup().scale(privateKey);
  let sponge2 = new Poseidon2.Sponge();
  sponge2.absorb(sharedSecret.x);
  let cipherText = [];
  for (let i = 0; i < message.length; i++) {
    let keyStream = sponge2.squeeze();
    let encryptedChunk = message[i].add(keyStream);
    cipherText.push(encryptedChunk);
    if (i % 2 === 1)
      sponge2.absorb(cipherText[i - 1]);
    if (i % 2 === 1 || i === message.length - 1)
      sponge2.absorb(cipherText[i]);
  }
  let authenticationTag = sponge2.squeeze();
  cipherText.push(authenticationTag);
  return { publicKey, cipherText };
}
function decrypt({ publicKey, cipherText }, privateKey) {
  let sharedSecret = publicKey.scale(privateKey.s);
  let sponge2 = new Poseidon2.Sponge();
  sponge2.absorb(sharedSecret.x);
  let authenticationTag = cipherText.pop();
  let message = [];
  for (let i = 0; i < cipherText.length; i++) {
    let keyStream = sponge2.squeeze();
    let messageChunk = cipherText[i].sub(keyStream);
    message.push(messageChunk);
    if (i % 2 === 1)
      sponge2.absorb(cipherText[i - 1]);
    if (i % 2 === 1 || i === cipherText.length - 1)
      sponge2.absorb(cipherText[i]);
  }
  sponge2.squeeze().assertEquals(authenticationTag);
  return message;
}

// dist/node/lib/provable/string.js
var DEFAULT_STRING_LENGTH = 128;
var Character = class _Character extends Struct({ value: Field4 }) {
  constructor(value) {
    super({ value: Field4(value) });
  }
  isNull() {
    return this.value.equals(NullCharacter().value);
  }
  toField() {
    return this.value;
  }
  toString() {
    const charCode = Number(this.value.toString());
    return String.fromCharCode(charCode);
  }
  static fromString(str) {
    return new _Character(str.charCodeAt(0));
  }
  // TODO: Add support for more character sets
  // right now it's 16 bits because 8 not supported :/
  static check(c) {
    Gadgets.rangeCheckN(16, c.value);
  }
};
var RawCircuitString = {
  ...provable({ values: Provable.Array(Character, DEFAULT_STRING_LENGTH) }),
  toValue({ values }) {
    return values.map((x) => x.toString()).join("").replace(/[^ -~]+/g, "");
  },
  fromValue(value) {
    if (typeof value === "object")
      return value;
    return {
      values: fillWithNull(value.split("").map((x) => Character.fromString(x)), DEFAULT_STRING_LENGTH)
    };
  }
};
var CircuitString = class _CircuitString extends Struct(RawCircuitString) {
  // this is the publicly accessible constructor
  static fromCharacters(chars) {
    return new _CircuitString({ values: fillWithNull(chars, this.maxLength) });
  }
  maxLength() {
    return this.constructor.maxLength;
  }
  // some O(n) computation that should be only done once in the circuit
  computeLengthAndMask() {
    let n = this.values.length;
    let length = Field4(0);
    let mask = [];
    let wasntNullAlready = Bool4(true);
    for (let i = 0; i < n; i++) {
      let isNull = this.values[i].isNull();
      mask[i] = isNull.and(wasntNullAlready);
      wasntNullAlready = isNull.not().and(wasntNullAlready);
      length.add(wasntNullAlready.toField());
    }
    mask[n] = wasntNullAlready;
    this._length = length;
    this._mask = mask;
    return { mask, length };
  }
  lengthMask() {
    return this._mask ?? this.computeLengthAndMask().mask;
  }
  length() {
    return this._length ?? this.computeLengthAndMask().length;
  }
  /**
   * returns true if `this` has the same value as `other`
   */
  equals(other) {
    return Provable.equal(_CircuitString, this, other);
  }
  /**
   * appends another string to this one, returns the result and proves that it fits
   * within the `maxLength` of this string (the other string can have a different maxLength)
   */
  append(str) {
    let n = this.maxLength();
    this.length().add(str.length()).assertLessThan(n);
    let chars = this.values;
    let otherChars = fillWithNull(str.values, n);
    let possibleResults = [];
    for (let length = 0; length < n + 1; length++) {
      possibleResults[length] = chars.slice(0, length).concat(otherChars.slice(0, n - length));
    }
    let result = [];
    let mask = this.lengthMask();
    for (let i = 0; i < n; i++) {
      let possibleCharsAtI = possibleResults.map((r) => r[i]);
      result[i] = Provable.switch(mask, Character, possibleCharsAtI);
    }
    return _CircuitString.fromCharacters(result);
  }
  hash() {
    return Poseidon2.hash(this.values.map((x) => x.value));
  }
  substring(start, end) {
    return _CircuitString.fromCharacters(this.values.slice(start, end));
  }
  toString() {
    return _CircuitString.toValue(this);
  }
  static fromString(str) {
    if (str.length > this.maxLength) {
      throw Error("CircuitString.fromString: input string exceeds max length!");
    }
    return new _CircuitString(_CircuitString.fromValue(str));
  }
};
CircuitString.maxLength = DEFAULT_STRING_LENGTH;
var NullCharacter = () => new Character(Field4(0));
function fillWithNull([...values], length) {
  let nullChar = NullCharacter();
  for (let i = values.length; i < length; i++) {
    values[i] = nullChar;
  }
  return values;
}

// dist/node/lib/provable/merkle-map.js
var import_tslib6 = require("tslib");
var MerkleMap = class {
  /**
   * Creates a new, empty Merkle Map.
   * @returns A new MerkleMap
   * @example
   * ```ts
   * const merkleMap = new MerkleMap();
   * ```
   */
  constructor() {
    this.tree = new MerkleTree(256);
  }
  _keyToIndex(key) {
    let bits = BinableFp.toBits(key.toBigInt()).reverse();
    if (bits[0]) {
      throw Error("Key must be less than 2^254, to avoid collisions in the field modulus. Please use a smaller key.");
    }
    let n = 0n;
    for (let i = bits.length - 1; i >= 0; i--) {
      n = n << 1n | BigInt(bits[i]);
    }
    return n;
  }
  /**
   * Sets a key of the merkle map to a given value.
   * @param key The key to set in the map.
   * @param value The value to set.
   * @example
   * ```ts
   * const key = Field(5);
   * const value = Field(10);
   * merkleMap.set(key, value);
   * ```
   */
  set(key, value) {
    const index = this._keyToIndex(key);
    this.tree.setLeaf(index, value);
  }
  /**
   * Returns a value given a key. Values are by default Field(0).
   * @param key The key to get the value from.
   * @returns The value stored at the key.
   * @example
   * ```ts
   * const key = Field(5);
   * const value = merkleMap.get(key);
   * console.log(value); // Output: the value at key 5 or Field(0) if key does not exist
   * ```
   */
  get(key) {
    const index = this._keyToIndex(key);
    return this.tree.getNode(0, index);
  }
  /**
   * Returns the root of the Merkle Map.
   * @returns The root of the Merkle Map.
   * @example
   * ```ts
   * const root = merkleMap.getRoot();
   * ```
   */
  getRoot() {
    return this.tree.getRoot();
  }
  /**
   * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.
   * @param key The key to make a witness for.
   * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.
   * @example
   * ```ts
   * const key = Field(5);
   * const witness = merkleMap.getWitness(key);
   * ```
   */
  getWitness(key) {
    const index = this._keyToIndex(key);
    class MyMerkleWitness extends MerkleWitness(256) {
    }
    const witness2 = new MyMerkleWitness(this.tree.getWitness(index));
    return new MerkleMapWitness(witness2.isLeft, witness2.path);
  }
};
var MerkleMapWitness = class extends CircuitValue {
  constructor(isLefts, siblings) {
    super();
    this.isLefts = isLefts;
    this.siblings = siblings;
  }
  /**
   * @deprecated This method is deprecated and will be removed in the next release. Please use {@link computeRootAndKeyV2} instead.
   */
  computeRootAndKey(value) {
    let hash3 = value;
    const isLeft = this.isLefts;
    const siblings = this.siblings;
    let key = Field4(0);
    for (let i = 0; i < 255; i++) {
      const left = Provable.if(isLeft[i], hash3, siblings[i]);
      const right = Provable.if(isLeft[i], siblings[i], hash3);
      hash3 = Poseidon2.hash([left, right]);
      const bit2 = Provable.if(isLeft[i], Field4(0), Field4(1));
      key = key.mul(2).add(bit2);
    }
    return [hash3, key];
  }
  /**
   * Computes the merkle tree root for a given value and the key for this witness
   * @param value The value to compute the root for.
   * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.
   */
  computeRootAndKeyV2(value) {
    this.isLefts[0].assertTrue();
    let hash3 = value;
    const isLeft = this.isLefts;
    const siblings = this.siblings;
    let key = Field4(0);
    for (let i = 0; i < 255; i++) {
      const left = Provable.if(isLeft[i], hash3, siblings[i]);
      const right = Provable.if(isLeft[i], siblings[i], hash3);
      hash3 = Poseidon2.hash([left, right]);
      const bit2 = Provable.if(isLeft[i], Field4(0), Field4(1));
      key = key.mul(2).add(bit2);
    }
    return [hash3, key];
  }
};
(0, import_tslib6.__decorate)([
  arrayProp(Bool4, 255),
  (0, import_tslib6.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "isLefts", void 0);
(0, import_tslib6.__decorate)([
  arrayProp(Field4, 255),
  (0, import_tslib6.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "siblings", void 0);

// dist/node/lib/provable/crypto/nullifier.js
var Nullifier = class extends Struct({
  publicKey: Group3,
  public: {
    nullifier: Group3,
    s: Scalar3
  },
  private: {
    c: Field4,
    g_r: Group3,
    h_m_pk_r: Group3
  }
}) {
  static fromJSON(json) {
    return super.fromJSON(json);
  }
  /**
   * Verifies that the Nullifier belongs to a specific message. Throws an error if the Nullifier is incorrect.
   *
   * @example
   *
   * ```ts
   * let nullifierMessage = [voteId, ...otherData];
   * // throws an error if the nullifier is invalid or doesn't belong to this specific message
   * nullifier.verify(nullifierMessage);
   * ```
   */
  verify(message) {
    let { publicKey, public: { nullifier, s }, private: { c } } = this;
    let G = Group3.generator;
    let pk_fields = Group3.toFields(publicKey);
    let h_m_pk = Poseidon2.hashToGroup([...message, ...pk_fields]);
    let pk_c = this.publicKey.scale(c);
    let g_r = G.scale(s).sub(pk_c);
    let h_m_pk_s = h_m_pk.scale(s);
    let h_m_pk_s_div_nullifier_s = h_m_pk_s.sub(nullifier.scale(c));
    Poseidon2.hash([
      ...Group3.toFields(G),
      ...pk_fields,
      ...Group3.toFields(h_m_pk),
      ...Group3.toFields(nullifier),
      ...Group3.toFields(g_r),
      ...Group3.toFields(h_m_pk_s_div_nullifier_s)
    ]).assertEquals(c, "Nullifier does not match private input!");
  }
  /**
   * The key of the nullifier, which belongs to a unique message and a public key.
   * Used as an index in Merkle trees.
   *
   * @example
   * ```ts
   * // returns the key of the nullifier which can be used as index in a Merkle tree/map
   * let key = nullifier.key();
   * ```
   */
  key() {
    return Poseidon2.hash(Group3.toFields(this.public.nullifier));
  }
  /**
   * @deprecated This method uses the deprecated {@link MerkleMapWitness.computeRootAndKey} which may be vulnerable to hash collisions in key indices. Use {@link isUnusedV2} instead, which utilizes the safer {@link MerkleMapWitness.computeRootAndKeyV2} method.
   */
  isUnused(witness2, root) {
    let [newRoot, key] = witness2.computeRootAndKey(Field4(0));
    key.assertEquals(this.key());
    let isUnused = newRoot.equals(root);
    let isUsed = witness2.computeRootAndKey(Field4(1))[0].equals(root);
    isUsed.or(isUnused).assertTrue();
    return isUnused;
  }
  /**
   * Returns the state of the Nullifier.
   *
   * @example
   * ```ts
   * // returns a Bool based on whether or not the nullifier has been used before
   * let isUnused = nullifier.isUnusedV2();
   * ```
   */
  isUnusedV2(witness2, root) {
    let [newRoot, key] = witness2.computeRootAndKeyV2(Field4(0));
    key.assertEquals(this.key());
    let isUnused = newRoot.equals(root);
    let isUsed = witness2.computeRootAndKey(Field4(1))[0].equals(root);
    isUsed.or(isUnused).assertTrue();
    return isUnused;
  }
  /**
   * @deprecated This method uses the deprecated {@link MerkleMapWitness.computeRootAndKey} which may be vulnerable to hash collisions in key indices. Use {@link assertUnusedV2} instead, which utilizes the safer {@link MerkleMapWitness.computeRootAndKeyV2} method.
   */
  assertUnused(witness2, root) {
    let [impliedRoot, key] = witness2.computeRootAndKey(Field4(0));
    this.key().assertEquals(key);
    impliedRoot.assertEquals(root);
  }
  /**
   * Checks if the Nullifier has been used before.
   *
   * @example
   * ```ts
   * // asserts that the nullifier has not been used before, throws an error otherwise
   * nullifier.assertUnusedV2();
   * ```
   */
  assertUnusedV2(witness2, root) {
    let [impliedRoot, key] = witness2.computeRootAndKeyV2(Field4(0));
    this.key().assertEquals(key);
    impliedRoot.assertEquals(root);
  }
  /**
   * @deprecated This method uses the deprecated {@link MerkleMapWitness.computeRootAndKey} which may be vulnerable to hash collisions in key indices. Use {@link setUsedV2} instead, which utilizes the safer {@link MerkleMapWitness.computeRootAndKeyV2} method.
   */
  setUsed(witness2) {
    let [newRoot, key] = witness2.computeRootAndKey(Field4(1));
    key.assertEquals(this.key());
    return newRoot;
  }
  /**
   * Sets the Nullifier, returns the new Merkle root.
   *
   * @example
   * ```ts
   * // calculates the new root of the Merkle tree in which the nullifier is set to used
   * let newRoot = nullifier.setUsedV2(witness);
   * ```
   */
  setUsedV2(witness2) {
    let [newRoot, key] = witness2.computeRootAndKeyV2(Field4(1));
    key.assertEquals(this.key());
    return newRoot;
  }
  /**
   * Returns the {@link PublicKey} that is associated with this Nullifier.
   *
   * @example
   * ```ts
   * let pk = nullifier.getPublicKey();
   * ```
   */
  getPublicKey() {
    return PublicKey2.fromGroup(this.publicKey);
  }
  /**
   *
   * _Note_: This is *not* the recommended way to create a Nullifier in production. Please use mina-signer to create Nullifiers.
   * Also, this function cannot be run within provable code to avoid unintended creations of Nullifiers - a Nullifier should never be created inside proveable code (e.g. a smart contract) directly, but rather created inside the users wallet (or other secure enclaves, so the private key never leaves that enclave).
   *
   * PLUME: An ECDSA Nullifier Scheme for Unique
   * Pseudonymity within Zero Knowledge Proofs
   * https://eprint.iacr.org/2022/1255.pdf chapter 3 page 14
   */
  static createTestNullifier(message, sk) {
    if (Provable.inCheckedComputation()) {
      throw Error("This function cannot not be run within provable code. If you want to create a Nullifier, run this method outside provable code or use mina-signer to do so.");
    }
    const Hash2 = Poseidon2.hash;
    const Hash3 = Poseidon2.hashToGroup;
    const pk = sk.toPublicKey().toGroup();
    const G = Group3.generator;
    const r = Scalar3.random();
    const h_m_pk = Hash3([...message, ...Group3.toFields(pk)]);
    const nullifier = h_m_pk.scale(sk.toBigInt());
    const h_m_pk_r = h_m_pk.scale(r.toBigInt());
    const g_r = G.scale(r.toBigInt());
    const c = Hash2([
      ...Group3.toFields(G),
      ...Group3.toFields(pk),
      ...Group3.toFields(h_m_pk),
      ...Group3.toFields(nullifier),
      ...Group3.toFields(g_r),
      ...Group3.toFields(h_m_pk_r)
    ]);
    const s = r.add(sk.s.mul(Scalar3.from(c.toBigInt())));
    return {
      publicKey: pk.toJSON(),
      private: {
        c: c.toString(),
        g_r: g_r.toJSON(),
        h_m_pk_r: h_m_pk_r.toJSON()
      },
      public: {
        nullifier: nullifier.toJSON(),
        s: s.toJSON()
      }
    };
  }
};

// dist/node/bindings/crypto/finite-field-examples.js
var pSmall = 101n;
var pBabybear = (1n << 31n) - 1n;
var pGoldilocks = (1n << 64n) - (1n << 32n) + 1n;
var p25519 = (1n << 255n) - 19n;
var pSecp256k1 = (1n << 256n) - (1n << 32n) - 977n;
var pSecq256k1 = (1n << 256n) - 0x14551231950b75fc4402da1732fc9bebfn;
var pBls12_381 = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001n;
var qBls12_381 = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001n;
var exampleFields = {
  Fp,
  Fq,
  small: createField(pSmall),
  babybear: createField(pBabybear),
  goldilocks: createField(pGoldilocks),
  f25519: createField(p25519),
  secp256k1: createField(pSecp256k1),
  secq256k1: createField(pSecq256k1),
  bls12_381_base: createField(pBls12_381),
  bls12_381_scalar: createField(qBls12_381)
};

// dist/node/bindings/crypto/elliptic-curve-examples.js
var secp256k1Params = {
  name: "secp256k1",
  modulus: exampleFields.secp256k1.modulus,
  order: exampleFields.secq256k1.modulus,
  a: 0n,
  b: 7n,
  generator: {
    x: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
    y: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
  }
};
var pallasParams = {
  name: "Pallas",
  modulus: Pallas.modulus,
  order: Pallas.order,
  a: Pallas.a,
  b: Pallas.b,
  generator: Pallas.one,
  endoBase: Pallas.endoBase,
  endoScalar: Pallas.endoScalar
};
var vestaParams = {
  name: "Vesta",
  modulus: Vesta.modulus,
  order: Vesta.order,
  a: Vesta.a,
  b: Vesta.b,
  generator: Vesta.one,
  endoBase: Vesta.endoBase,
  endoScalar: Vesta.endoScalar
};
var CurveParams = {
  Secp256k1: secp256k1Params,
  Pallas: pallasParams,
  Vesta: vestaParams
};

// dist/node/lib/provable/crypto/crypto.js
var Crypto = {
  /**
   * Create elliptic curve arithmetic methods.
   */
  createCurve(params) {
    return createCurveAffine(params);
  },
  /**
   * Parameters defining an elliptic curve in short Weierstraß form
   * y^2 = x^3 + ax + b
   */
  CurveParams
};

// dist/node/lib/mina/actions/offchain-state-serialization.js
function toKeyHash(prefix, keyType, key) {
  return hashPackedWithPrefix([prefix, Field4(0)], keyType, key);
}
function toAction({ prefix, keyType, valueType, key, value, previousValue }) {
  valueType = ProvableType.get(valueType);
  let valueSize = valueType.sizeInFields();
  let padding2 = valueSize % 2 === 0 ? [] : [Field4(0)];
  let keyHash = hashPackedWithPrefix([prefix, Field4(0)], keyType, key);
  let usesPreviousValue = Bool4(previousValue !== void 0).toField();
  let previousValueHash = previousValue !== void 0 ? Provable.if(previousValue.isSome, Poseidon2.hashPacked(valueType, previousValue.value), Field4(0)) : Field4(0);
  let valueHash = Poseidon2.hashPacked(valueType, value);
  return [
    ...valueType.toFields(value),
    ...padding2,
    usesPreviousValue,
    previousValueHash,
    keyHash,
    valueHash
  ];
}
function fromActionWithoutHashes(valueType, action) {
  valueType = ProvableType.get(valueType);
  let valueSize = valueType.sizeInFields();
  let paddingSize = valueSize % 2 === 0 ? 0 : 1;
  assert3(action.length === valueSize + paddingSize, "invalid action size");
  let value = valueType.fromFields(action.slice(0, valueSize));
  valueType.check(value);
  return value;
}
function hashPackedWithPrefix(prefix, type, value) {
  let state3 = Poseidon2.initialState();
  state3 = Poseidon2.update(state3, prefix);
  if (type !== void 0) {
    let input = ProvableType.get(type).toInput(value);
    let packed = packToFields(input);
    state3 = Poseidon2.update(state3, packed);
  }
  return state3[0];
}
var MerkleLeaf = class _MerkleLeaf extends Struct({
  key: Field4,
  value: Field4,
  usesPreviousValue: Bool4,
  previousValue: Field4,
  prefix: Unconstrained.withEmpty([])
}) {
  static fromAction(action) {
    assert3(action.length >= 4, "invalid action size");
    let [usesPreviousValue_, previousValue, key, value] = action.slice(-4);
    let usesPreviousValue = usesPreviousValue_.assertBool();
    let prefix = Unconstrained.from(action.slice(0, -4));
    return new _MerkleLeaf({
      usesPreviousValue,
      previousValue,
      key,
      value,
      prefix
    });
  }
  /**
   * A custom method to hash an action which only hashes the key and value in provable code.
   * Therefore, it only proves that the key and value are part of the action, and nothing about
   * the rest of the action.
   */
  static hash(action) {
    let preHashState = Provable.witnessFields(3, () => {
      let prefix = action.prefix.get();
      let init = salt(prefixes.event);
      return Poseidon2.update(init, prefix);
    });
    return Poseidon2.update(preHashState, [
      action.usesPreviousValue.toField(),
      action.previousValue,
      action.key,
      action.value
    ])[0];
  }
};
function pushAction(actionsHash, action) {
  return hashWithPrefix(prefixes.sequenceEvents, [
    actionsHash,
    MerkleLeaf.hash(action)
  ]);
}
var ActionList = class extends MerkleList.create(MerkleLeaf, pushAction, Actions3.empty().hash) {
};
var LinearizedAction = class extends Struct({
  action: MerkleLeaf,
  /**
   * Whether this action is the last in an account update.
   * In a linearized sequence of actions, this value determines the points at which we commit an atomic update to the Merkle tree.
   */
  isCheckPoint: Bool4
}) {
  /**
   * A custom method to hash an action which only hashes the key and value in provable code.
   * Therefore, it only proves that the key and value are part of the action, and nothing about
   * the rest of the action.
   */
  static hash({ action, isCheckPoint }) {
    let preHashState = Provable.witnessFields(3, () => {
      let prefix = action.prefix.get();
      let init = salt(prefixes.event);
      return Poseidon2.update(init, prefix);
    });
    return Poseidon2.update(preHashState, [
      // pack two bools into 1 field
      action.usesPreviousValue.toField().add(isCheckPoint.toField().mul(2)),
      action.previousValue,
      action.key,
      action.value
    ])[0];
  }
};
var LinearizedActionList = class extends MerkleList.create(LinearizedAction, (hash3, action) => Poseidon2.hash([hash3, LinearizedAction.hash(action)]), Actions3.empty().hash) {
};
async function fetchMerkleLeaves(contract2, config) {
  class MerkleActions2 extends MerkleList.create(
    ActionList,
    (hash3, actions) => Actions3.updateSequenceState(hash3, actions.hash),
    // if no "start" action hash was specified, this means we are fetching the entire history of actions, which started from the empty action state hash
    // otherwise we are only fetching a part of the history, which starts at `fromActionState`
    config?.fromActionState ?? Actions3.emptyActionState()
  ) {
  }
  let result = await fetchActions(contract2.address, config, contract2.tokenId);
  if ("error" in result)
    throw Error(JSON.stringify(result));
  let merkleLeafs = result.map((event) => event.actions.map((action) => MerkleLeaf.fromAction(action.map(Field4))));
  return MerkleActions2.from(merkleLeafs.map((a2) => ActionList.fromReverse(a2)));
}
async function fetchMerkleMap(height, contract2, endActionState) {
  let result = await fetchActions(contract2.address, { endActionState }, contract2.tokenId);
  if ("error" in result)
    throw Error(JSON.stringify(result));
  let leaves = result.map((event) => event.actions.map((action) => MerkleLeaf.fromAction(action.map(Field4))).reverse());
  let merkleMap = new (IndexedMerkleMap(height))();
  let valueMap = /* @__PURE__ */ new Map();
  updateMerkleMap(leaves, merkleMap, valueMap);
  return { merkleMap, valueMap };
}
function updateMerkleMap(updates, tree, valueMap) {
  let intermediateTree = tree.clone();
  for (let leaves of updates) {
    let isValidUpdate = true;
    let updates2 = [];
    for (let leaf of leaves) {
      let { key, value, usesPreviousValue, previousValue, prefix } = MerkleLeaf.toValue(leaf);
      let previous = intermediateTree.getOption(key).orElse(0n);
      let isValidAction = !usesPreviousValue || previous.toBigInt() === previousValue;
      if (!isValidAction) {
        isValidUpdate = false;
        break;
      }
      intermediateTree.set(key, value);
      updates2.push({ key, fullValue: prefix });
    }
    if (isValidUpdate) {
      tree.overwrite(intermediateTree);
      for (let { key, fullValue } of updates2) {
        if (valueMap)
          valueMap.set(key, fullValue);
      }
    } else {
      intermediateTree.overwrite(tree);
    }
  }
}

// dist/node/lib/mina/actions/offchain-state-rollup.js
var ActionIterator = class extends MerkleListIterator.create(
  ActionList,
  (hash3, actions) => Actions.updateSequenceState(hash3, actions.hash),
  // we don't have to care about the initial hash here because we will just step forward
  Actions.emptyActionState()
) {
};
var OffchainStateCommitments = class _OffchainStateCommitments extends Struct({
  // this should just be a MerkleTree type that carries the full tree as aux data
  root: Field4,
  length: Field4,
  // TODO: make zkprogram support auxiliary data in public inputs
  // actionState: ActionIterator,
  actionState: Field4
}) {
  static emptyFromHeight(height) {
    let emptyMerkleTree = new (IndexedMerkleMap(height))();
    return new _OffchainStateCommitments({
      root: emptyMerkleTree.root,
      length: emptyMerkleTree.length,
      actionState: Actions.emptyActionState()
    });
  }
};
function merkleUpdateBatch({ maxActionsPerProof, maxActionsPerUpdate }, stateA, actions, tree) {
  actions.currentHash.assertEquals(stateA.actionState);
  let linearActions = LinearizedActionList.empty();
  for (let i = 0; i < maxActionsPerProof; i++) {
    let inner = actions.next().startIterating();
    let isAtEnd = Bool4(false);
    for (let i2 = 0; i2 < maxActionsPerUpdate; i2++) {
      let { element: action, isDummy } = inner.Unsafe.next();
      let isCheckPoint = inner.isAtEnd();
      [isAtEnd, isCheckPoint] = [
        isAtEnd.or(isCheckPoint),
        isCheckPoint.and(isAtEnd.not())
      ];
      linearActions.pushIf(isDummy.not(), new LinearizedAction({ action, isCheckPoint }));
    }
    inner.assertAtEnd(`Expected at most ${maxActionsPerUpdate} actions per account update.`);
  }
  actions.assertAtEnd();
  stateA.root.assertEquals(tree.root);
  stateA.length.assertEquals(tree.length);
  let intermediateTree = tree.clone();
  let isValidUpdate = Bool4(true);
  linearActions.forEach(maxActionsPerProof, (element, isDummy) => {
    let { action, isCheckPoint } = element;
    let { key, value, usesPreviousValue, previousValue } = action;
    let actualPreviousValue = intermediateTree.setIf(isDummy.not(), key, value);
    let matchesPreviousValue = actualPreviousValue.orElse(0n).equals(previousValue);
    let isValidAction = usesPreviousValue.implies(matchesPreviousValue);
    isValidUpdate = isValidUpdate.and(isValidAction);
    tree.overwriteIf(isCheckPoint.and(isValidUpdate), intermediateTree);
    isValidUpdate = Provable.if(isCheckPoint, Bool4(true), isValidUpdate);
    intermediateTree.overwriteIf(isCheckPoint, tree);
  });
  return {
    root: tree.root,
    length: tree.length,
    actionState: actions.currentHash
  };
}
function OffchainStateRollup({
  /**
   * the constraints used in one batch proof with a height-31 tree are:
   *
   * 1967*A + 87*A*U + 2
   *
   * where A = maxActionsPerProof and U = maxActionsPerUpdate.
   *
   * To determine defaults, we set U=4 which should cover most use cases while ensuring
   * that the main loop which is independent of U dominates.
   *
   * Targeting ~50k constraints, to leave room for recursive verification, yields A=22.
   */
  maxActionsPerProof = 22,
  maxActionsPerUpdate = 4,
  logTotalCapacity = 30
} = {}) {
  class IndexedMerkleMapN extends IndexedMerkleMap(logTotalCapacity + 1) {
  }
  let offchainStateRollup = ZkProgram({
    name: "merkle-map-rollup",
    publicInput: OffchainStateCommitments,
    publicOutput: OffchainStateCommitments,
    methods: {
      /**
       * `firstBatch()` creates the initial proof A -> B
       */
      firstBatch: {
        // [actions, tree]
        privateInputs: [ActionIterator, IndexedMerkleMapN],
        async method(stateA, actions, tree) {
          return merkleUpdateBatch({ maxActionsPerProof, maxActionsPerUpdate }, stateA, actions, tree);
        }
      },
      /**
       * `nextBatch()` takes an existing proof A -> B, adds its own logic to prove B -> B', so that the output is a proof A -> B'
       */
      nextBatch: {
        // [actions, tree, proof]
        privateInputs: [ActionIterator, IndexedMerkleMapN, SelfProof],
        async method(stateA, actions, tree, recursiveProof) {
          recursiveProof.verify();
          Provable.assertEqual(OffchainStateCommitments, recursiveProof.publicInput, stateA);
          let stateB = recursiveProof.publicOutput;
          return merkleUpdateBatch({ maxActionsPerProof, maxActionsPerUpdate }, stateB, actions, tree);
        }
      }
    }
  });
  let RollupProof = ZkProgram.Proof(offchainStateRollup);
  let isCompiled = false;
  return {
    Proof: RollupProof,
    program: offchainStateRollup,
    async compile() {
      if (isCompiled)
        return;
      let result = await offchainStateRollup.compile();
      isCompiled = true;
      return result;
    },
    async prove(tree, actions) {
      assert3(tree.height === logTotalCapacity + 1, "Tree height must match");
      if (getProofsEnabled())
        await this.compile();
      tree = tree.clone();
      let iterator = actions.startIterating();
      let inputState = new OffchainStateCommitments({
        root: tree.root,
        length: tree.length,
        actionState: iterator.currentHash
      });
      if (!getProofsEnabled()) {
        let actionsList = actions.data.get().map(({ element: actionsList2 }) => actionsList2.data.get().map(({ element }) => element).reverse()).reverse();
        updateMerkleMap(actionsList, tree);
        let finalState = new OffchainStateCommitments({
          root: tree.root,
          length: tree.length,
          actionState: iterator.hash
        });
        let proof2 = await RollupProof.dummy(inputState, finalState, 2, 15);
        return { proof: proof2, tree, nProofs: 0 };
      }
      let slice = sliceActions(iterator, maxActionsPerProof);
      let proof = await offchainStateRollup.firstBatch(inputState, slice, tree);
      tree.root = proof.publicOutput.root;
      tree.length = proof.publicOutput.length;
      let nProofs = 1;
      for (let i = 1; ; i++) {
        if (iterator.isAtEnd().toBoolean())
          break;
        nProofs++;
        let slice2 = sliceActions(iterator, maxActionsPerProof);
        proof = await offchainStateRollup.nextBatch(inputState, slice2, tree, proof);
        tree.root = proof.publicOutput.root;
        tree.length = proof.publicOutput.length;
      }
      return { proof, tree, nProofs };
    }
  };
}
function sliceActions(actions, batchSize) {
  class ActionListsList extends MerkleList.create(ActionList, (hash3, actions2) => Actions.updateSequenceState(hash3, actions2.hash), actions.currentHash) {
  }
  let slice = ActionListsList.empty();
  let totalSize = 0;
  while (true) {
    if (actions.isAtEnd().toBoolean())
      break;
    let nextList = actions.data.get()[actions._index("next")].element;
    let nextSize = nextList.data.get().length;
    assert3(nextSize <= batchSize, "Actions in one update exceed maximum batch size");
    if (totalSize + nextSize > batchSize)
      break;
    let nextMerkleList = actions.next();
    slice.push(nextMerkleList);
    totalSize += nextSize;
  }
  return slice.startIterating();
}

// dist/node/lib/mina/actions/offchain-state.js
function OffchainState(config, options) {
  let { logTotalCapacity = 30, maxActionsPerUpdate = 4, maxActionsPerProof } = options ?? {};
  const height = logTotalCapacity + 1;
  class IndexedMerkleMapN extends IndexedMerkleMap(height) {
  }
  let internal = {
    _contract: void 0,
    _contractClass: void 0,
    _merkleMap: void 0,
    _valueMap: void 0,
    get contract() {
      return assertDefined(internal._contract, "Must call `setContractInstance()` first");
    }
  };
  const onchainActionState = async () => {
    let actionState = (await internal.contract.offchainState.fetch())?.actionState;
    assert3(actionState !== void 0, "Could not fetch action state");
    return actionState;
  };
  const merkleMaps = async () => {
    if (internal._merkleMap !== void 0 && internal._valueMap !== void 0) {
      return { merkleMap: internal._merkleMap, valueMap: internal._valueMap };
    }
    let actionState = await onchainActionState();
    let { merkleMap, valueMap } = await fetchMerkleMap(height, internal.contract, actionState);
    internal._merkleMap = merkleMap;
    internal._valueMap = valueMap;
    return { merkleMap, valueMap };
  };
  let rollup = OffchainStateRollup({
    logTotalCapacity,
    maxActionsPerProof,
    maxActionsPerUpdate
  });
  function getContract() {
    let Contract = assertDefined(internal._contractClass, "Must call `setContractInstance()` or `setContractClass()` first");
    return contract(Contract);
  }
  function maybeContract() {
    try {
      return getContract();
    } catch {
      return internal.contract;
    }
  }
  async function get2(key, valueType) {
    let state3 = maybeContract().offchainState.getAndRequireEquals();
    let map2 = await Provable.witnessAsync(IndexedMerkleMapN, async () => (await merkleMaps()).merkleMap);
    map2.root.assertEquals(state3.root, "root mismatch");
    map2.length.assertEquals(state3.length, "length mismatch");
    let valueHash = map2.getOption(key);
    const optionType = Option(valueType);
    let value = await Provable.witnessAsync(optionType, async () => {
      let { valueMap } = await merkleMaps();
      let valueFields = valueMap.get(key.toBigInt());
      if (valueFields === void 0) {
        return optionType.none();
      }
      let value2 = fromActionWithoutHashes(valueType, valueFields);
      return optionType.from(value2);
    });
    let hashMatches = Poseidon2.hashPacked(valueType, value.value).equals(valueHash.value);
    let bothNone = value.isSome.or(valueHash.isSome).not();
    assert3(hashMatches.or(bothNone), "value hash mismatch");
    return value;
  }
  function field(index, type) {
    type = ProvableType.get(type);
    const prefix = Field4(index);
    let optionType = Option(type);
    return {
      _type: type,
      overwrite(value) {
        let action = toAction({
          prefix,
          keyType: void 0,
          valueType: type,
          key: void 0,
          value: type.fromValue(value)
        });
        let update = getContract().self;
        update.body.actions = Actions3.pushEvent(update.body.actions, action);
      },
      update({ from, to }) {
        let action = toAction({
          prefix,
          keyType: void 0,
          valueType: type,
          key: void 0,
          value: type.fromValue(to),
          previousValue: optionType.fromValue(from)
        });
        let update = getContract().self;
        update.body.actions = Actions3.pushEvent(update.body.actions, action);
      },
      async get() {
        let key = toKeyHash(prefix, void 0, void 0);
        return await get2(key, type);
      }
    };
  }
  function map(index, keyType, valueType) {
    keyType = ProvableType.get(keyType);
    valueType = ProvableType.get(valueType);
    const prefix = Field4(index);
    let optionType = Option(valueType);
    return {
      _keyType: keyType,
      _valueType: valueType,
      overwrite(key, value) {
        let action = toAction({
          prefix,
          keyType,
          valueType,
          key,
          value: valueType.fromValue(value)
        });
        let update = getContract().self;
        update.body.actions = Actions3.pushEvent(update.body.actions, action);
      },
      update(key, { from, to }) {
        let action = toAction({
          prefix,
          keyType,
          valueType,
          key,
          value: valueType.fromValue(to),
          previousValue: optionType.fromValue(from)
        });
        let update = getContract().self;
        update.body.actions = Actions3.pushEvent(update.body.actions, action);
      },
      async get(key) {
        let keyHash = toKeyHash(prefix, keyType, key);
        return await get2(keyHash, valueType);
      }
    };
  }
  return {
    setContractInstance(contract2) {
      internal._contract = contract2;
      internal._contractClass = contract2.constructor;
    },
    setContractClass(contractClass) {
      internal._contractClass = contractClass;
    },
    async compile() {
      await rollup.compile();
    },
    async createSettlementProof() {
      let { merkleMap } = await merkleMaps();
      let actionState = await onchainActionState();
      let actions = await fetchMerkleLeaves(internal.contract, {
        fromActionState: actionState
      });
      let result = await rollup.prove(merkleMap, actions);
      let { merkleMap: newMerkleMap, valueMap: newValueMap } = await fetchMerkleMap(height, internal.contract);
      internal._merkleMap = newMerkleMap;
      internal._valueMap = newValueMap;
      return result.proof;
    },
    Proof: rollup.Proof,
    async settle(proof) {
      proof.verify();
      let state3 = getContract().offchainState.getAndRequireEquals();
      Provable.assertEqual(OffchainStateCommitments, state3, proof.publicInput);
      getContract().account.actionState.requireEquals(proof.publicOutput.actionState);
      getContract().offchainState.set(proof.publicOutput);
    },
    fields: Object.fromEntries(Object.entries(config).map(([key, kind], i) => [
      key,
      kind.kind === "offchain-field" ? field(i, kind.type) : map(i, kind.keyType, kind.valueType)
    ])),
    commitments() {
      return State2(OffchainStateCommitments.emptyFromHeight(height));
    }
  };
}
OffchainState.Map = OffchainMap;
OffchainState.Field = OffchainField;
OffchainState.Commitments = OffchainStateCommitments;
function OffchainField(type) {
  return { kind: "offchain-field", type };
}
function OffchainMap(key, value) {
  return { kind: "offchain-map", keyType: key, valueType: value };
}

// dist/node/lib/mina/actions/action-types.js
var emptyActionsHash = Actions3.empty().hash;
var emptyActionState = Actions3.emptyActionState();
function MerkleActions(actionType, fromActionState) {
  return MerkleList.create(MerkleActionList(actionType), (hash3, actions) => hashWithPrefix(prefixes.sequenceEvents, [hash3, actions.hash]), fromActionState ?? emptyActionState);
}
MerkleActions.fromFields = actionFieldsToMerkleList;
function MerkleActionList(actionType) {
  return MerkleList.create(HashedAction(actionType), (hash3, action) => hashWithPrefix(prefixes.sequenceEvents, [hash3, action.hash]), emptyActionsHash);
}
function HashedAction(actionType) {
  let type = ProvableType.get(actionType);
  return Hashed.create(type, (action) => hashWithPrefix(prefixes.event, type.toFields(action)));
}
function actionFieldsToMerkleList(actionType, fields2, fromActionState) {
  let type = ProvableType.get(actionType);
  const HashedActionT = HashedAction(type);
  const MerkleActionListT = MerkleActionList(type);
  const MerkleActionsT = MerkleActions(type, fromActionState ? Field4(fromActionState) : void 0);
  let actions = fields2.map((event) => event.map((action) => type.fromFields(action.map(Field4))));
  let hashes = actions.map((as) => as.map((a2) => HashedActionT.hash(a2)));
  return MerkleActionsT.from(hashes.map((h) => MerkleActionListT.from(h)));
}
function MerkleActionHashes(fromActionState) {
  return MerkleList.create(Field4, (hash3, actionsHash) => hashWithPrefix(prefixes.sequenceEvents, [hash3, actionsHash]), fromActionState ?? emptyActionState);
}
function FlatActions(actionType) {
  return MerkleList.create(HashedAction(actionType));
}

// dist/node/lib/mina/actions/batch-reducer.js
var BatchReducer = class {
  constructor({ actionType, batchSize, maxUpdatesPerProof = 300, maxUpdatesFinalProof = 100, maxActionsPerUpdate = Math.min(batchSize, 5) }) {
    this.batchSize = batchSize;
    this.actionType = ProvableType.get(actionType);
    this.Batch = ActionBatch(this.actionType);
    this.maxUpdatesFinalProof = maxUpdatesFinalProof;
    this.program = actionStackProgram(maxUpdatesPerProof);
    this.BatchProof = ZkProgram.Proof(this.program);
    assert(maxActionsPerUpdate <= batchSize, "Invalid maxActionsPerUpdate, must be smaller than the batch size because we process entire updates at once.");
    this.maxActionsPerUpdate = maxActionsPerUpdate;
  }
  static get initialActionState() {
    return emptyActionState;
  }
  static get initialActionStack() {
    return emptyActionState;
  }
  contractClass() {
    return assertDefined(this._contractClass, "Contract instance or class must be set before calling this method");
  }
  contract() {
    let Contract = this.contractClass();
    return contract(Contract);
  }
  /**
   * Set the smart contract instance this reducer is connected with.
   *
   * Note: This is a required step before using `dispatch()`, `proveNextBatch()` or `processNextBatch()`.
   */
  setContractInstance(contract2) {
    this._contract = contract2;
    this._contractClass = contract2.constructor;
  }
  /**
   * Set the smart contract class this reducer is connected with.
   *
   * Note: You can use either this method or `setContractInstance()` before calling `compile()`.
   * However, `setContractInstance()` is required for `proveNextBatch()`.
   */
  setContractClass(contractClass) {
    this._contractClass = contractClass;
  }
  /**
   * Submit an action.
   */
  dispatch(action) {
    let update = this.contract().self;
    let fields2 = this.actionType.toFields(this.actionType.fromValue(action));
    update.body.actions = Actions3.pushEvent(update.body.actions, fields2);
  }
  /**
   * Conditionally submit an action.
   */
  dispatchIf(condition, action) {
    let update = this.contract().self;
    let fields2 = this.actionType.toFields(this.actionType.fromValue(action));
    let newActions = Actions3.pushEvent(update.body.actions, fields2);
    update.body.actions = Provable.if(condition, Actions3, newActions, update.body.actions);
  }
  /**
   * Process a batch of actions which was created by `prepareBatches()`.
   *
   * **Important**: The callback exposes the action's value along with an `isDummy` flag.
   * This is necessary because we process a dynamically-sized list in a fixed number of steps.
   * Dummies will be passed to your callback once the actual actions are exhausted.
   *
   * Make sure to write your code to account for dummies. For example, when sending MINA from your contract for every action,
   * you probably want to zero out the balance decrease in the `isDummy` case:
   * ```ts
   * processBatch({ batch, proof }, (action, isDummy) => {
   *   // ... other logic ...
   *
   *   let amountToSend = Provable.if(isDummy, UInt64.zero, action.amount);
   *   this.balance.subInPlace(amountToSend);
   * });
   * ```
   *
   * **Warning**: Don't call `processBatch()` on two _different_ batches within the same method. The second call
   * would override the preconditions set by the first call, which would leave the method insecure.
   * To process more actions per method call, increase the `batchSize`.
   */
  processBatch({ batch, proof }, callback) {
    let { actionType, batchSize } = this;
    let contract2 = this.contract();
    let { useOnchainStack, processedActionState, onchainActionState, onchainStack } = batch;
    let useNewStack = useOnchainStack.not();
    contract2.actionState.requireEquals(processedActionState);
    contract2.actionStack.requireEqualsIf(useOnchainStack, onchainStack);
    contract2.account.actionState.requireEqualsIf(useNewStack, onchainActionState);
    let { isRecursive } = batch;
    proof.verifyIf(isRecursive);
    Provable.assertEqualIf(isRecursive, Field4, proof.publicInput, onchainActionState);
    let initialState = { actions: onchainActionState, stack: emptyActionState };
    let startState = Provable.if(isRecursive, ActionStackState, proof.publicOutput, initialState);
    let stackingResult = actionStackChunk(this.maxUpdatesFinalProof, startState, batch.witnesses);
    Provable.assertEqualIf(useNewStack, Field4, stackingResult.actions, processedActionState);
    let stackToUse = Provable.if(useOnchainStack, onchainStack, stackingResult.stack);
    let { stack } = batch;
    stack = stack.clone();
    stack.hash.assertEquals(stackToUse);
    let nActionLists = Unconstrained.witness(() => {
      let lists = stack.toArrayUnconstrained().get();
      let n = 0;
      let totalSize = 0;
      for (let list of lists.reverse()) {
        totalSize += list.lengthUnconstrained().get();
        if (totalSize > batchSize)
          break;
        n++;
      }
      return n;
    });
    let flatActions = FlatActions(actionType).empty();
    for (let i = 0; i < batchSize; i++) {
      let shouldPop = Provable.witness(Bool4, () => i < nActionLists.get());
      let actionList = stack.popIfUnsafe(shouldPop);
      actionList = Provable.if(shouldPop, stack.innerProvable, actionList, stack.innerProvable.empty());
      actionList.forEach(this.maxActionsPerUpdate, (action, isDummy) => {
        flatActions.pushIf(isDummy.not(), action);
      });
      let nextActionState = Actions3.updateSequenceState(processedActionState, actionList.hash);
      processedActionState = Provable.if(shouldPop, nextActionState, processedActionState);
    }
    const HashedActionT = HashedAction(actionType);
    const emptyHashedAction = HashedActionT.empty();
    flatActions.forEach(batchSize, (hashedAction, isDummy, i) => {
      hashedAction = Provable.if(isDummy, HashedActionT, emptyHashedAction, hashedAction);
      callback(hashedAction.unhash(), isDummy, i);
    });
    contract2.actionState.set(processedActionState);
    contract2.actionStack.set(stack.hash);
  }
  /**
   * Compile the recursive action stack prover.
   */
  async compile() {
    return await this.program.compile();
  }
  /**
   * Create a proof which returns the next actions batch(es) to process and helps guarantee their correctness.
   */
  async prepareBatches() {
    let { batchSize, actionType } = this;
    let contract2 = assertDefined(this._contract, "Contract instance must be set before proving actions");
    let fromActionState = assertDefined(await contract2.actionState.fetch(), "Could not fetch action state").toBigInt();
    let { endActionState, witnesses, actions } = await fetchActionWitnesses(contract2, fromActionState, this.actionType);
    if (witnesses.length === 0)
      return [];
    let { proof, isRecursive, finalWitnesses } = await provePartialActionStack(endActionState, witnesses, this.program, this.maxUpdatesFinalProof);
    let stack = MerkleActions(actionType).fromReverse(actions.toArrayUnconstrained().get());
    let batches = [];
    let baseHint = {
      isRecursive,
      onchainActionState: Field4(endActionState),
      witnesses: finalWitnesses
    };
    let stackArray = stack.toArrayUnconstrained().get();
    let processedActionState = Field4(fromActionState);
    let onchainStack = Field4(0);
    let useOnchainStack = Bool4(false);
    let i = stackArray.length - 1;
    while (i >= 0) {
      batches.push({
        ...baseHint,
        useOnchainStack,
        processedActionState,
        onchainStack,
        stack: stack.clone()
      });
      let currentBatchSize = 0;
      while (i >= 0) {
        currentBatchSize += stackArray[i].lengthUnconstrained().get();
        if (currentBatchSize > batchSize)
          break;
        let actionList = stack.pop();
        processedActionState = Actions3.updateSequenceState(processedActionState, actionList.hash);
        i--;
      }
      onchainStack = stack.hash;
      useOnchainStack = Bool4(true);
    }
    stack.isEmpty().assertTrue();
    return batches.map((batch) => ({ proof, batch }));
  }
};
function ActionBatch(actionType) {
  return Struct({
    useOnchainStack: Bool4,
    processedActionState: Field4,
    onchainActionState: Field4,
    onchainStack: Field4,
    stack: MerkleActions(actionType),
    isRecursive: Bool4,
    witnesses: Unconstrained.withEmpty([])
  });
}
async function fetchActionWitnesses(contract2, fromActionState, actionType) {
  let result = await fetchActions(contract2.address, { fromActionState: Field4(fromActionState) }, contract2.tokenId);
  if ("error" in result)
    throw Error(JSON.stringify(result));
  let actionFields = result.map(({ actions: actions2 }) => actions2.map((action) => action.map(BigInt)).reverse());
  let actions = MerkleActions.fromFields(actionType, actionFields, fromActionState);
  let actionState = fromActionState;
  let witnesses = [];
  let hashes = actionFields.map((actions2) => actions2.reduce(pushAction2, Actions2.empty().hash));
  for (let actionsHash of hashes) {
    witnesses.push({ hash: actionsHash, stateBefore: actionState });
    actionState = Actions2.updateSequenceState(actionState, actionsHash);
  }
  return { endActionState: actionState, witnesses, actions };
}
function pushAction2(actionsHash, action) {
  return hashWithPrefix2(prefixes.sequenceEvents, [
    actionsHash,
    hashWithPrefix2(prefixes.event, action)
  ]);
}
async function provePartialActionStack(endActionState, witnesses, program, finalChunkSize) {
  let finalActionsChunk = witnesses.slice(0, finalChunkSize);
  let remainingActions = witnesses.slice(finalChunkSize);
  let { isEmpty, proof } = await proveActionStack(endActionState, remainingActions, program);
  return {
    proof,
    isRecursive: isEmpty.not(),
    finalWitnesses: Unconstrained.from(finalActionsChunk)
  };
}
async function proveActionStack(endActionState, actions, program) {
  endActionState = Field4(endActionState);
  let { maxUpdatesPerProof } = program;
  const ActionStackProof = ZkProgram.Proof(program);
  let n = actions.length;
  let isEmpty = Bool4(n === 0);
  let stack = MerkleActionHashes().empty();
  for (let action of [...actions].reverse()) {
    if (action === void 0)
      continue;
    stack.push(Field4(action.hash));
  }
  if (!getProofsEnabled()) {
    let startActionState = actions[0]?.stateBefore ?? endActionState;
    let proof2 = await ActionStackProof.dummy(endActionState, { actions: Field4(startActionState), stack: stack.hash }, 1, 14);
    return { isEmpty, proof: proof2 };
  }
  let chunks = [];
  let nChunks = Math.ceil(n / maxUpdatesPerProof);
  for (let i = 0, k = 0; i < nChunks; i++) {
    let batch = [];
    for (let j = 0; j < maxUpdatesPerProof; j++, k++) {
      batch[j] = actions[k];
    }
    chunks[i] = Unconstrained.from(batch);
  }
  let proof = await ActionStackProof.dummy(Field4(0), { actions: emptyActionState, stack: emptyActionState }, 1, 14);
  for (let i = nChunks - 1; i >= 0; i--) {
    let isRecursive = Bool4(i < nChunks - 1);
    proof = await program.proveChunk(endActionState, proof, isRecursive, chunks[i]);
  }
  proof.publicOutput.stack.assertEquals(stack.hash, "Stack hash mismatch");
  return { isEmpty, proof };
}
var ActionStackState = class extends Struct({
  actions: Field4,
  stack: Field4
}) {
};
var OptionActionWitness = class extends Option(Struct({ hash: Field4, stateBefore: Field4 })) {
};
function actionStackChunk(maxUpdatesPerProof, startState, witnesses) {
  let stack = MerkleActionHashes(startState.stack).empty();
  let actions = startState.actions;
  for (let i = maxUpdatesPerProof - 1; i >= 0; i--) {
    let { didPop, state: state3, hash: hash3 } = pop(actions, i, witnesses);
    stack.pushIf(didPop, hash3);
    actions = state3;
  }
  return new ActionStackState({ actions, stack: stack.hash });
}
function actionStackProgram(maxUpdatesPerProof) {
  let program = ZkProgram({
    name: "action-stack-prover",
    // input: actions to pop from
    publicInput: Field4,
    // output: actions after popping, and the new stack
    publicOutput: ActionStackState,
    methods: {
      proveChunk: {
        privateInputs: [
          SelfProof,
          Bool4,
          Unconstrained.withEmpty([])
        ],
        async method(input, proofSoFar, isRecursive, witnesses) {
          proofSoFar.verifyIf(isRecursive);
          Provable.assertEqualIf(isRecursive, Field4, input, proofSoFar.publicInput);
          let initialState = { actions: input, stack: emptyActionState };
          let startState = Provable.if(isRecursive, ActionStackState, proofSoFar.publicOutput, initialState);
          return actionStackChunk(maxUpdatesPerProof, startState, witnesses);
        }
      }
    }
  });
  return Object.assign(program, { maxUpdatesPerProof });
}
function pop(state3, i, witnesses) {
  let { isSome, value: witness2 } = Provable.witness(OptionActionWitness, () => witnesses.get()[i]);
  let impliedState = Actions3.updateSequenceState(witness2.stateBefore, witness2.hash);
  Provable.assertEqualIf(isSome, Field4, impliedState, state3);
  return {
    didPop: isSome,
    state: Provable.if(isSome, witness2.stateBefore, state3),
    hash: witness2.hash
  };
}

// dist/node/index.js
var Experimental_ = {
  memoizeWitness,
  IndexedMerkleMap
};
var Experimental;
(function(Experimental2) {
  Experimental2.memoizeWitness = Experimental_.memoizeWitness;
  Experimental2.IndexedMerkleMap = Experimental_.IndexedMerkleMap;
  Experimental2.OffchainState = OffchainState;
  class OffchainStateCommitments2 extends OffchainStateCommitments {
  }
  Experimental2.OffchainStateCommitments = OffchainStateCommitments2;
  class BatchReducer2 extends BatchReducer {
  }
  Experimental2.BatchReducer = BatchReducer2;
  Experimental2.ActionBatch = ActionBatch;
})(Experimental || (Experimental = {}));
Error.stackTraceLimit = 1e5;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AccountUpdate,
  AccountUpdateForest,
  AccountUpdateTree,
  Bool,
  Bytes,
  Cache,
  Character,
  Circuit,
  CircuitString,
  Crypto,
  DynamicProof,
  EcdsaSignature,
  EcdsaSignatureV2,
  Empty,
  Encoding,
  Encryption,
  Experimental,
  FeatureFlags,
  Field,
  ForeignCurve,
  ForeignCurveV2,
  Gadgets,
  Group,
  Hash,
  Hashed,
  Int64,
  Keccak,
  Keypair,
  Ledger,
  Lightnet,
  MerkleList,
  MerkleListIterator,
  MerkleMap,
  MerkleMapWitness,
  MerkleTree,
  MerkleWitness,
  Mina,
  Nullifier,
  Option,
  Packed,
  Permissions,
  Poseidon,
  PrivateKey,
  Proof,
  Provable,
  PublicKey,
  Reducer,
  Scalar,
  ScalarField,
  SelfProof,
  Sign,
  Signature,
  SmartContract,
  State,
  Struct,
  TokenAccountUpdateIterator,
  TokenContract,
  TokenContractV2,
  TokenId,
  TokenSymbol,
  Transaction,
  TransactionVersion,
  Types,
  UInt32,
  UInt64,
  UInt8,
  Unconstrained,
  Undefined,
  VerificationKey,
  Void,
  ZkProgram,
  ZkappPublicInput,
  addCachedAccount,
  assert,
  checkZkappTransaction,
  circuitMain,
  createEcdsa,
  createEcdsaV2,
  createForeignCurve,
  createForeignCurveV2,
  createForeignField,
  declareMethods,
  declareState,
  fetchAccount,
  fetchEvents,
  fetchLastBlock,
  fetchTransactionStatus,
  initializeBindings,
  method,
  provable,
  provablePure,
  public_,
  sendZkapp,
  setArchiveGraphqlEndpoint,
  setGraphqlEndpoint,
  setGraphqlEndpoints,
  setNumberOfWorkers,
  state,
  verify
});
