import * as Json from './src/types.js';
import type { SignedLegacy, Signed, NetworkId, SignedRosetta } from './src/types.js';
import * as TransactionJson from '../bindings/mina-transaction/gen/transaction-json.js';
import * as Rosetta from './src/rosetta.js';
export { Client, Client as default, type NetworkId };
declare class Client {
    private network;
    constructor({ network }: {
        network: NetworkId;
    });
    /**
     * Generates a public/private key pair
     *
     * @returns A Mina key pair
     */
    genKeys(): Json.Keypair;
    /**
     * Verifies if a key pair is valid by checking if the public key can be derived from
     * the private key and additionally checking if we can use the private key to
     * sign a transaction. If the key pair is invalid, an exception is thrown.
     *
     * @param keypair A key pair
     * @returns True if the `keypair` is a verifiable key pair, otherwise throw an exception
     */
    verifyKeypair({ privateKey, publicKey }: Json.Keypair): boolean;
    /**
     * Derives the public key of the corresponding private key
     *
     * @param privateKey The private key used to get the corresponding public key
     * @returns A public key
     */
    derivePublicKey(privateKeyBase58: Json.PrivateKey): Json.PublicKey;
    /**
     * Derives the public key corresponding to a given private key. This function addresses compatibility with private keys generated by external tools that may produce keys outside the domain of the Pallas curve, that was previously accepted by the older [client_sdk](https://www.npmjs.com/package/@o1labs/client-sdk).
     * The function first converts the input private key (in Base58 format) to a format that is compatible with the domain of the Pallas curve by applying a modulus operation. This step ensures backward compatibility with older keys that may not directly fit the Pallas curve's domain. Once the private key is in the correct domain, it is used to derive the corresponding public key.
     * @param privateKeyBase58 - The private key (in Base58 format) used to derive the corresponding public key. The key is expected to be out of the domain of the Pallas curve and will be converted to fit within the domain as part of this process.
     * @returns {Json.PublicKey} The derived public key in Base58 format, corresponding to the input private key, now within the domain of the Pallas curve.
     * @remarks
     * This function is labeled as "unsafe" due to the modulus operation applied to ensure backward compatibility, which might not adhere to strict security protocols expected in [mina-signer](https://www.npmjs.com/package/mina-signer). It is primarily intended for use cases requiring interoperability with keys managed by previous versions of the [client_sdk](https://www.npmjs.com/package/@o1labs/client-sdk) or other tools that may produce keys outside the Pallas curve's domain.
     * It is an essential tool for migrating old keys for use with the current [mina-signer](https://www.npmjs.com/package/mina-signer) library, by allowing keys that would otherwise be rejected to be used effectively.
     *
     * @example
     * ```ts
     * // Assuming `oldPrivateKeyBase58` is a private key in Base58 format from an older client SDK
     * const publicKeyBase58 = derivePublicKeyUnsafe(oldPrivateKeyBase58);
     * console.log(publicKeyBase58); // Logs the derived public key in Base58 format
     * ```
     */
    derivePublicKeyUnsafe(privateKeyBase58: Json.PrivateKey): Json.PublicKey;
    /**
     * Converts a private key that is out of the domain of the Pallas curve to a private key in base58 format that is in the domain by taking the modulus of the private key.
     * This is done to keep backwards compatibility with the previous version of the [client_sdk](https://www.npmjs.com/package/@o1labs/client-sdk), which did the same thing when converting a private key to base58.
     * @param keyBase58 - The private key that is out of the domain of the Pallas curve
     * @returns The private key that is in the domain of the Pallas curve
     * @remarks
     * This function is particularly useful when migrating old keys to be used by the current [mina-signer](https://www.npmjs.com/package/mina-signer) library,
     * which may reject keys that do not fit the domain of the Pallas curve, by performing a modulus operation on the key, it ensures that keys
     * from the older client_sdk can be made compatible.
     */
    convertPrivateKeyToBase58WithMod(keyBase58: string): string;
    /**
     * Signs an arbitrary list of field elements in a SNARK-compatible way.
     * The resulting signature can be verified in o1js as follows:
     * ```ts
     * // sign field elements with mina-signer
     * let signed = client.signFields(fields, privateKey);
     *
     * // read signature in o1js and verify
     * let signature = Signature.fromBase58(signed.signature);
     * let isValid: Bool = signature.verify(publicKey, fields.map(Field));
     * ```
     *
     * @param fields An arbitrary list of field elements
     * @param privateKey The private key used for signing
     * @returns The signed field elements
     */
    signFields(fields: bigint[], privateKey: Json.PrivateKey): Signed<bigint[]>;
    /**
     * Verifies a signature created by {@link signFields}.
     *
     * @param signedFields The signed field elements
     * @returns True if the `signedFields` contains a valid signature matching
     * the fields and publicKey.
     */
    verifyFields({ data, signature, publicKey }: Signed<bigint[]>): boolean;
    /**
     * Signs an arbitrary message
     *
     * @param message An arbitrary string message to be signed
     * @param privateKey The private key used to sign the message
     * @returns A signed message
     */
    signMessage(message: string, privateKey: Json.PrivateKey): SignedLegacy<string>;
    /**
     * Verifies a signature created by {@link signMessage}.
     *
     * @param signedMessage A signed message
     * @returns True if the `signedMessage` contains a valid signature matching
     * the message and publicKey.
     */
    verifyMessage({ data, signature, publicKey }: SignedLegacy<string>): boolean;
    /**
     * Signs a Rosetta transaction
     *
     * @param transaction An object describing the transaction to be signed.
     * @param privateKey The private key used to sign the transaction (in Base58
     * format).
     * @returns A signature of the transaction in Rosetta format.
     */
    signRosettaTransaction(transaction: Rosetta.UnsignedTransaction, privateKey: Json.PrivateKey): SignedRosetta<Rosetta.UnsignedTransaction>;
    /**
     * Verifies a signature created by {@link signRosettaTransaction}.
     *
     * @param signedTransaction The signed transaction (in Rosetta format)
     * @returns True if the `signedTransaction` contains a valid signature
     * matching the transaction and publicKey.
     */
    verifyRosettaTransaction(signedTransaction: SignedRosetta<Rosetta.UnsignedTransaction>): boolean;
    /**
     * Signs a payment transaction using a private key.
     *
     * This type of transaction allows a user to transfer funds from one account
     * to another over the network.
     *
     * @param payment An object describing the payment
     * @param privateKey The private key used to sign the transaction
     * @returns A signed payment transaction
     */
    signPayment(payment: Json.Payment, privateKey: Json.PrivateKey): SignedLegacy<Json.Payment>;
    /**
     * Verifies a signed payment.
     *
     * @param signedPayment A signed payment transaction
     * @returns True if the `signedPayment` is a verifiable payment
     */
    verifyPayment({ data, signature, publicKey, }: SignedLegacy<Json.Payment>): boolean;
    /**
     * Signs a stake delegation transaction using a private key.
     *
     * This type of transaction allows a user to delegate their
     * funds from one account to another for use in staking. The
     * account that is delegated to is then considered as having these
     * funds when determining whether it can produce a block in a given slot.
     *
     * @param delegation An object describing the stake delegation
     * @param privateKey The private key used to sign the transaction
     * @returns A signed stake delegation
     */
    signStakeDelegation(delegation: Json.StakeDelegation, privateKey: Json.PrivateKey): SignedLegacy<Json.StakeDelegation>;
    /**
     * Verifies a signed stake delegation.
     *
     * @param signedStakeDelegation A signed stake delegation
     * @returns True if the `signedStakeDelegation` is a verifiable stake delegation
     */
    verifyStakeDelegation({ data, signature, publicKey, }: SignedLegacy<Json.StakeDelegation>): boolean;
    /**
     * Compute the hash of a signed payment.
     *
     * @param signedPayment A signed payment transaction
     * @returns A transaction hash
     */
    hashPayment({ data, signature }: SignedLegacy<Json.Payment>, options?: {
        berkeley?: boolean;
    }): string;
    /**
     * Compute the hash of a signed stake delegation.
     *
     * @param signedStakeDelegation A signed stake delegation
     * @returns A transaction hash
     */
    hashStakeDelegation({ data, signature }: SignedLegacy<Json.StakeDelegation>, options?: {
        berkeley?: boolean;
    }): string;
    /**
     * Sign a zkapp command transaction using a private key.
     *
     * This type of transaction allows a user to update state on a given
     * Smart Contract running on Mina.
     *
     * @param zkappCommand An object representing a zkApp transaction
     * @param privateKey The fee payer private key
     * @returns Signed `zkappCommand`
     */
    signZkappCommand({ feePayer: feePayer_, zkappCommand }: Json.ZkappCommand, privateKey: Json.PrivateKey): Signed<Json.ZkappCommand>;
    /**
     * Verifies a signed zkApp transaction.
     *
     * @param signedZkappCommand A signed zkApp transaction
     * @returns True if the signature is valid
     */
    verifyZkappCommand({ data, publicKey, signature, }: Signed<Json.ZkappCommand>): boolean;
    /**
     * Converts a Rosetta signed transaction to a JSON string that is
     * compatible with GraphQL. The JSON string is a representation of
     * a `Signed_command` which is what our GraphQL expects.
     *
     * @param signedRosettaTxn A signed Rosetta transaction
     * @returns A string that represents the JSON conversion of a signed Rosetta transaction`.
     */
    signedRosettaTransactionToSignedCommand(signedRosettaTxn: string): string;
    /**
     * Creates the payload for Rosetta /construction/combine using a response
     * from /construction/payloads.
     *
     * @param signingPayload A payload resulting from /construction/payloads
     * @param privateKey The private key used to sign the transaction
     * @returns A string with the resulting payload for /construction/combine.
     */
    rosettaCombinePayload(signingPayload: Rosetta.UnsignedPayload, privateKey: Json.PrivateKey): {
        network_identifier: {
            blockchain: string; /**
             * Converts a private key that is out of the domain of the Pallas curve to a private key in base58 format that is in the domain by taking the modulus of the private key.
             * This is done to keep backwards compatibility with the previous version of the [client_sdk](https://www.npmjs.com/package/@o1labs/client-sdk), which did the same thing when converting a private key to base58.
             * @param keyBase58 - The private key that is out of the domain of the Pallas curve
             * @returns The private key that is in the domain of the Pallas curve
             * @remarks
             * This function is particularly useful when migrating old keys to be used by the current [mina-signer](https://www.npmjs.com/package/mina-signer) library,
             * which may reject keys that do not fit the domain of the Pallas curve, by performing a modulus operation on the key, it ensures that keys
             * from the older client_sdk can be made compatible.
             */
            network: Json.NetworkId;
        };
        unsigned_transaction: string;
        signatures: {
            hex_bytes: string;
            public_key: {
                hex_bytes: string;
                curve_type: string;
            };
            signature_type: string;
            signing_payload: unknown;
        }[];
    };
    /**
     * Return the hex-encoded format of a valid public key. This will throw an exception if
     * the key is invalid or the conversion fails.
     *
     * @param publicKey A valid public key
     * @returns A string that represents the hex encoding of a public key.
     */
    publicKeyToRaw(publicKeyBase58: string): string;
    /**
     * Signs an arbitrary payload using a private key. This function can sign strings,
     * payments, stake delegations, and zkapp commands. If the payload is unrecognized, an Error
     * is thrown.
     *
     * @param payload A signable payload
     * @param privateKey A private key
     * @returns A signed payload
     */
    signTransaction<T extends Json.SignableData | Json.ZkappCommand>(payload: T, privateKey: Json.PrivateKey): T extends Json.SignableData ? SignedLegacy<T> : Signed<T>;
    /**
     * Verifies a signed payload. The payload can be a string, payment, stake delegation or zkApp transaction.
     * If the payload is unrecognized, an Error is thrown.
     *
     * @param signedPayload A signed payload
     * @returns True if the signature is valid
     */
    verifyTransaction(signed: SignedLegacy<Json.SignableData> | Signed<Json.ZkappCommand>): boolean;
    /**
     * Calculates the minimum fee of a zkapp command transaction. A fee for a zkapp command transaction is
     * the sum of all account updates plus the specified fee amount. If no fee is passed in, `0.001`
     * is used (according to the Mina spec) by default.
     * @param accountUpdates A list of account updates
     * @returns  The fee to be paid by the fee payer accountUpdate
     */
    getAccountUpdateMinimumFee(accountUpdates: TransactionJson.AccountUpdate[]): number;
    /**
     * Creates a nullifier
     *
     * @param message A unique message that belongs to a specific nullifier
     * @param privateKeyBase58 The private key used to create the nullifier
     * @returns A nullifier
     */
    createNullifier(message: bigint[], privateKeyBase58: Json.PrivateKey): Json.Nullifier;
    /**
     * Returns the network ID.
     *
     * @returns {NetworkId} The network ID.
     */
    get networkId(): NetworkId;
}
