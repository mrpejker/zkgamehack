'use strict';

var client = require('@trpc/client');
var unstableCoreDoNotImport = require('@trpc/server/unstable-core-do-not-import');
var cache = require('next/cache');
var notFound = require('next/dist/client/components/not-found');
var redirect = require('next/dist/client/components/redirect');
var React = require('react');
var formDataToObject = require('./formDataToObject.js');
var shared = require('./shared.js');

/// <reference types="next" />
// ts-prune-ignore-next
function experimental_createTRPCNextAppDirServer(opts) {
    const getClient = React.cache(()=>{
        const config = opts.config();
        return client.createTRPCUntypedClient(config);
    });
    return unstableCoreDoNotImport.createRecursiveProxy((callOpts)=>{
        // lazily initialize client
        const client$1 = getClient();
        const pathCopy = [
            ...callOpts.path
        ];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const action = pathCopy.pop();
        const procedurePath = pathCopy.join('.');
        const procedureType = client.clientCallTypeToProcedureType(action);
        const cacheTag = shared.generateCacheTag(procedurePath, callOpts.args[0]);
        if (action === 'revalidate') {
            cache.revalidateTag(cacheTag);
            return;
        }
        return client$1[procedureType](procedurePath, ...callOpts.args);
    });
}
/**
 * Rethrow errors that should be handled by Next.js
 */ const throwNextErrors = (error)=>{
    const { cause  } = error;
    if (redirect.isRedirectError(cause) || notFound.isNotFoundError(cause)) {
        throw error.cause;
    }
};
function experimental_createServerActionHandler(t, opts) {
    const config = t._config;
    const { normalizeFormData =true , createContext , rethrowNextErrors =true ,  } = opts;
    const transformer = config.transformer;
    // TODO allow this to take a `TRouter` in addition to a `AnyProcedure`
    return function createServerAction(proc) {
        return async function actionHandler(rawInput) {
            let ctx = undefined;
            try {
                ctx = await createContext?.() ?? {};
                if (normalizeFormData && shared.isFormData(rawInput)) {
                    // Normalizes FormData so we can use `z.object({})` etc on the server
                    try {
                        rawInput = formDataToObject.formDataToObject(rawInput);
                    } catch  {
                        throw new unstableCoreDoNotImport.TRPCError({
                            code: 'INTERNAL_SERVER_ERROR',
                            message: 'Failed to convert FormData to an object'
                        });
                    }
                } else if (rawInput && !shared.isFormData(rawInput)) {
                    rawInput = transformer.input.deserialize(rawInput);
                }
                const data = proc._def.experimental_caller ? await proc(rawInput) : await proc({
                    input: undefined,
                    ctx,
                    path: '',
                    getRawInput: async ()=>rawInput,
                    type: proc._def.type
                });
                const transformedJSON = unstableCoreDoNotImport.transformTRPCResponse(config, {
                    result: {
                        data
                    }
                });
                return transformedJSON;
            } catch (cause) {
                const error = unstableCoreDoNotImport.getTRPCErrorFromUnknown(cause);
                opts.onError?.({
                    ctx,
                    error,
                    input: rawInput,
                    path: '',
                    type: proc._def.type
                });
                rethrowNextErrors && throwNextErrors(error);
                const shape = unstableCoreDoNotImport.getErrorShape({
                    config,
                    ctx,
                    error,
                    input: rawInput,
                    path: '',
                    type: proc._def.type
                });
                return unstableCoreDoNotImport.transformTRPCResponse(t._config, {
                    error: shape
                });
            }
        };
    };
}
// ts-prune-ignore-next
async function experimental_revalidateEndpoint(req) {
    const { cacheTag  } = await req.json();
    if (typeof cacheTag !== 'string') {
        return new Response(JSON.stringify({
            revalidated: false,
            error: 'cacheTag must be a string'
        }), {
            status: 400
        });
    }
    cache.revalidateTag(cacheTag);
    return new Response(JSON.stringify({
        revalidated: true,
        now: Date.now()
    }), {
        status: 200
    });
}

exports.experimental_createServerActionHandler = experimental_createServerActionHandler;
exports.experimental_createTRPCNextAppDirServer = experimental_createTRPCNextAppDirServer;
exports.experimental_revalidateEndpoint = experimental_revalidateEndpoint;
