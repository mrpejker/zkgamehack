import { Field } from "o1js";
import { log, noop, mapSequential } from "@proto-kit/common";
import { InMemoryStateService } from "@proto-kit/module";
const errors = {
    parentIsUndefined: () => new Error("Parent StateService is undefined"),
};
export class CachedStateService extends InMemoryStateService {
    constructor(parent) {
        super();
        this.parent = parent;
        this.writes = [];
    }
    /**
     * Works like get(), but if a value is in this store,
     * but is known to be empty, this will return null
     */
    getNullAware(key) {
        return this.values[key.toString()];
    }
    assertParentNotNull(parent) {
        if (parent === undefined) {
            throw errors.parentIsUndefined();
        }
    }
    writeStates(entries) {
        this.writes.push(...entries);
    }
    async commit() {
        await mapSequential(this.writes, async ({ key, value }) => {
            await this.set(key, value);
        });
    }
    async openTransaction() {
        noop();
    }
    async preloadKey(key) {
        await this.preloadKeys([key]);
    }
    async preloadKeys(keys) {
        if (this.parent !== undefined) {
            // Only preload it if it hasn't been preloaded previously
            // TODO Not safe for deletes
            const keysToBeLoaded = keys.filter((key) => this.get(key) === undefined);
            const loaded = await this.parent.getMany(keysToBeLoaded);
            log.trace(`Preloaded: ${loaded.map(({ key, value }) => `${key}: ${value?.map((x) => x.toString()) ?? []}`)}`);
            await mapSequential(loaded, async ({ key, value }) => {
                await this.set(key, value);
            });
        }
    }
    async getMany(keys) {
        const remoteKeys = [];
        const local = [];
        keys.forEach((key) => {
            const localValue = this.getNullAware(key);
            if (localValue !== undefined) {
                local.push({ key, value: localValue ?? undefined });
            }
            else {
                remoteKeys.push(key);
            }
        });
        const remote = await this.parent?.getMany(remoteKeys);
        return local.concat(remote ?? []);
    }
    async get(key) {
        const entries = await this.getMany([key]);
        return entries.at(0)?.value;
    }
    /**
     * Merges all caches set() operation into the parent and
     * resets this instance to the parent's state (by clearing the cache and
     * defaulting to the parent)
     */
    async mergeIntoParent() {
        const { parent, values } = this;
        this.assertParentNotNull(parent);
        // Set all cached values on parent
        await parent.openTransaction();
        const writes = Object.entries(values).map(([key, value]) => ({
            key: Field(key),
            value: value ?? undefined,
        }));
        parent.writeStates(writes);
        await parent.commit();
        // Clear cache
        this.values = {};
    }
}
