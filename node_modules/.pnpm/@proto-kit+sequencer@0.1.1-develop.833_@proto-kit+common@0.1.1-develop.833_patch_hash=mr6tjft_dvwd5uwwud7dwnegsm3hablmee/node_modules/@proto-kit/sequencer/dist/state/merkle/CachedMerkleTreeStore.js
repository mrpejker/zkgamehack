import { log, noop, InMemoryMerkleTreeStorage, RollupMerkleTree, } from "@proto-kit/common";
export class CachedMerkleTreeStore extends InMemoryMerkleTreeStorage {
    async openTransaction() {
        noop();
    }
    async commit() {
        noop();
    }
    constructor(parent) {
        super();
        this.parent = parent;
        this.writeCache = {};
    }
    getNode(key, level) {
        return super.getNode(key, level);
    }
    setNode(key, level, value) {
        var _a;
        super.setNode(key, level, value);
        ((_a = this.writeCache)[level] ?? (_a[level] = {}))[key.toString()] = value;
    }
    getWrittenNodes() {
        return this.writeCache;
    }
    resetWrittenNodes() {
        this.writeCache = {};
    }
    collectNodesToFetch(index) {
        // Algo from RollupMerkleTree.getWitness()
        const { leafCount, HEIGHT } = RollupMerkleTree;
        let currentIndex = index >= leafCount ? index % leafCount : index;
        const nodesToRetrieve = [];
        for (let level = 0; level < HEIGHT; level++) {
            const key = currentIndex;
            const isLeft = key % 2n === 0n;
            const siblingKey = isLeft ? key + 1n : key - 1n;
            // Only preload node if it is not already preloaded.
            // We also don't want to overwrite because changes will get lost (tracing)
            if (this.getNode(key, level) === undefined) {
                nodesToRetrieve.push({
                    key,
                    level,
                });
                if (level === 0) {
                    log.trace(`Queued preloading of ${key} @ ${level}`);
                }
            }
            if (this.getNode(siblingKey, level) === undefined) {
                nodesToRetrieve.push({
                    key: siblingKey,
                    level,
                });
            }
            currentIndex /= 2n;
        }
        return nodesToRetrieve;
    }
    async preloadKeys(keys) {
        const nodesToRetrieve = keys.flatMap((key) => this.collectNodesToFetch(key));
        const results = await this.parent.getNodesAsync(nodesToRetrieve);
        nodesToRetrieve.forEach(({ key, level }, index) => {
            const value = results[index];
            if (value !== undefined) {
                this.setNode(key, level, value);
            }
        });
    }
    async preloadKey(index) {
        await this.preloadKeys([index]);
    }
    async mergeIntoParent() {
        // In case no state got set we can skip this step
        if (Object.keys(this.writeCache).length === 0) {
            return;
        }
        await this.parent.openTransaction();
        const nodes = this.getWrittenNodes();
        const writes = Object.keys(nodes).flatMap((levelString) => {
            const level = Number(levelString);
            return Object.entries(nodes[level]).map(([key, value]) => {
                return {
                    key: BigInt(key),
                    level,
                    value,
                };
            });
        });
        this.parent.writeNodes(writes);
        await this.parent.commit();
        this.resetWrittenNodes();
    }
    async setNodeAsync(key, level, value) {
        this.setNode(key, level, value);
    }
    async getNodesAsync(nodes) {
        const results = Array(nodes.length).fill(undefined);
        const toFetch = [];
        nodes.forEach((node, index) => {
            const localResult = this.getNode(node.key, node.level);
            if (localResult !== undefined) {
                results[index] = localResult;
            }
            else {
                toFetch.push(node);
            }
        });
        // Reverse here, so that we can use pop() later
        const fetchResult = (await this.parent.getNodesAsync(toFetch)).reverse();
        results.forEach((result, index) => {
            if (result === undefined) {
                results[index] = fetchResult.pop();
            }
        });
        return results;
    }
    writeNodes(nodes) {
        nodes.forEach(({ key, level, value }) => {
            this.setNode(key, level, value);
        });
    }
}
