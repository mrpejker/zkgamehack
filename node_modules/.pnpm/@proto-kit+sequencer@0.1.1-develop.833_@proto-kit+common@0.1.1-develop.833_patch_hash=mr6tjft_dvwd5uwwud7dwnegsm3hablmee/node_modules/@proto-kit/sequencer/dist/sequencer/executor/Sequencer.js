var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sequencer_1;
import { ModuleContainer, log, } from "@proto-kit/common";
import { MethodIdFactory, } from "@proto-kit/module";
import { injectable } from "tsyringe";
export let Sequencer = Sequencer_1 = class Sequencer extends ModuleContainer {
    /**
     * Alternative constructor for Sequencer
     * @param definition
     * @returns Sequencer
     */
    static from(definition) {
        return class ScopedSequencer extends Sequencer_1 {
            constructor() {
                super(definition);
            }
        };
    }
    get runtime() {
        return this.container.resolve("Runtime");
    }
    get protocol() {
        return this.container.resolve("Protocol");
    }
    get dependencyContainer() {
        return this.container;
    }
    /**
     * Starts the sequencer by iterating over all provided
     * modules to start each
     */
    async start() {
        // Set default STWitnessProvider inside protocol
        // eslint-disable-next-line max-len
        // TODO But what is the default? How do we deal with stages states (i.e. simulated state) in the DI container?
        // const witnessProviderReference = this.protocol.dependencyContainer
        // .resolve(
        //   StateTransitionWitnessProviderReference
        // );
        // const witnessProvider =
        //   this.container.resolve<StateTransitionWitnessProvider>(
        //     "StateTransitionWitnessProvider"
        //   );
        // witnessProviderReference.setWitnessProvider(witnessProvider);
        this.useDependencyFactory(this.container.resolve(MethodIdFactory));
        // Log startup info
        const moduleClassNames = Object.values(this.definition.modules).map((clazz) => clazz.name);
        log.info("Starting sequencer...");
        log.info("Modules:", moduleClassNames);
        // eslint-disable-next-line guard-for-in
        for (const moduleName in this.definition.modules) {
            const sequencerModule = this.resolve(moduleName);
            log.info(`Starting sequencer module ${moduleName} (${sequencerModule.constructor.name})`);
            // eslint-disable-next-line no-await-in-loop
            await sequencerModule.start();
        }
    }
};
Sequencer = Sequencer_1 = __decorate([
    injectable()
], Sequencer);
