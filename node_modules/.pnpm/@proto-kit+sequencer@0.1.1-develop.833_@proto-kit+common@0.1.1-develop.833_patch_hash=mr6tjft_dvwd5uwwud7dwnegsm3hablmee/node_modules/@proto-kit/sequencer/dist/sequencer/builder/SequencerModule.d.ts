import { ConfigurableModule, StaticConfigurableModule, TypedClass, Presets, NoConfig } from "@proto-kit/common";
/**
 * Lifecycle of a SequencerModule
 *
 * start(): Executed to execute any logic required to start the module
 */
export declare abstract class SequencerModule<Config = NoConfig> extends ConfigurableModule<Config> {
    static presets: Presets<unknown>;
    /**
     * Start the module and all it's functionality.
     * The returned Promise has to resolve after initialization,
     * since it will block in the sequencer init.
     * That means that you mustn't await server.start() for example.
     */
    abstract start(): Promise<void>;
}
/**
 * Marks the decorated class as a runtime module, while also
 * making it injectable with our dependency injection solution.
 */
export declare function sequencerModule(): (target: StaticConfigurableModule<unknown> & TypedClass<SequencerModule<unknown>>) => void;
//# sourceMappingURL=SequencerModule.d.ts.map