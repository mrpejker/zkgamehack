var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable } from "tsyringe";
import { Runtime, } from "@proto-kit/module";
import { Path, Withdrawal } from "@proto-kit/protocol";
import { Field } from "o1js";
import { SettlementModule } from "../SettlementModule";
import { SequencerModule } from "../../sequencer/builder/SequencerModule";
import { Sequencer } from "../../sequencer/executor/Sequencer";
export let WithdrawalQueue = class WithdrawalQueue extends SequencerModule {
    constructor(runtime, sequencer) {
        super();
        this.runtime = runtime;
        this.sequencer = sequencer;
        this.lockedQueue = [];
        this.unlockedQueue = [];
        this.outgoingWithdrawalIds = [];
        this.currentIndex = 0;
    }
    peek(num) {
        return this.unlockedQueue.slice(0, num);
    }
    pop(num) {
        const slice = this.peek(num);
        this.unlockedQueue = this.unlockedQueue.slice(num);
        return slice;
    }
    length() {
        return this.unlockedQueue.length;
    }
    async start() {
        // Hacky workaround for this cyclic dependency
        const settlementModule = this.sequencer.resolveOrFail("SettlementModule", SettlementModule);
        const resolver = this.runtime.dependencyContainer.resolve("MethodIdResolver");
        const [withdrawalModule, withdrawalMethod] = settlementModule
            .getSettlementModuleConfig()
            .withdrawalMethodPath.split(".");
        const methodId = resolver.getMethodId(withdrawalModule, withdrawalMethod);
        this.outgoingWithdrawalIds = [methodId];
        // TODO Very primitive and error-prone, wait for runtime events
        // TODO Replace by stateservice call?
        if (settlementModule.addresses !== undefined) {
            const { settlement } = settlementModule.getContracts();
            this.currentIndex = Number(settlement.outgoingMessageCursor.get().toBigInt());
        }
        this.sequencer.events.on("block-produced", (block) => {
            this.lockedQueue.push(block);
        });
        settlementModule.events.on("settlement-submitted", (batch) => {
            // TODO After persistance PR, link the blocks with the batch based on the ids
            // TODO After runtime events, use those
            const withdrawals = this.lockedQueue.flatMap((block) => {
                const [withdrawalModule2, withdrawalStatePath] = settlementModule
                    .getSettlementModuleConfig()
                    .withdrawalStatePath.split(".");
                const path = Path.fromProperty(withdrawalModule2, withdrawalStatePath);
                return block.transactions
                    .filter((tx) => this.outgoingWithdrawalIds.includes(tx.tx.methodId.toBigInt()) &&
                    tx.status.toBoolean())
                    .map((tx) => {
                    const thisPath = Path.fromKey(path, Field, Field(this.currentIndex));
                    const fields = tx.stateTransitions
                        .filter((value) => value.path.equals(thisPath).toBoolean())
                        .at(-1)?.toValue.value;
                    const withdrawal = Withdrawal.fromFields(fields);
                    return {
                        // eslint-disable-next-line no-plusplus
                        index: this.currentIndex++,
                        value: withdrawal,
                    };
                });
            });
            this.unlockedQueue.push(...withdrawals);
            this.lockedQueue = [];
        });
    }
};
WithdrawalQueue = __decorate([
    injectable(),
    __param(0, inject("Runtime")),
    __param(1, inject("Sequencer")),
    __metadata("design:paramtypes", [Runtime,
        Sequencer])
], WithdrawalQueue);
