var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable } from "tsyringe";
import { Field, Poseidon, PrivateKey, Signature, UInt32, UInt64, } from "o1js";
import { Runtime, MethodParameterEncoder, } from "@proto-kit/module";
import { EMPTY_PUBLICKEY, mapSequential } from "@proto-kit/common";
import { RuntimeTransaction } from "@proto-kit/protocol";
import { PendingTransaction } from "../../mempool/PendingTransaction";
/**
 * IncomingMessageAdapter implementation for a Mina Baselayer
 * based on decoding L1-dispatched actions
 */
export let MinaIncomingMessageAdapter = class MinaIncomingMessageAdapter {
    constructor(baseLayer, runtime) {
        this.baseLayer = baseLayer;
        this.runtime = runtime;
    }
    async mapActionToTransactions(tx, fieldArgs) {
        const { methodId } = tx;
        const methodPointer = this.runtime.methodIdResolver.getMethodNameFromId(methodId.toBigInt());
        if (methodPointer === undefined) {
            throw new Error(`Runtime method with methodId ${methodId} doesn't exist`);
        }
        const [moduleName, methodName] = methodPointer;
        const module = this.runtime.resolve(moduleName);
        const methodEncoder = MethodParameterEncoder.fromMethod(module, methodName);
        // The reason why auxiliary is empty here, is that proof verification in the case
        // of incoming messages has to happen on the L1 for multiple reasons.
        const args = await methodEncoder.decode(fieldArgs, []);
        const { fields, auxiliary } = methodEncoder.encode(args);
        return new PendingTransaction({
            methodId,
            sender: EMPTY_PUBLICKEY,
            nonce: UInt64.zero,
            signature: Signature.create(PrivateKey.random(), [Field(0)]),
            argsFields: fields,
            auxiliaryData: auxiliary,
            isMessage: true,
        });
    }
    async getPendingMessages(address, params) {
        const { network } = this.baseLayer;
        if (network === undefined) {
            throw new Error("Network hasn't been set for settlement");
        }
        if (address === undefined) {
            throw new Error("L1 contract hasn't been deployed yet");
        }
        const actions = await network.fetchActions(address, {
            fromActionState: Field(params.fromActionHash),
            // TODO Somehow that doesn't work on localBlockchain
            // endActionState: params.toActionHash
            //   ? Field(params.toActionHash)
            //   : undefined,
        });
        const events = await network.fetchEvents(address, undefined, {
            from: UInt32.from(Math.max(params.fromL1Block - 5, 0)),
        });
        if ("error" in actions) {
            throw new Error(`Error ${actions.error.statusCode}: ${actions.error.statusText}`);
        }
        const messages = await mapSequential(actions, async (action) => {
            // Find events corresponding to the transaction to get the raw args
            const tx = RuntimeTransaction.fromHashData(action.actions[0].map((x) => Field(x)));
            const correspondingEvent = events
                .map((event) => {
                return event.events.find((event2) => {
                    return Poseidon.hash(event2.data.map((x) => Field(x))).equals(tx.argsHash);
                });
            })
                .find((x) => x !== undefined);
            if (correspondingEvent === undefined) {
                throw new Error("Couldn't find events corresponding to action");
            }
            const args = correspondingEvent.data.map((x) => Field(x));
            return await this.mapActionToTransactions(tx, args);
        });
        return {
            messages,
            from: params.fromActionHash,
            to: params.toActionHash ?? "0",
        };
    }
};
MinaIncomingMessageAdapter = __decorate([
    injectable(),
    __param(0, inject("BaseLayer")),
    __param(1, inject("Runtime")),
    __metadata("design:paramtypes", [Function, Runtime])
], MinaIncomingMessageAdapter);
