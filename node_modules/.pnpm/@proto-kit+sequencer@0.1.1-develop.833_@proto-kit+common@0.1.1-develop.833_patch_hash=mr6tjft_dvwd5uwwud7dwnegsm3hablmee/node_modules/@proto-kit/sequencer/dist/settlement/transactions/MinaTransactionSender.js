var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable } from "tsyringe";
import { FlowCreator } from "../../worker/flow/Flow";
import { SettlementProvingTask, } from "../tasks/SettlementProvingTask";
import { MinaTransactionSimulator } from "./MinaTransactionSimulator";
export let MinaTransactionSender = class MinaTransactionSender {
    constructor(creator, provingTask, simulator, baseLayer) {
        this.creator = creator;
        this.provingTask = provingTask;
        this.simulator = simulator;
        this.baseLayer = baseLayer;
        this.txQueue = {};
        // TODO Persist
        this.cache = [];
    }
    async trySendCached(tx) {
        const feePayer = tx.transaction.feePayer.body;
        const sender = feePayer.publicKey.toBase58();
        const senderQueue = this.txQueue[sender];
        const sendable = senderQueue.at(0) === Number(feePayer.nonce.toString());
        if (sendable) {
            const txId = await tx.send();
            senderQueue.pop();
            return txId;
        }
        return undefined;
    }
    async resolveCached() {
        const indizesToRemove = [];
        for (let i = 0; i < this.cache.length; i++) {
            // eslint-disable-next-line no-await-in-loop
            const result = await this.trySendCached(this.cache[i]);
            if (result !== undefined) {
                indizesToRemove.push(i);
            }
        }
        this.cache = this.cache.filter((ignored, index) => !indizesToRemove.includes(index));
        return indizesToRemove.length;
    }
    async sendOrQueue(tx) {
        this.cache.push(tx);
        let removedLastIteration = 0;
        do {
            // eslint-disable-next-line no-await-in-loop
            removedLastIteration = await this.resolveCached();
        } while (removedLastIteration > 0);
    }
    async proveAndSendTransaction(transaction) {
        var _a, _b;
        const { publicKey, nonce } = transaction.transaction.feePayer.body;
        // Add Transaction to sender's queue
        ((_a = this.txQueue)[_b = publicKey.toBase58()] ?? (_a[_b] = [])).push(Number(nonce.toString()));
        const flow = this.creator.createFlow(`tx-${publicKey.toBase58()}-${nonce.toString()}`, {});
        const accounts = await this.simulator.getAccounts(transaction);
        await this.simulator.applyTransaction(transaction);
        const resultPromise = flow.withFlow(async (resolve, reject) => {
            await flow.pushTask(this.provingTask, {
                transaction,
                chainState: {
                    graphql: this.baseLayer.config.network.graphql,
                    accounts,
                },
            }, async (result) => {
                resolve(result);
            });
        });
        const result = await resultPromise;
        await this.sendOrQueue(result.transaction);
    }
};
MinaTransactionSender = __decorate([
    injectable(),
    __param(3, inject("BaseLayer")),
    __metadata("design:paramtypes", [FlowCreator,
        SettlementProvingTask,
        MinaTransactionSimulator, Function])
], MinaTransactionSender);
