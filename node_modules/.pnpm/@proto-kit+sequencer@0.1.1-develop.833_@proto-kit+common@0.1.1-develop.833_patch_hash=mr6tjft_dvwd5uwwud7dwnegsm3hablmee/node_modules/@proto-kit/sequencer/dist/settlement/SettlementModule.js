var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Protocol, BATCH_SIGNATURE_PREFIX, Path, OutgoingMessageArgument, OutgoingMessageArgumentBatch, OUTGOING_MESSAGE_BATCH_SIZE, } from "@proto-kit/protocol";
import { AccountUpdate, Field, Mina, Signature, Permissions, } from "o1js";
import { inject } from "tsyringe";
import { EventEmitter, log, noop, RollupMerkleTree, } from "@proto-kit/common";
import { Runtime } from "@proto-kit/module";
import { SequencerModule, sequencerModule, } from "../sequencer/builder/SequencerModule";
import { FlowCreator } from "../worker/flow/Flow";
import { CachedMerkleTreeStore } from "../state/merkle/CachedMerkleTreeStore";
import { BlockProofSerializer } from "../protocol/production/helpers/BlockProofSerializer";
import { MinaTransactionSender } from "./transactions/MinaTransactionSender";
export let SettlementModule = class SettlementModule extends SequencerModule {
    constructor(baseLayer, protocol, runtime, flowCreator, incomingMessagesAdapter, messageStorage, settlementStorage, outgoingMessageQueue, merkleTreeStore, blockProofSerializer, transactionSender) {
        super();
        this.baseLayer = baseLayer;
        this.protocol = protocol;
        this.runtime = runtime;
        this.flowCreator = flowCreator;
        this.incomingMessagesAdapter = incomingMessagesAdapter;
        this.messageStorage = messageStorage;
        this.settlementStorage = settlementStorage;
        this.outgoingMessageQueue = outgoingMessageQueue;
        this.merkleTreeStore = merkleTreeStore;
        this.blockProofSerializer = blockProofSerializer;
        this.transactionSender = transactionSender;
        this.events = new EventEmitter();
    }
    settlementContractModule() {
        return this.protocol.dependencyContainer.resolve("SettlementContractModule");
    }
    getSettlementModuleConfig() {
        if (this.settlementModuleConfig === undefined) {
            const settlementContractModule = this.settlementContractModule();
            this.settlementModuleConfig =
                settlementContractModule.resolve("SettlementContract").config;
            if (this.settlementModuleConfig === undefined) {
                throw new Error("Failed to fetch config from SettlementContract");
            }
        }
        return this.settlementModuleConfig;
    }
    getContracts() {
        if (this.contracts === undefined) {
            const { addresses, protocol } = this;
            if (addresses === undefined) {
                throw new Error("Settlement Contract hasn't been deployed yet. Deploy it first, then restart");
            }
            const settlementContractModule = protocol.dependencyContainer.resolve("SettlementContractModule");
            // TODO Add generic inference of concrete Contract types
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            this.contracts = settlementContractModule.createContracts(addresses);
        }
        return this.contracts;
    }
    /* eslint-disable no-await-in-loop */
    async sendRollupTransactions(options) {
        const length = this.outgoingMessageQueue.length();
        const { feepayer } = this.config;
        let { nonce } = options;
        const txs = [];
        const { settlement } = this.getContracts();
        const cachedStore = new CachedMerkleTreeStore(this.merkleTreeStore);
        const tree = new RollupMerkleTree(cachedStore);
        const [withdrawalModule, withdrawalStateName] = this.getSettlementModuleConfig().withdrawalStatePath.split(".");
        const basePath = Path.fromProperty(withdrawalModule, withdrawalStateName);
        for (let i = 0; i < length; i += OUTGOING_MESSAGE_BATCH_SIZE) {
            const batch = this.outgoingMessageQueue.peek(OUTGOING_MESSAGE_BATCH_SIZE);
            const keys = batch.map((x) => Path.fromKey(basePath, Field, Field(x.index)));
            // Preload keys
            await cachedStore.preloadKeys(keys.map((key) => key.toBigInt()));
            const transactionParamaters = batch.map((message, index) => {
                const witness = tree.getWitness(keys[index].toBigInt());
                return new OutgoingMessageArgument({
                    witness,
                    value: message.value,
                });
            });
            const tx = await Mina.transaction({
                sender: feepayer.toPublicKey(),
                // eslint-disable-next-line no-plusplus
                nonce: nonce++,
                fee: String(0.01 * 1e9),
                memo: "Protokit settle",
            }, async () => {
                await settlement.rollupOutgoingMessages(OutgoingMessageArgumentBatch.fromMessages(transactionParamaters));
            });
            const signedTx = tx.sign([feepayer]);
            await this.transactionSender.proveAndSendTransaction(signedTx);
            this.outgoingMessageQueue.pop(OUTGOING_MESSAGE_BATCH_SIZE);
            txs.push({
                tx: signedTx,
            });
        }
        return txs;
    }
    /* eslint-enable no-await-in-loop */
    async settleBatch(batch, options = {}) {
        const { settlement, dispatch } = this.getContracts();
        const { feepayer } = this.config;
        log.debug("Preparing settlement");
        const lastSettlementL1Block = settlement.lastSettlementL1Block.get().value;
        const signature = Signature.create(feepayer, [
            BATCH_SIGNATURE_PREFIX,
            lastSettlementL1Block,
        ]);
        const fromSequenceStateHash = dispatch.honoredMessagesHash.get();
        const latestSequenceStateHash = settlement.account.actionState.get();
        // Fetch actions and store them into the messageStorage
        const actions = await this.incomingMessagesAdapter.getPendingMessages(settlement.address, {
            fromActionHash: fromSequenceStateHash.toString(),
            toActionHash: latestSequenceStateHash.toString(),
            fromL1Block: Number(lastSettlementL1Block.toString()),
        });
        await this.messageStorage.pushMessages(actions.from, actions.to, actions.messages);
        const blockProof = await this.blockProofSerializer
            .getBlockProofSerializer()
            .fromJSONProof(batch.proof);
        const tx = await Mina.transaction({
            sender: feepayer.toPublicKey(),
            nonce: options?.nonce,
            fee: String(0.01 * 1e9),
            memo: "Protokit settle",
        }, async () => {
            await settlement.settle(blockProof, signature, dispatch.address, feepayer.toPublicKey(), batch.fromNetworkState, batch.toNetworkState, latestSequenceStateHash);
        });
        tx.sign([feepayer]);
        await this.transactionSender.proveAndSendTransaction(tx);
        log.info("Settlement transaction send queued");
        this.events.emit("settlement-submitted", batch);
        return {
            // transactionHash: sent.hash() ?? "",
            batches: [batch.height],
            promisedMessagesHash: latestSequenceStateHash.toString(),
        };
    }
    async deploy(settlementKey, dispatchKey, options = {}) {
        const feepayerKey = this.config.feepayer;
        const feepayer = feepayerKey.toPublicKey();
        const nonce = options?.nonce ?? 0;
        // const flow = this.flowCreator.createFlow<undefined>(
        //   `deploy-${feepayer.toBase58()}-${nonce.toString()}`,
        //   undefined
        // );
        const sm = this.protocol.dependencyContainer.resolve("SettlementContractModule");
        const { settlement, dispatch } = sm.createContracts({
            settlement: settlementKey.toPublicKey(),
            dispatch: dispatchKey.toPublicKey(),
        });
        const tx = await Mina.transaction({
            sender: feepayer,
            nonce,
            fee: String(0.01 * 1e9),
            memo: "Protokit settlement deploy",
        }, async () => {
            AccountUpdate.fundNewAccount(feepayer, 2);
            await settlement.deploy({
                verificationKey: undefined,
            });
            settlement.account.permissions.set({
                ...Permissions.default(),
                access: Permissions.none(),
            });
            await dispatch.deploy({
                verificationKey: undefined,
            });
        }).sign([feepayerKey, settlementKey, dispatchKey]);
        // This should already apply the tx result to the
        // cached accounts / local blockchain
        await this.transactionSender.proveAndSendTransaction(tx);
        const tx2 = await Mina.transaction({
            sender: feepayer,
            nonce: nonce + 1,
            fee: String(0.01 * 1e9),
            memo: "Protokit settlement init",
        }, async () => {
            await settlement.initialize(feepayerKey.toPublicKey(), dispatchKey.toPublicKey());
        }).sign([feepayerKey]);
        await this.transactionSender.proveAndSendTransaction(tx2);
        this.addresses = {
            settlement: settlementKey.toPublicKey(),
            dispatch: dispatchKey.toPublicKey(),
        };
    }
    async start() {
        noop();
    }
};
SettlementModule = __decorate([
    sequencerModule(),
    __param(0, inject("BaseLayer")),
    __param(1, inject("Protocol")),
    __param(2, inject("Runtime")),
    __param(4, inject("IncomingMessageAdapter")),
    __param(5, inject("MessageStorage")),
    __param(6, inject("SettlementStorage")),
    __param(7, inject("OutgoingMessageQueue")),
    __param(8, inject("AsyncMerkleStore")),
    __param(10, inject("TransactionSender")),
    __metadata("design:paramtypes", [Function, Protocol,
        Runtime,
        FlowCreator, Object, Object, Object, Object, Object, BlockProofSerializer,
        MinaTransactionSender])
], SettlementModule);
