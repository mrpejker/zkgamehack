import { log } from "@proto-kit/common";
const errors = {
    notComputable: (name) => new Error(`Task ${name} not computable on selected worker`),
};
// Had to use any here, because otherwise you couldn't assign any tasks to it
export class FlowTaskWorker {
    constructor(mq, tasks) {
        this.tasks = tasks;
        this.workers = [];
        this.queue = mq;
    }
    // The array type is this weird, because we first want to extract the
    // element type, and after that, we expect multiple elements of that -> []
    initHandler(task) {
        const queueName = task.name;
        return this.queue.createWorker(queueName, async (data) => {
            log.debug(`Received task in queue ${queueName}`);
            try {
                // Use first handler that returns a non-undefined result
                const input = await task.inputSerializer().fromJSON(data.payload);
                const output = await task.compute(input);
                if (output === undefined) {
                    throw errors.notComputable(data.name);
                }
                const result = {
                    status: "success",
                    taskId: data.taskId,
                    flowId: data.flowId,
                    name: data.name,
                    payload: await task.resultSerializer().toJSON(output),
                };
                return result;
            }
            catch (error) {
                const payload = error instanceof Error ? error.message : JSON.stringify(error);
                return {
                    status: "error",
                    taskId: data.taskId,
                    flowId: data.flowId,
                    name: data.name,
                    payload,
                };
            }
        });
    }
    async start() {
        // Call all task's prepare() method
        // Call them in order of registration, because the prepare methods
        // might depend on each other or a result that is saved in a DI singleton
        for (const task of this.tasks) {
            // eslint-disable-next-line no-await-in-loop
            await task.prepare();
        }
        this.workers = this.tasks.map((task) => this.initHandler(task));
    }
    async close() {
        await Promise.all(this.workers.map(async (worker) => {
            await worker.close();
        }));
    }
}
