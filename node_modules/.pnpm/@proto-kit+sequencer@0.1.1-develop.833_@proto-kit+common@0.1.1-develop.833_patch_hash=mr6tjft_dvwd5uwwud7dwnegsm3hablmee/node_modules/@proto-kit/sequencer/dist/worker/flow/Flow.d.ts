import { Closeable, InstantiatedQueue, TaskQueue } from "../queue/TaskQueue";
import { Task, TaskPayload } from "./Task";
export declare class ConnectionHolder implements Closeable {
    private readonly queueImpl;
    private queues;
    private listeners;
    constructor(queueImpl: TaskQueue);
    registerListener(flowId: string, queue: string, listener: (payload: TaskPayload) => Promise<void>): void;
    unregisterListener(flowId: string, queue: string): void;
    private openQueue;
    private onCompleted;
    getQueue(name: string): Promise<InstantiatedQueue>;
    close(): Promise<void>;
}
interface CompletedCallback<Input, Result> {
    (result: Result, originalInput: Input): Promise<any>;
}
export declare class Flow<State> implements Closeable {
    private readonly connectionHolder;
    readonly flowId: string;
    state: State;
    private erroredOut;
    private readonly registeredListeners;
    private resultsPending;
    private taskCounter;
    private resolveFunction?;
    private errorFunction?;
    tasksInProgress: number;
    constructor(connectionHolder: ConnectionHolder, flowId: string, state: State);
    private waitForResult;
    resolve<Result>(result: Result): void;
    reject(error: Error): void;
    private resolveResponse;
    pushTask<Input, Result>(task: Task<Input, Result>, input: Input, completed?: CompletedCallback<Input, Result>, overrides?: {
        taskName?: string;
    }): Promise<void>;
    forEach<Type>(inputs: Type[], fun: (input: Type, index: number, array: Type[]) => Promise<void>): Promise<void>;
    withFlow<Result>(executor: (resolve: (result: Result) => void, reject: (reason: any) => void) => Promise<void>): Promise<Result>;
    close(): Promise<void>;
}
export declare class FlowCreator {
    private readonly connectionHolder;
    constructor(connectionHolder: ConnectionHolder);
    createFlow<State>(flowId: string, state: State): Flow<State>;
}
export {};
//# sourceMappingURL=Flow.d.ts.map