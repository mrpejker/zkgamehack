import { log, noop } from "@proto-kit/common";
import { SequencerModule } from "../../sequencer/builder/SequencerModule";
async function sleep(ms) {
    await new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
export class LocalTaskQueue extends SequencerModule {
    constructor() {
        super(...arguments);
        this.queues = {};
        this.workers = {};
        this.listeners = {};
    }
    workNextTasks() {
        Object.entries(this.queues).forEach((queue) => {
            const [queueName, tasks] = queue;
            if (tasks.length > 0) {
                tasks.forEach((task) => {
                    // Execute task in worker
                    void this.workers[queueName].handler(task.payload).then((payload) => {
                        log.trace("LocalTaskQueue got", JSON.stringify(payload));
                        // Notify listeners about result
                        const listenerPromises = this.listeners[queueName].map(async (listener) => {
                            await listener(payload);
                        });
                        void Promise.all(listenerPromises);
                    });
                });
            }
            this.queues[queue[0]] = [];
        });
    }
    createWorker(queueName, executor) {
        this.workers[queueName] = {
            busy: false,
            handler: async (data) => {
                await sleep(this.config.simulatedDuration ?? 0);
                return await executor(data);
            },
        };
        this.workNextTasks();
        return {
            close: async () => {
                noop();
            },
        };
    }
    async getQueue(queueName) {
        this.queues[queueName] = [];
        let id = 0;
        return {
            name: queueName,
            addTask: async (payload) => {
                id += 1;
                const nextId = String(id).toString();
                this.queues[queueName].push({ payload, taskId: nextId });
                this.workNextTasks();
                return { taskId: nextId };
            },
            onCompleted: async (listener) => {
                var _a;
                ((_a = this.listeners)[queueName] ?? (_a[queueName] = [])).push(listener);
            },
            close: async () => {
                noop();
            },
        };
    }
    async start() {
        noop();
    }
}
