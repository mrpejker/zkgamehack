var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable, Lifecycle, scoped } from "tsyringe";
import { log } from "@proto-kit/common";
const errors = {
    resolveNotDefined: () => new Error("The resolve callback has not been initialized yet. Call .withFlow() first!"),
};
export let ConnectionHolder = class ConnectionHolder {
    constructor(queueImpl) {
        this.queueImpl = queueImpl;
        this.queues = {};
        this.listeners = {};
    }
    registerListener(flowId, queue, listener) {
        if (this.listeners[queue] === undefined) {
            this.listeners[queue] = {};
        }
        this.listeners[queue][flowId] = listener;
    }
    unregisterListener(flowId, queue) {
        delete this.listeners[queue][flowId];
    }
    async openQueue(name) {
        const queue = await this.queueImpl.getQueue(name);
        await queue.onCompleted(async (payload) => {
            await this.onCompleted(name, payload);
        });
        return queue;
    }
    async onCompleted(name, payload) {
        const listener = this.listeners[name]?.[payload.flowId];
        if (listener !== undefined) {
            await listener(payload);
        }
    }
    async getQueue(name) {
        if (this.queues[name] !== undefined) {
            return this.queues[name];
        }
        const queue = await this.openQueue(name);
        this.queues[name] = queue;
        return queue;
    }
    async close() {
        // TODO
    }
};
ConnectionHolder = __decorate([
    injectable()
    // ResolutionScoped => We want a new instance every time we resolve it
    ,
    scoped(Lifecycle.ResolutionScoped),
    __param(0, inject("TaskQueue")),
    __metadata("design:paramtypes", [Object])
], ConnectionHolder);
export class Flow {
    constructor(connectionHolder, flowId, state) {
        this.connectionHolder = connectionHolder;
        this.flowId = flowId;
        this.state = state;
        // Indicates whether this flow has received one error and has
        // therefore cancelled
        this.erroredOut = false;
        this.registeredListeners = [];
        this.resultsPending = {};
        this.taskCounter = 0;
        this.tasksInProgress = 0;
    }
    waitForResult(queue, taskId, callback) {
        this.resultsPending[taskId] = callback;
        if (!this.registeredListeners.includes(queue)) {
            // Open Listener onto Connectionhandler
            this.connectionHolder.registerListener(this.flowId, queue, async (payload) => {
                await this.resolveResponse(payload);
            });
            this.registeredListeners.push(queue);
        }
    }
    resolve(result) {
        if (this.resolveFunction === undefined) {
            throw errors.resolveNotDefined();
        }
        this.resolveFunction(result);
    }
    reject(error) {
        this.erroredOut = true;
        this.errorFunction?.(error);
    }
    async resolveResponse(response) {
        if (response.taskId !== undefined) {
            const resolveFunction = this.resultsPending[response.taskId];
            if (!this.erroredOut) {
                if (response.status === "error") {
                    this.reject(new Error(`Error in worker: ${response.payload}, task: ${response.flowId}:${response.taskId}`));
                    return;
                }
                if (resolveFunction !== undefined) {
                    delete this.resultsPending[response.taskId];
                    await resolveFunction(response);
                }
            }
        }
    }
    async pushTask(task, input, completed, overrides) {
        const queueName = task.name;
        const taskName = overrides?.taskName ?? task.name;
        const queue = await this.connectionHolder.getQueue(queueName);
        const payload = await task.inputSerializer().toJSON(input);
        this.taskCounter += 1;
        const taskId = String(this.taskCounter);
        log.trace(`Pushing task ${task.name}`);
        await queue.addTask({
            name: taskName,
            taskId,
            flowId: this.flowId,
            payload,
        });
        this.tasksInProgress += 1;
        const callback = async (returnPayload) => {
            log.trace(`Completed ${returnPayload.name}, task: ${returnPayload.flowId}:${returnPayload?.taskId ?? "-"}`);
            const decoded = await task
                .resultSerializer()
                .fromJSON(returnPayload.payload);
            this.tasksInProgress -= 1;
            return await completed?.(decoded, input);
        };
        this.waitForResult(queueName, taskId, callback);
    }
    async forEach(inputs, fun) {
        const promises = inputs.map(fun);
        await Promise.all(promises);
    }
    async withFlow(executor) {
        return await new Promise((resolve, reject) => {
            this.resolveFunction = resolve;
            this.errorFunction = reject;
            void executor(resolve, reject);
        });
    }
    async close() {
        this.registeredListeners.forEach((queue) => {
            this.connectionHolder.unregisterListener(this.flowId, queue);
        });
    }
}
export let FlowCreator = class FlowCreator {
    constructor(connectionHolder) {
        this.connectionHolder = connectionHolder;
    }
    createFlow(flowId, state) {
        return new Flow(this.connectionHolder, flowId, state);
    }
};
FlowCreator = __decorate([
    injectable(),
    __metadata("design:paramtypes", [ConnectionHolder])
], FlowCreator);
