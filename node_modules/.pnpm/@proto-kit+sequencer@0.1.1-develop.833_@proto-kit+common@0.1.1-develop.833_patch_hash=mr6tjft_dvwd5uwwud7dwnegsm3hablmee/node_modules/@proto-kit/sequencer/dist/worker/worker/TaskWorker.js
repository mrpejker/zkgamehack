import groupBy from "lodash/groupBy";
import { log } from "@proto-kit/common";
import { TASKS_REDUCE_SUFFIX } from "../manager/MapReduceFlow";
const errors = {
    notComputable: (name) => new Error(`Task ${name} not computable on selected worker`),
};
export class TaskWorker {
    constructor(mq) {
        this.tasks = [];
        this.workers = [];
        this.queue = mq;
    }
    addReducableTask(queue, task) {
        this.tasks.push({
            queue,
            task,
            handler: async (payload) => {
                if (payload.name === `${task.name()}${TASKS_REDUCE_SUFFIX}`) {
                    return await this.doReduceStep(task, payload);
                }
                return undefined;
            },
        });
    }
    addMapReduceTask(queue, task) {
        this.tasks.push({
            queue,
            task,
            handler: async (payload) => {
                if (payload.name === task.name()) {
                    return await this.doMapStep(task, payload);
                }
                if (payload.name === `${task.name()}${TASKS_REDUCE_SUFFIX}`) {
                    return await this.doReduceStep(task, payload);
                }
                return undefined;
            },
        });
    }
    addMapTask(queue, task) {
        this.tasks.push({
            queue,
            task,
            handler: async (payload) => {
                if (payload.name === task.name()) {
                    return await this.doMapStep(task, payload);
                }
                return undefined;
            },
        });
    }
    // The array type is this weird, because we first want to extract the
    // element type, and after that, we expect multiple elements of that -> []
    initHandler(queueName, tasks) {
        return this.queue.createWorker(queueName, async (data) => {
            log.trace(`Received task in queue ${queueName}`);
            // Use first handler that returns a non-undefined result
            let result;
            for (const task of tasks) {
                // eslint-disable-next-line no-await-in-loop
                const candidate = await task.handler(data);
                if (candidate !== undefined) {
                    result = candidate;
                    break;
                }
            }
            if (result === undefined) {
                throw errors.notComputable(data.name);
            }
            return result;
        });
    }
    async doReduceStep(task, payload) {
        // Here we only need the resultSerializer, because reducing is a function
        // of type ([Result, Result]) => Result
        const serializer = task.resultSerializer();
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const payloadArray = JSON.parse(payload.payload);
        const r1 = serializer.fromJSON(payloadArray[0]);
        const r2 = serializer.fromJSON(payloadArray[1]);
        const result = await task.reduce(r1, r2);
        return {
            name: payload.name,
            payload: serializer.toJSON(result),
            taskId: payload.taskId,
            flowId: payload.flowId,
        };
    }
    async doMapStep(task, payload) {
        const input = task.inputSerializer().fromJSON(payload.payload);
        const result = await task.map(input);
        return {
            name: payload.name,
            payload: task.resultSerializer().toJSON(result),
            taskId: payload.taskId,
            flowId: payload.flowId,
        };
    }
    async start() {
        // Call all task's prepare() method
        // Call them in order of registration, because the prepare methods
        // might depend on each other or a result that is saved in a DI singleton
        for (const task of this.tasks) {
            // eslint-disable-next-line no-await-in-loop
            await task.task.prepare();
        }
        this.workers = Object.entries(groupBy(this.tasks, (task) => task.queue)).map((tasks) => this.initHandler(tasks[0], tasks[1]));
    }
    async close() {
        await Promise.all(this.workers.map(async (worker) => {
            await worker.close();
        }));
    }
}
