"use strict";
/*
import { TaskSerializer } from "../worker/manager/ReducableTask";
import { DynamicProof, Field, Proof, JsonProof } from "o1js";
import { Subclass } from "@proto-kit/protocol";
import { MOCK_PROOF, TypedClass } from "@proto-kit/common";
import { InferProvable } from "o1js/dist/node/lib/provable/types/struct";

type EitherProof<PublicInputType, PublicOutputType> =
  | Proof<PublicInputType, PublicOutputType>
  | DynamicProof<PublicInputType, PublicOutputType>;
type EitherProofClass<PublicInputType, PublicOutputType> =
  | typeof Proof<PublicInputType, PublicOutputType>
  | typeof DynamicProof<PublicInputType, PublicOutputType>;

type SerializerType = "Static" | "Dynamic" | "Both";

type ProofType<
  PublicInputType,
  PublicOutputType,
  Type extends SerializerType,
> = Type extends "Dynamic"
  ? DynamicProof<PublicInputType, PublicOutputType>
  : Type extends "Static"
    ? Proof<PublicInputType, PublicOutputType>
    : EitherProof<PublicInputType, PublicOutputType>;

type ProofTypeClass<
  PublicInputType,
  PublicOutputType,
  Type extends SerializerType,
> = Type extends "Dynamic"
  ? typeof DynamicProof<PublicInputType, PublicOutputType>
  : Type extends "Static"
    ? typeof Proof<PublicInputType, PublicOutputType>
    : EitherProofClass<PublicInputType, PublicOutputType>;

export class DynamicProofTaskSerializer<
  PublicInputType,
  PublicOutputType,
  Type extends SerializerType = "Both",
> implements TaskSerializer<ProofType<PublicInputType, PublicOutputType, Type>>
{
  // private proofType: "Static" | "Dynamic" | "Both";

  public constructor(
    private readonly proofType: Type,
    private readonly proofClass: ProofTypeClass<PublicInputType, PublicOutputType, Type>
  ) {
    // this.proofType =
    //   proofClass.prototype instanceof Proof ? "Static" : "Dynamic";
  }

  private isProof(
    proof: Subclass<EitherProofClass<PublicInputType, PublicOutputType>>
  ): proof is ProofTypeClass<PublicInputType, PublicOutputType, Type> {
    return this.proofType === "Static";
  }

  private isDynamicProof(
    proof: Subclass<EitherProofClass<PublicInputType, PublicOutputType>>
  ): proof is ProofTypeClass<PublicInputType, PublicOutputType, Type> {
    return this.proofType === "Dynamic";
  }

  public toJSON(
    proof: ProofType<PublicInputType, PublicOutputType, Type>
  ): string {
    return JSON.stringify(this.toJSONProof(proof));
  }

  public toJSONProof(
    proof: ProofType<PublicInputType, PublicOutputType, Type>
  ): JsonProof {
    if (proof.proof === MOCK_PROOF) {
      return {
        publicInput: this.proofClass.publicInputType
          // eslint-disable-next-line max-len
          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions,@typescript-eslint/no-unsafe-argument
          .toFields(proof.publicInput as any)
          .map(String),

        publicOutput: this.proofClass.publicOutputType
          // eslint-disable-next-line max-len
          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions,@typescript-eslint/no-unsafe-argument
          .toFields(proof.publicOutput as any)
          .map(String),

        maxProofsVerified: proof.maxProofsVerified,
        proof: MOCK_PROOF,
      };
    }
    return proof.toJSON();
  }

  public async fromJSON(
    json: string
  ): Promise<ProofType<PublicInputType, PublicOutputType, Type>> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return await this.fromJSONProof(JSON.parse(json));
  }

  public async fromJSONProof(
    jsonProof: JsonProof
  ): Promise<ProofType<PublicInputType, PublicOutputType, Type>> {
    // if (jsonProof.proof === "mock-proof") {
    //   // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    //   const publicInput: PublicInputType =
    //     this.proofClass.publicInputType.fromFields(
    //       jsonProof.publicInput.map(Field)
    //     );
    //   // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    //   const publicOutput: PublicOutputType =
    //     this.proofClass.publicOutputType.fromFields(
    //       jsonProof.publicOutput.map(Field)
    //     );
    //   await this.proofClass.dummy(publicInput, publicOutput, jsonProof.maxProofsVerified)
    //   // eslint-disable-next-line new-cap
    //   return new this.proofClass({
    //     publicInput,
    //     publicOutput,
    //     proof: "mock-proof",
    //     maxProofsVerified: jsonProof.maxProofsVerified,
    //   });
    // }

    const { proofClass } = this;

    if(this.isDynamicProof(proofClass)) {
      return await proofClass.fromJSON(jsonProof);
    }
  }
}
*/ 
