import { State, StateMap, } from "@proto-kit/protocol";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function isStringKeyOf(key) {
    return typeof key === "string";
}
/* eslint-disable guard-for-in,@typescript-eslint/consistent-type-assertions */
export const QueryBuilderFactory = {
    fillQuery(runtimeModule, queryTransportModule) {
        let query = {};
        for (const propertyName in runtimeModule) {
            // we're accessing the propertyName twice here and in the functions below
            // because the path reference/value was wrong in the query API otherwise
            const propertyCheck = runtimeModule[propertyName];
            if (propertyCheck instanceof StateMap) {
                query = {
                    ...query,
                    [propertyName]: {
                        get: async (key) => {
                            const property = runtimeModule[propertyName];
                            const path = property.getPath(key);
                            const fields = await queryTransportModule.get(path);
                            return fields ? property.valueType.fromFields(fields) : undefined;
                        },
                        path: (key) => {
                            const property = runtimeModule[propertyName];
                            return property.getPath(key);
                        },
                        merkleWitness: async (key) => {
                            const property = runtimeModule[propertyName];
                            const path = property.getPath(key);
                            return await queryTransportModule.merkleWitness(path);
                        },
                    },
                };
            }
            if (propertyCheck instanceof State) {
                query = {
                    ...query,
                    [propertyName]: {
                        get: async () => {
                            const property = runtimeModule[propertyName];
                            const path = property.path;
                            const fields = await queryTransportModule.get(path);
                            return fields ? property.valueType.fromFields(fields) : undefined;
                        },
                        path: () => {
                            const property = runtimeModule[propertyName];
                            return property.path;
                        },
                        merkleWitness: async () => {
                            const property = runtimeModule[propertyName];
                            const path = property.path;
                            return await queryTransportModule.merkleWitness(path);
                        },
                    },
                };
            }
        }
        return query;
    },
    fromRuntime(runtime, queryTransportModule) {
        const { modules } = runtime.definition;
        return Object.keys(modules).reduce((query, runtimeModuleName) => {
            runtime.assertIsValidModuleName(runtimeModuleName);
            const runtimeModule = runtime.resolve(runtimeModuleName);
            query[runtimeModuleName] = QueryBuilderFactory.fillQuery(runtimeModule, queryTransportModule);
            return query;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        }, {});
    },
    fromProtocol(protocol, queryTransportModule) {
        const { modules } = protocol.definition;
        return Object.keys(modules).reduce((query, protocolModuleName) => {
            protocol.assertIsValidModuleName(protocolModuleName);
            const protocolModule = protocol.resolve(protocolModuleName);
            query[protocolModuleName] = QueryBuilderFactory.fillQuery(protocolModule, queryTransportModule);
            return query;
        }, 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        {});
    },
};
/* eslint-enable guard-for-in,@typescript-eslint/consistent-type-assertions */
