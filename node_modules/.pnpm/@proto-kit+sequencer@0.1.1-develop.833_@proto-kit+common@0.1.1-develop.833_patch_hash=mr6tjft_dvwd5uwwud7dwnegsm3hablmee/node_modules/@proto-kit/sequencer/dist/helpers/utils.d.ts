import { Proof, DynamicProof } from "o1js";
import { Subclass } from "@proto-kit/protocol";
import { TypedClass } from "@proto-kit/common";
import { TaskSerializer } from "../worker/flow/Task";
export declare function distinct<Value>(value: Value, index: number, array: Value[]): boolean;
export declare function distinctByPredicate<Value>(predicate: (a: Value, b: Value) => boolean): (value: Value, index: number, array: Value[]) => boolean;
export declare function distinctByString<Value extends {
    toString: () => string;
}>(value: Value, index: number, array: Value[]): boolean;
type JsonProof = ReturnType<typeof Proof.prototype.toJSON>;
declare abstract class ProofTaskSerializerBase<PublicInputType, PublicOutputType> {
    private readonly proofClassInternal;
    protected constructor(proofClassInternal: Subclass<typeof Proof<PublicInputType, PublicOutputType> | typeof DynamicProof<PublicInputType, PublicOutputType>>);
    protected getDummy<T extends Proof<PublicInputType, PublicOutputType> | DynamicProof<PublicInputType, PublicOutputType>>(c: TypedClass<T>, jsonProof: JsonProof): T;
    toJSON(proof: Proof<PublicInputType, PublicOutputType> | DynamicProof<PublicInputType, PublicOutputType>): string;
    toJSONProof(proof: Proof<PublicInputType, PublicOutputType> | DynamicProof<PublicInputType, PublicOutputType>): JsonProof;
}
export declare class ProofTaskSerializer<PublicInputType, PublicOutputType> extends ProofTaskSerializerBase<PublicInputType, PublicOutputType> implements TaskSerializer<Proof<PublicInputType, PublicOutputType>> {
    private readonly proofClass;
    constructor(proofClass: Subclass<typeof Proof<PublicInputType, PublicOutputType>>);
    fromJSON(json: string): Promise<Proof<PublicInputType, PublicOutputType>>;
    fromJSONProof(jsonProof: JsonProof): Promise<Proof<PublicInputType, PublicOutputType>>;
}
export declare class DynamicProofTaskSerializer<PublicInputType, PublicOutputType> extends ProofTaskSerializerBase<PublicInputType, PublicOutputType> implements TaskSerializer<DynamicProof<PublicInputType, PublicOutputType>> {
    private readonly proofClass;
    constructor(proofClass: Subclass<typeof DynamicProof<PublicInputType, PublicOutputType>>);
    fromJSON(json: string): Promise<DynamicProof<PublicInputType, PublicOutputType>>;
    fromJSONProof(jsonProof: JsonProof): Promise<DynamicProof<PublicInputType, PublicOutputType>>;
}
export type PairTuple<Type> = [Type, Type];
export declare class PairProofTaskSerializer<PublicInputType, PublicOutputType> implements TaskSerializer<PairTuple<Proof<PublicInputType, PublicOutputType>>> {
    private readonly proofClass;
    private readonly proofSerializer;
    constructor(proofClass: Subclass<typeof Proof<PublicInputType, PublicOutputType>>);
    fromJSON(json: string): Promise<PairTuple<Proof<PublicInputType, PublicOutputType>>>;
    toJSON(input: PairTuple<Proof<PublicInputType, PublicOutputType>>): string;
}
export {};
//# sourceMappingURL=utils.d.ts.map