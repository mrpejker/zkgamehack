import { Field } from "o1js";
import { MOCK_PROOF } from "@proto-kit/common";
export function distinct(value, index, array) {
    return array.indexOf(value) === index;
}
export function distinctByPredicate(predicate) {
    return (v, index, array) => {
        return array.findIndex((other) => predicate(v, other)) === index;
    };
}
export function distinctByString(value, index, array) {
    return array.findIndex((it) => it.toString() === value.toString()) === index;
}
class ProofTaskSerializerBase {
    constructor(proofClassInternal) {
        this.proofClassInternal = proofClassInternal;
    }
    getDummy(c, jsonProof) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const publicInput = this.proofClassInternal.publicInputType.fromFields(jsonProof.publicInput.map(Field));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const publicOutput = this.proofClassInternal.publicOutputType.fromFields(jsonProof.publicOutput.map(Field));
        // eslint-disable-next-line new-cap
        return new c({
            publicInput,
            publicOutput,
            proof: "mock-proof",
            maxProofsVerified: jsonProof.maxProofsVerified,
        });
    }
    toJSON(proof) {
        return JSON.stringify(this.toJSONProof(proof));
    }
    toJSONProof(proof) {
        if (proof.proof === MOCK_PROOF) {
            return {
                publicInput: this.proofClassInternal.publicInputType
                    // eslint-disable-next-line max-len
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions,@typescript-eslint/no-unsafe-argument
                    .toFields(proof.publicInput)
                    .map(String),
                publicOutput: this.proofClassInternal.publicOutputType
                    // eslint-disable-next-line max-len
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions,@typescript-eslint/no-unsafe-argument
                    .toFields(proof.publicOutput)
                    .map(String),
                maxProofsVerified: proof.maxProofsVerified,
                proof: MOCK_PROOF,
            };
        }
        return proof.toJSON();
    }
}
export class ProofTaskSerializer extends ProofTaskSerializerBase {
    constructor(proofClass) {
        super(proofClass);
        this.proofClass = proofClass;
    }
    async fromJSON(json) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return await this.fromJSONProof(JSON.parse(json));
    }
    async fromJSONProof(jsonProof) {
        if (jsonProof.proof === "mock-proof") {
            return this.getDummy(this.proofClass, jsonProof);
        }
        return await this.proofClass.fromJSON(jsonProof);
    }
}
export class DynamicProofTaskSerializer extends ProofTaskSerializerBase {
    constructor(proofClass) {
        super(proofClass);
        this.proofClass = proofClass;
    }
    async fromJSON(json) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return await this.fromJSONProof(JSON.parse(json));
    }
    async fromJSONProof(jsonProof) {
        if (jsonProof.proof === "mock-proof") {
            return this.getDummy(this.proofClass, jsonProof);
        }
        const { proofClass } = this;
        return await proofClass.fromJSON(jsonProof);
    }
}
export class PairProofTaskSerializer {
    constructor(proofClass) {
        this.proofClass = proofClass;
        this.proofSerializer = new ProofTaskSerializer(this.proofClass);
    }
    async fromJSON(json) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const array = JSON.parse(json);
        return [
            await this.proofSerializer.fromJSONProof(array[0]),
            await this.proofSerializer.fromJSONProof(array[1]),
        ];
    }
    toJSON(input) {
        return JSON.stringify(input.map((element) => this.proofSerializer.toJSONProof(element)));
    }
}
