import { Field, type PrivateKey, PublicKey, Signature, UInt64 } from "o1js";
import { RuntimeTransaction, SignedTransaction } from "@proto-kit/protocol";
export type UnsignedTransactionBody = {
    methodId: Field;
    nonce: UInt64;
    sender: PublicKey;
    argsFields: Field[];
    /**
     * Used to transport non-provable data, mainly proof data for now
     * These values will not be part of the signature message or transaction hash
     */
    auxiliaryData: string[];
    isMessage: boolean;
};
export declare class UnsignedTransaction implements UnsignedTransactionBody {
    methodId: Field;
    nonce: UInt64;
    sender: PublicKey;
    argsFields: Field[];
    auxiliaryData: string[];
    isMessage: boolean;
    constructor(data: {
        methodId: Field;
        nonce: UInt64;
        sender: PublicKey;
        argsFields: Field[];
        auxiliaryData: string[];
        isMessage: boolean;
    });
    argsHash(): Field;
    hash(): Field;
    getSignatureData(): Field[];
    sign(privateKey: PrivateKey): PendingTransaction;
    toRuntimeTransaction(): RuntimeTransaction;
    signed(signature: Signature): PendingTransaction;
}
interface PendingTransactionJSONType {
    hash: string;
    methodId: string;
    nonce: string;
    sender: string;
    argsFields: string[];
    auxiliaryData: string[];
    signature: {
        r: string;
        s: string;
    };
    isMessage: boolean;
}
export declare class PendingTransaction extends UnsignedTransaction {
    static fromJSON(object: PendingTransactionJSONType): PendingTransaction;
    signature: Signature;
    constructor(data: {
        methodId: Field;
        nonce: UInt64;
        sender: PublicKey;
        signature: Signature;
        argsFields: Field[];
        auxiliaryData: string[];
        isMessage: boolean;
    });
    toJSON(): PendingTransactionJSONType;
    toProtocolTransaction(): SignedTransaction;
}
export {};
//# sourceMappingURL=PendingTransaction.d.ts.map