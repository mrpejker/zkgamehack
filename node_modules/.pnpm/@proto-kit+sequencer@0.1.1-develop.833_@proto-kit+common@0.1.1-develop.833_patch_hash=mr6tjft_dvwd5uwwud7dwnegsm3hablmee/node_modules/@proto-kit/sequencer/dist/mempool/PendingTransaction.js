import { Bool, Field, Poseidon, PublicKey, Signature, UInt64, } from "o1js";
import { PublicKeyOption, RuntimeTransaction, SignedTransaction, UInt64Option, } from "@proto-kit/protocol";
export class UnsignedTransaction {
    constructor(data) {
        this.methodId = data.methodId;
        this.nonce = data.nonce;
        this.sender = data.sender;
        this.argsFields = data.argsFields;
        this.auxiliaryData = data.auxiliaryData;
        this.isMessage = data.isMessage;
    }
    argsHash() {
        return Poseidon.hash(this.argsFields);
    }
    hash() {
        return Poseidon.hash([
            this.methodId,
            ...this.sender.toFields(),
            ...this.nonce.toFields(),
            this.argsHash(),
        ]);
    }
    getSignatureData() {
        return SignedTransaction.getSignatureData({
            nonce: this.nonce,
            methodId: this.methodId,
            argsHash: this.argsHash(),
        });
    }
    sign(privateKey) {
        const signature = Signature.create(privateKey, this.getSignatureData());
        return this.signed(signature);
    }
    toRuntimeTransaction() {
        const isSome = Bool(!this.isMessage);
        return new RuntimeTransaction({
            methodId: this.methodId,
            argsHash: Poseidon.hash(this.argsFields),
            nonce: new UInt64Option({ value: this.nonce, isSome }),
            sender: new PublicKeyOption({ value: this.sender, isSome }),
        });
    }
    signed(signature) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        return new PendingTransaction({
            methodId: this.methodId,
            sender: this.sender,
            nonce: this.nonce,
            signature,
            argsFields: this.argsFields,
            auxiliaryData: this.auxiliaryData,
            isMessage: this.isMessage,
        });
    }
}
export class PendingTransaction extends UnsignedTransaction {
    static fromJSON(object) {
        return new PendingTransaction({
            methodId: Field.fromJSON(object.methodId),
            nonce: UInt64.from(object.nonce),
            sender: PublicKey.fromBase58(object.sender),
            argsFields: object.argsFields.map((x) => Field.fromJSON(x)),
            signature: Signature.fromJSON(object.signature),
            auxiliaryData: object.auxiliaryData.slice(),
            isMessage: object.isMessage,
        });
    }
    constructor(data) {
        super(data);
        this.signature = data.signature;
    }
    toJSON() {
        return {
            hash: this.hash.toString(),
            methodId: this.methodId.toJSON(),
            nonce: this.nonce.toString(),
            sender: this.sender.toBase58(),
            argsFields: this.argsFields.map((x) => x.toJSON()),
            auxiliaryData: this.auxiliaryData.slice(),
            isMessage: this.isMessage,
            signature: {
                r: this.signature.r.toJSON(),
                s: this.signature.s.toJSON(),
            },
        };
    }
    toProtocolTransaction() {
        return new SignedTransaction({
            transaction: this.toRuntimeTransaction(),
            signature: this.signature,
        });
    }
}
