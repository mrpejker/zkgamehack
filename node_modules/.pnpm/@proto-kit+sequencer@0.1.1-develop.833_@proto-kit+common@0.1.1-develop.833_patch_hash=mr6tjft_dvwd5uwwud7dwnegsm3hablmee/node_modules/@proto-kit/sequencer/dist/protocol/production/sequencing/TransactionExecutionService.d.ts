import { Protocol, ProtocolModulesRecord, RuntimeMethodExecutionContext, StateServiceProvider, MandatoryProtocolModulesRecord } from "@proto-kit/protocol";
import { Runtime, RuntimeModulesRecord } from "@proto-kit/module";
import { PendingTransaction } from "../../../mempool/PendingTransaction";
import { CachedStateService } from "../../../state/state/CachedStateService";
import { AsyncMerkleTreeStore } from "../../../state/async/AsyncMerkleTreeStore";
import { Block, BlockResult, BlockWithResult } from "../../../storage/model/Block";
export type SomeRuntimeMethod = (...args: unknown[]) => Promise<unknown>;
export declare class TransactionExecutionService {
    private readonly runtime;
    private readonly protocol;
    private readonly executionContext;
    private readonly stateServiceProvider;
    private readonly transactionHooks;
    private readonly blockHooks;
    constructor(runtime: Runtime<RuntimeModulesRecord>, protocol: Protocol<MandatoryProtocolModulesRecord & ProtocolModulesRecord>, executionContext: RuntimeMethodExecutionContext, stateServiceProvider: StateServiceProvider);
    private allKeys;
    private applyTransitions;
    private collectStateDiff;
    private decodeTransaction;
    private getAppChainForModule;
    private executeWithExecutionContext;
    private executeRuntimeMethod;
    private wrapHooksForContext;
    private executeProtocolHooks;
    /**
     * Main entry point for creating a unproven block with everything
     * attached that is needed for tracing
     */
    createBlock(stateService: CachedStateService, transactions: PendingTransaction[], lastBlockWithResult: BlockWithResult, allowEmptyBlocks: boolean): Promise<Block | undefined>;
    generateMetadataForNextBlock(block: Block, merkleTreeStore: AsyncMerkleTreeStore, blockHashTreeStore: AsyncMerkleTreeStore, modifyTreeStore?: boolean): Promise<BlockResult>;
    private createExecutionTrace;
}
//# sourceMappingURL=TransactionExecutionService.d.ts.map