import { Mempool } from "../../../mempool/Mempool";
import { SequencerModule } from "../../../sequencer/builder/SequencerModule";
import { UnprovenBlockQueue } from "../../../storage/repositories/UnprovenBlockStorage";
import { AsyncMerkleTreeStore } from "../../../state/async/AsyncMerkleTreeStore";
import { AsyncStateService } from "../../../state/async/AsyncStateService";
import { UnprovenBlockWithMetadata } from "../../../storage/model/UnprovenBlock";
import { MessageStorage } from "../../../storage/repositories/MessageStorage";
import { TransactionExecutionService } from "./TransactionExecutionService";
export interface BlockConfig {
    allowEmptyBlock?: boolean;
}
export declare class UnprovenProducerModule extends SequencerModule<BlockConfig> {
    private readonly mempool;
    private readonly messageStorage;
    private readonly unprovenStateService;
    private readonly unprovenMerkleStore;
    private readonly unprovenBlockQueue;
    private readonly blockTreeStore;
    private readonly executionService;
    private productionInProgress;
    constructor(mempool: Mempool, messageStorage: MessageStorage, unprovenStateService: AsyncStateService, unprovenMerkleStore: AsyncMerkleTreeStore, unprovenBlockQueue: UnprovenBlockQueue, blockTreeStore: AsyncMerkleTreeStore, executionService: TransactionExecutionService);
    private allowEmptyBlock;
    tryProduceUnprovenBlock(): Promise<UnprovenBlockWithMetadata | undefined>;
    private collectProductionData;
    private produceUnprovenBlock;
    start(): Promise<void>;
}
//# sourceMappingURL=UnprovenProducerModule.d.ts.map