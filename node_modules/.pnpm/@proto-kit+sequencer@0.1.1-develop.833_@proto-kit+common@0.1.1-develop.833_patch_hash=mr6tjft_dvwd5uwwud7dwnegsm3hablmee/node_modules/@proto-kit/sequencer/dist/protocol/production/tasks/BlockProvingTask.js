var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { BlockProverExecutionData, BlockProverPublicInput, Protocol, StateServiceProvider, } from "@proto-kit/protocol";
import { Field } from "o1js";
import { Runtime } from "@proto-kit/module";
import { inject, injectable, Lifecycle, scoped } from "tsyringe";
import { ProvableMethodExecutionContext } from "@proto-kit/common";
import { PairProofTaskSerializer, ProofTaskSerializer, } from "../../../helpers/utils";
import { PreFilledStateService } from "../../../state/prefilled/PreFilledStateService";
import { TaskWorkerModule } from "../../../worker/worker/TaskWorkerModule";
import { CompileRegistry } from "./CompileRegistry";
export class DecodedStateSerializer {
    static fromJSON(json) {
        return Object.fromEntries(Object.entries(json).map(([key, value]) => [
            key,
            value.map((encodedField) => Field(encodedField)),
        ]));
    }
    static toJSON(input) {
        return Object.fromEntries(Object.entries(input).map(([key, value]) => [
            key,
            value.map((field) => field.toString()),
        ]));
    }
}
export let BlockReductionTask = class BlockReductionTask extends TaskWorkerModule {
    constructor(protocol, executionContext, compileRegistry) {
        super();
        this.protocol = protocol;
        this.executionContext = executionContext;
        this.compileRegistry = compileRegistry;
        this.name = "blockReduction";
        this.blockProver = this.protocol.blockProver;
    }
    inputSerializer() {
        return new PairProofTaskSerializer(this.blockProver.zkProgrammable.zkProgram.Proof);
    }
    resultSerializer() {
        return new ProofTaskSerializer(this.blockProver.zkProgrammable.zkProgram.Proof);
    }
    async compute(input) {
        const [r1, r2] = input;
        await this.blockProver.merge(r1.publicInput, r1, r2);
        return await this.executionContext.current().result.prove();
    }
    async prepare() {
        await this.compileRegistry.compile("BlockProver", this.blockProver.zkProgrammable.zkProgram);
    }
};
BlockReductionTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Protocol")),
    __metadata("design:paramtypes", [Protocol,
        ProvableMethodExecutionContext,
        CompileRegistry])
], BlockReductionTask);
export let BlockProvingTask = class BlockProvingTask extends TaskWorkerModule {
    constructor(protocol, runtime, stateServiceProvider, executionContext, compileRegistry) {
        super();
        this.protocol = protocol;
        this.runtime = runtime;
        this.stateServiceProvider = stateServiceProvider;
        this.executionContext = executionContext;
        this.compileRegistry = compileRegistry;
        this.runtimeProofType = this.runtime.zkProgrammable.zkProgram.Proof;
        this.name = "block";
        this.stateTransitionProver = protocol.stateTransitionProver;
        this.blockProver = this.protocol.blockProver;
    }
    inputSerializer() {
        const stProofSerializer = new ProofTaskSerializer(this.stateTransitionProver.zkProgrammable.zkProgram.Proof);
        const runtimeProofSerializer = new ProofTaskSerializer(this.runtimeProofType);
        return {
            toJSON(input) {
                const jsonReadyObject = {
                    input1: stProofSerializer.toJSON(input.input1),
                    input2: runtimeProofSerializer.toJSON(input.input2),
                    params: {
                        publicInput: BlockProverPublicInput.toJSON(input.params.publicInput),
                        executionData: BlockProverExecutionData.toJSON(input.params.executionData),
                        startingState: DecodedStateSerializer.toJSON(input.params.startingState),
                    },
                };
                return JSON.stringify(jsonReadyObject);
            },
            async fromJSON(json) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const jsonReadyObject = JSON.parse(json);
                return {
                    input1: await stProofSerializer.fromJSON(jsonReadyObject.input1),
                    input2: await runtimeProofSerializer.fromJSON(jsonReadyObject.input2),
                    params: {
                        publicInput: BlockProverPublicInput.fromJSON(jsonReadyObject.params.publicInput),
                        executionData: BlockProverExecutionData.fromJSON(jsonReadyObject.params.executionData),
                        startingState: DecodedStateSerializer.fromJSON(jsonReadyObject.params.startingState),
                    },
                };
            },
        };
    }
    // eslint-disable-next-line sonarjs/no-identical-functions
    resultSerializer() {
        return new ProofTaskSerializer(this.blockProver.zkProgrammable.zkProgram.Proof);
    }
    async executeWithPrefilledStateService(startingState, callback) {
        const prefilledStateService = new PreFilledStateService(startingState);
        this.stateServiceProvider.setCurrentStateService(prefilledStateService);
        const returnValue = await callback();
        this.stateServiceProvider.popCurrentStateService();
        return returnValue;
    }
    async compute(input) {
        const stateTransitionProof = input.input1;
        const runtimeProof = input.input2;
        await this.executeWithPrefilledStateService(input.params.startingState, async () => {
            await this.blockProver.proveTransaction(input.params.publicInput, stateTransitionProof, runtimeProof, input.params.executionData);
        });
        return await this.executeWithPrefilledStateService(input.params.startingState, async () => await this.executionContext.current().result.prove());
    }
    // eslint-disable-next-line sonarjs/no-identical-functions
    async prepare() {
        // Compile
        await this.compileRegistry.compile("BlockProver", this.blockProver.zkProgrammable.zkProgram);
    }
};
BlockProvingTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Protocol")),
    __param(1, inject("Runtime")),
    __param(2, inject("StateServiceProvider")),
    __metadata("design:paramtypes", [Protocol,
        Runtime,
        StateServiceProvider,
        ProvableMethodExecutionContext,
        CompileRegistry])
], BlockProvingTask);
