import { SettleableBatch } from "../../../storage/model/Batch";
import { BatchProducerModule } from "../BatchProducerModule";
import { BlockProducerModule } from "../sequencing/BlockProducerModule";
import { Block } from "../../../storage/model/Block";
import { BlockQueue } from "../../../storage/repositories/BlockStorage";
import { SettlementModule } from "../../../settlement/SettlementModule";
import { BatchStorage } from "../../../storage/repositories/BatchStorage";
import { SettlementStorage } from "../../../storage/repositories/SettlementStorage";
import { BlockTrigger, BlockTriggerBase } from "./BlockTrigger";
export declare class ManualBlockTrigger extends BlockTriggerBase implements BlockTrigger {
    constructor(batchProducerModule: BatchProducerModule, blockProducerModule: BlockProducerModule, settlementModule: SettlementModule | undefined, blockQueue: BlockQueue, batchStorage: BatchStorage, settlementStorage: SettlementStorage | undefined);
    /**
     * Produces both an unproven block and immediately produce a
     * settlement block proof
     */
    produceBlockAndBatch(): Promise<[
        Block | undefined,
        SettleableBatch | undefined
    ]>;
    produceBatch(): Promise<SettleableBatch | undefined>;
    settle(batch: SettleableBatch): Promise<import("../../..").Settlement | undefined>;
    produceBlock(enqueueInSettlementQueue?: boolean): Promise<Block | undefined>;
}
//# sourceMappingURL=ManualBlockTrigger.d.ts.map