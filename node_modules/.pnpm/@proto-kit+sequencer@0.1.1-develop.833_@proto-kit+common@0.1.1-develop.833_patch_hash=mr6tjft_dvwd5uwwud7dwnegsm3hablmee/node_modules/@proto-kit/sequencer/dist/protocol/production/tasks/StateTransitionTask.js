var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable, Lifecycle, scoped } from "tsyringe";
import { Protocol, StateTransitionProvableBatch, StateTransitionProverPublicInput, StateTransitionProverPublicOutput, } from "@proto-kit/protocol";
import { log, ProvableMethodExecutionContext } from "@proto-kit/common";
import { PairProofTaskSerializer, ProofTaskSerializer, } from "../../../helpers/utils";
import { TaskWorkerModule } from "../../../worker/worker/TaskWorkerModule";
import { PreFilledWitnessProvider } from "../../../state/prefilled/PreFilledWitnessProvider";
import { StateTransitionParametersSerializer, } from "./StateTransitionTaskParameters";
import { CompileRegistry } from "./CompileRegistry";
export let StateTransitionTask = class StateTransitionTask extends TaskWorkerModule {
    constructor(protocol, executionContext, compileRegistry) {
        super();
        this.protocol = protocol;
        this.executionContext = executionContext;
        this.compileRegistry = compileRegistry;
        this.name = "stateTransitionProof";
        this.stateTransitionProver = this.protocol.stateTransitionProver;
    }
    inputSerializer() {
        return new StateTransitionParametersSerializer();
    }
    resultSerializer() {
        return new ProofTaskSerializer(this.stateTransitionProver.zkProgrammable.zkProgram.Proof);
    }
    async compute(input) {
        const witnessProvider = new PreFilledWitnessProvider(input.merkleWitnesses);
        const { witnessProviderReference } = this.stateTransitionProver;
        const previousProvider = witnessProviderReference.getWitnessProvider();
        witnessProviderReference.setWitnessProvider(witnessProvider);
        const stBatch = input.stateTransitions.slice();
        // Array.from({
        //   length: ProtocolConstants.stateTransitionProverBatchSize - stBatch.length,
        // }).forEach(() => {
        //   stBatch.push({
        //     ProvableStateTransition.dummy()
        //   });
        // });
        const output = await this.stateTransitionProver.runBatch(input.publicInput, StateTransitionProvableBatch.fromMappings(stBatch));
        log.debug("STTask public io:", {
            input: StateTransitionProverPublicInput.toJSON(input.publicInput),
            output: StateTransitionProverPublicOutput.toJSON(output),
        });
        const proof = await this.executionContext
            .current()
            .result.prove();
        if (previousProvider !== undefined) {
            witnessProviderReference.setWitnessProvider(previousProvider);
        }
        return proof;
    }
    async prepare() {
        await this.compileRegistry.compile("StateTransitionProver", this.stateTransitionProver.zkProgrammable.zkProgram);
    }
};
StateTransitionTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Protocol")),
    __metadata("design:paramtypes", [Protocol,
        ProvableMethodExecutionContext,
        CompileRegistry])
], StateTransitionTask);
export let StateTransitionReductionTask = class StateTransitionReductionTask extends TaskWorkerModule {
    constructor(protocol, executionContext, compileRegistry) {
        super();
        this.protocol = protocol;
        this.executionContext = executionContext;
        this.compileRegistry = compileRegistry;
        this.name = "stateTransitionReduction";
        this.stateTransitionProver = this.protocol.stateTransitionProver;
    }
    inputSerializer() {
        return new PairProofTaskSerializer(this.stateTransitionProver.zkProgrammable.zkProgram.Proof);
    }
    // eslint-disable-next-line sonarjs/no-identical-functions
    resultSerializer() {
        return new ProofTaskSerializer(this.stateTransitionProver.zkProgrammable.zkProgram.Proof);
    }
    async compute(input) {
        const [r1, r2] = input;
        await this.stateTransitionProver.merge(r1.publicInput, r1, r2);
        return await this.executionContext
            .current()
            .result.prove();
    }
    // eslint-disable-next-line sonarjs/no-identical-functions
    async prepare() {
        await this.compileRegistry.compile("StateTransitionProver", this.stateTransitionProver.zkProgrammable.zkProgram);
    }
};
StateTransitionReductionTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Protocol")),
    __metadata("design:paramtypes", [Protocol,
        ProvableMethodExecutionContext,
        CompileRegistry])
], StateTransitionReductionTask);
