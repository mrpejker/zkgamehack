import { Proof } from "o1js";
import { BlockProof, MandatoryProtocolModulesRecord, MethodPublicOutput, Protocol, StateTransitionProof } from "@proto-kit/protocol";
import { TaskQueue } from "../../worker/queue/TaskQueue";
import { Flow, FlowCreator } from "../../worker/flow/Flow";
import type { BlockTrace } from "./BatchProducerModule";
import { StateTransitionReductionTask, StateTransitionTask } from "./tasks/StateTransitionTask";
import { RuntimeProvingTask } from "./tasks/RuntimeProvingTask";
import { BlockProverParameters, BlockProvingTask, BlockProvingTaskParameters, BlockReductionTask } from "./tasks/BlockProvingTask";
import { ReductionTaskFlow } from "./flow/ReductionTaskFlow";
import { NewBlockProverParameters, NewBlockProvingParameters, NewBlockTask } from "./tasks/NewBlockTask";
type RuntimeProof = Proof<undefined, MethodPublicOutput>;
interface BlockProductionFlowState {
    pairings: {
        runtimeProof?: RuntimeProof;
        stProof?: StateTransitionProof;
        blockArguments: BlockProverParameters;
    }[][];
    blockPairings: {
        blockProof?: BlockProof;
        stProof?: StateTransitionProof;
        provingArguments: NewBlockProverParameters;
    }[];
}
/**
 * We could rename this into BlockCreationStategy and enable the injection of
 * different creation strategies.
 */
export declare class BlockTaskFlowService {
    private readonly taskQueue;
    private readonly flowCreator;
    private readonly stateTransitionTask;
    private readonly stateTransitionReductionTask;
    private readonly runtimeProvingTask;
    private readonly transactionProvingTask;
    private readonly blockProvingTask;
    private readonly blockReductionTask;
    private readonly protocol;
    constructor(taskQueue: TaskQueue, flowCreator: FlowCreator, stateTransitionTask: StateTransitionTask, stateTransitionReductionTask: StateTransitionReductionTask, runtimeProvingTask: RuntimeProvingTask, transactionProvingTask: BlockProvingTask, blockProvingTask: NewBlockTask, blockReductionTask: BlockReductionTask, protocol: Protocol<MandatoryProtocolModulesRecord>);
    pushPairing(flow: Flow<BlockProductionFlowState>, transactionReductionTask: ReductionTaskFlow<BlockProvingTaskParameters, BlockProof>, blockIndex: number, transactionIndex: number): Promise<void>;
    pushBlockPairing(flow: Flow<BlockProductionFlowState>, blockReductionTask: ReductionTaskFlow<NewBlockProvingParameters, BlockProof>, index: number): Promise<void>;
    private createSTMergeFlow;
    executeFlow(blockTraces: BlockTrace[], batchId: number): Promise<BlockProof>;
}
export {};
//# sourceMappingURL=BlockTaskFlowService.d.ts.map