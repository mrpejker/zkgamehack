var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject } from "tsyringe";
import { DefaultProvableHashList, MINA_EVENT_PREFIXES, MinaPrefixedProvableHashList, } from "@proto-kit/protocol";
import { Field } from "o1js";
import { log, noop, RollupMerkleTree } from "@proto-kit/common";
import { sequencerModule, SequencerModule, } from "../../sequencer/builder/SequencerModule";
import { CachedStateService } from "../../state/state/CachedStateService";
import { CachedMerkleTreeStore } from "../../state/merkle/CachedMerkleTreeStore";
import { TransactionTraceService } from "./TransactionTraceService";
import { BlockTaskFlowService } from "./BlockTaskFlowService";
import { BlockProofSerializer } from "./helpers/BlockProofSerializer";
const errors = {
    blockWithoutTxs: () => new Error("Can't create a block with zero transactions"),
};
/**
 * The BatchProducerModule has the resposiblity to oversee the block production
 * and combine all necessary parts for that to happen. The flow roughly follows
 * the following steps:
 *
 * 1. BlockTrigger triggers and executes the startup function
 * 2.
 */
export let BatchProducerModule = class BatchProducerModule extends SequencerModule {
    constructor(asyncStateService, merkleStore, batchStorage, blockTreeStore, traceService, blockFlowService, blockProofSerializer) {
        super();
        this.asyncStateService = asyncStateService;
        this.merkleStore = merkleStore;
        this.batchStorage = batchStorage;
        this.blockTreeStore = blockTreeStore;
        this.traceService = traceService;
        this.blockFlowService = blockFlowService;
        this.blockProofSerializer = blockProofSerializer;
        this.productionInProgress = false;
    }
    async applyStateChanges(blocks, batch) {
        await batch.stateService.mergeIntoParent();
        await batch.merkleStore.mergeIntoParent();
    }
    /**
     * Main function to call when wanting to create a new block based on the
     * transactions that are present in the mempool. This function should also
     * be the one called by BlockTriggers
     */
    async createBatch(blocks) {
        log.info("Producing batch...");
        const height = await this.batchStorage.getCurrentBlockHeight();
        const batchWithStateDiff = await this.tryProduceBatch(blocks, height);
        if (batchWithStateDiff !== undefined) {
            log.info(`Batch produced (${batchWithStateDiff.batch.bundles.length} blocks, ${batchWithStateDiff.batch.bundles.flat(1).length} txs)`);
            // Apply state changes to current StateService
            await this.applyStateChanges(blocks.map((data) => data.block.block), batchWithStateDiff);
        }
        return batchWithStateDiff?.batch;
    }
    async start() {
        noop();
    }
    async tryProduceBatch(blocks, height) {
        if (!this.productionInProgress) {
            try {
                this.productionInProgress = true;
                const batch = await this.produceBatch(blocks, height);
                this.productionInProgress = false;
                return batch;
            }
            catch (error) {
                this.productionInProgress = false;
                // TODO Check if that still makes sense
                if (error instanceof Error) {
                    if (!error.message.includes("Can't create a block with zero transactions")) {
                        log.error(error);
                    }
                    throw error;
                }
                else {
                    log.error(error);
                }
            }
        }
        else {
            log.debug("Skipping new block production because production is still in progress");
        }
        return undefined;
    }
    async produceBatch(blocks, height) {
        const batch = await this.computeBatch(blocks, height);
        const computedBundles = blocks.map((bundle) => bundle.block.block.hash.toString());
        const jsonProof = this.blockProofSerializer
            .getBlockProofSerializer()
            .toJSONProof(batch.proof);
        return {
            batch: {
                proof: jsonProof,
                bundles: computedBundles,
                height,
                fromNetworkState: batch.fromNetworkState,
                toNetworkState: batch.toNetworkState,
            },
            stateService: batch.stateService,
            merkleStore: batch.merkleStore,
        };
    }
    /**
     * Very naive impl for now
     *
     * How we produce batches:
     *
     * 1. We get all pending txs from the mempool and define an order
     * 2. We execute them to get results / intermediate state-roots.
     * We define a tuple of (tx data (methodId, args), state-input, state-output)
     * as a "tx trace"
     * 3. We create tasks based on those traces
     *
     */
    async computeBatch(blocks, blockId) {
        if (blocks.length === 0 || blocks.flat(1).length === 0) {
            throw errors.blockWithoutTxs();
        }
        const stateServices = {
            stateService: new CachedStateService(this.asyncStateService),
            merkleStore: new CachedMerkleTreeStore(this.merkleStore),
        };
        const blockTraces = [];
        const eternalBundleTracker = new DefaultProvableHashList(Field, blocks[0].block.block.fromEternalTransactionsHash);
        const messageTracker = new MinaPrefixedProvableHashList(Field, MINA_EVENT_PREFIXES.sequenceEvents, blocks[0].block.block.fromMessagesHash);
        for (const blockWithPreviousResult of blocks) {
            const { block } = blockWithPreviousResult.block;
            const txs = block.transactions;
            const bundleTracker = new DefaultProvableHashList(Field);
            const transactionTraces = [];
            for (const [, tx] of txs.entries()) {
                // eslint-disable-next-line no-await-in-loop
                const result = await this.traceService.createTransactionTrace(tx, stateServices, block.networkState.during, bundleTracker, eternalBundleTracker, messageTracker);
                transactionTraces.push(result);
            }
            // eslint-disable-next-line no-await-in-loop
            const blockTrace = await this.traceService.createBlockTrace(transactionTraces, stateServices, this.blockTreeStore, Field(blockWithPreviousResult.lastBlockResult?.stateRoot ??
                RollupMerkleTree.EMPTY_ROOT), blockWithPreviousResult.block);
            blockTraces.push(blockTrace);
        }
        const proof = await this.blockFlowService.executeFlow(blockTraces, blockId);
        const fromNetworkState = blocks[0].block.block.networkState.before;
        const toNetworkState = blocks.at(-1).block.result.afterNetworkState;
        return {
            proof,
            stateService: stateServices.stateService,
            merkleStore: stateServices.merkleStore,
            fromNetworkState,
            toNetworkState,
        };
    }
};
BatchProducerModule = __decorate([
    sequencerModule(),
    __param(0, inject("AsyncStateService")),
    __param(1, inject("AsyncMerkleStore")),
    __param(2, inject("BatchStorage")),
    __param(3, inject("BlockTreeStore")),
    __metadata("design:paramtypes", [Object, Object, Object, Object, TransactionTraceService,
        BlockTaskFlowService,
        BlockProofSerializer])
], BatchProducerModule);
