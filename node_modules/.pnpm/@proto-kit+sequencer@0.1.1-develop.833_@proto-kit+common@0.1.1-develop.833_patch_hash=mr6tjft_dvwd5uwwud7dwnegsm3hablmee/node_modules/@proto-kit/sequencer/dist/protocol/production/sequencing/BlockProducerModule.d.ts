import { MethodIdResolver, Runtime, RuntimeModulesRecord } from "@proto-kit/module";
import { Mempool } from "../../../mempool/Mempool";
import { SequencerModule } from "../../../sequencer/builder/SequencerModule";
import { BlockQueue } from "../../../storage/repositories/BlockStorage";
import { AsyncMerkleTreeStore } from "../../../state/async/AsyncMerkleTreeStore";
import { AsyncStateService } from "../../../state/async/AsyncStateService";
import { BlockWithResult } from "../../../storage/model/Block";
import { MessageStorage } from "../../../storage/repositories/MessageStorage";
import { TransactionExecutionService } from "./TransactionExecutionService";
export interface BlockConfig {
    allowEmptyBlock?: boolean;
}
export declare class BlockProducerModule extends SequencerModule<BlockConfig> {
    private readonly mempool;
    private readonly messageStorage;
    private readonly unprovenStateService;
    private readonly unprovenMerkleStore;
    private readonly blockQueue;
    private readonly blockTreeStore;
    private readonly executionService;
    private readonly methodIdResolver;
    private readonly runtime;
    private productionInProgress;
    constructor(mempool: Mempool, messageStorage: MessageStorage, unprovenStateService: AsyncStateService, unprovenMerkleStore: AsyncMerkleTreeStore, blockQueue: BlockQueue, blockTreeStore: AsyncMerkleTreeStore, executionService: TransactionExecutionService, methodIdResolver: MethodIdResolver, runtime: Runtime<RuntimeModulesRecord>);
    private allowEmptyBlock;
    private prettyPrintBlockContents;
    tryProduceBlock(): Promise<BlockWithResult | undefined>;
    private collectProductionData;
    private produceBlock;
    start(): Promise<void>;
}
//# sourceMappingURL=BlockProducerModule.d.ts.map