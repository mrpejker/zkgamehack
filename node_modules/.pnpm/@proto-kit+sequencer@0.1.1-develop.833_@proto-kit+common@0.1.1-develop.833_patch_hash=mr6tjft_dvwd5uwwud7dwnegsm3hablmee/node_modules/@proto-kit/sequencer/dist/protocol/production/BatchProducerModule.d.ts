import { Field } from "o1js";
import { SequencerModule } from "../../sequencer/builder/SequencerModule";
import { BatchStorage } from "../../storage/repositories/BatchStorage";
import { SettleableBatch } from "../../storage/model/Batch";
import { AsyncStateService } from "../../state/async/AsyncStateService";
import { AsyncMerkleTreeStore } from "../../state/async/AsyncMerkleTreeStore";
import { BlockResult, BlockWithResult } from "../../storage/model/Block";
import { BlockProverParameters } from "./tasks/BlockProvingTask";
import { StateTransitionProofParameters } from "./tasks/StateTransitionTaskParameters";
import { RuntimeProofParameters } from "./tasks/RuntimeTaskParameters";
import { TransactionTraceService } from "./TransactionTraceService";
import { BlockTaskFlowService } from "./BlockTaskFlowService";
import { NewBlockProverParameters } from "./tasks/NewBlockTask";
import { BlockProofSerializer } from "./helpers/BlockProofSerializer";
export type StateRecord = Record<string, Field[] | undefined>;
export interface TransactionTrace {
    runtimeProver: RuntimeProofParameters;
    stateTransitionProver: StateTransitionProofParameters[];
    blockProver: BlockProverParameters;
}
export interface BlockTrace {
    block: NewBlockProverParameters;
    stateTransitionProver: StateTransitionProofParameters[];
    transactions: TransactionTrace[];
}
export interface BlockWithPreviousResult {
    block: BlockWithResult;
    lastBlockResult?: BlockResult;
}
/**
 * The BatchProducerModule has the resposiblity to oversee the block production
 * and combine all necessary parts for that to happen. The flow roughly follows
 * the following steps:
 *
 * 1. BlockTrigger triggers and executes the startup function
 * 2.
 */
export declare class BatchProducerModule extends SequencerModule {
    private readonly asyncStateService;
    private readonly merkleStore;
    private readonly batchStorage;
    private readonly blockTreeStore;
    private readonly traceService;
    private readonly blockFlowService;
    private readonly blockProofSerializer;
    private productionInProgress;
    constructor(asyncStateService: AsyncStateService, merkleStore: AsyncMerkleTreeStore, batchStorage: BatchStorage, blockTreeStore: AsyncMerkleTreeStore, traceService: TransactionTraceService, blockFlowService: BlockTaskFlowService, blockProofSerializer: BlockProofSerializer);
    private applyStateChanges;
    /**
     * Main function to call when wanting to create a new block based on the
     * transactions that are present in the mempool. This function should also
     * be the one called by BlockTriggers
     */
    createBatch(blocks: BlockWithPreviousResult[]): Promise<SettleableBatch | undefined>;
    start(): Promise<void>;
    private tryProduceBatch;
    private produceBatch;
    /**
     * Very naive impl for now
     *
     * How we produce batches:
     *
     * 1. We get all pending txs from the mempool and define an order
     * 2. We execute them to get results / intermediate state-roots.
     * We define a tuple of (tx data (methodId, args), state-input, state-output)
     * as a "tx trace"
     * 3. We create tasks based on those traces
     *
     */
    private computeBatch;
}
//# sourceMappingURL=BatchProducerModule.d.ts.map