var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable, Lifecycle, scoped } from "tsyringe";
import { BlockProverPublicInput, NetworkState, Protocol, BlockHashMerkleTreeWitness, } from "@proto-kit/protocol";
import { ProvableMethodExecutionContext } from "@proto-kit/common";
import { ProofTaskSerializer } from "../../../helpers/utils";
import { PreFilledStateService } from "../../../state/prefilled/PreFilledStateService";
import { TaskWorkerModule } from "../../../worker/worker/TaskWorkerModule";
import { CompileRegistry } from "./CompileRegistry";
import { DecodedStateSerializer } from "./BlockProvingTask";
export let NewBlockTask = class NewBlockTask extends TaskWorkerModule {
    constructor(protocol, executionContext, compileRegistry) {
        super();
        this.protocol = protocol;
        this.executionContext = executionContext;
        this.compileRegistry = compileRegistry;
        this.name = "newBlock";
        this.stateTransitionProver = protocol.stateTransitionProver;
        this.blockProver = this.protocol.blockProver;
    }
    inputSerializer() {
        const stProofSerializer = new ProofTaskSerializer(this.stateTransitionProver.zkProgrammable.zkProgram.Proof);
        const blockProofSerializer = new ProofTaskSerializer(this.blockProver.zkProgrammable.zkProgram.Proof);
        return {
            toJSON: (input) => JSON.stringify({
                input1: stProofSerializer.toJSON(input.input1),
                input2: blockProofSerializer.toJSON(input.input2),
                params: {
                    publicInput: BlockProverPublicInput.toJSON(input.params.publicInput),
                    networkState: NetworkState.toJSON(input.params.networkState),
                    blockWitness: BlockHashMerkleTreeWitness.toJSON(input.params.blockWitness),
                    startingState: DecodedStateSerializer.toJSON(input.params.startingState),
                },
            }),
            fromJSON: async (json) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const jsonObject = JSON.parse(json);
                return {
                    input1: await stProofSerializer.fromJSON(jsonObject.input1),
                    input2: await blockProofSerializer.fromJSON(jsonObject.input2),
                    params: {
                        publicInput: BlockProverPublicInput.fromJSON(jsonObject.params.publicInput),
                        networkState: new NetworkState(NetworkState.fromJSON(jsonObject.params.networkState)),
                        blockWitness: new BlockHashMerkleTreeWitness(BlockHashMerkleTreeWitness.fromJSON(jsonObject.params.blockWitness)),
                        startingState: DecodedStateSerializer.fromJSON(jsonObject.params.startingState),
                    },
                };
            },
        };
    }
    resultSerializer() {
        return new ProofTaskSerializer(this.blockProver.zkProgrammable.zkProgram.Proof);
    }
    async executeWithPrefilledStateService(startingState, callback) {
        const prefilledStateService = new PreFilledStateService(startingState);
        this.protocol.stateServiceProvider.setCurrentStateService(prefilledStateService);
        const returnValue = await callback();
        this.protocol.stateServiceProvider.popCurrentStateService();
        return returnValue;
    }
    async compute(input) {
        const { input1, input2, params: parameters } = input;
        const { networkState, blockWitness, startingState, publicInput } = parameters;
        await this.executeWithPrefilledStateService(startingState, async () => {
            await this.blockProver.proveBlock(publicInput, networkState, blockWitness, input1, input2);
        });
        return await this.executeWithPrefilledStateService(startingState, async () => await this.executionContext.current().result.prove());
    }
    async prepare() {
        // Compile
        await this.compileRegistry.compile("BlockProver", this.blockProver.zkProgrammable.zkProgram);
    }
};
NewBlockTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Protocol")),
    __metadata("design:paramtypes", [Protocol,
        ProvableMethodExecutionContext,
        CompileRegistry])
], NewBlockTask);
