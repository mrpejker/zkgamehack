import { Field } from "o1js";
import { SequencerModule } from "../../sequencer/builder/SequencerModule";
import { BlockStorage } from "../../storage/repositories/BlockStorage";
import { SettleableBatch } from "../../storage/model/Block";
import { AsyncStateService } from "../../state/async/AsyncStateService";
import { AsyncMerkleTreeStore } from "../../state/async/AsyncMerkleTreeStore";
import { UnprovenBlockMetadata, UnprovenBlockWithMetadata } from "../../storage/model/UnprovenBlock";
import { BlockProverParameters } from "./tasks/BlockProvingTask";
import { StateTransitionProofParameters } from "./tasks/StateTransitionTaskParameters";
import { RuntimeProofParameters } from "./tasks/RuntimeTaskParameters";
import { TransactionTraceService } from "./TransactionTraceService";
import { BlockTaskFlowService } from "./BlockTaskFlowService";
import { NewBlockProverParameters } from "./tasks/NewBlockTask";
import { BlockProofSerializer } from "./helpers/BlockProofSerializer";
export type StateRecord = Record<string, Field[] | undefined>;
export interface TransactionTrace {
    runtimeProver: RuntimeProofParameters;
    stateTransitionProver: StateTransitionProofParameters[];
    blockProver: BlockProverParameters;
}
export interface BlockTrace {
    block: NewBlockProverParameters;
    stateTransitionProver: StateTransitionProofParameters[];
    transactions: TransactionTrace[];
}
export interface UnprovenBlockWithPreviousMetadata {
    block: UnprovenBlockWithMetadata;
    lastBlockMetadata?: UnprovenBlockMetadata;
}
/**
 * The BlockProducerModule has the resposiblity to oversee the block production
 * and combine all necessary parts for that to happen. The flow roughly follows
 * the following steps:
 *
 * 1. BlockTrigger triggers and executes the startup function
 * 2.
 */
export declare class BlockProducerModule extends SequencerModule {
    private readonly asyncStateService;
    private readonly merkleStore;
    private readonly blockStorage;
    private readonly blockTreeStore;
    private readonly traceService;
    private readonly blockFlowService;
    private readonly blockProofSerializer;
    private productionInProgress;
    constructor(asyncStateService: AsyncStateService, merkleStore: AsyncMerkleTreeStore, blockStorage: BlockStorage, blockTreeStore: AsyncMerkleTreeStore, traceService: TransactionTraceService, blockFlowService: BlockTaskFlowService, blockProofSerializer: BlockProofSerializer);
    private applyStateChanges;
    /**
     * Main function to call when wanting to create a new block based on the
     * transactions that are present in the mempool. This function should also
     * be the one called by BlockTriggers
     */
    createBlock(unprovenBlocks: UnprovenBlockWithPreviousMetadata[]): Promise<SettleableBatch | undefined>;
    start(): Promise<void>;
    private tryProduceBlock;
    private produceBlock;
    /**
     * Very naive impl for now
     *
     * How we produce Blocks (batches):
     *
     * 1. We get all pending txs from the mempool and define an order
     * 2. We execute them to get results / intermediate state-roots.
     * We define a tuple of (tx data (methodId, args), state-input, state-output)
     * as a "tx trace"
     * 3. We create tasks based on those traces
     *
     */
    private computeBlock;
}
//# sourceMappingURL=BlockProducerModule.d.ts.map