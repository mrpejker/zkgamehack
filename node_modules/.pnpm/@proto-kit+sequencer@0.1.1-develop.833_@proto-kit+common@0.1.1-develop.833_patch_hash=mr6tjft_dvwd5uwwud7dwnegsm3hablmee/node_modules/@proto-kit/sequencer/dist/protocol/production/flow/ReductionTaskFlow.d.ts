import { Flow, FlowCreator } from "../../../worker/flow/Flow";
import { Task } from "../../../worker/flow/Task";
import { PairTuple } from "../../../helpers/utils";
/**
 *  This type is used to consistently define the input type of a MapReduce flow
 *  that is depenend on the result a pairing.
 */
export interface PairingDerivedInput<Input1, Input2, AdditionalParameters> {
    input1: Input1;
    input2: Input2;
    params: AdditionalParameters;
}
/**
 * This class builds and executes a flow that follows the map-reduce pattern.
 * This works in 2 steps:
 * 1. Mapping: Execute the mappingTask to transform from Input -> Output
 * 2. Reduction: Find suitable pairs and merge them [Output, Output] -> Output
 *
 * We use this pattern extensively in our pipeline,
 */
export declare class ReductionTaskFlow<Input, Output> {
    private readonly options;
    private readonly flowCreator;
    private readonly flow;
    private started;
    private parentFlow?;
    constructor(options: {
        name: string;
        inputLength: number;
        mappingTask: Task<Input, Output>;
        reductionTask: Task<PairTuple<Output>, Output>;
        mergableFunction: (a: Output, b: Output) => boolean;
    }, flowCreator: FlowCreator);
    private resolveReducibleTasks;
    private resolveReduction;
    private initCompletionCallback;
    /**
     * Execute the flow using a callback method that is invoked upon
     * completion of the flow.
     * Push inputs using pushInput()
     * @param callback
     */
    onCompletion(callback: (output: Output) => Promise<void>): void;
    /**
     * To be used in conjunction with onCompletion
     * It allows errors from this flow to be "defered" to another parent
     * flow which might be properly awaited and therefore will throw the
     * error up to the user
     * @param flow
     */
    deferErrorsTo(flow: Flow<unknown>): void;
    /**
     * Execute the flow using the returned Promise that resolved when
     * the flow is finished
     * @param inputs initial inputs - doesnt have to be the complete set of inputs
     */
    execute(inputs?: Input[]): Promise<Output>;
    pushInput(input: Input): Promise<void>;
}
//# sourceMappingURL=ReductionTaskFlow.d.ts.map