var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { inject, injectable, Lifecycle, scoped } from "tsyringe";
import { MethodParameterEncoder, Runtime, } from "@proto-kit/module";
import { RuntimeMethodExecutionContext, } from "@proto-kit/protocol";
import { ProofTaskSerializer } from "../../../helpers/utils";
import { TaskWorkerModule } from "../../../worker/worker/TaskWorkerModule";
import { PreFilledStateService } from "../../../state/prefilled/PreFilledStateService";
import { RuntimeProofParametersSerializer, } from "./RuntimeTaskParameters";
export let RuntimeProvingTask = class RuntimeProvingTask extends TaskWorkerModule {
    constructor(runtime, executionContext) {
        super();
        this.runtime = runtime;
        this.executionContext = executionContext;
        this.runtimeZkProgrammable = this.runtime.zkProgrammable.zkProgram;
        this.name = "runtimeProof";
    }
    inputSerializer() {
        return new RuntimeProofParametersSerializer();
    }
    resultSerializer() {
        return new ProofTaskSerializer(this.runtimeZkProgrammable.Proof);
    }
    async compute(input) {
        const method = this.runtime.getMethodById(input.tx.methodId.toBigInt());
        const methodDescriptors = this.runtime.dependencyContainer
            .resolve("MethodIdResolver")
            .getMethodNameFromId(input.tx.methodId.toBigInt());
        if (methodDescriptors === undefined || method === undefined) {
            throw new Error(`MethodId not found ${input.tx.methodId.toString()}`);
        }
        const [moduleName, methodName] = methodDescriptors;
        const parameterEncoder = MethodParameterEncoder.fromMethod(this.runtime.resolve(moduleName), methodName);
        const decodedArguments = await parameterEncoder.decode(input.tx.argsFields, input.tx.auxiliaryData);
        const prefilledStateService = new PreFilledStateService(input.state);
        this.runtime.stateServiceProvider.setCurrentStateService(prefilledStateService);
        // Set network state and transaction for the runtimemodule to access
        const { transaction, signature } = input.tx.toProtocolTransaction();
        const contextInputs = {
            networkState: input.networkState,
            transaction,
            signature,
        };
        this.executionContext.setup(contextInputs);
        await method(...decodedArguments);
        const { result } = this.executionContext.current();
        this.executionContext.setup(contextInputs);
        const proof = await result.prove();
        this.runtime.stateServiceProvider.popCurrentStateService();
        return proof;
    }
    async prepare() {
        await this.runtimeZkProgrammable.compile();
    }
};
RuntimeProvingTask = __decorate([
    injectable(),
    scoped(Lifecycle.ContainerScoped),
    __param(0, inject("Runtime")),
    __metadata("design:paramtypes", [Runtime,
        RuntimeMethodExecutionContext])
], RuntimeProvingTask);
