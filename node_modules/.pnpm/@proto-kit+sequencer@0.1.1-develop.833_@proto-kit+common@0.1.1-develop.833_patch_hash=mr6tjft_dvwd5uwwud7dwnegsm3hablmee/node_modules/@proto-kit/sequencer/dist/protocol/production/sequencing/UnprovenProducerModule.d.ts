import { Mempool } from "../../../mempool/Mempool";
import { SequencerModule } from "../../../sequencer/builder/SequencerModule";
import { BlockQueue } from "../../../storage/repositories/BlockStorage";
import { AsyncMerkleTreeStore } from "../../../state/async/AsyncMerkleTreeStore";
import { AsyncStateService } from "../../../state/async/AsyncStateService";
import { BlockWithResult } from "../../../storage/model/Block";
import { MessageStorage } from "../../../storage/repositories/MessageStorage";
import { TransactionExecutionService } from "./TransactionExecutionService";
export interface BlockConfig {
    allowEmptyBlock?: boolean;
}
export declare class UnprovenProducerModule extends SequencerModule<BlockConfig> {
    private readonly mempool;
    private readonly messageStorage;
    private readonly unprovenStateService;
    private readonly unprovenMerkleStore;
    private readonly blockQueue;
    private readonly blockTreeStore;
    private readonly executionService;
    private productionInProgress;
    constructor(mempool: Mempool, messageStorage: MessageStorage, unprovenStateService: AsyncStateService, unprovenMerkleStore: AsyncMerkleTreeStore, blockQueue: BlockQueue, blockTreeStore: AsyncMerkleTreeStore, executionService: TransactionExecutionService);
    private allowEmptyBlock;
    tryProduceUnprovenBlock(): Promise<BlockWithResult | undefined>;
    private collectProductionData;
    private produceUnprovenBlock;
    start(): Promise<void>;
}
//# sourceMappingURL=UnprovenProducerModule.d.ts.map