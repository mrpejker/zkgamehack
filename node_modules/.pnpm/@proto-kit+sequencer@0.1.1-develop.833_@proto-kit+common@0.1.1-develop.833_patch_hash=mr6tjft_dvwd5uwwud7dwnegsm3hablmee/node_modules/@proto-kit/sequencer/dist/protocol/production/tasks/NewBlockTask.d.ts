import { BlockProverPublicInput, BlockProverPublicOutput, NetworkState, Protocol, StateTransitionProof, BlockHashMerkleTreeWitness, MandatoryProtocolModulesRecord } from "@proto-kit/protocol";
import { Proof } from "o1js";
import { ProvableMethodExecutionContext } from "@proto-kit/common";
import { Task, TaskSerializer } from "../../../worker/flow/Task";
import { TaskWorkerModule } from "../../../worker/worker/TaskWorkerModule";
import { PairingDerivedInput } from "../flow/ReductionTaskFlow";
import { TaskStateRecord } from "../TransactionTraceService";
import { CompileRegistry } from "./CompileRegistry";
type BlockProof = Proof<BlockProverPublicInput, BlockProverPublicOutput>;
export interface NewBlockProverParameters {
    publicInput: BlockProverPublicInput;
    networkState: NetworkState;
    blockWitness: BlockHashMerkleTreeWitness;
    startingState: TaskStateRecord;
}
export type NewBlockProvingParameters = PairingDerivedInput<StateTransitionProof, BlockProof, NewBlockProverParameters>;
export declare class NewBlockTask extends TaskWorkerModule implements Task<NewBlockProvingParameters, BlockProof> {
    private readonly protocol;
    private readonly executionContext;
    private readonly compileRegistry;
    private readonly stateTransitionProver;
    private readonly blockProver;
    readonly name = "newBlock";
    constructor(protocol: Protocol<MandatoryProtocolModulesRecord>, executionContext: ProvableMethodExecutionContext, compileRegistry: CompileRegistry);
    inputSerializer(): TaskSerializer<NewBlockProvingParameters>;
    resultSerializer(): TaskSerializer<BlockProof>;
    private executeWithPrefilledStateService;
    compute(input: NewBlockProvingParameters): Promise<BlockProof>;
    prepare(): Promise<void>;
}
export {};
//# sourceMappingURL=NewBlockTask.d.ts.map