import { Closeable } from "../../../worker/queue/TaskQueue";
import { BatchProducerModule } from "../BatchProducerModule";
import { Mempool } from "../../../mempool/Mempool";
import { BlockQueue } from "../../../storage/repositories/BlockStorage";
import { BlockProducerModule } from "../sequencing/BlockProducerModule";
import { SettlementModule } from "../../../settlement/SettlementModule";
import { SettlementStorage } from "../../../storage/repositories/SettlementStorage";
import { BatchStorage } from "../../../storage/repositories/BatchStorage";
import { BlockEvents, BlockTrigger, BlockTriggerBase } from "./BlockTrigger";
export interface TimedBlockTriggerConfig {
    /**
     * Interval for the tick event to be fired.
     * The time x of any block trigger time is always guaranteed to be
     * tick % x == 0.
     * Value has to be a divisor of gcd(blockInterval, settlementInterval).
     * If it doesn't satisfy this requirement, this config will not be respected
     */
    tick?: number;
    settlementInterval?: number;
    blockInterval: number;
    produceEmptyBlocks?: boolean;
}
export interface TimedBlockTriggerEvent extends BlockEvents {
    tick: [number];
}
export declare class TimedBlockTrigger extends BlockTriggerBase<TimedBlockTriggerConfig, TimedBlockTriggerEvent> implements BlockTrigger, Closeable {
    private readonly mempool;
    private interval?;
    constructor(batchProducerModule: BatchProducerModule | undefined, blockProducerModule: BlockProducerModule, settlementModule: SettlementModule | undefined, blockQueue: BlockQueue, batchStorage: BatchStorage, settlementStorage: SettlementStorage | undefined, mempool: Mempool);
    private getTimerInterval;
    start(): Promise<void>;
    private produceUnprovenBlock;
    close(): Promise<void>;
}
//# sourceMappingURL=TimedBlockTrigger.d.ts.map