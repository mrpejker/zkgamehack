var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import "reflect-metadata";
import { Field, PrivateKey, PublicKey, UInt64 } from "o1js";
import { Runtime, runtimeMethod, RuntimeModule, runtimeModule, state, } from "@proto-kit/module";
import { AccountStateModule, Option, State, StateMap, VanillaProtocol, } from "@proto-kit/protocol";
import { log } from "@proto-kit/common";
import { BlockProducerModule, LocalTaskQueue, LocalTaskWorkerModule, NoopBaseLayer, PrivateMempool, Sequencer, TimedBlockTrigger, UnsignedTransaction } from "@proto-kit/sequencer";
import { BlockStorageResolver, GraphqlSequencerModule, GraphqlServer, MempoolResolver, NodeStatusResolver, QueryGraphqlModule } from "@proto-kit/api";
import { AppChain } from "./appChain/AppChain";
import { StateServiceQueryModule } from "./query/StateServiceQueryModule";
import { InMemorySigner } from "./transaction/InMemorySigner";
import { InMemoryTransactionSender } from "./transaction/InMemoryTransactionSender";
log.setLevel(log.levels.INFO);
function createNewTx() {
    const pk = PrivateKey.random();
    const tx = new UnsignedTransaction({
        nonce: UInt64.zero,
        args: [Field(1)],
        methodId: Field(1),
        sender: pk.toPublicKey(),
    }).sign(pk);
    console.log(tx.toJSON());
}
createNewTx();
let Balances = class Balances extends RuntimeModule {
    constructor() {
        super(...arguments);
        this.balances = StateMap.from(PublicKey, UInt64);
        this.totalSupply = State.from(UInt64);
    }
    getBalance(address) {
        return this.balances.get(address);
    }
    setBalance(address, balance) {
        this.balances.set(address, balance);
    }
};
/**
 * We use `satisfies` here in order to be able to access
 * presets by key in a type safe way.
 */
Balances.presets = {};
__decorate([
    state(),
    __metadata("design:type", Object)
], Balances.prototype, "balances", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], Balances.prototype, "totalSupply", void 0);
__decorate([
    runtimeMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey]),
    __metadata("design:returntype", Option)
], Balances.prototype, "getBalance", null);
__decorate([
    runtimeMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey, UInt64]),
    __metadata("design:returntype", void 0)
], Balances.prototype, "setBalance", null);
Balances = __decorate([
    runtimeModule()
], Balances);
export { Balances };
const appChain = AppChain.from({
    runtime: Runtime.from({
        modules: {
            Balances,
        },
        config: {
            Balances: {},
        },
    }),
    protocol: VanillaProtocol.from({ AccountStateModule }, { AccountStateModule: {}, StateTransitionProver: {}, BlockProver: {} }),
    sequencer: Sequencer.from({
        modules: {
            Mempool: PrivateMempool,
            GraphqlServer,
            LocalTaskWorkerModule,
            BaseLayer: NoopBaseLayer,
            BlockProducerModule,
            BlockTrigger: TimedBlockTrigger,
            TaskQueue: LocalTaskQueue,
            Graphql: GraphqlSequencerModule.from({
                modules: {
                    MempoolResolver,
                    QueryGraphqlModule,
                    BlockStorageResolver,
                    NodeStatusResolver,
                },
                config: {
                    MempoolResolver: {},
                    QueryGraphqlModule: {},
                    BlockStorageResolver: {},
                    NodeStatusResolver: {},
                },
            }),
        },
    }),
    modules: {
        Signer: InMemorySigner,
        TransactionSender: InMemoryTransactionSender,
        QueryTransportModule: StateServiceQueryModule,
    },
});
appChain.configure({
    Runtime: {
        Balances: {},
    },
    Protocol: {
        BlockProver: {},
        StateTransitionProver: {},
        AccountStateModule: {},
    },
    Sequencer: {
        GraphqlServer: {
            port: 8080,
            host: "0.0.0.0",
        },
        Graphql: {
            QueryGraphqlModule: {},
            MempoolResolver: {},
            BlockStorageResolver: {},
            NodeStatusResolver: {}
        },
        Mempool: {},
        BlockProducerModule: {},
        LocalTaskWorkerModule: {},
        BaseLayer: {},
        TaskQueue: {},
        BlockTrigger: {
            blocktime: 5000
        },
    },
    TransactionSender: {},
    QueryTransportModule: {},
    Signer: {
        signer: PrivateKey.random(),
    },
});
await appChain.start();
const pk = PublicKey.fromBase58("B62qmETai5Y8vvrmWSU8F4NX7pTyPqYLMhc1pgX3wD8dGc2wbCWUcqP");
console.log(pk.toJSON());
const balances = appChain.runtime.resolve("Balances");
console.log("Path:", balances.balances.getPath(pk).toString());
const asyncState = appChain.sequencer.dependencyContainer.resolve("AsyncStateService");
await asyncState.setAsync(balances.balances.getPath(pk), [Field(100)]);
await asyncState.setAsync(balances.totalSupply.path, [Field(10000)]);
