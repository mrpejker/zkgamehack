/* eslint-disable @typescript-eslint/consistent-type-assertions */
import { ModuleContainer, } from "@proto-kit/common";
import { MethodParameterEncoder, } from "@proto-kit/module";
import { NetworkStateQuery, QueryBuilderFactory, UnsignedTransaction, DummyStateService, } from "@proto-kit/sequencer";
import { NetworkState, RuntimeTransaction, RuntimeMethodExecutionContext, } from "@proto-kit/protocol";
import { Field, UInt64 } from "o1js";
import { container } from "tsyringe";
import { AppChainTransaction } from "../transaction/AppChainTransaction";
import { AreProofsEnabledFactory } from "./AreProofsEnabledFactory";
import { SharedDependencyFactory } from "./SharedDependencyFactory";
/**
 * AppChain acts as a wrapper connecting Runtime, Protocol and Sequencer
 */
export class AppChain extends ModuleContainer {
    // alternative AppChain constructor
    static from(definition) {
        return new AppChain(definition);
    }
    constructor(definition) {
        const expandedDefinition = {
            modules: {
                Runtime: definition.Runtime,
                Protocol: definition.Protocol,
                Sequencer: definition.Sequencer,
                ...definition.modules,
            },
        };
        super(expandedDefinition);
        this.definition = expandedDefinition;
    }
    get query() {
        const queryTransportModule = this.container.resolve("QueryTransportModule");
        const networkStateTransportModule = this.container.resolve("NetworkStateTransportModule");
        const network = new NetworkStateQuery(networkStateTransportModule);
        return {
            runtime: QueryBuilderFactory.fromRuntime(this.runtime, queryTransportModule),
            protocol: QueryBuilderFactory.fromProtocol(this.protocol, queryTransportModule),
            network,
        };
    }
    get runtime() {
        return this.resolve("Runtime");
    }
    get sequencer() {
        return this.resolve("Sequencer");
    }
    get protocol() {
        return this.resolve("Protocol");
    }
    async transaction(sender, callback, options) {
        const executionContext = container.resolve(RuntimeMethodExecutionContext);
        executionContext.setup({
            transaction: RuntimeTransaction.dummyTransaction(),
            networkState: NetworkState.empty(),
        });
        executionContext.setSimulated(true);
        const stateServiceProvider = this.container.resolve("StateServiceProvider");
        stateServiceProvider.setCurrentStateService(new DummyStateService());
        await callback();
        stateServiceProvider.popCurrentStateService();
        const { methodName, moduleName, args } = executionContext.current().result;
        // TODO: extract error
        if (methodName === undefined ||
            moduleName === undefined ||
            args === undefined) {
            throw new Error("Unable to determine moduleName, methodName or args for the transaction");
        }
        // forgive me, i'll fix this type issue soon
        const runtimeModule = this.runtime.resolve(moduleName);
        const encoder = MethodParameterEncoder.fromMethod(runtimeModule, methodName);
        const { fields, auxiliary } = encoder.encode(args);
        const retrieveNonce = async (publicKey) => {
            const query = this.query.protocol;
            const accountState = await query.AccountState.accountState.get(publicKey);
            return accountState?.nonce;
        };
        const nonce = options?.nonce !== undefined
            ? UInt64.from(options.nonce)
            : (await retrieveNonce(sender)) ?? UInt64.from(0);
        const unsignedTransaction = new UnsignedTransaction({
            methodId: Field(this.runtime.dependencyContainer
                .resolve("MethodIdResolver")
                .getMethodId(moduleName, methodName)),
            argsFields: fields,
            auxiliaryData: auxiliary,
            nonce,
            sender,
            isMessage: false,
        });
        const signer = this.container.resolve("Signer");
        const transactionSender = this.container.resolve("TransactionSender");
        const transaction = new AppChainTransaction(signer, transactionSender);
        transaction.withUnsignedTransaction(unsignedTransaction);
        return transaction;
    }
    /**
     * Starts the appchain and cross-registers runtime to sequencer
     */
    async start(dependencyContainer = container) {
        this.create(() => dependencyContainer);
        this.useDependencyFactory(this.container.resolve(AreProofsEnabledFactory));
        this.useDependencyFactory(this.container.resolve(SharedDependencyFactory));
        // These three statements are crucial for dependencies inside any of these
        // components to access their siblings inside their constructor.
        // This is because when it is the first time they are resolved, create()
        // will not be called until after the constructor finished because of
        // how tsyringe handles hooks
        this.resolve("Runtime");
        this.resolve("Protocol");
        this.resolve("Sequencer");
        // // Workaround to get protocol and sequencer to have
        // // access to the same WitnessProviderReference
        // const reference = new StateTransitionWitnessProviderReference();
        // this.registerValue({
        //   StateTransitionWitnessProviderReference: reference,
        // });
        // console.log("creating sequencer");
        // this.sequencer.create(() => this.container);
        await this.protocol.start();
        // this.runtime.start();
        await this.sequencer.start();
    }
}
/* eslint-enable @typescript-eslint/consistent-type-assertions */
