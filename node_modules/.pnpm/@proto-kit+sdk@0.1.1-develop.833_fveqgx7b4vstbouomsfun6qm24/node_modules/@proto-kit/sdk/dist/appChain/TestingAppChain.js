import { Runtime } from "@proto-kit/module";
import { Protocol, } from "@proto-kit/protocol";
import { VanillaRuntimeModules, VanillaProtocolModules, InMemorySequencerModules, } from "@proto-kit/library";
import { Sequencer, ManualBlockTrigger, } from "@proto-kit/sequencer";
import { PrivateKey } from "o1js";
import { StateServiceQueryModule } from "../query/StateServiceQueryModule";
import { InMemorySigner } from "../transaction/InMemorySigner";
import { InMemoryTransactionSender } from "../transaction/InMemoryTransactionSender";
import { BlockStorageNetworkStateModule } from "../query/BlockStorageNetworkStateModule";
import { AppChain } from "./AppChain";
export const randomFeeRecipient = PrivateKey.random().toPublicKey().toBase58();
export class TestingAppChain extends AppChain {
    static fromRuntime(runtimeModules) {
        const appChain = new TestingAppChain({
            Runtime: Runtime.from({
                modules: VanillaRuntimeModules.with(runtimeModules),
            }),
            Protocol: Protocol.from({
                modules: VanillaProtocolModules.with({}),
            }),
            Sequencer: Sequencer.from({
                modules: InMemorySequencerModules.with({}),
            }),
            modules: {
                Signer: InMemorySigner,
                TransactionSender: InMemoryTransactionSender,
                QueryTransportModule: StateServiceQueryModule,
                NetworkStateTransportModule: BlockStorageNetworkStateModule,
            },
        });
        appChain.configurePartial({
            Protocol: {
                AccountState: {},
                BlockProver: {},
                StateTransitionProver: {},
                BlockHeight: {},
                LastStateRoot: {},
                TransactionFee: {
                    tokenId: 0n,
                    feeRecipient: randomFeeRecipient,
                    baseFee: 0n,
                    perWeightUnitFee: 0n,
                    methods: {},
                },
            },
            Sequencer: {
                Database: {},
                BlockTrigger: {},
                Mempool: {},
                BatchProducerModule: {},
                LocalTaskWorkerModule: {
                    StateTransitionTask: {},
                    RuntimeProvingTask: {},
                    StateTransitionReductionTask: {},
                    BlockReductionTask: {},
                    BlockProvingTask: {},
                    BlockBuildingTask: {},
                },
                BaseLayer: {},
                BlockProducerModule: {},
                TaskQueue: {
                    simulatedDuration: 0,
                },
            },
            Signer: {
                signer: PrivateKey.random(),
            },
            TransactionSender: {},
            QueryTransportModule: {},
            NetworkStateTransportModule: {},
        });
        return appChain;
    }
    setSigner(signer) {
        const inMemorySigner = this.resolveOrFail("Signer", InMemorySigner);
        inMemorySigner.config.signer = signer;
    }
    async produceBlock() {
        const blockTrigger = this.sequencer.resolveOrFail("BlockTrigger", ManualBlockTrigger);
        return await blockTrigger.produceBlock();
    }
}
