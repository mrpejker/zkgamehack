var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { buildSchemaSync } from "type-graphql";
import { injectable } from "tsyringe";
import { SequencerModule } from "@proto-kit/sequencer";
import { log, noop } from "@proto-kit/common";
import { stitchSchemas } from "@graphql-tools/stitch";
import { createYoga } from "graphql-yoga";
import Koa from "koa";
function assertArrayIsNotEmpty(array, errorMessage) {
    if (array.length === 0) {
        throw new Error(errorMessage);
    }
}
export let GraphqlServer = class GraphqlServer extends SequencerModule {
    constructor() {
        super(...arguments);
        this.modules = [];
        this.schemas = [];
    }
    setContainer(container) {
        this.dependencyContainer = container;
    }
    assertDependencyContainerSet(container) {
        if (container === undefined) {
            throw new Error("DependencyContainer for GraphqlServer not set");
        }
    }
    registerModule(module) {
        this.modules.push(module);
    }
    registerSchema(schema) {
        this.schemas.push(schema);
    }
    async start() {
        noop();
    }
    async startServer() {
        const { dependencyContainer, modules } = this;
        this.assertDependencyContainerSet(dependencyContainer);
        assertArrayIsNotEmpty(modules, "At least one module has to be provided to GraphqlServer");
        // Building schema
        const resolverSchema = buildSchemaSync({
            resolvers: modules,
            // resolvers: [MempoolResolver as Function],
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            container: { get: (cls) => dependencyContainer.resolve(cls) },
            validate: {
                enableDebugMessages: true,
            },
        });
        // TODO Injection token of Graphql Container not respected atm, only class is used
        // Instantiate all modules at startup
        modules.forEach((module) => {
            dependencyContainer?.resolve(module);
        });
        const schema = [resolverSchema, ...this.schemas].reduce((schema1, schema2) => stitchSchemas({
            subschemas: [{ schema: schema1 }, { schema: schema2 }],
        }));
        const app = new Koa();
        const yoga = createYoga({
            schema,
            graphiql: this.config.graphiql,
        });
        // Bind GraphQL Yoga to `/graphql` endpoint
        app.use(async (ctx) => {
            // Second parameter adds Koa's context into GraphQL Context
            const response = await yoga.handleNodeRequest(ctx.req, ctx);
            // Set status code
            ctx.status = response.status;
            // Set headers
            response.headers.forEach((value, key) => {
                ctx.append(key, value);
            });
            // Converts ReadableStream to a NodeJS Stream
            ctx.body = response.body;
        });
        const { port, host } = this.config;
        this.server = app.listen({ port, host }, () => {
            log.info(`GraphQL Server listening on ${host}:${port}`);
        });
    }
    close() {
        this.server?.close();
    }
};
GraphqlServer = __decorate([
    injectable()
], GraphqlServer);
