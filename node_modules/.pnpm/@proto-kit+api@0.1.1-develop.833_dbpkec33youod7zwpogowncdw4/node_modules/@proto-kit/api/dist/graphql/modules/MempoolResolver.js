var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TransactionObject_1;
import { Arg, Field, InputType, Mutation, ObjectType, Query, registerEnumType, } from "type-graphql";
import { inject } from "tsyringe";
import { IsNumberString } from "class-validator";
import { PendingTransaction, } from "@proto-kit/sequencer";
import { graphqlModule, GraphqlModule } from "../GraphqlModule.js";
export let Signature = class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
    }
};
__decorate([
    Field(),
    IsNumberString(),
    __metadata("design:type", String)
], Signature.prototype, "r", void 0);
__decorate([
    Field(),
    IsNumberString(),
    __metadata("design:type", String)
], Signature.prototype, "s", void 0);
Signature = __decorate([
    ObjectType(),
    InputType("SignatureInput"),
    __metadata("design:paramtypes", [String, String])
], Signature);
export let TransactionObject = TransactionObject_1 = class TransactionObject {
    static fromServiceLayerModel(pt) {
        const { methodId, sender, nonce, signature, argsFields, auxiliaryData, isMessage, } = pt.toJSON();
        return new TransactionObject_1(pt.hash().toString(), methodId, sender, nonce, signature, argsFields, auxiliaryData, isMessage);
    }
    constructor(hash, methodId, sender, nonce, signature, argsFields, auxiliaryData, isMessage) {
        this.hash = hash;
        this.methodId = methodId;
        this.sender = sender;
        this.nonce = nonce;
        this.signature = signature;
        this.argsFields = argsFields;
        this.auxiliaryData = auxiliaryData;
        this.isMessage = isMessage;
    }
};
__decorate([
    Field(),
    __metadata("design:type", String)
], TransactionObject.prototype, "hash", void 0);
__decorate([
    Field(),
    IsNumberString(),
    __metadata("design:type", String)
], TransactionObject.prototype, "methodId", void 0);
__decorate([
    Field(),
    __metadata("design:type", String)
], TransactionObject.prototype, "sender", void 0);
__decorate([
    Field(),
    IsNumberString(),
    __metadata("design:type", String)
], TransactionObject.prototype, "nonce", void 0);
__decorate([
    Field(() => Signature),
    __metadata("design:type", Signature)
], TransactionObject.prototype, "signature", void 0);
__decorate([
    Field(() => [String]),
    __metadata("design:type", Array)
], TransactionObject.prototype, "argsFields", void 0);
__decorate([
    Field(() => [String]),
    __metadata("design:type", Array)
], TransactionObject.prototype, "auxiliaryData", void 0);
__decorate([
    Field(),
    __metadata("design:type", Boolean)
], TransactionObject.prototype, "isMessage", void 0);
TransactionObject = TransactionObject_1 = __decorate([
    ObjectType(),
    InputType("TransactionObjectInput"),
    __metadata("design:paramtypes", [String, String, String, String, Signature, Array, Array, Boolean])
], TransactionObject);
var InclusionStatus;
(function (InclusionStatus) {
    InclusionStatus["UNKNOWN"] = "unknown";
    InclusionStatus["PENDING"] = "pending";
    InclusionStatus["INCLUDED"] = "included";
    InclusionStatus["SETTLED"] = "settled";
})(InclusionStatus || (InclusionStatus = {}));
registerEnumType(InclusionStatus, {
    name: "InclusionStatus",
});
export let MempoolResolver = class MempoolResolver extends GraphqlModule {
    constructor(mempool, transactionStorage) {
        super();
        this.mempool = mempool;
        this.transactionStorage = transactionStorage;
    }
    async submitTx(tx) {
        const decoded = PendingTransaction.fromJSON(tx);
        await this.mempool.add(decoded);
        return decoded.hash().toString();
    }
    async transactionState(hash) {
        const txs = await this.mempool.getTxs();
        const tx = txs.find((x) => x.hash().toString() === hash);
        if (tx) {
            return InclusionStatus.PENDING;
        }
        const dbTx = await this.transactionStorage.findTransaction(hash);
        if (dbTx !== undefined) {
            if (dbTx.batch !== undefined) {
                return InclusionStatus.SETTLED;
            }
            if (dbTx.block !== undefined) {
                return InclusionStatus.INCLUDED;
            }
        }
        return InclusionStatus.UNKNOWN;
    }
    async transactions() {
        const txs = await this.mempool.getTxs();
        return txs.map((x) => x.hash().toString());
    }
};
__decorate([
    Mutation(() => String, {
        description: "Adds a transaction to the mempool and validates it",
    }),
    __param(0, Arg("tx")),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TransactionObject]),
    __metadata("design:returntype", Promise)
], MempoolResolver.prototype, "submitTx", null);
__decorate([
    Query(() => InclusionStatus, {
        description: "Returns the state of a given transaction",
    }),
    __param(0, Arg("hash", {
        description: "The hash of the transaction to be queried for",
    })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MempoolResolver.prototype, "transactionState", null);
__decorate([
    Query(() => [String], {
        description: "Returns the hashes of all transactions that are currently inside the mempool",
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MempoolResolver.prototype, "transactions", null);
MempoolResolver = __decorate([
    graphqlModule(),
    __param(0, inject("Mempool")),
    __param(1, inject("TransactionStorage")),
    __metadata("design:paramtypes", [Object, Object])
], MempoolResolver);
