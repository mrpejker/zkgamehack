"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createDynamicallyTrackedParams: null,
    getFallbackRouteParams: null,
    getParamKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createDynamicallyTrackedParams: function() {
        return createDynamicallyTrackedParams;
    },
    getFallbackRouteParams: function() {
        return getFallbackRouteParams;
    },
    getParamKeys: function() {
        return getParamKeys;
    }
});
const _dynamicrendering = require("../../server/app-render/dynamic-rendering");
const _reflect = require("../../server/web/spec-extension/adapters/reflect");
const _routematcher = require("../../shared/lib/router/utils/route-matcher");
const _routeregex = require("../../shared/lib/router/utils/route-regex");
const _staticgenerationasyncstorageexternal = require("./static-generation-async-storage.external");
function getParamKeys(page) {
    const pattern = (0, _routeregex.getRouteRegex)(page);
    const matcher = (0, _routematcher.getRouteMatcher)(pattern);
    // Get the default list of allowed params.
    return Object.keys(matcher(page));
}
function getFallbackRouteParams(pageOrKeys) {
    let keys;
    if (typeof pageOrKeys === 'string') {
        keys = getParamKeys(pageOrKeys);
    } else {
        keys = pageOrKeys;
    }
    // If there are no keys, we can return early.
    if (keys.length === 0) return null;
    const params = new Map();
    // As we're creating unique keys for each of the dynamic route params, we only
    // need to generate a unique ID once per request because each of the keys will
    // be also be unique.
    const uniqueID = Math.random().toString(16).slice(2);
    for (const key of keys){
        params.set(key, "%%drp:" + key + ":" + uniqueID + "%%");
    }
    return params;
}
function createDynamicallyTrackedParams(params) {
    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (!staticGenerationStore || !staticGenerationStore.isStaticGeneration || !staticGenerationStore.fallbackRouteParams || staticGenerationStore.fallbackRouteParams.size === 0) {
        return params;
    }
    // If there are no unknown route params, we can just return the params.
    const { fallbackRouteParams } = staticGenerationStore;
    return new Proxy(params, {
        get (target, prop, receiver) {
            // If the property is in the params object, we should track the access if
            // it's an unknown dynamic param.
            if (typeof prop === 'string' && prop in params && fallbackRouteParams.has(prop)) {
                (0, _dynamicrendering.trackFallbackParamAccessed)(staticGenerationStore, "params." + prop);
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string' && prop in params && fallbackRouteParams.has(prop)) {
                (0, _dynamicrendering.trackFallbackParamAccessed)(staticGenerationStore, "params." + prop);
            }
            return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys (target) {
            for(const key in params){
                if (fallbackRouteParams.has(key)) {
                    (0, _dynamicrendering.trackFallbackParamAccessed)(staticGenerationStore, 'params');
                }
            }
            return Reflect.ownKeys(target);
        }
    });
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=fallback-params.js.map