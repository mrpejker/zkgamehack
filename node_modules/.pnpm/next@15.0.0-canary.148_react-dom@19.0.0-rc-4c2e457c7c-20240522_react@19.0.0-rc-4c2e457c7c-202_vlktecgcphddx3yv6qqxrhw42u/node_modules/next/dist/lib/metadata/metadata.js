"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createMetadataComponents: null,
    createMetadataContext: null,
    createTrackedMetadataContext: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createMetadataComponents: function() {
        return createMetadataComponents;
    },
    createMetadataContext: function() {
        return createMetadataContext;
    },
    createTrackedMetadataContext: function() {
        return createTrackedMetadataContext;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _basic = require("./generate/basic");
const _alternate = require("./generate/alternate");
const _opengraph = require("./generate/opengraph");
const _icons = require("./generate/icons");
const _resolvemetadata = require("./resolve-metadata");
const _meta = require("./generate/meta");
const _notfound = require("../../client/components/not-found");
const _dynamicrendering = require("../../server/app-render/dynamic-rendering");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createMetadataContext(pathname, renderOpts) {
    return {
        pathname,
        trailingSlash: renderOpts.trailingSlash,
        isStandaloneMode: renderOpts.nextConfigOutput === 'standalone'
    };
}
function createTrackedMetadataContext(pathname, renderOpts, staticGenerationStore) {
    return {
        // Use the regular metadata context, but we trap the pathname access.
        ...createMetadataContext(pathname, renderOpts),
        // Setup the trap around the pathname access so we can track when the
        // pathname is accessed while resolving metadata which would indicate it's
        // being used to resolve a relative URL. If that's the case, we don't want
        // to provide it, and instead we should error.
        get pathname () {
            if (staticGenerationStore && staticGenerationStore.isStaticGeneration && staticGenerationStore.fallbackRouteParams && staticGenerationStore.fallbackRouteParams.size > 0) {
                (0, _dynamicrendering.trackFallbackParamAccessed)(staticGenerationStore, 'metadata relative url resolving');
            }
            return pathname;
        }
    };
}
function createMetadataComponents({ tree, query, metadataContext, getDynamicParamFromSegment, appUsingSizeAdjustment, errorType, createDynamicallyTrackedSearchParams, createDynamicallyTrackedParams }) {
    let currentMetadataReady = null;
    async function MetadataTree() {
        const pendingMetadata = getResolvedMetadata(tree, query, getDynamicParamFromSegment, metadataContext, createDynamicallyTrackedSearchParams, createDynamicallyTrackedParams, errorType);
        // We instrument the promise compatible with React. This isn't necessary but we can
        // perform a similar trick in synchronously unwrapping in the outlet component to avoid
        // ticking a new microtask unecessarily
        const metadataReady = pendingMetadata.then(([error])=>{
            if (error) {
                metadataReady.status = 'rejected';
                metadataReady.value = error;
                throw error;
            }
            metadataReady.status = 'fulfilled';
            metadataReady.value = undefined;
        }, (error)=>{
            metadataReady.status = 'rejected';
            metadataReady.value = error;
            throw error;
        });
        metadataReady.status = 'pending';
        currentMetadataReady = metadataReady;
        // We aren't going to await this promise immediately but if it rejects early we don't
        // want unhandled rejection errors so we attach a throwaway catch handler.
        metadataReady.catch(()=>{});
        // We ignore any error from metadata here because it needs to be thrown from within the Page
        // not where the metadata itself is actually rendered
        const [, elements] = await pendingMetadata;
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                elements.map((el, index)=>{
                    return /*#__PURE__*/ _react.default.cloneElement(el, {
                        key: index
                    });
                }),
                appUsingSizeAdjustment ? /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
                    name: "next-size-adjust"
                }) : null
            ]
        });
    }
    function getMetadataReady() {
        return Promise.resolve().then(()=>{
            if (currentMetadataReady) {
                return currentMetadataReady;
            }
            throw new Error('getMetadataReady was called before MetadataTree rendered');
        });
    }
    return [
        MetadataTree,
        getMetadataReady
    ];
}
async function getResolvedMetadata(tree, query, getDynamicParamFromSegment, metadataContext, createDynamicallyTrackedSearchParams, createDynamicallyTrackedParams, errorType) {
    const errorMetadataItem = [
        null,
        null,
        null
    ];
    const errorConvention = errorType === 'redirect' ? undefined : errorType;
    const searchParams = createDynamicallyTrackedSearchParams(query);
    const [error, metadata, viewport] = await (0, _resolvemetadata.resolveMetadata)({
        tree,
        parentParams: {},
        metadataItems: [],
        errorMetadataItem,
        searchParams,
        getDynamicParamFromSegment,
        errorConvention,
        metadataContext,
        createDynamicallyTrackedParams
    });
    if (!error) {
        return [
            null,
            createMetadataElements(metadata, viewport)
        ];
    } else {
        // If a not-found error is triggered during metadata resolution, we want to capture the metadata
        // for the not-found route instead of whatever triggered the error. For all error types, we resolve an
        // error, which will cause the outlet to throw it so it'll be handled by an error boundary
        // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).
        if (!errorType && (0, _notfound.isNotFoundError)(error)) {
            const [notFoundMetadataError, notFoundMetadata, notFoundViewport] = await (0, _resolvemetadata.resolveMetadata)({
                tree,
                parentParams: {},
                metadataItems: [],
                errorMetadataItem,
                searchParams,
                getDynamicParamFromSegment,
                errorConvention: 'not-found',
                metadataContext,
                createDynamicallyTrackedParams
            });
            return [
                notFoundMetadataError || error,
                createMetadataElements(notFoundMetadata, notFoundViewport)
            ];
        }
        return [
            error,
            []
        ];
    }
}
function createMetadataElements(metadata, viewport) {
    return (0, _meta.MetaFilter)([
        (0, _basic.ViewportMeta)({
            viewport: viewport
        }),
        (0, _basic.BasicMeta)({
            metadata
        }),
        (0, _alternate.AlternatesMetadata)({
            alternates: metadata.alternates
        }),
        (0, _basic.ItunesMeta)({
            itunes: metadata.itunes
        }),
        (0, _basic.FacebookMeta)({
            facebook: metadata.facebook
        }),
        (0, _basic.FormatDetectionMeta)({
            formatDetection: metadata.formatDetection
        }),
        (0, _basic.VerificationMeta)({
            verification: metadata.verification
        }),
        (0, _basic.AppleWebAppMeta)({
            appleWebApp: metadata.appleWebApp
        }),
        (0, _opengraph.OpenGraphMetadata)({
            openGraph: metadata.openGraph
        }),
        (0, _opengraph.TwitterMetadata)({
            twitter: metadata.twitter
        }),
        (0, _opengraph.AppLinksMeta)({
            appLinks: metadata.appLinks
        }),
        (0, _icons.IconsMetadata)({
            icons: metadata.icons
        })
    ]);
}

//# sourceMappingURL=metadata.js.map