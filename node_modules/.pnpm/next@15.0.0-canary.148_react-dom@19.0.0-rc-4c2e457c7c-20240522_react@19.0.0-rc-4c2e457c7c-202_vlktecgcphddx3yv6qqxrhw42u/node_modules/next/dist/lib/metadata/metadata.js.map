{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type {\n  AppRenderContext,\n  GetDynamicParamFromSegment,\n} from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport type { MetadataContext } from './types/resolvers'\nimport type { CreateDynamicallyTrackedParams } from '../../client/components/fallback-params'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport { trackFallbackParamAccessed } from '../../server/app-render/dynamic-rendering'\n\nexport function createMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts']\n): MetadataContext {\n  return {\n    pathname,\n    trailingSlash: renderOpts.trailingSlash,\n    isStandaloneMode: renderOpts.nextConfigOutput === 'standalone',\n  }\n}\n\nexport function createTrackedMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts'],\n  staticGenerationStore: StaticGenerationStore | null\n): MetadataContext {\n  return {\n    // Use the regular metadata context, but we trap the pathname access.\n    ...createMetadataContext(pathname, renderOpts),\n\n    // Setup the trap around the pathname access so we can track when the\n    // pathname is accessed while resolving metadata which would indicate it's\n    // being used to resolve a relative URL. If that's the case, we don't want\n    // to provide it, and instead we should error.\n    get pathname() {\n      if (\n        staticGenerationStore &&\n        staticGenerationStore.isStaticGeneration &&\n        staticGenerationStore.fallbackRouteParams &&\n        staticGenerationStore.fallbackRouteParams.size > 0\n      ) {\n        trackFallbackParamAccessed(\n          staticGenerationStore,\n          'metadata relative url resolving'\n        )\n      }\n\n      return pathname\n    },\n  }\n}\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  query,\n  metadataContext,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n  createDynamicallyTrackedParams,\n}: {\n  tree: LoaderTree\n  query: ParsedUrlQuery\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedParams: CreateDynamicallyTrackedParams\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, () => Promise<void>] {\n  let currentMetadataReady:\n    | null\n    | (Promise<void> & {\n        status?: string\n        value?: unknown\n      }) = null\n\n  async function MetadataTree() {\n    const pendingMetadata = getResolvedMetadata(\n      tree,\n      query,\n      getDynamicParamFromSegment,\n      metadataContext,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n      errorType\n    )\n\n    // We instrument the promise compatible with React. This isn't necessary but we can\n    // perform a similar trick in synchronously unwrapping in the outlet component to avoid\n    // ticking a new microtask unecessarily\n    const metadataReady: Promise<void> & { status: string; value: unknown } =\n      pendingMetadata.then(\n        ([error]) => {\n          if (error) {\n            metadataReady.status = 'rejected'\n            metadataReady.value = error\n            throw error\n          }\n          metadataReady.status = 'fulfilled'\n          metadataReady.value = undefined\n        },\n        (error) => {\n          metadataReady.status = 'rejected'\n          metadataReady.value = error\n          throw error\n        }\n      ) as Promise<void> & { status: string; value: unknown }\n    metadataReady.status = 'pending'\n    currentMetadataReady = metadataReady\n    // We aren't going to await this promise immediately but if it rejects early we don't\n    // want unhandled rejection errors so we attach a throwaway catch handler.\n    metadataReady.catch(() => {})\n\n    // We ignore any error from metadata here because it needs to be thrown from within the Page\n    // not where the metadata itself is actually rendered\n    const [, elements] = await pendingMetadata\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n        {appUsingSizeAdjustment ? <meta name=\"next-size-adjust\" /> : null}\n      </>\n    )\n  }\n\n  function getMetadataReady() {\n    return Promise.resolve().then(() => {\n      if (currentMetadataReady) {\n        return currentMetadataReady\n      }\n      throw new Error(\n        'getMetadataReady was called before MetadataTree rendered'\n      )\n    })\n  }\n\n  return [MetadataTree, getMetadataReady]\n}\n\nasync function getResolvedMetadata(\n  tree: LoaderTree,\n  query: ParsedUrlQuery,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery,\n  createDynamicallyTrackedParams: CreateDynamicallyTrackedParams,\n  errorType?: 'not-found' | 'redirect'\n): Promise<[any, Array<React.ReactNode>]> {\n  const errorMetadataItem: [null, null, null] = [null, null, null]\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n  const searchParams = createDynamicallyTrackedSearchParams(query)\n\n  const [error, metadata, viewport] = await resolveMetadata({\n    tree,\n    parentParams: {},\n    metadataItems: [],\n    errorMetadataItem,\n    searchParams,\n    getDynamicParamFromSegment,\n    errorConvention,\n    metadataContext,\n    createDynamicallyTrackedParams,\n  })\n  if (!error) {\n    return [null, createMetadataElements(metadata, viewport)]\n  } else {\n    // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n    // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n    // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n    // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n    if (!errorType && isNotFoundError(error)) {\n      const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n        await resolveMetadata({\n          tree,\n          parentParams: {},\n          metadataItems: [],\n          errorMetadataItem,\n          searchParams,\n          getDynamicParamFromSegment,\n          errorConvention: 'not-found',\n          metadataContext,\n          createDynamicallyTrackedParams,\n        })\n      return [\n        notFoundMetadataError || error,\n        createMetadataElements(notFoundMetadata, notFoundViewport),\n      ]\n    }\n    return [error, []]\n  }\n}\n\nfunction createMetadataElements(\n  metadata: ResolvedMetadata,\n  viewport: ResolvedViewport\n) {\n  return MetaFilter([\n    ViewportMeta({ viewport: viewport }),\n    BasicMeta({ metadata }),\n    AlternatesMetadata({ alternates: metadata.alternates }),\n    ItunesMeta({ itunes: metadata.itunes }),\n    FacebookMeta({ facebook: metadata.facebook }),\n    FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n    VerificationMeta({ verification: metadata.verification }),\n    AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n    OpenGraphMetadata({ openGraph: metadata.openGraph }),\n    TwitterMetadata({ twitter: metadata.twitter }),\n    AppLinksMeta({ appLinks: metadata.appLinks }),\n    IconsMetadata({ icons: metadata.icons }),\n  ])\n}\n"],"names":["createMetadataComponents","createMetadataContext","createTrackedMetadataContext","pathname","renderOpts","trailingSlash","isStandaloneMode","nextConfigOutput","staticGenerationStore","isStaticGeneration","fallbackRouteParams","size","trackFallbackParamAccessed","tree","query","metadataContext","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","createDynamicallyTrackedParams","currentMetadataReady","MetadataTree","pendingMetadata","getResolvedMetadata","metadataReady","then","error","status","value","undefined","catch","elements","map","el","index","React","cloneElement","key","meta","name","getMetadataReady","Promise","resolve","Error","errorMetadataItem","errorConvention","searchParams","metadata","viewport","resolveMetadata","parentParams","metadataItems","createMetadataElements","isNotFoundError","notFoundMetadataError","notFoundMetadata","notFoundViewport","MetaFilter","ViewportMeta","BasicMeta","AlternatesMetadata","alternates","ItunesMeta","itunes","FacebookMeta","facebook","FormatDetectionMeta","formatDetection","VerificationMeta","verification","AppleWebAppMeta","appleWebApp","OpenGraphMetadata","openGraph","TwitterMetadata","twitter","AppLinksMeta","appLinks","IconsMetadata","icons"],"mappings":"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"}