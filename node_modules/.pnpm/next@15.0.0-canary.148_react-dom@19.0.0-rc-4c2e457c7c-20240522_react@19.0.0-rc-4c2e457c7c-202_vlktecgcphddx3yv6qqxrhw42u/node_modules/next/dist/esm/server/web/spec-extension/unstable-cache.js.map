{"version":3,"sources":["../../../../src/server/web/spec-extension/unstable-cache.ts"],"sourcesContent":["import type { IncrementalCache } from '../../lib/incremental-cache'\n\nimport { CACHE_ONE_YEAR } from '../../../lib/constants'\nimport {\n  addImplicitTags,\n  validateRevalidate,\n  validateTags,\n} from '../../lib/patch-fetch'\nimport { staticGenerationAsyncStorage } from '../../../client/components/static-generation-async-storage.external'\nimport { requestAsyncStorage } from '../../../client/components/request-async-storage.external'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchData,\n} from '../../response-cache'\nimport { prerenderAsyncStorage } from '../../app-render/prerender-async-storage.external'\n\ntype Callback = (...args: any[]) => Promise<any>\n\nlet noStoreFetchIdx = 0\n\nasync function cacheNewResult<T>(\n  result: T,\n  incrementalCache: IncrementalCache,\n  cacheKey: string,\n  tags: string[],\n  revalidate: number | false | undefined,\n  fetchIdx: number,\n  fetchUrl: string\n): Promise<unknown> {\n  await incrementalCache.set(\n    cacheKey,\n    {\n      kind: CachedRouteKind.FETCH,\n      data: {\n        headers: {},\n        // TODO: handle non-JSON values?\n        body: JSON.stringify(result),\n        status: 200,\n        url: '',\n      } satisfies CachedFetchData,\n      revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,\n    },\n    {\n      revalidate,\n      fetchCache: true,\n      tags,\n      fetchIdx,\n      fetchUrl,\n    }\n  )\n  return\n}\n\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */\nexport function unstable_cache<T extends Callback>(\n  cb: T,\n  keyParts?: string[],\n  options: {\n    /**\n     * The revalidation interval in seconds.\n     */\n    revalidate?: number | false\n    tags?: string[]\n  } = {}\n): T {\n  if (options.revalidate === 0) {\n    throw new Error(\n      `Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`\n    )\n  }\n\n  // Validate the tags provided are valid\n  const tags = options.tags\n    ? validateTags(options.tags, `unstable_cache ${cb.toString()}`)\n    : []\n\n  // Validate the revalidate options\n  validateRevalidate(\n    options.revalidate,\n    `unstable_cache ${cb.name || cb.toString()}`\n  )\n\n  // Stash the fixed part of the key at construction time. The invocation key will combine\n  // the fixed key with the arguments when actually called\n  // @TODO if cb.toString() is long we should hash it\n  // @TODO come up with a collision-free way to combine keyParts\n  // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n  // and the error produced by accidentally using something that cannot be safely coerced is likely\n  // hard to debug\n  const fixedKey = `${cb.toString()}-${\n    Array.isArray(keyParts) && keyParts.join(',')\n  }`\n\n  const cachedCb = async (...args: any[]) => {\n    const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n    const requestStore = requestAsyncStorage.getStore()\n\n    // We must be able to find the incremental cache otherwise we throw\n    const maybeIncrementalCache:\n      | import('../../lib/incremental-cache').IncrementalCache\n      | undefined =\n      staticGenerationStore?.incrementalCache ||\n      (globalThis as any).__incrementalCache\n\n    if (!maybeIncrementalCache) {\n      throw new Error(\n        `Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`\n      )\n    }\n    const incrementalCache = maybeIncrementalCache\n\n    const prerenderStore = prerenderAsyncStorage.getStore()\n    const cacheSignal = prerenderStore?.cacheSignal\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    try {\n      // If there's no request store, we aren't in a request (or we're not in app\n      // router)  and if there's no static generation store, we aren't in app\n      // router. Default to an empty pathname and search params when there's no\n      // request store or static generation store available.\n      const pathname =\n        requestStore?.url.pathname ?? staticGenerationStore?.route ?? ''\n      const searchParams = new URLSearchParams(requestStore?.url.search ?? '')\n\n      const sortedSearchKeys = [...searchParams.keys()].sort((a, b) => {\n        return a.localeCompare(b)\n      })\n      const sortedSearch = sortedSearchKeys\n        .map((key) => `${key}=${searchParams.get(key)}`)\n        .join('&')\n\n      // Construct the complete cache key for this function invocation\n      // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n      // the keyspace smaller than the execution space\n      const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n      const cacheKey = await incrementalCache.generateCacheKey(invocationKey)\n      // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n      const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`\n      const fetchIdx =\n        (staticGenerationStore\n          ? staticGenerationStore.nextFetchId\n          : noStoreFetchIdx) ?? 1\n\n      if (staticGenerationStore) {\n        staticGenerationStore.nextFetchId = fetchIdx + 1\n\n        // We are in an App Router context. We try to return the cached entry if it exists and is valid\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        // We update the store's revalidate property if the option.revalidate is a higher precedence\n        if (typeof options.revalidate === 'number') {\n          if (\n            typeof staticGenerationStore.revalidate === 'number' &&\n            staticGenerationStore.revalidate < options.revalidate\n          ) {\n            // The store is already revalidating on a shorter time interval, leave it alone\n          } else {\n            staticGenerationStore.revalidate = options.revalidate\n          }\n        } else if (\n          options.revalidate === false &&\n          typeof staticGenerationStore.revalidate === 'undefined'\n        ) {\n          // The store has not defined revalidate type so we can use the false option\n          staticGenerationStore.revalidate = options.revalidate\n        }\n\n        // We need to accumulate the tags for this invocation within the store\n        if (!staticGenerationStore.tags) {\n          staticGenerationStore.tags = tags.slice()\n        } else {\n          for (const tag of tags) {\n            // @TODO refactor tags to be a set to avoid this O(n) lookup\n            if (!staticGenerationStore.tags.includes(tag)) {\n              staticGenerationStore.tags.push(tag)\n            }\n          }\n        }\n        // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n        // of this function is potentially a little confusing\n        const implicitTags = addImplicitTags(\n          staticGenerationStore,\n          requestStore\n        )\n\n        if (\n          // when we are nested inside of other unstable_cache's\n          // we should bypass cache similar to fetches\n          staticGenerationStore.fetchCache !== 'force-no-store' &&\n          !staticGenerationStore.isOnDemandRevalidate &&\n          !incrementalCache.isOnDemandRevalidate &&\n          !staticGenerationStore.isDraftMode\n        ) {\n          // We attempt to get the current cache entry from the incremental cache.\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            softTags: implicitTags,\n            fetchIdx,\n            fetchUrl,\n            isFallback: false,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else {\n              // We have a valid cache entry so we will be returning it. We also check to see if we need\n              // to background revalidate it by checking if it is stale.\n              const cachedResponse =\n                cacheEntry.value.data.body !== undefined\n                  ? JSON.parse(cacheEntry.value.data.body)\n                  : undefined\n              if (cacheEntry.isStale) {\n                // In App Router we return the stale result and revalidate in the background\n                if (!staticGenerationStore.pendingRevalidates) {\n                  staticGenerationStore.pendingRevalidates = {}\n                }\n                // We run the cache function asynchronously and save the result when it completes\n                staticGenerationStore.pendingRevalidates[invocationKey] =\n                  staticGenerationAsyncStorage\n                    .run(\n                      {\n                        ...staticGenerationStore,\n                        // force any nested fetches to bypass cache so they revalidate\n                        // when the unstable_cache call is revalidated\n                        fetchCache: 'force-no-store',\n                        isUnstableCacheCallback: true,\n                      },\n                      cb,\n                      ...args\n                    )\n                    .then((result) => {\n                      return cacheNewResult(\n                        result,\n                        incrementalCache,\n                        cacheKey,\n                        tags,\n                        options.revalidate,\n                        fetchIdx,\n                        fetchUrl\n                      )\n                    })\n                    // @TODO This error handling seems wrong. We swallow the error?\n                    .catch((err) =>\n                      console.error(\n                        `revalidating cache with key: ${invocationKey}`,\n                        err\n                      )\n                    )\n              }\n              // We had a valid cache entry so we return it here\n              return cachedResponse\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        const result = await staticGenerationAsyncStorage.run(\n          {\n            ...staticGenerationStore,\n            // force any nested fetches to bypass cache so they revalidate\n            // when the unstable_cache call is revalidated\n            fetchCache: 'force-no-store',\n            isUnstableCacheCallback: true,\n          },\n          cb,\n          ...args\n        )\n\n        if (!staticGenerationStore.isDraftMode) {\n          cacheNewResult(\n            result,\n            incrementalCache,\n            cacheKey,\n            tags,\n            options.revalidate,\n            fetchIdx,\n            fetchUrl\n          )\n        }\n\n        return result\n      } else {\n        noStoreFetchIdx += 1\n        // We are in Pages Router or were called outside of a render. We don't have a store\n        // so we just call the callback directly when it needs to run.\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        if (!incrementalCache.isOnDemandRevalidate) {\n          // We aren't doing an on demand revalidation so we check use the cache if valid\n\n          // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n          // of this function is potentially a little confusing\n          const implicitTags =\n            staticGenerationStore &&\n            addImplicitTags(staticGenerationStore, requestStore)\n\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            fetchIdx,\n            fetchUrl,\n            softTags: implicitTags,\n            isFallback: false,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else if (!cacheEntry.isStale) {\n              // We have a valid cache entry and it is fresh so we return it\n              return cacheEntry.value.data.body !== undefined\n                ? JSON.parse(cacheEntry.value.data.body)\n                : undefined\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        // @TODO this storage wrapper is included here because it existed prior to the latest refactor\n        // however it is incorrect logic because it causes any internal cache calls to follow the App Router\n        // path rather than Pages router path. This may mean there is existing buggy behavior however no specific\n        // issues are known at this time. The whole static generation storage pathways should be reworked\n        // to allow tracking which \"mode\" we are in without the presence of a store or not. For now I have\n        // maintained the existing behavior to limit the impact of the current refactor\n        const result = await staticGenerationAsyncStorage.run(\n          // We are making a fake store that is useful for scoping fetchCache: 'force-no-store' and isUnstableCacheCallback: true\n          // The fact that we need to construct this kind of fake store indicates the code is not factored correctly\n          // @TODO refactor to not require this fake store object\n          {\n            // force any nested fetches to bypass cache so they revalidate\n            // when the unstable_cache call is revalidated\n            fetchCache: 'force-no-store',\n            isUnstableCacheCallback: true,\n            route: '/',\n            page: '/',\n            isStaticGeneration: false,\n            fallbackRouteParams: null,\n          },\n          cb,\n          ...args\n        )\n        cacheNewResult(\n          result,\n          incrementalCache,\n          cacheKey,\n          tags,\n          options.revalidate,\n          fetchIdx,\n          fetchUrl\n        )\n        return result\n      }\n    } finally {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n    }\n  }\n  // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n  return cachedCb as unknown as T\n}\n"],"names":["CACHE_ONE_YEAR","addImplicitTags","validateRevalidate","validateTags","staticGenerationAsyncStorage","requestAsyncStorage","CachedRouteKind","IncrementalCacheKind","prerenderAsyncStorage","noStoreFetchIdx","cacheNewResult","result","incrementalCache","cacheKey","tags","revalidate","fetchIdx","fetchUrl","set","kind","FETCH","data","headers","body","JSON","stringify","status","url","fetchCache","unstable_cache","cb","keyParts","options","Error","toString","name","fixedKey","Array","isArray","join","cachedCb","args","staticGenerationStore","getStore","requestStore","maybeIncrementalCache","globalThis","__incrementalCache","prerenderStore","cacheSignal","beginRead","pathname","route","searchParams","URLSearchParams","search","sortedSearchKeys","keys","sort","a","b","localeCompare","sortedSearch","map","key","get","invocationKey","generateCacheKey","length","nextFetchId","slice","tag","includes","push","implicitTags","isOnDemandRevalidate","isDraftMode","cacheEntry","softTags","isFallback","value","console","error","cachedResponse","undefined","parse","isStale","pendingRevalidates","run","isUnstableCacheCallback","then","catch","err","page","isStaticGeneration","fallbackRouteParams","endRead"],"mappings":"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"}