{"version":3,"sources":["../../../src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type {\n  FlightSegmentPath,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n} from './types'\nimport React from 'react'\nimport { isClientReference } from '../../lib/client-reference'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { CreateSegmentPath, AppRenderContext } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { Params } from '../../client/components/params'\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  createSegmentPath: CreateSegmentPath\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  firstItem?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getMetadataReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n}): Promise<CacheNodeSeedData> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props)\n  )\n}\n\nfunction errorMissingDefaultExport(pagePath: string, convention: string) {\n  throw new Error(\n    `The default export is not a React Component in \"${pagePath}/${convention}\"`\n  )\n}\n\nconst cacheNodeKey = 'c'\n\nasync function createComponentTreeInternal({\n  createSegmentPath,\n  loaderTree: tree,\n  parentParams,\n  firstItem,\n  rootLayoutIncluded,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  getMetadataReady,\n  ctx,\n  missingSlots,\n  preloadCallbacks,\n}: {\n  createSegmentPath: CreateSegmentPath\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  firstItem?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getMetadataReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n}): Promise<CacheNodeSeedData> {\n  const {\n    renderOpts: { nextConfigOutput, experimental },\n    staticGenerationStore,\n    componentMod: {\n      NotFoundBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      ClientPageRoot,\n      createUntrackedSearchParams,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, layoutOrPagePath, segment, components, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const { layout, template, error, loading, 'not-found': notFound } = components\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    preloadCallbacks,\n    ctx,\n    layoutOrPagePath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [React.Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const [layoutOrPageMod] = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is not runtime server to dynamic render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      staticGenerationStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      staticGenerationStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (\n        staticGenerationStore.isStaticGeneration &&\n        !experimental.isRoutePPREnabled\n      ) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        staticGenerationStore.dynamicUsageDescription = err.message\n        staticGenerationStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      staticGenerationStore.dynamicShouldError = false\n      staticGenerationStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    staticGenerationStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, staticGenerationStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    ctx.defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    if (\n      typeof staticGenerationStore.revalidate === 'undefined' ||\n      (typeof staticGenerationStore.revalidate === 'number' &&\n        staticGenerationStore.revalidate > ctx.defaultRevalidate)\n    ) {\n      staticGenerationStore.revalidate = ctx.defaultRevalidate\n    }\n\n    if (\n      !staticGenerationStore.forceStatic &&\n      staticGenerationStore.isStaticGeneration &&\n      ctx.defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !experimental.isRoutePPREnabled\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  const isStaticGeneration = staticGenerationStore.isStaticGeneration\n\n  // If there's a dynamic usage error attached to the store, throw it.\n  if (staticGenerationStore.dynamicUsageErr) {\n    throw staticGenerationStore.dynamicUsageErr\n  }\n\n  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let Component = LayoutOrPage\n  const parallelKeys = Object.keys(parallelRoutes)\n  const hasSlotKey = parallelKeys.length > 1\n\n  // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n  // This ensures that a `NotFoundBoundary` is available for when that happens,\n  // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n  // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n  // rely on the `NotFound` behavior.\n  if (hasSlotKey && rootLayoutAtThisLevel && LayoutOrPage) {\n    Component = (componentProps: { params: Params }) => {\n      const NotFoundComponent = NotFound\n      const RootLayoutComponent = LayoutOrPage\n      return (\n        <NotFoundBoundary\n          notFound={\n            NotFoundComponent ? (\n              <Segment\n                isStaticGeneration={isStaticGeneration}\n                ready={getMetadataReady}\n              >\n                {layerAssets}\n                {/*\n                 * We are intentionally only forwarding params to the root layout, as passing any of the parallel route props\n                 * might trigger `notFound()`, which is not currently supported in the root layout.\n                 */}\n                <RootLayoutComponent params={componentProps.params}>\n                  {notFoundStyles}\n                  <NotFoundComponent />\n                </RootLayoutComponent>\n              </Segment>\n            ) : undefined\n          }\n        >\n          <RootLayoutComponent {...componentProps} />\n        </NotFoundBoundary>\n      )\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    const { isValidElementType } = require('next/dist/compiled/react-is')\n    if (\n      (isPage || typeof Component !== 'undefined') &&\n      !isValidElementType(Component)\n    ) {\n      errorMissingDefaultExport(pagePath, 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  // Create object holding the parent params and current params\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : // Pass through parent params to children\n        parentParams\n\n  // Resolve the segment param\n  const actualSegment = segmentParam ? segmentParam.treeSegment : segment\n\n  //\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const currentSegmentPath: FlightSegmentPath = firstItem\n          ? [parallelRouteKey]\n          : [actualSegment, parallelRouteKey]\n\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent =\n          NotFound && isChildrenRouteKey ? <NotFound /> : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is defered until the actual navigation.\n          // It does not take into account whether the data is dynamic — even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different — loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.layoutOrPagePath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const seedData = await createComponentTreeInternal({\n            createSegmentPath: (child) => {\n              return createSegmentPath([...currentSegmentPath, ...child])\n            },\n            loaderTree: parallelRoute,\n            parentParams: currentParams,\n            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n            injectedCSS: injectedCSSWithCurrentLayout,\n            injectedJS: injectedJSWithCurrentLayout,\n            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n            // getMetadataReady is used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            getMetadataReady: isChildrenRouteKey\n              ? getMetadataReady\n              : () => Promise.resolve(),\n            ctx,\n            missingSlots,\n            preloadCallbacks,\n          })\n\n          childCacheNodeSeedData = seedData\n        }\n\n        // This is turned back into an object below.\n        return [\n          parallelRouteKey,\n          <LayoutRouter\n            parallelRouterKey={parallelRouteKey}\n            segmentPath={createSegmentPath(currentSegmentPath)}\n            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n            error={ErrorComponent}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n            template={\n              <Template>\n                <RenderFromTemplateContext />\n              </Template>\n            }\n            templateStyles={templateStyles}\n            templateScripts={templateScripts}\n            notFound={notFoundComponent}\n            notFoundStyles={notFoundStyles}\n          />,\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  const loadingData: LoadingModuleData = Loading\n    ? [<Loading key=\"l\" />, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!Component) {\n    return [\n      actualSegment,\n      <Segment\n        key={cacheNodeKey}\n        isStaticGeneration={isStaticGeneration}\n        ready={getMetadataReady}\n      >\n        {layerAssets}\n        {parallelRouteProps.children}\n      </Segment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n    ]\n  }\n\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    staticGenerationStore.isStaticGeneration &&\n    staticGenerationStore.forceDynamic &&\n    experimental.isRoutePPREnabled\n  ) {\n    return [\n      actualSegment,\n      <Segment\n        key={cacheNodeKey}\n        isStaticGeneration={isStaticGeneration}\n        ready={getMetadataReady}\n      >\n        <Postpone\n          reason='dynamic = \"force-dynamic\" was used'\n          route={staticGenerationStore.route}\n        />\n        {layerAssets}\n      </Segment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n    ]\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  // We avoid cloning this object because it gets consumed here exclusively.\n  const props: { [prop: string]: any } = parallelRouteProps\n\n  // Assign params to props\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n\n  if (isPage) {\n    // Assign searchParams to props if this is a page\n    let pageElement: React.ReactNode\n    if (isClientComponent) {\n      // When we are passing searchParams to a client component Page we don't want to track the dynamic access\n      // here in the RSC layer because the serialization will trigger a dynamic API usage.\n      // Instead we pass the searchParams untracked but we wrap the Page in a root client component\n      // which can among other things adds the dynamic tracking before rendering the page.\n      // @TODO make the root wrapper part of next-app-loader so we don't need the extra client component\n      props.params = currentParams\n      props.searchParams = createUntrackedSearchParams(query)\n      pageElement = <ClientPageRoot props={props} Component={Component} />\n    } else {\n      // If we are passing searchParams to a server component Page we need to track their usage in case\n      // the current render mode tracks dynamic API usage.\n      props.params = createDynamicallyTrackedParams(currentParams)\n      props.searchParams = createDynamicallyTrackedSearchParams(query)\n      pageElement = <Component {...props} />\n    }\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        <MetadataOutlet ready={getMetadataReady} />\n        <Segment\n          isStaticGeneration={isStaticGeneration}\n          ready={getMetadataReady}\n        >\n          {pageElement}\n          {layerAssets}\n        </Segment>\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n    ]\n  } else {\n    props.params = createDynamicallyTrackedParams(currentParams)\n\n    // For layouts we just render the component\n    return [\n      actualSegment,\n      // It is critical that this tree render something other than `null` because the client router uses\n      // null to represent an lazy hole. The current implementation satisfies this because the two inner slots\n      // ensure there is a fragment even if both slots render null. If we ever refactor this to only render the component\n      // or similar we need to ensure there is a fragment. Long term we should move to using a Symbol to communicate\n      // a lazy hole rather than null\n      <Segment\n        key={cacheNodeKey}\n        isStaticGeneration={isStaticGeneration}\n        ready={getMetadataReady}\n      >\n        {layerAssets}\n        <Component {...props} />\n      </Segment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n    ]\n  }\n}\n\nasync function MetadataOutlet({\n  ready,\n}: {\n  ready: () => Promise<void> & { status?: string; value?: unknown }\n}) {\n  const r = ready()\n  // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n  if (r.status === 'rejected') {\n    throw r.value\n  } else if (r.status !== 'fulfilled') {\n    await r\n  }\n  return null\n}\n\nasync function Segment({\n  isStaticGeneration,\n  ready,\n  children,\n}: {\n  isStaticGeneration: boolean\n  ready?: () => Promise<void>\n  children: React.ReactNode\n}) {\n  if (isStaticGeneration && ready) {\n    // During static generation we wait for metadata to complete before rendering segments.\n    // This is slower but it allows us to ensure that metadata is finished before we start\n    // rendering the segment which can synchronously abort the render in certain circumstances\n    try {\n      await ready()\n    } catch {\n      // we'll let the MetadataOutlet component render with the page error to let the right\n      // error boundary catch this error\n    }\n  }\n  return children\n}\n"],"names":["React","isClientReference","getLayoutOrPageModule","interopDefault","parseLoaderTree","createComponentStylesAndScripts","getLayerAssets","hasLoadingComponentInTree","validateRevalidate","PARALLEL_ROUTE_DEFAULT_PATH","getTracer","NextNodeServerSpan","StaticGenBailoutError","createComponentTree","props","trace","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","Error","cacheNodeKey","createSegmentPath","loaderTree","tree","parentParams","firstItem","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","getMetadataReady","ctx","missingSlots","preloadCallbacks","renderOpts","nextConfigOutput","experimental","staticGenerationStore","componentMod","NotFoundBoundary","LayoutRouter","RenderFromTemplateContext","ClientPageRoot","createUntrackedSearchParams","createDynamicallyTrackedSearchParams","createDynamicallyTrackedParams","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","layoutOrPagePath","segment","components","parallelRoutes","layout","template","error","loading","notFound","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","Template","templateStyles","templateScripts","filePath","getComponent","Fragment","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","layoutOrPageMod","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","dynamic","dynamicShouldError","forceDynamic","isStaticGeneration","isRoutePPREnabled","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","route","defaultRevalidate","dynamicUsageErr","LayoutOrPage","undefined","Component","parallelKeys","Object","keys","hasSlotKey","length","componentProps","NotFoundComponent","RootLayoutComponent","Segment","ready","params","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","actualSegment","treeSegment","parallelRouteMap","Promise","all","map","parallelRouteKey","isChildrenRouteKey","currentSegmentPath","parallelRoute","notFoundComponent","childCacheNodeSeedData","parsedTree","endsWith","add","seedData","child","resolve","parallelRouterKey","segmentPath","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingData","children","reason","isClientComponent","console","pageElement","searchParams","MetadataOutlet","r","status"],"mappings":"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"}