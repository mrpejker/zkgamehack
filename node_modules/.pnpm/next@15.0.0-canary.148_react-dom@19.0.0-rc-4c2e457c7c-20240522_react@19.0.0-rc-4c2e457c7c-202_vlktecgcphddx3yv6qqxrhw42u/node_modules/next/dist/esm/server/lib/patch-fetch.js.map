{"version":3,"sources":["../../../src/server/lib/patch-fetch.ts"],"sourcesContent":["import type {\n  StaticGenerationAsyncStorage,\n  StaticGenerationStore,\n} from '../../client/components/static-generation-async-storage.external'\n\nimport { AppRenderSpan, NextNodeServerSpan } from './trace/constants'\nimport { getTracer, SpanKind } from './trace/tracer'\nimport {\n  CACHE_ONE_YEAR,\n  NEXT_CACHE_IMPLICIT_TAG_ID,\n  NEXT_CACHE_TAG_MAX_ITEMS,\n  NEXT_CACHE_TAG_MAX_LENGTH,\n} from '../../lib/constants'\nimport { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering'\nimport type { FetchMetric } from '../base-http'\nimport { createDedupeFetch } from './dedupe-fetch'\nimport type {\n  RequestAsyncStorage,\n  RequestStore,\n} from '../../client/components/request-async-storage.external'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchData,\n} from '../response-cache'\nimport type { PrerenderAsyncStorage } from '../app-render/prerender-async-storage.external'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\ntype Fetcher = typeof fetch\n\ntype PatchedFetcher = Fetcher & {\n  readonly __nextPatched: true\n  readonly __nextGetStaticStore: () => StaticGenerationAsyncStorage\n  readonly _nextOriginalFetch: Fetcher\n}\n\nexport const NEXT_PATCH_SYMBOL = Symbol.for('next-patch')\n\nfunction isFetchPatched() {\n  return (globalThis as Record<symbol, unknown>)[NEXT_PATCH_SYMBOL] === true\n}\n\nexport function validateRevalidate(\n  revalidateVal: unknown,\n  route: string\n): undefined | number | false {\n  try {\n    let normalizedRevalidate: false | number | undefined = undefined\n\n    if (revalidateVal === false) {\n      normalizedRevalidate = revalidateVal\n    } else if (\n      typeof revalidateVal === 'number' &&\n      !isNaN(revalidateVal) &&\n      revalidateVal > -1\n    ) {\n      normalizedRevalidate = revalidateVal\n    } else if (typeof revalidateVal !== 'undefined') {\n      throw new Error(\n        `Invalid revalidate value \"${revalidateVal}\" on \"${route}\", must be a non-negative number or \"false\"`\n      )\n    }\n    return normalizedRevalidate\n  } catch (err: any) {\n    // handle client component error from attempting to check revalidate value\n    if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n      throw err\n    }\n    return undefined\n  }\n}\n\nexport function validateTags(tags: any[], description: string) {\n  const validTags: string[] = []\n  const invalidTags: Array<{\n    tag: any\n    reason: string\n  }> = []\n\n  for (let i = 0; i < tags.length; i++) {\n    const tag = tags[i]\n\n    if (typeof tag !== 'string') {\n      invalidTags.push({ tag, reason: 'invalid type, must be a string' })\n    } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {\n      invalidTags.push({\n        tag,\n        reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`,\n      })\n    } else {\n      validTags.push(tag)\n    }\n\n    if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {\n      console.warn(\n        `Warning: exceeded max tag count for ${description}, dropped tags:`,\n        tags.slice(i).join(', ')\n      )\n      break\n    }\n  }\n\n  if (invalidTags.length > 0) {\n    console.warn(`Warning: invalid tags passed to ${description}: `)\n\n    for (const { tag, reason } of invalidTags) {\n      console.log(`tag: \"${tag}\" ${reason}`)\n    }\n  }\n  return validTags\n}\n\nconst getDerivedTags = (pathname: string): string[] => {\n  const derivedTags: string[] = [`/layout`]\n\n  // we automatically add the current path segments as tags\n  // for revalidatePath handling\n  if (pathname.startsWith('/')) {\n    const pathnameParts = pathname.split('/')\n\n    for (let i = 1; i < pathnameParts.length + 1; i++) {\n      let curPathname = pathnameParts.slice(0, i).join('/')\n\n      if (curPathname) {\n        // all derived tags other than the page are layout tags\n        if (!curPathname.endsWith('/page') && !curPathname.endsWith('/route')) {\n          curPathname = `${curPathname}${\n            !curPathname.endsWith('/') ? '/' : ''\n          }layout`\n        }\n        derivedTags.push(curPathname)\n      }\n    }\n  }\n  return derivedTags\n}\n\nexport function addImplicitTags(\n  staticGenerationStore: StaticGenerationStore,\n  requestStore: RequestStore | undefined\n) {\n  const newTags: string[] = []\n  const { page, fallbackRouteParams } = staticGenerationStore\n  const hasFallbackRouteParams =\n    fallbackRouteParams && fallbackRouteParams.size > 0\n\n  // Ini the tags array if it doesn't exist.\n  staticGenerationStore.tags ??= []\n\n  // Add the derived tags from the page.\n  const derivedTags = getDerivedTags(page)\n  for (let tag of derivedTags) {\n    tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`\n    if (!staticGenerationStore.tags?.includes(tag)) {\n      staticGenerationStore.tags.push(tag)\n    }\n    newTags.push(tag)\n  }\n\n  // Add the tags from the pathname. If the route has unknown params, we don't\n  // want to add the pathname as a tag, as it will be invalid.\n  if (requestStore?.url.pathname && !hasFallbackRouteParams) {\n    const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${requestStore.url.pathname}`\n    if (!staticGenerationStore.tags?.includes(tag)) {\n      staticGenerationStore.tags.push(tag)\n    }\n    newTags.push(tag)\n  }\n\n  return newTags\n}\n\nfunction trackFetchMetric(\n  staticGenerationStore: StaticGenerationStore,\n  ctx: Omit<FetchMetric, 'end' | 'idx'>\n) {\n  // If the static generation store is not available, we can't track the fetch\n  if (!staticGenerationStore) return\n  if (staticGenerationStore.requestEndedState?.ended) return\n\n  const isDebugBuild =\n    (!!process.env.NEXT_DEBUG_BUILD ||\n      process.env.NEXT_SSG_FETCH_METRICS === '1') &&\n    staticGenerationStore.isStaticGeneration\n  const isDevelopment = process.env.NODE_ENV === 'development'\n\n  if (\n    // The only time we want to track fetch metrics outside of development is when\n    // we are performing a static generation & we are in debug mode.\n    !isDebugBuild &&\n    !isDevelopment\n  ) {\n    return\n  }\n\n  staticGenerationStore.fetchMetrics ??= []\n\n  staticGenerationStore.fetchMetrics.push({\n    ...ctx,\n    end: Date.now(),\n    idx: staticGenerationStore.nextFetchId || 0,\n  })\n}\n\ninterface PatchableModule {\n  staticGenerationAsyncStorage: StaticGenerationAsyncStorage\n  requestAsyncStorage: RequestAsyncStorage\n  prerenderAsyncStorage: PrerenderAsyncStorage\n}\n\nexport function createPatchedFetcher(\n  originFetch: Fetcher,\n  {\n    staticGenerationAsyncStorage,\n    requestAsyncStorage,\n    prerenderAsyncStorage,\n  }: PatchableModule\n): PatchedFetcher {\n  // Create the patched fetch function. We don't set the type here, as it's\n  // verified as the return value of this function.\n  const patched = async (\n    input: RequestInfo | URL,\n    init: RequestInit | undefined\n  ) => {\n    let url: URL | undefined\n    try {\n      url = new URL(input instanceof Request ? input.url : input)\n      url.username = ''\n      url.password = ''\n    } catch {\n      // Error caused by malformed URL should be handled by native fetch\n      url = undefined\n    }\n    const fetchUrl = url?.href ?? ''\n    const fetchStart = Date.now()\n    const method = init?.method?.toUpperCase() || 'GET'\n\n    // Do create a new span trace for internal fetches in the\n    // non-verbose mode.\n    const isInternal = (init?.next as any)?.internal === true\n    const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1'\n\n    const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n\n    const result = getTracer().trace(\n      isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch,\n      {\n        hideSpan,\n        kind: SpanKind.CLIENT,\n        spanName: ['fetch', method, fetchUrl].filter(Boolean).join(' '),\n        attributes: {\n          'http.url': fetchUrl,\n          'http.method': method,\n          'net.peer.name': url?.hostname,\n          'net.peer.port': url?.port || undefined,\n        },\n      },\n      async () => {\n        // If this is an internal fetch, we should not do any special treatment.\n        if (isInternal) {\n          return originFetch(input, init)\n        }\n\n        const requestStore = requestAsyncStorage.getStore()\n\n        // If the staticGenerationStore is not available, we can't do any\n        // special treatment of fetch, therefore fallback to the original\n        // fetch implementation.\n        if (!staticGenerationStore) {\n          return originFetch(input, init)\n        }\n\n        // We should also fallback to the original fetch implementation if we\n        // are in draft mode, it does not constitute a static generation.\n        if (staticGenerationStore.isDraftMode) {\n          return originFetch(input, init)\n        }\n\n        const isRequestInput =\n          input &&\n          typeof input === 'object' &&\n          typeof (input as Request).method === 'string'\n\n        const getRequestMeta = (field: string) => {\n          // If request input is present but init is not, retrieve from input first.\n          const value = (init as any)?.[field]\n          return value || (isRequestInput ? (input as any)[field] : null)\n        }\n\n        let finalRevalidate: number | undefined | false = undefined\n        const getNextField = (field: 'revalidate' | 'tags') => {\n          return typeof init?.next?.[field] !== 'undefined'\n            ? init?.next?.[field]\n            : isRequestInput\n              ? (input as any).next?.[field]\n              : undefined\n        }\n        // RequestInit doesn't keep extra fields e.g. next so it's\n        // only available if init is used separate\n        let currentFetchRevalidate = getNextField('revalidate')\n        const tags: string[] = validateTags(\n          getNextField('tags') || [],\n          `fetch ${input.toString()}`\n        )\n\n        if (Array.isArray(tags)) {\n          if (!staticGenerationStore.tags) {\n            staticGenerationStore.tags = []\n          }\n          for (const tag of tags) {\n            if (!staticGenerationStore.tags.includes(tag)) {\n              staticGenerationStore.tags.push(tag)\n            }\n          }\n        }\n        const implicitTags = addImplicitTags(\n          staticGenerationStore,\n          requestStore\n        )\n\n        const pageFetchCacheMode = staticGenerationStore.fetchCache\n        const isUsingNoStore = !!staticGenerationStore.isUnstableNoStore\n\n        let currentFetchCacheConfig = getRequestMeta('cache')\n        let cacheReason = ''\n        let cacheWarning: string | undefined\n\n        if (\n          typeof currentFetchCacheConfig === 'string' &&\n          typeof currentFetchRevalidate !== 'undefined'\n        ) {\n          // when providing fetch with a Request input, it'll automatically set a cache value of 'default'\n          // we only want to warn if the user is explicitly setting a cache value\n          if (!(isRequestInput && currentFetchCacheConfig === 'default')) {\n            cacheWarning = `Specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`\n          }\n          currentFetchCacheConfig = undefined\n        }\n\n        if (currentFetchCacheConfig === 'force-cache') {\n          currentFetchRevalidate = false\n        } else if (\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store' ||\n          pageFetchCacheMode === 'force-no-store' ||\n          pageFetchCacheMode === 'only-no-store' ||\n          // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n          // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n          // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n          // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n          // other configurations.\n          (!pageFetchCacheMode && staticGenerationStore.forceDynamic)\n        ) {\n          currentFetchRevalidate = 0\n        }\n\n        if (\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store'\n        ) {\n          cacheReason = `cache: ${currentFetchCacheConfig}`\n        }\n\n        finalRevalidate = validateRevalidate(\n          currentFetchRevalidate,\n          staticGenerationStore.route\n        )\n\n        const _headers = getRequestMeta('headers')\n        const initHeaders: Headers =\n          typeof _headers?.get === 'function'\n            ? _headers\n            : new Headers(_headers || {})\n\n        const hasUnCacheableHeader =\n          initHeaders.get('authorization') || initHeaders.get('cookie')\n\n        const isUnCacheableMethod = !['get', 'head'].includes(\n          getRequestMeta('method')?.toLowerCase() || 'get'\n        )\n\n        /**\n         * We automatically disable fetch caching under the following conditions:\n         * - Fetch cache configs are not set. Specifically:\n         *    - A page fetch cache mode is not set (export const fetchCache=...)\n         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))\n         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))\n         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())\n         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)\n         */\n        const hasNoExplicitCacheConfig =\n          // eslint-disable-next-line eqeqeq\n          pageFetchCacheMode == undefined &&\n          // eslint-disable-next-line eqeqeq\n          currentFetchCacheConfig == undefined &&\n          // eslint-disable-next-line eqeqeq\n          currentFetchRevalidate == undefined\n        const autoNoCache =\n          // this condition is hit for null/undefined\n          // eslint-disable-next-line eqeqeq\n          (hasNoExplicitCacheConfig &&\n            // we disable automatic no caching behavior during build time SSG so that we can still\n            // leverage the fetch cache between SSG workers\n            !staticGenerationStore.isPrerendering) ||\n          ((hasUnCacheableHeader || isUnCacheableMethod) &&\n            staticGenerationStore.revalidate === 0)\n\n        switch (pageFetchCacheMode) {\n          case 'force-no-store': {\n            cacheReason = 'fetchCache = force-no-store'\n            break\n          }\n          case 'only-no-store': {\n            if (\n              currentFetchCacheConfig === 'force-cache' ||\n              (typeof finalRevalidate !== 'undefined' &&\n                (finalRevalidate === false || finalRevalidate > 0))\n            ) {\n              throw new Error(\n                `cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`\n              )\n            }\n            cacheReason = 'fetchCache = only-no-store'\n            break\n          }\n          case 'only-cache': {\n            if (currentFetchCacheConfig === 'no-store') {\n              throw new Error(\n                `cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`\n              )\n            }\n            break\n          }\n          case 'force-cache': {\n            if (\n              typeof currentFetchRevalidate === 'undefined' ||\n              currentFetchRevalidate === 0\n            ) {\n              cacheReason = 'fetchCache = force-cache'\n              finalRevalidate = false\n            }\n            break\n          }\n          default:\n          // sometimes we won't match the above cases. the reason we don't move\n          // everything to this switch is the use of autoNoCache which is not a fetchCacheMode\n          // I suspect this could be unified with fetchCacheMode however in which case we could\n          // simplify the switch case and ensure we have an exhaustive switch handling all modes\n        }\n\n        if (typeof finalRevalidate === 'undefined') {\n          if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n            finalRevalidate = false\n            cacheReason = 'fetchCache = default-cache'\n          } else if (pageFetchCacheMode === 'default-no-store') {\n            finalRevalidate = 0\n            cacheReason = 'fetchCache = default-no-store'\n          } else if (isUsingNoStore) {\n            finalRevalidate = 0\n            cacheReason = 'noStore call'\n          } else if (autoNoCache) {\n            finalRevalidate = 0\n            cacheReason = 'auto no cache'\n          } else {\n            // TODO: should we consider this case an invariant?\n            cacheReason = 'auto cache'\n            finalRevalidate =\n              typeof staticGenerationStore.revalidate === 'boolean' ||\n              typeof staticGenerationStore.revalidate === 'undefined'\n                ? false\n                : staticGenerationStore.revalidate\n          }\n        } else if (!cacheReason) {\n          cacheReason = `revalidate: ${finalRevalidate}`\n        }\n\n        if (\n          // when force static is configured we don't bail from\n          // `revalidate: 0` values\n          !(staticGenerationStore.forceStatic && finalRevalidate === 0) &&\n          // we don't consider autoNoCache to switch to dynamic for ISR\n          !autoNoCache &&\n          // If the revalidate value isn't currently set or the value is less\n          // than the current revalidate value, we should update the revalidate\n          // value.\n          (typeof staticGenerationStore.revalidate === 'undefined' ||\n            (typeof finalRevalidate === 'number' &&\n              (staticGenerationStore.revalidate === false ||\n                (typeof staticGenerationStore.revalidate === 'number' &&\n                  finalRevalidate < staticGenerationStore.revalidate))))\n        ) {\n          // If we were setting the revalidate value to 0, we should try to\n          // postpone instead first.\n          if (finalRevalidate === 0) {\n            markCurrentScopeAsDynamic(\n              staticGenerationStore,\n              `revalidate: 0 fetch ${input} ${staticGenerationStore.route}`\n            )\n          }\n\n          staticGenerationStore.revalidate = finalRevalidate\n        }\n\n        const isCacheableRevalidate =\n          (typeof finalRevalidate === 'number' && finalRevalidate > 0) ||\n          finalRevalidate === false\n\n        let cacheKey: string | undefined\n        const { incrementalCache } = staticGenerationStore\n\n        if (\n          incrementalCache &&\n          (isCacheableRevalidate || requestStore?.serverComponentsHmrCache)\n        ) {\n          try {\n            cacheKey = await incrementalCache.generateCacheKey(\n              fetchUrl,\n              isRequestInput ? (input as RequestInit) : init\n            )\n          } catch (err) {\n            console.error(`Failed to generate cache key for`, input)\n          }\n        }\n\n        const fetchIdx = staticGenerationStore.nextFetchId ?? 1\n        staticGenerationStore.nextFetchId = fetchIdx + 1\n\n        const normalizedRevalidate =\n          typeof finalRevalidate !== 'number' ? CACHE_ONE_YEAR : finalRevalidate\n\n        let handleUnlock = () => Promise.resolve()\n\n        const doOriginalFetch = async (\n          isStale?: boolean,\n          cacheReasonOverride?: string\n        ) => {\n          const requestInputFields = [\n            'cache',\n            'credentials',\n            'headers',\n            'integrity',\n            'keepalive',\n            'method',\n            'mode',\n            'redirect',\n            'referrer',\n            'referrerPolicy',\n            'window',\n            'duplex',\n\n            // don't pass through signal when revalidating\n            ...(isStale ? [] : ['signal']),\n          ]\n\n          if (isRequestInput) {\n            const reqInput: Request = input as any\n            const reqOptions: RequestInit = {\n              body: (reqInput as any)._ogBody || reqInput.body,\n            }\n\n            for (const field of requestInputFields) {\n              // @ts-expect-error custom fields\n              reqOptions[field] = reqInput[field]\n            }\n            input = new Request(reqInput.url, reqOptions)\n          } else if (init) {\n            const { _ogBody, body, signal, ...otherInput } =\n              init as RequestInit & { _ogBody?: any }\n            init = {\n              ...otherInput,\n              body: _ogBody || body,\n              signal: isStale ? undefined : signal,\n            }\n          }\n\n          // add metadata to init without editing the original\n          const clonedInit = {\n            ...init,\n            next: { ...init?.next, fetchType: 'origin', fetchIdx },\n          }\n\n          return originFetch(input, clonedInit).then(async (res) => {\n            if (!isStale) {\n              trackFetchMetric(staticGenerationStore, {\n                start: fetchStart,\n                url: fetchUrl,\n                cacheReason: cacheReasonOverride || cacheReason,\n                cacheStatus:\n                  finalRevalidate === 0 || cacheReasonOverride\n                    ? 'skip'\n                    : 'miss',\n                cacheWarning,\n                status: res.status,\n                method: clonedInit.method || 'GET',\n              })\n            }\n            if (\n              res.status === 200 &&\n              incrementalCache &&\n              cacheKey &&\n              (isCacheableRevalidate || requestStore?.serverComponentsHmrCache)\n            ) {\n              if (prerenderStore) {\n                // We are prerendering at build time or revalidate time so we need to\n                // buffer the response so we can guarantee it can be read in a microtask\n\n                const bodyBuffer = await res.arrayBuffer()\n\n                const fetchedData = {\n                  headers: Object.fromEntries(res.headers.entries()),\n                  body: Buffer.from(bodyBuffer).toString('base64'),\n                  status: res.status,\n                  url: res.url,\n                }\n\n                // We can skip checking the serverComponentsHmrCache because we aren't in\n                // dev mode.\n\n                await incrementalCache.set(\n                  cacheKey,\n                  {\n                    kind: CachedRouteKind.FETCH,\n                    data: fetchedData,\n                    revalidate: normalizedRevalidate,\n                  },\n                  {\n                    fetchCache: true,\n                    revalidate: finalRevalidate,\n                    fetchUrl,\n                    fetchIdx,\n                    tags,\n                  }\n                )\n                await handleUnlock()\n\n                // We we return a new Response to the caller.\n                return new Response(bodyBuffer, {\n                  headers: res.headers,\n                  status: res.status,\n                  statusText: res.statusText,\n                })\n              } else {\n                // We are dynamically rendering including dev mode. We want to return\n                // the response to the caller as soon  as possible because it might stream\n                // over a very long time.\n                res\n                  .clone()\n                  .arrayBuffer()\n                  .then(async (arrayBuffer) => {\n                    const bodyBuffer = Buffer.from(arrayBuffer)\n\n                    const fetchedData = {\n                      headers: Object.fromEntries(res.headers.entries()),\n                      body: bodyBuffer.toString('base64'),\n                      status: res.status,\n                      url: res.url,\n                    }\n\n                    requestStore?.serverComponentsHmrCache?.set(\n                      cacheKey,\n                      fetchedData\n                    )\n\n                    if (isCacheableRevalidate) {\n                      await incrementalCache.set(\n                        cacheKey,\n                        {\n                          kind: CachedRouteKind.FETCH,\n                          data: fetchedData,\n                          revalidate: normalizedRevalidate,\n                        },\n                        {\n                          fetchCache: true,\n                          revalidate: finalRevalidate,\n                          fetchUrl,\n                          fetchIdx,\n                          tags,\n                        }\n                      )\n                    }\n                  })\n                  .catch((error) =>\n                    console.warn(`Failed to set fetch cache`, input, error)\n                  )\n                  .finally(handleUnlock)\n\n                return res\n              }\n            }\n\n            return res\n          })\n        }\n\n        let cacheReasonOverride\n        let isForegroundRevalidate = false\n        let isHmrRefreshCache = false\n\n        if (cacheKey && incrementalCache) {\n          let cachedFetchData: CachedFetchData | undefined\n\n          if (\n            requestStore?.isHmrRefresh &&\n            requestStore.serverComponentsHmrCache\n          ) {\n            cachedFetchData =\n              requestStore.serverComponentsHmrCache.get(cacheKey)\n\n            isHmrRefreshCache = true\n          }\n\n          if (isCacheableRevalidate && !cachedFetchData) {\n            handleUnlock = await incrementalCache.lock(cacheKey)\n            const entry = staticGenerationStore.isOnDemandRevalidate\n              ? null\n              : await incrementalCache.get(cacheKey, {\n                  kind: IncrementalCacheKind.FETCH,\n                  revalidate: finalRevalidate,\n                  fetchUrl,\n                  fetchIdx,\n                  tags,\n                  softTags: implicitTags,\n                  isFallback: false,\n                })\n\n            if (hasNoExplicitCacheConfig) {\n              // We sometimes use the cache to dedupe fetches that do not specify a cache configuration\n              // In these cases we want to make sure we still exclude them from prerenders if dynamicIO is on\n              // so we introduce an artificial Task boundary here.\n              const prerenderStore = prerenderAsyncStorage.getStore()\n              if (prerenderStore) {\n                await waitAtLeastOneReactRenderTask()\n              }\n            }\n\n            if (entry) {\n              await handleUnlock()\n            } else {\n              // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n              cacheReasonOverride = 'cache-control: no-cache (hard refresh)'\n            }\n\n            if (entry?.value && entry.value.kind === CachedRouteKind.FETCH) {\n              // when stale and is revalidating we wait for fresh data\n              // so the revalidated entry has the updated data\n              if (staticGenerationStore.isRevalidate && entry.isStale) {\n                isForegroundRevalidate = true\n              } else {\n                if (entry.isStale) {\n                  staticGenerationStore.pendingRevalidates ??= {}\n                  if (!staticGenerationStore.pendingRevalidates[cacheKey]) {\n                    staticGenerationStore.pendingRevalidates[cacheKey] =\n                      doOriginalFetch(true)\n                        .catch(console.error)\n                        .finally(() => {\n                          staticGenerationStore.pendingRevalidates ??= {}\n                          delete staticGenerationStore.pendingRevalidates[\n                            cacheKey || ''\n                          ]\n                        })\n                  }\n                }\n\n                cachedFetchData = entry.value.data\n              }\n            }\n          }\n\n          if (cachedFetchData) {\n            trackFetchMetric(staticGenerationStore, {\n              start: fetchStart,\n              url: fetchUrl,\n              cacheReason,\n              cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',\n              cacheWarning,\n              status: cachedFetchData.status || 200,\n              method: init?.method || 'GET',\n            })\n\n            const response = new Response(\n              Buffer.from(cachedFetchData.body, 'base64'),\n              {\n                headers: cachedFetchData.headers,\n                status: cachedFetchData.status,\n              }\n            )\n\n            Object.defineProperty(response, 'url', {\n              value: cachedFetchData.url,\n            })\n\n            return response\n          }\n        }\n\n        if (\n          staticGenerationStore.isStaticGeneration &&\n          init &&\n          typeof init === 'object'\n        ) {\n          const { cache } = init\n\n          // Delete `cache` property as Cloudflare Workers will throw an error\n          if (isEdgeRuntime) delete init.cache\n\n          if (cache === 'no-store') {\n            // If enabled, we should bail out of static generation.\n            markCurrentScopeAsDynamic(\n              staticGenerationStore,\n              `no-store fetch ${input} ${staticGenerationStore.route}`\n            )\n          }\n\n          const hasNextConfig = 'next' in init\n          const { next = {} } = init\n          if (\n            typeof next.revalidate === 'number' &&\n            (typeof staticGenerationStore.revalidate === 'undefined' ||\n              (typeof staticGenerationStore.revalidate === 'number' &&\n                next.revalidate < staticGenerationStore.revalidate))\n          ) {\n            if (next.revalidate === 0) {\n              // If enabled, we should bail out of static generation.\n              markCurrentScopeAsDynamic(\n                staticGenerationStore,\n                `revalidate: 0 fetch ${input} ${staticGenerationStore.route}`\n              )\n            }\n\n            if (!staticGenerationStore.forceStatic || next.revalidate !== 0) {\n              staticGenerationStore.revalidate = next.revalidate\n            }\n          }\n          if (hasNextConfig) delete init.next\n        }\n\n        // if we are revalidating the whole page via time or on-demand and\n        // the fetch cache entry is stale we should still de-dupe the\n        // origin hit if it's a cache-able entry\n        if (cacheKey && isForegroundRevalidate) {\n          const pendingRevalidateKey = cacheKey\n          staticGenerationStore.pendingRevalidates ??= {}\n          const pendingRevalidate =\n            staticGenerationStore.pendingRevalidates[pendingRevalidateKey]\n\n          if (pendingRevalidate) {\n            const revalidatedResult: {\n              body: ArrayBuffer\n              headers: Headers\n              status: number\n              statusText: string\n            } = await pendingRevalidate\n            return new Response(revalidatedResult.body, {\n              headers: revalidatedResult.headers,\n              status: revalidatedResult.status,\n              statusText: revalidatedResult.statusText,\n            })\n          }\n\n          /**\n           * We used to just resolve the Response and clone it however for static generation\n           * with dynamicIO we need the response to be able to be resolved in a microtask\n           * and Response#clone() will never have a body that can resolve in a microtask in node (as observed through experimentation)\n           * So instead we await the body and then when it is available we construct manually\n           * cloned Response objects with the body as an ArrayBuffer. This will be resolvable in\n           * a microtask making it compatiable with dynamicIO\n           */\n          const pendingResponse = doOriginalFetch(true, cacheReasonOverride)\n          const nextRevalidate = pendingResponse\n            .then(async (response) => {\n              return {\n                body: await response.arrayBuffer(),\n                headers: response.headers,\n                status: response.status,\n                statusText: response.statusText,\n              }\n            })\n            .finally(() => {\n              staticGenerationStore.pendingRevalidates ??= {}\n              delete staticGenerationStore.pendingRevalidates[\n                pendingRevalidateKey\n              ]\n            })\n          nextRevalidate.catch(() => {})\n          staticGenerationStore.pendingRevalidates[pendingRevalidateKey] =\n            nextRevalidate\n          return (await pendingResponse).clone()\n        } else {\n          return doOriginalFetch(false, cacheReasonOverride)\n        }\n      }\n    )\n\n    const prerenderStore = prerenderAsyncStorage.getStore()\n    if (prerenderStore && prerenderStore.cacheSignal) {\n      // During static generation we track cache reads so we can reason about when they fill\n      const cacheSignal = prerenderStore.cacheSignal\n      cacheSignal.beginRead()\n      try {\n        return await result\n      } finally {\n        cacheSignal.endRead()\n      }\n    } else {\n      return result\n    }\n  }\n\n  // Attach the necessary properties to the patched fetch function.\n  // We don't use this to determine if the fetch function has been patched,\n  // but for external consumers to determine if the fetch function has been\n  // patched.\n  patched.__nextPatched = true as const\n  patched.__nextGetStaticStore = () => staticGenerationAsyncStorage\n  patched._nextOriginalFetch = originFetch\n  ;(globalThis as Record<symbol, unknown>)[NEXT_PATCH_SYMBOL] = true\n\n  return patched\n}\n// we patch fetch to collect cache information used for\n// determining if a page is static or not\nexport function patchFetch(options: PatchableModule) {\n  // If we've already patched fetch, we should not patch it again.\n  if (isFetchPatched()) return\n\n  // Grab the original fetch function. We'll attach this so we can use it in\n  // the patched fetch function.\n  const original = createDedupeFetch(globalThis.fetch)\n\n  // Set the global fetch to the patched fetch.\n  globalThis.fetch = createPatchedFetcher(original, options)\n}\n"],"names":["AppRenderSpan","NextNodeServerSpan","getTracer","SpanKind","CACHE_ONE_YEAR","NEXT_CACHE_IMPLICIT_TAG_ID","NEXT_CACHE_TAG_MAX_ITEMS","NEXT_CACHE_TAG_MAX_LENGTH","markCurrentScopeAsDynamic","createDedupeFetch","CachedRouteKind","IncrementalCacheKind","waitAtLeastOneReactRenderTask","isEdgeRuntime","process","env","NEXT_RUNTIME","NEXT_PATCH_SYMBOL","Symbol","for","isFetchPatched","globalThis","validateRevalidate","revalidateVal","route","normalizedRevalidate","undefined","isNaN","Error","err","message","includes","validateTags","tags","description","validTags","invalidTags","i","length","tag","push","reason","console","warn","slice","join","log","getDerivedTags","pathname","derivedTags","startsWith","pathnameParts","split","curPathname","endsWith","addImplicitTags","staticGenerationStore","requestStore","newTags","page","fallbackRouteParams","hasFallbackRouteParams","size","url","trackFetchMetric","ctx","requestEndedState","ended","isDebugBuild","NEXT_DEBUG_BUILD","NEXT_SSG_FETCH_METRICS","isStaticGeneration","isDevelopment","NODE_ENV","fetchMetrics","end","Date","now","idx","nextFetchId","createPatchedFetcher","originFetch","staticGenerationAsyncStorage","requestAsyncStorage","prerenderAsyncStorage","patched","input","init","URL","Request","username","password","fetchUrl","href","fetchStart","method","toUpperCase","isInternal","next","internal","hideSpan","NEXT_OTEL_FETCH_DISABLED","getStore","result","trace","internalFetch","fetch","kind","CLIENT","spanName","filter","Boolean","attributes","hostname","port","getRequestMeta","isDraftMode","isRequestInput","field","value","finalRevalidate","getNextField","currentFetchRevalidate","toString","Array","isArray","implicitTags","pageFetchCacheMode","fetchCache","isUsingNoStore","isUnstableNoStore","currentFetchCacheConfig","cacheReason","cacheWarning","forceDynamic","_headers","initHeaders","get","Headers","hasUnCacheableHeader","isUnCacheableMethod","toLowerCase","hasNoExplicitCacheConfig","autoNoCache","isPrerendering","revalidate","forceStatic","isCacheableRevalidate","cacheKey","incrementalCache","serverComponentsHmrCache","generateCacheKey","error","fetchIdx","handleUnlock","Promise","resolve","doOriginalFetch","isStale","cacheReasonOverride","requestInputFields","reqInput","reqOptions","body","_ogBody","signal","otherInput","clonedInit","fetchType","then","res","start","cacheStatus","status","prerenderStore","bodyBuffer","arrayBuffer","fetchedData","headers","Object","fromEntries","entries","Buffer","from","set","FETCH","data","Response","statusText","clone","catch","finally","isForegroundRevalidate","isHmrRefreshCache","cachedFetchData","isHmrRefresh","lock","entry","isOnDemandRevalidate","softTags","isFallback","isRevalidate","pendingRevalidates","response","defineProperty","cache","hasNextConfig","pendingRevalidateKey","pendingRevalidate","revalidatedResult","pendingResponse","nextRevalidate","cacheSignal","beginRead","endRead","__nextPatched","__nextGetStaticStore","_nextOriginalFetch","patchFetch","options","original"],"mappings":"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"}