{"version":3,"sources":["../../../src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the dynamicIO flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nexport class CacheSignal {\n  private count: number\n  private listeners: Array<() => void>\n\n  constructor() {\n    this.count = 0\n    this.listeners = []\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  async cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        // We increment the count here in case a read begin/end cycle happens before the\n        // next scheduled task. This ensures we only ever have one task scheduled at a time.\n        this.count++\n        setTimeout(() => {\n          // We need to decrement our own increment here\n          this.count--\n          if (this.count === 0) {\n            for (let i = 0; i < this.listeners.length; i++) {\n              this.listeners[i]()\n            }\n            this.listeners.length = 0\n          }\n        })\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n  }\n\n  endRead() {\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    if (this.count === 1) {\n      setTimeout(() => {\n        // We deferred the decrement above and need to do it now for proper balancing\n        this.count--\n        if (this.count === 0) {\n          for (let i = 0; i < this.listeners.length; i++) {\n            this.listeners[i]()\n          }\n          this.listeners.length = 0\n        }\n      }, 0)\n    } else {\n      this.count--\n    }\n  }\n}\n"],"names":["CacheSignal","constructor","count","listeners","cacheReady","Promise","resolve","push","setTimeout","i","length","beginRead","endRead"],"mappings":"AAAA;;;;;CAKC,GAED,OAAO,MAAMA;IAIXC,aAAc;QACZ,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,SAAS,GAAG,EAAE;IACrB;IAEA;;;;GAIC,GACD,MAAMC,aAAa;QACjB,OAAO,IAAIC,QAAc,CAACC;YACxB,IAAI,CAACH,SAAS,CAACI,IAAI,CAACD;YACpB,IAAI,IAAI,CAACJ,KAAK,KAAK,GAAG;gBACpB,gFAAgF;gBAChF,oFAAoF;gBACpF,IAAI,CAACA,KAAK;gBACVM,WAAW;oBACT,8CAA8C;oBAC9C,IAAI,CAACN,KAAK;oBACV,IAAI,IAAI,CAACA,KAAK,KAAK,GAAG;wBACpB,IAAK,IAAIO,IAAI,GAAGA,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAED,IAAK;4BAC9C,IAAI,CAACN,SAAS,CAACM,EAAE;wBACnB;wBACA,IAAI,CAACN,SAAS,CAACO,MAAM,GAAG;oBAC1B;gBACF;YACF;QACF;IACF;IAEAC,YAAY;QACV,IAAI,CAACT,KAAK;IACZ;IAEAU,UAAU;QACR,4FAA4F;QAC5F,kGAAkG;QAClG,gGAAgG;QAChG,2BAA2B;QAC3B,+GAA+G;QAC/G,mHAAmH;QACnH,IAAI,IAAI,CAACV,KAAK,KAAK,GAAG;YACpBM,WAAW;gBACT,6EAA6E;gBAC7E,IAAI,CAACN,KAAK;gBACV,IAAI,IAAI,CAACA,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIO,IAAI,GAAGA,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAED,IAAK;wBAC9C,IAAI,CAACN,SAAS,CAACM,EAAE;oBACnB;oBACA,IAAI,CAACN,SAAS,CAACO,MAAM,GAAG;gBAC1B;YACF,GAAG;QACL,OAAO;YACL,IAAI,CAACR,KAAK;QACZ;IACF;AACF"}