{"version":3,"sources":["../../../../src/build/webpack/plugins/next-trace-entrypoints-plugin.ts"],"sourcesContent":["import nodePath from 'path'\nimport crypto from 'crypto'\nimport type { Span } from '../../../trace'\nimport { spans } from './profiling-plugin'\nimport isError from '../../../lib/is-error'\nimport { nodeFileTrace } from 'next/dist/compiled/@vercel/nft'\nimport type { SWCLoaderOptions } from '../loaders/next-swc-loader'\nimport type { NodeFileTraceReasons } from 'next/dist/compiled/@vercel/nft'\nimport {\n  CLIENT_REFERENCE_MANIFEST,\n  TRACE_OUTPUT_VERSION,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n  type CompilerNameValues,\n} from '../../../shared/lib/constants'\nimport { webpack, sources } from 'next/dist/compiled/webpack/webpack'\nimport {\n  NODE_ESM_RESOLVE_OPTIONS,\n  NODE_RESOLVE_OPTIONS,\n} from '../../webpack-config'\nimport type { NextConfigComplete } from '../../../server/config-shared'\nimport { loadBindings } from '../../swc'\nimport picomatch from 'next/dist/compiled/picomatch'\nimport { getModuleBuildInfo } from '../loaders/get-module-build-info'\nimport { getPageFilePath } from '../../entries'\nimport { resolveExternal } from '../../handle-externals'\nimport swcLoader from '../loaders/next-swc-loader'\n\nconst PLUGIN_NAME = 'TraceEntryPointsPlugin'\nexport const TRACE_IGNORES = [\n  '**/*/next/dist/server/next.js',\n  '**/*/next/dist/bin/next',\n]\n\nconst NOT_TRACEABLE = [\n  '.wasm',\n  '.png',\n  '.jpg',\n  '.jpeg',\n  '.gif',\n  '.webp',\n  '.avif',\n  '.ico',\n  '.bmp',\n  '.svg',\n]\n\nfunction getModuleFromDependency(\n  compilation: any,\n  dep: any\n): webpack.Module & { resource?: string; request?: string } {\n  return compilation.moduleGraph.getModule(dep)\n}\n\nexport function getFilesMapFromReasons(\n  fileList: Set<string>,\n  reasons: NodeFileTraceReasons,\n  ignoreFn?: (file: string, parent?: string) => Boolean\n) {\n  // this uses the reasons tree to collect files specific to a\n  // certain parent allowing us to not have to trace each parent\n  // separately\n  const parentFilesMap = new Map<string, Map<string, { ignored: boolean }>>()\n\n  function propagateToParents(\n    parents: Set<string>,\n    file: string,\n    seen = new Set<string>()\n  ) {\n    for (const parent of parents || []) {\n      if (!seen.has(parent)) {\n        seen.add(parent)\n        let parentFiles = parentFilesMap.get(parent)\n\n        if (!parentFiles) {\n          parentFiles = new Map()\n          parentFilesMap.set(parent, parentFiles)\n        }\n        const ignored = Boolean(ignoreFn?.(file, parent))\n        parentFiles.set(file, { ignored })\n\n        const parentReason = reasons.get(parent)\n\n        if (parentReason?.parents) {\n          propagateToParents(parentReason.parents, file, seen)\n        }\n      }\n    }\n  }\n\n  for (const file of fileList!) {\n    const reason = reasons!.get(file)\n    const isInitial =\n      reason?.type.length === 1 && reason.type.includes('initial')\n\n    if (\n      !reason ||\n      !reason.parents ||\n      (isInitial && reason.parents.size === 0)\n    ) {\n      continue\n    }\n    propagateToParents(reason.parents, file)\n  }\n  return parentFilesMap\n}\n\nexport interface TurbotraceAction {\n  action: 'print' | 'annotate'\n  input: string[]\n  contextDirectory: string\n  processCwd: string\n  logLevel?: NonNullable<\n    NextConfigComplete['experimental']['turbotrace']\n  >['logLevel']\n  showAll?: boolean\n  memoryLimit?: number\n}\n\nexport interface BuildTraceContext {\n  entriesTrace?: {\n    action: TurbotraceAction\n    appDir: string\n    outputPath: string\n    depModArray: string[]\n    entryNameMap: Record<string, string>\n  }\n  chunksTrace?: {\n    action: TurbotraceAction\n    outputPath: string\n    entryNameFilesMap: Record<string, Array<string>>\n  }\n}\n\nexport function getHash(content: string | Buffer): string {\n  return crypto.createHash('sha1').update(content).digest('hex')\n}\n\nexport class TraceEntryPointsPlugin implements webpack.WebpackPluginInstance {\n  public buildTraceContext: BuildTraceContext = {}\n\n  private rootDir: string\n  private appDir: string | undefined\n  private pagesDir: string | undefined\n  private optOutBundlingPackages: string[]\n  private appDirEnabled?: boolean\n  private tracingRoot: string\n  private entryTraces: Map<string, Map<string, { bundled: boolean }>>\n  private traceIgnores: string[]\n  private esmExternals?: NextConfigComplete['experimental']['esmExternals']\n  private turbotrace?: NextConfigComplete['experimental']['turbotrace']\n  private traceHashes: Map<string, string>\n  private flyingShuttle?: boolean\n  private compilerType: CompilerNameValues\n  private swcLoaderConfig: {\n    loader: string\n    options: SWCLoaderOptions\n  }\n\n  constructor({\n    rootDir,\n    appDir,\n    pagesDir,\n    compilerType,\n    optOutBundlingPackages,\n    appDirEnabled,\n    traceIgnores,\n    esmExternals,\n    outputFileTracingRoot,\n    turbotrace,\n    flyingShuttle,\n    swcLoaderConfig,\n  }: {\n    rootDir: string\n    compilerType: CompilerNameValues\n    flyingShuttle?: boolean\n    appDir: string | undefined\n    pagesDir: string | undefined\n    optOutBundlingPackages: string[]\n    appDirEnabled?: boolean\n    traceIgnores?: string[]\n    outputFileTracingRoot?: string\n    esmExternals?: NextConfigComplete['experimental']['esmExternals']\n    turbotrace?: NextConfigComplete['experimental']['turbotrace']\n    swcLoaderConfig: TraceEntryPointsPlugin['swcLoaderConfig']\n  }) {\n    this.rootDir = rootDir\n    this.appDir = appDir\n    this.pagesDir = pagesDir\n    this.entryTraces = new Map()\n    this.esmExternals = esmExternals\n    this.appDirEnabled = appDirEnabled\n    this.traceIgnores = traceIgnores || []\n    this.tracingRoot = outputFileTracingRoot || rootDir\n    this.turbotrace = turbotrace\n    this.optOutBundlingPackages = optOutBundlingPackages\n    this.flyingShuttle = flyingShuttle\n    this.traceHashes = new Map()\n    this.compilerType = compilerType\n    this.swcLoaderConfig = swcLoaderConfig\n  }\n\n  // Here we output all traced assets and webpack chunks to a\n  // ${page}.js.nft.json file\n  async createTraceAssets(\n    compilation: webpack.Compilation,\n    assets: any,\n    span: Span\n  ) {\n    const outputPath = compilation.outputOptions.path || ''\n\n    await span.traceChild('create-trace-assets').traceAsyncFn(async () => {\n      const entryFilesMap = new Map<any, Set<string>>()\n      const chunksToTrace = new Set<string>()\n      const entryNameFilesMap = new Map<string, Array<string>>()\n\n      const isTraceable = (file: string) =>\n        !NOT_TRACEABLE.some((suffix) => {\n          return file.endsWith(suffix)\n        })\n\n      for (const entrypoint of compilation.entrypoints.values()) {\n        const entryFiles = new Set<string>()\n\n        for (const chunk of entrypoint\n          .getEntrypointChunk()\n          .getAllReferencedChunks()) {\n          for (const file of chunk.files) {\n            if (isTraceable(file)) {\n              const filePath = nodePath.join(outputPath, file)\n              chunksToTrace.add(filePath)\n              entryFiles.add(filePath)\n            }\n          }\n          for (const file of chunk.auxiliaryFiles) {\n            if (isTraceable(file)) {\n              const filePath = nodePath.join(outputPath, file)\n              chunksToTrace.add(filePath)\n              entryFiles.add(filePath)\n            }\n          }\n        }\n        entryFilesMap.set(entrypoint, entryFiles)\n        entryNameFilesMap.set(entrypoint.name || '', [...entryFiles])\n      }\n\n      // startTrace existed and callable\n      this.buildTraceContext.chunksTrace = {\n        action: {\n          action: 'annotate',\n          input: [...chunksToTrace],\n          contextDirectory:\n            this.turbotrace?.contextDirectory ?? this.tracingRoot,\n          processCwd: this.turbotrace?.processCwd ?? this.rootDir,\n          showAll: this.turbotrace?.logAll,\n          logLevel: this.turbotrace?.logLevel,\n        },\n        outputPath,\n        entryNameFilesMap: Object.fromEntries(entryNameFilesMap),\n      }\n      const distDir = nodePath.join(\n        outputPath,\n        this.compilerType === 'server' ? '../..' : '../'\n      )\n\n      // server compiler outputs to `server/chunks` so we traverse up\n      // one, but edge-server does not so don't for that one\n      const outputPrefix = this.compilerType === 'server' ? '../' : ''\n\n      for (const [entrypoint, entryFiles] of entryFilesMap) {\n        const traceOutputName = `${outputPrefix}${entrypoint.name}.js.nft.json`\n        const traceOutputPath = nodePath.dirname(\n          nodePath.join(outputPath, traceOutputName)\n        )\n\n        // don't include the entry itself in the trace\n        entryFiles.delete(\n          nodePath.join(outputPath, `${outputPrefix}${entrypoint.name}.js`)\n        )\n\n        if (entrypoint.name.startsWith('app/')) {\n          // include the client reference manifest\n          const clientManifestsForPage =\n            entrypoint.name.endsWith('/page') ||\n            entrypoint.name === UNDERSCORE_NOT_FOUND_ROUTE_ENTRY\n              ? nodePath.join(\n                  outputPath,\n                  outputPrefix,\n                  entrypoint.name.replace(/%5F/g, '_') +\n                    '_' +\n                    CLIENT_REFERENCE_MANIFEST +\n                    '.js'\n                )\n              : null\n\n          if (clientManifestsForPage !== null) {\n            entryFiles.add(clientManifestsForPage)\n          }\n        }\n\n        const finalFiles: string[] = []\n        const readFile = (path: string): Promise<Buffer | string> => {\n          return new Promise((resolve, reject) => {\n            compilation.inputFileSystem.readFile(path, (err, result) => {\n              if (err) {\n                return reject(err)\n              }\n              resolve(result || '')\n            })\n          })\n        }\n        const fileHashes: Record<string, string> = {}\n\n        await Promise.all(\n          [\n            ...new Set([\n              ...entryFiles,\n              ...(this.entryTraces.get(entrypoint.name)?.keys() || []),\n            ]),\n          ].map(async (file) => {\n            const fileInfo = this.entryTraces.get(entrypoint.name)?.get(file)\n\n            const relativeFile = nodePath\n              .relative(traceOutputPath, file)\n              .replace(/\\\\/g, '/')\n\n            if (file) {\n              if (!file.startsWith(distDir) && this.flyingShuttle) {\n                let hash = this.traceHashes.get(file)\n\n                // file isn't read during tracing so calculate hash now\n                if (!hash) {\n                  hash = getHash(await readFile(file))\n                  this.traceHashes.set(file, hash)\n                }\n                fileHashes[relativeFile] = hash\n              }\n\n              if (!fileInfo?.bundled) {\n                finalFiles.push(relativeFile)\n              }\n            }\n          })\n        )\n\n        assets[traceOutputName] = new sources.RawSource(\n          JSON.stringify({\n            version: TRACE_OUTPUT_VERSION,\n            files: finalFiles,\n\n            ...(this.flyingShuttle\n              ? {\n                  fileHashes,\n                }\n              : {}),\n          })\n        )\n      }\n    })\n  }\n\n  tapfinishModules(\n    compilation: webpack.Compilation,\n    traceEntrypointsPluginSpan: Span,\n    doResolve: (\n      request: string,\n      parent: string,\n      job: import('@vercel/nft/out/node-file-trace').Job,\n      isEsmRequested: boolean\n    ) => Promise<string>,\n    readlink: any,\n    stat: any\n  ) {\n    async function getOriginalHash(path: string): Promise<string> {\n      return new Promise((resolve, reject) => {\n        if (path.includes('?')) {\n          path = path.substring(0, path.indexOf('?'))\n        }\n        compilation.inputFileSystem.readFile(path, (err, result) => {\n          if (err) {\n            return reject(err)\n          }\n          resolve(getHash(result || ''))\n        })\n      })\n    }\n\n    compilation.hooks.finishModules.tapAsync(\n      PLUGIN_NAME,\n      async (_stats: any, callback: any) => {\n        const finishModulesSpan =\n          traceEntrypointsPluginSpan.traceChild('finish-modules')\n        await finishModulesSpan\n          .traceAsyncFn(async () => {\n            // we create entry -> module maps so that we can\n            // look them up faster instead of having to iterate\n            // over the compilation modules list\n            const entryNameMap = new Map<string, string>()\n            const entryModMap = new Map<string, any>()\n            const additionalEntries = new Map<string, Map<string, any>>()\n\n            const depModMap = new Map<string, any>()\n\n            await finishModulesSpan\n              .traceChild('get-entries')\n              .traceAsyncFn(async () => {\n                for (const [name, entry] of compilation.entries.entries()) {\n                  const normalizedName = name?.replace(/\\\\/g, '/')\n\n                  const isPage = normalizedName.startsWith('pages/')\n                  const isApp =\n                    this.appDirEnabled && normalizedName.startsWith('app/')\n\n                  if (isApp || isPage) {\n                    for (const dep of entry.dependencies) {\n                      if (!dep) continue\n                      const entryMod = getModuleFromDependency(compilation, dep)\n\n                      // Handle case where entry is a loader coming from Next.js.\n                      // For example edge-loader or app-loader.\n                      if (entryMod && entryMod.resource === '') {\n                        const moduleBuildInfo = getModuleBuildInfo(entryMod)\n                        // All loaders that are used to create entries have a `route` property on the buildInfo.\n                        if (moduleBuildInfo.route) {\n                          const absolutePath = getPageFilePath({\n                            absolutePagePath:\n                              moduleBuildInfo.route.absolutePagePath,\n                            rootDir: this.rootDir,\n                            appDir: this.appDir,\n                            pagesDir: this.pagesDir,\n                          })\n\n                          // Ensures we don't handle non-pages.\n                          if (\n                            (this.pagesDir &&\n                              absolutePath.startsWith(this.pagesDir)) ||\n                            (this.appDir &&\n                              absolutePath.startsWith(this.appDir))\n                          ) {\n                            if (this.flyingShuttle) {\n                              this.traceHashes.set(\n                                absolutePath,\n                                await getOriginalHash(absolutePath)\n                              )\n                            }\n                            entryModMap.set(absolutePath, entryMod)\n                            entryNameMap.set(absolutePath, name)\n\n                            // attach related app route modules to ensure\n                            // we properly track them as dependencies\n                            // e.g. layouts, loading, etc\n                            if (\n                              this.flyingShuttle &&\n                              moduleBuildInfo.route?.relatedModules\n                            ) {\n                              let curAdditionalEntries =\n                                additionalEntries.get(name)\n\n                              if (!curAdditionalEntries) {\n                                curAdditionalEntries = new Map()\n                                additionalEntries.set(\n                                  name,\n                                  curAdditionalEntries\n                                )\n                              }\n\n                              for (const item of moduleBuildInfo.route\n                                ?.relatedModules) {\n                                curAdditionalEntries.set(item, entryMod)\n                              }\n                            }\n                          }\n                        }\n\n                        // If there was no `route` property, we can assume that it was something custom instead.\n                        // In order to trace these we add them to the additionalEntries map.\n                        if (entryMod.request) {\n                          let curMap = additionalEntries.get(name)\n\n                          if (!curMap) {\n                            curMap = new Map()\n                            additionalEntries.set(name, curMap)\n                          }\n                          depModMap.set(entryMod.request, entryMod)\n                          curMap.set(entryMod.resource, entryMod)\n                        }\n                      }\n\n                      if (entryMod && entryMod.resource) {\n                        entryNameMap.set(entryMod.resource, name)\n                        entryModMap.set(entryMod.resource, entryMod)\n\n                        let curMap = additionalEntries.get(name)\n\n                        if (!curMap) {\n                          curMap = new Map()\n                          additionalEntries.set(name, curMap)\n                        }\n                        if (this.flyingShuttle) {\n                          this.traceHashes.set(\n                            entryMod.resource,\n                            await getOriginalHash(entryMod.resource)\n                          )\n                        }\n                        depModMap.set(entryMod.resource, entryMod)\n                        curMap.set(entryMod.resource, entryMod)\n                      }\n                    }\n                  }\n                }\n              })\n\n            const readOriginalSource = (path: string) => {\n              return new Promise<string | Buffer>((resolve) => {\n                compilation.inputFileSystem.readFile(path, (err, result) => {\n                  if (err) {\n                    // we can't throw here as that crashes build un-necessarily\n                    return resolve('')\n                  }\n                  resolve(result || '')\n                })\n              })\n            }\n\n            const readFile = async (\n              path: string\n            ): Promise<Buffer | string | null> => {\n              const mod = depModMap.get(path) || entryModMap.get(path)\n\n              // map the transpiled source when available to avoid\n              // parse errors in node-file-trace\n              let source: Buffer | string = mod?.originalSource?.()?.buffer()\n\n              if (this.flyingShuttle) {\n                // fallback to reading raw source file, this may fail\n                // due to unsupported syntax but best effort attempt\n                let usingOriginalSource = false\n                if (\n                  !source ||\n                  source.toString().includes('next-flight-loader/module-proxy')\n                ) {\n                  source = await readOriginalSource(path)\n                  usingOriginalSource = true\n                }\n                const sourceString = source.toString()\n\n                // If this is a client component we need to trace the\n                // original transpiled source not the client proxy which is\n                // applied before this plugin is run due to the\n                // client-module-loader\n                if (\n                  usingOriginalSource &&\n                  // don't attempt transpiling CSS or image imports\n                  path.match(/\\.(tsx|ts|js|cjs|mjs|jsx)$/)\n                ) {\n                  let transformResolve: (result: string) => void\n                  let transformReject: (error: unknown) => void\n                  const transformPromise = new Promise<string>(\n                    (resolve, reject) => {\n                      transformResolve = resolve\n                      transformReject = reject\n                    }\n                  )\n\n                  // TODO: should we apply all loaders except the\n                  // client-module-loader?\n                  swcLoader.apply(\n                    {\n                      resourcePath: path,\n                      getOptions: () => {\n                        return this.swcLoaderConfig.options\n                      },\n                      async: () => {\n                        return (err: unknown, result: string) => {\n                          if (err) {\n                            return transformReject(err)\n                          }\n                          return transformResolve(result)\n                        }\n                      },\n                    },\n                    [sourceString, undefined]\n                  )\n                  source = await transformPromise\n                }\n              }\n              return source || ''\n            }\n\n            const entryPaths = Array.from(entryModMap.keys())\n            const entryPathDepMap = new Map<string, Set<string>>()\n\n            const collectDependencies = async (mod: any, parent: string) => {\n              if (!mod || !mod.dependencies) return\n\n              for (const dep of mod.dependencies) {\n                const depMod = getModuleFromDependency(compilation, dep)\n\n                if (depMod?.resource && !depModMap.get(depMod.resource)) {\n                  if (this.flyingShuttle) {\n                    // ensure we associate this dep with the entry\n                    let curDepSet = entryPathDepMap.get(parent)\n\n                    if (!curDepSet) {\n                      curDepSet = new Set()\n                      entryPathDepMap.set(parent, curDepSet)\n                    }\n                    curDepSet.add(depMod.resource)\n                    this.traceHashes.set(\n                      depMod.resource,\n                      await getOriginalHash(depMod.resource)\n                    )\n                  }\n                  depModMap.set(depMod.resource, depMod)\n                  await collectDependencies(depMod, parent)\n                }\n              }\n            }\n            const entriesToTrace = [...entryPaths]\n\n            for (const entry of entryPaths) {\n              await collectDependencies(entryModMap.get(entry), entry)\n              const entryName = entryNameMap.get(entry)!\n              const curExtraEntries = additionalEntries.get(entryName)\n\n              if (curExtraEntries) {\n                entriesToTrace.push(...curExtraEntries.keys())\n              }\n            }\n\n            const contextDirectory =\n              this.turbotrace?.contextDirectory ?? this.tracingRoot\n            const chunks = [...entriesToTrace]\n\n            this.buildTraceContext.entriesTrace = {\n              action: {\n                action: 'print',\n                input: chunks,\n                contextDirectory,\n                processCwd: this.turbotrace?.processCwd ?? this.rootDir,\n                logLevel: this.turbotrace?.logLevel,\n                showAll: this.turbotrace?.logAll,\n              },\n              appDir: this.rootDir,\n              depModArray: Array.from(depModMap.keys()),\n              entryNameMap: Object.fromEntries(entryNameMap),\n              outputPath: compilation.outputOptions.path!,\n            }\n\n            // if we're using turbotrace we can skip tracing\n            // loader contents as it should be able to capture\n            // fs usage in final chunks instead\n            if (this.turbotrace) {\n              let binding = await loadBindings()\n              if (\n                !binding?.isWasm &&\n                typeof binding.turbo.startTrace === 'function'\n              ) {\n                return\n              }\n            }\n\n            let fileList: Set<string>\n            let reasons: NodeFileTraceReasons\n            const ignores = [\n              ...TRACE_IGNORES,\n              ...this.traceIgnores,\n              '**/node_modules/**',\n            ]\n\n            // pre-compile the ignore matcher to avoid repeating on every ignoreFn call\n            const isIgnoreMatcher = picomatch(ignores, {\n              contains: true,\n              dot: true,\n            })\n            const ignoreFn = (path: string) => {\n              return isIgnoreMatcher(path)\n            }\n\n            await finishModulesSpan\n              .traceChild('node-file-trace-plugin', {\n                traceEntryCount: entriesToTrace.length + '',\n              })\n              .traceAsyncFn(async () => {\n                const result = await nodeFileTrace(entriesToTrace, {\n                  base: this.tracingRoot,\n                  processCwd: this.rootDir,\n                  readFile,\n                  readlink,\n                  stat,\n                  resolve: doResolve\n                    ? async (id, parent, job, isCjs) => {\n                        return doResolve(id, parent, job, !isCjs)\n                      }\n                    : undefined,\n                  ignore: ignoreFn,\n                  mixedModules: true,\n                })\n                // @ts-ignore\n                fileList = result.fileList\n                result.esmFileList.forEach((file) => fileList.add(file))\n                reasons = result.reasons\n              })\n\n            await finishModulesSpan\n              .traceChild('collect-traced-files')\n              .traceAsyncFn(() => {\n                const parentFilesMap = getFilesMapFromReasons(\n                  fileList,\n                  reasons,\n                  (file) => {\n                    // if a file was imported and a loader handled it\n                    // we don't include it in the trace e.g.\n                    // static image imports, CSS imports\n                    file = nodePath.join(this.tracingRoot, file)\n                    const depMod = depModMap.get(file)\n                    const isAsset = reasons\n                      .get(nodePath.relative(this.tracingRoot, file))\n                      ?.type.includes('asset')\n\n                    return (\n                      !isAsset &&\n                      Array.isArray(depMod?.loaders) &&\n                      depMod.loaders.length > 0\n                    )\n                  }\n                )\n\n                for (const entry of entryPaths) {\n                  const entryName = entryNameMap.get(entry)!\n                  const normalizedEntry = nodePath.relative(\n                    this.tracingRoot,\n                    entry\n                  )\n                  const curExtraEntries = additionalEntries.get(entryName)\n                  const finalDeps = new Map<string, { bundled: boolean }>()\n\n                  // ensure we include entry source file as well for\n                  // hash comparison\n                  finalDeps.set(entry, {\n                    bundled: true,\n                  })\n\n                  for (const [dep, info] of parentFilesMap\n                    .get(normalizedEntry)\n                    ?.entries() || []) {\n                    finalDeps.set(nodePath.join(this.tracingRoot, dep), {\n                      bundled: info.ignored,\n                    })\n                  }\n\n                  if (curExtraEntries) {\n                    for (const extraEntry of curExtraEntries.keys()) {\n                      const normalizedExtraEntry = nodePath.relative(\n                        this.tracingRoot,\n                        extraEntry\n                      )\n                      finalDeps.set(extraEntry, { bundled: false })\n\n                      for (const [dep, info] of parentFilesMap\n                        .get(normalizedExtraEntry)\n                        ?.entries() || []) {\n                        finalDeps.set(nodePath.join(this.tracingRoot, dep), {\n                          bundled: info.ignored,\n                        })\n                      }\n                    }\n                  }\n\n                  // ensure we grab all associated dependencies\n                  if (this.flyingShuttle) {\n                    const curDepSet = entryPathDepMap.get(entry)\n\n                    for (const item of curDepSet || []) {\n                      // ensure loader specific deps aren't included\n                      if (!item.includes('?')) {\n                        if (!finalDeps.has(item)) {\n                          finalDeps.set(item, {\n                            bundled: true,\n                          })\n                        }\n                        const parentFiles =\n                          parentFilesMap\n                            .get(nodePath.relative(this.tracingRoot, entry))\n                            ?.entries() || []\n\n                        for (const [dep, info] of parentFiles) {\n                          finalDeps.set(nodePath.join(this.tracingRoot, dep), {\n                            bundled: info.ignored,\n                          })\n                        }\n                      }\n                    }\n                  }\n\n                  this.entryTraces.set(entryName, finalDeps)\n                }\n              })\n          })\n          .then(\n            () => callback(),\n            (err) => callback(err)\n          )\n      }\n    )\n  }\n\n  apply(compiler: webpack.Compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      const readlink = async (path: string): Promise<string | null> => {\n        try {\n          return await new Promise((resolve, reject) => {\n            ;(\n              compilation.inputFileSystem\n                .readlink as typeof import('fs').readlink\n            )(path, (err, link) => {\n              if (err) return reject(err)\n              resolve(link)\n            })\n          })\n        } catch (e) {\n          if (\n            isError(e) &&\n            (e.code === 'EINVAL' || e.code === 'ENOENT' || e.code === 'UNKNOWN')\n          ) {\n            return null\n          }\n          throw e\n        }\n      }\n      const stat = async (path: string): Promise<import('fs').Stats | null> => {\n        try {\n          return await new Promise((resolve, reject) => {\n            ;(compilation.inputFileSystem.stat as typeof import('fs').stat)(\n              path,\n              (err, stats) => {\n                if (err) return reject(err)\n                resolve(stats)\n              }\n            )\n          })\n        } catch (e) {\n          if (isError(e) && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n            return null\n          }\n          throw e\n        }\n      }\n\n      const compilationSpan = spans.get(compilation) || spans.get(compiler)!\n      const traceEntrypointsPluginSpan = compilationSpan.traceChild(\n        'next-trace-entrypoint-plugin'\n      )\n      traceEntrypointsPluginSpan.traceFn(() => {\n        compilation.hooks.processAssets.tapAsync(\n          {\n            name: PLUGIN_NAME,\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,\n          },\n          (assets: any, callback: any) => {\n            this.createTraceAssets(\n              compilation,\n              assets,\n              traceEntrypointsPluginSpan\n            )\n              .then(() => callback())\n              .catch((err) => callback(err))\n          }\n        )\n\n        let resolver = compilation.resolverFactory.get('normal')\n\n        function getPkgName(name: string) {\n          const segments = name.split('/')\n          if (name[0] === '@' && segments.length > 1)\n            return segments.length > 1 ? segments.slice(0, 2).join('/') : null\n          return segments.length ? segments[0] : null\n        }\n\n        const getResolve = (\n          options: Parameters<typeof resolver.withOptions>[0]\n        ) => {\n          const curResolver = resolver.withOptions(options)\n\n          return (\n            parent: string,\n            request: string,\n            job: import('@vercel/nft/out/node-file-trace').Job\n          ) =>\n            new Promise<[string, boolean]>((resolve, reject) => {\n              const context = nodePath.dirname(parent)\n\n              curResolver.resolve(\n                {},\n                context,\n                request,\n                {\n                  fileDependencies: compilation.fileDependencies,\n                  missingDependencies: compilation.missingDependencies,\n                  contextDependencies: compilation.contextDependencies,\n                },\n                async (err: any, result?, resContext?) => {\n                  if (err) return reject(err)\n\n                  if (!result) {\n                    return reject(new Error('module not found'))\n                  }\n\n                  // webpack resolver doesn't strip loader query info\n                  // from the result so use path instead\n                  if (result.includes('?') || result.includes('!')) {\n                    result = resContext?.path || result\n                  }\n\n                  try {\n                    // we need to collect all parent package.json's used\n                    // as webpack's resolve doesn't expose this and parent\n                    // package.json could be needed for resolving e.g. stylis\n                    // stylis/package.json -> stylis/dist/umd/package.json\n                    if (result.includes('node_modules')) {\n                      let requestPath = result\n                        .replace(/\\\\/g, '/')\n                        .replace(/\\0/g, '')\n\n                      if (\n                        !nodePath.isAbsolute(request) &&\n                        request.includes('/') &&\n                        resContext?.descriptionFileRoot\n                      ) {\n                        requestPath = (\n                          resContext.descriptionFileRoot +\n                          request.slice(getPkgName(request)?.length || 0) +\n                          nodePath.sep +\n                          'package.json'\n                        )\n                          .replace(/\\\\/g, '/')\n                          .replace(/\\0/g, '')\n                      }\n\n                      const rootSeparatorIndex = requestPath.indexOf('/')\n                      let separatorIndex: number\n                      while (\n                        (separatorIndex = requestPath.lastIndexOf('/')) >\n                        rootSeparatorIndex\n                      ) {\n                        requestPath = requestPath.slice(0, separatorIndex)\n                        const curPackageJsonPath = `${requestPath}/package.json`\n                        if (await job.isFile(curPackageJsonPath)) {\n                          await job.emitFile(\n                            await job.realpath(curPackageJsonPath),\n                            'resolve',\n                            parent\n                          )\n                        }\n                      }\n                    }\n                  } catch (_err) {\n                    // we failed to resolve the package.json boundary,\n                    // we don't block emitting the initial asset from this\n                  }\n                  resolve([result, options.dependencyType === 'esm'])\n                }\n              )\n            })\n        }\n\n        const CJS_RESOLVE_OPTIONS = {\n          ...NODE_RESOLVE_OPTIONS,\n          fullySpecified: undefined,\n          modules: undefined,\n          extensions: undefined,\n        }\n        const BASE_CJS_RESOLVE_OPTIONS = {\n          ...CJS_RESOLVE_OPTIONS,\n          alias: false,\n        }\n        const ESM_RESOLVE_OPTIONS = {\n          ...NODE_ESM_RESOLVE_OPTIONS,\n          fullySpecified: undefined,\n          modules: undefined,\n          extensions: undefined,\n        }\n        const BASE_ESM_RESOLVE_OPTIONS = {\n          ...ESM_RESOLVE_OPTIONS,\n          alias: false,\n        }\n\n        const doResolve = async (\n          request: string,\n          parent: string,\n          job: import('@vercel/nft/out/node-file-trace').Job,\n          isEsmRequested: boolean\n        ): Promise<string> => {\n          const context = nodePath.dirname(parent)\n          // When in esm externals mode, and using import, we resolve with\n          // ESM resolving options.\n          const { res } = await resolveExternal(\n            this.rootDir,\n            this.esmExternals,\n            context,\n            request,\n            isEsmRequested,\n            this.optOutBundlingPackages,\n            (options) => (_: string, resRequest: string) => {\n              return getResolve(options)(parent, resRequest, job)\n            },\n            undefined,\n            undefined,\n            ESM_RESOLVE_OPTIONS,\n            CJS_RESOLVE_OPTIONS,\n            BASE_ESM_RESOLVE_OPTIONS,\n            BASE_CJS_RESOLVE_OPTIONS\n          )\n\n          if (!res) {\n            throw new Error(`failed to resolve ${request} from ${parent}`)\n          }\n          return res.replace(/\\0/g, '')\n        }\n\n        this.tapfinishModules(\n          compilation,\n          traceEntrypointsPluginSpan,\n          doResolve,\n          readlink,\n          stat\n        )\n      })\n    })\n  }\n}\n"],"names":["nodePath","crypto","spans","isError","nodeFileTrace","CLIENT_REFERENCE_MANIFEST","TRACE_OUTPUT_VERSION","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","webpack","sources","NODE_ESM_RESOLVE_OPTIONS","NODE_RESOLVE_OPTIONS","loadBindings","picomatch","getModuleBuildInfo","getPageFilePath","resolveExternal","swcLoader","PLUGIN_NAME","TRACE_IGNORES","NOT_TRACEABLE","getModuleFromDependency","compilation","dep","moduleGraph","getModule","getFilesMapFromReasons","fileList","reasons","ignoreFn","parentFilesMap","Map","propagateToParents","parents","file","seen","Set","parent","has","add","parentFiles","get","set","ignored","Boolean","parentReason","reason","isInitial","type","length","includes","size","getHash","content","createHash","update","digest","TraceEntryPointsPlugin","constructor","rootDir","appDir","pagesDir","compilerType","optOutBundlingPackages","appDirEnabled","traceIgnores","esmExternals","outputFileTracingRoot","turbotrace","flyingShuttle","swcLoaderConfig","buildTraceContext","entryTraces","tracingRoot","traceHashes","createTraceAssets","assets","span","outputPath","outputOptions","path","traceChild","traceAsyncFn","entryFilesMap","chunksToTrace","entryNameFilesMap","isTraceable","some","suffix","endsWith","entrypoint","entrypoints","values","entryFiles","chunk","getEntrypointChunk","getAllReferencedChunks","files","filePath","join","auxiliaryFiles","name","chunksTrace","action","input","contextDirectory","processCwd","showAll","logAll","logLevel","Object","fromEntries","distDir","outputPrefix","traceOutputName","traceOutputPath","dirname","delete","startsWith","clientManifestsForPage","replace","finalFiles","readFile","Promise","resolve","reject","inputFileSystem","err","result","fileHashes","all","keys","map","fileInfo","relativeFile","relative","hash","bundled","push","RawSource","JSON","stringify","version","tapfinishModules","traceEntrypointsPluginSpan","doResolve","readlink","stat","getOriginalHash","substring","indexOf","hooks","finishModules","tapAsync","_stats","callback","finishModulesSpan","entryNameMap","entryModMap","additionalEntries","depModMap","entry","entries","normalizedName","isPage","isApp","dependencies","entryMod","resource","moduleBuildInfo","route","absolutePath","absolutePagePath","relatedModules","curAdditionalEntries","item","request","curMap","readOriginalSource","mod","source","originalSource","buffer","usingOriginalSource","toString","sourceString","match","transformResolve","transformReject","transformPromise","apply","resourcePath","getOptions","options","async","undefined","entryPaths","Array","from","entryPathDepMap","collectDependencies","depMod","curDepSet","entriesToTrace","entryName","curExtraEntries","chunks","entriesTrace","depModArray","binding","isWasm","turbo","startTrace","ignores","isIgnoreMatcher","contains","dot","traceEntryCount","base","id","job","isCjs","ignore","mixedModules","esmFileList","forEach","isAsset","isArray","loaders","normalizedEntry","finalDeps","info","extraEntry","normalizedExtraEntry","then","compiler","tap","link","e","code","stats","compilationSpan","traceFn","processAssets","stage","Compilation","PROCESS_ASSETS_STAGE_SUMMARIZE","catch","resolver","resolverFactory","getPkgName","segments","split","slice","getResolve","curResolver","withOptions","context","fileDependencies","missingDependencies","contextDependencies","resContext","Error","requestPath","isAbsolute","descriptionFileRoot","sep","rootSeparatorIndex","separatorIndex","lastIndexOf","curPackageJsonPath","isFile","emitFile","realpath","_err","dependencyType","CJS_RESOLVE_OPTIONS","fullySpecified","modules","extensions","BASE_CJS_RESOLVE_OPTIONS","alias","ESM_RESOLVE_OPTIONS","BASE_ESM_RESOLVE_OPTIONS","isEsmRequested","res","_","resRequest"],"mappings":"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"}