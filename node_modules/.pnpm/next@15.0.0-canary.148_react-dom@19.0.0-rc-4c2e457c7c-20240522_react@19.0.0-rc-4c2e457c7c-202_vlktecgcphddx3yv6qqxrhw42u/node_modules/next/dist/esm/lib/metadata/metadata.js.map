{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type {\n  AppRenderContext,\n  GetDynamicParamFromSegment,\n} from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport type { MetadataContext } from './types/resolvers'\nimport type { CreateDynamicallyTrackedParams } from '../../client/components/fallback-params'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport { trackFallbackParamAccessed } from '../../server/app-render/dynamic-rendering'\n\nexport function createMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts']\n): MetadataContext {\n  return {\n    pathname,\n    trailingSlash: renderOpts.trailingSlash,\n    isStandaloneMode: renderOpts.nextConfigOutput === 'standalone',\n  }\n}\n\nexport function createTrackedMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts'],\n  staticGenerationStore: StaticGenerationStore | null\n): MetadataContext {\n  return {\n    // Use the regular metadata context, but we trap the pathname access.\n    ...createMetadataContext(pathname, renderOpts),\n\n    // Setup the trap around the pathname access so we can track when the\n    // pathname is accessed while resolving metadata which would indicate it's\n    // being used to resolve a relative URL. If that's the case, we don't want\n    // to provide it, and instead we should error.\n    get pathname() {\n      if (\n        staticGenerationStore &&\n        staticGenerationStore.isStaticGeneration &&\n        staticGenerationStore.fallbackRouteParams &&\n        staticGenerationStore.fallbackRouteParams.size > 0\n      ) {\n        trackFallbackParamAccessed(\n          staticGenerationStore,\n          'metadata relative url resolving'\n        )\n      }\n\n      return pathname\n    },\n  }\n}\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  query,\n  metadataContext,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n  createDynamicallyTrackedParams,\n}: {\n  tree: LoaderTree\n  query: ParsedUrlQuery\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedParams: CreateDynamicallyTrackedParams\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, () => Promise<void>] {\n  let currentMetadataReady:\n    | null\n    | (Promise<void> & {\n        status?: string\n        value?: unknown\n      }) = null\n\n  async function MetadataTree() {\n    const pendingMetadata = getResolvedMetadata(\n      tree,\n      query,\n      getDynamicParamFromSegment,\n      metadataContext,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n      errorType\n    )\n\n    // We instrument the promise compatible with React. This isn't necessary but we can\n    // perform a similar trick in synchronously unwrapping in the outlet component to avoid\n    // ticking a new microtask unecessarily\n    const metadataReady: Promise<void> & { status: string; value: unknown } =\n      pendingMetadata.then(\n        ([error]) => {\n          if (error) {\n            metadataReady.status = 'rejected'\n            metadataReady.value = error\n            throw error\n          }\n          metadataReady.status = 'fulfilled'\n          metadataReady.value = undefined\n        },\n        (error) => {\n          metadataReady.status = 'rejected'\n          metadataReady.value = error\n          throw error\n        }\n      ) as Promise<void> & { status: string; value: unknown }\n    metadataReady.status = 'pending'\n    currentMetadataReady = metadataReady\n    // We aren't going to await this promise immediately but if it rejects early we don't\n    // want unhandled rejection errors so we attach a throwaway catch handler.\n    metadataReady.catch(() => {})\n\n    // We ignore any error from metadata here because it needs to be thrown from within the Page\n    // not where the metadata itself is actually rendered\n    const [, elements] = await pendingMetadata\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n        {appUsingSizeAdjustment ? <meta name=\"next-size-adjust\" /> : null}\n      </>\n    )\n  }\n\n  function getMetadataReady() {\n    return Promise.resolve().then(() => {\n      if (currentMetadataReady) {\n        return currentMetadataReady\n      }\n      throw new Error(\n        'getMetadataReady was called before MetadataTree rendered'\n      )\n    })\n  }\n\n  return [MetadataTree, getMetadataReady]\n}\n\nasync function getResolvedMetadata(\n  tree: LoaderTree,\n  query: ParsedUrlQuery,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery,\n  createDynamicallyTrackedParams: CreateDynamicallyTrackedParams,\n  errorType?: 'not-found' | 'redirect'\n): Promise<[any, Array<React.ReactNode>]> {\n  const errorMetadataItem: [null, null, null] = [null, null, null]\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n  const searchParams = createDynamicallyTrackedSearchParams(query)\n\n  const [error, metadata, viewport] = await resolveMetadata({\n    tree,\n    parentParams: {},\n    metadataItems: [],\n    errorMetadataItem,\n    searchParams,\n    getDynamicParamFromSegment,\n    errorConvention,\n    metadataContext,\n    createDynamicallyTrackedParams,\n  })\n  if (!error) {\n    return [null, createMetadataElements(metadata, viewport)]\n  } else {\n    // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n    // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n    // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n    // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n    if (!errorType && isNotFoundError(error)) {\n      const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n        await resolveMetadata({\n          tree,\n          parentParams: {},\n          metadataItems: [],\n          errorMetadataItem,\n          searchParams,\n          getDynamicParamFromSegment,\n          errorConvention: 'not-found',\n          metadataContext,\n          createDynamicallyTrackedParams,\n        })\n      return [\n        notFoundMetadataError || error,\n        createMetadataElements(notFoundMetadata, notFoundViewport),\n      ]\n    }\n    return [error, []]\n  }\n}\n\nfunction createMetadataElements(\n  metadata: ResolvedMetadata,\n  viewport: ResolvedViewport\n) {\n  return MetaFilter([\n    ViewportMeta({ viewport: viewport }),\n    BasicMeta({ metadata }),\n    AlternatesMetadata({ alternates: metadata.alternates }),\n    ItunesMeta({ itunes: metadata.itunes }),\n    FacebookMeta({ facebook: metadata.facebook }),\n    FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n    VerificationMeta({ verification: metadata.verification }),\n    AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n    OpenGraphMetadata({ openGraph: metadata.openGraph }),\n    TwitterMetadata({ twitter: metadata.twitter }),\n    AppLinksMeta({ appLinks: metadata.appLinks }),\n    IconsMetadata({ icons: metadata.icons }),\n  ])\n}\n"],"names":["React","AppleWebAppMeta","FormatDetectionMeta","ItunesMeta","BasicMeta","ViewportMeta","VerificationMeta","FacebookMeta","AlternatesMetadata","OpenGraphMetadata","TwitterMetadata","AppLinksMeta","IconsMetadata","resolveMetadata","MetaFilter","isNotFoundError","trackFallbackParamAccessed","createMetadataContext","pathname","renderOpts","trailingSlash","isStandaloneMode","nextConfigOutput","createTrackedMetadataContext","staticGenerationStore","isStaticGeneration","fallbackRouteParams","size","createMetadataComponents","tree","query","metadataContext","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","createDynamicallyTrackedParams","currentMetadataReady","MetadataTree","pendingMetadata","getResolvedMetadata","metadataReady","then","error","status","value","undefined","catch","elements","map","el","index","cloneElement","key","meta","name","getMetadataReady","Promise","resolve","Error","errorMetadataItem","errorConvention","searchParams","metadata","viewport","parentParams","metadataItems","createMetadataElements","notFoundMetadataError","notFoundMetadata","notFoundViewport","alternates","itunes","facebook","formatDetection","verification","appleWebApp","openGraph","twitter","appLinks","icons"],"mappings":"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"}