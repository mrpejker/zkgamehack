{"version":3,"sources":["../../../../src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype Task = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // This is usually non-null. It represents a brand new Cache Node tree whose\n  // data is still pending. If it's null, it means there's no pending data but\n  // the client patched the router state.\n  node: CacheNode | null\n  children: Map<string, Task> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function updateCacheNodeOnNavigation(\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData,\n  prefetchHead: React.ReactNode,\n  onlyHashChange: boolean\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData[2]\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // For most navigations, we need to issue a \"dynamic\" request to fetch the\n  // full RSC data from the server since during rendering, we'll only serve\n  // the prefetch shell. For some navigations, we re-use the existing cache node\n  // (via `spawnReusedTask`), and don't actually need fresh data from the server.\n  // In those cases, we use this `needsDynamicRequest` flag to return a `null`\n  // cache node, which signals to the caller that we don't need to issue a\n  // dynamic request. We start off with a `false` value, and then for each parallel\n  // route, we set it to `true` if we encounter a segment that needs a dynamic request.\n  let needsDynamicRequest = false\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren[parallelRouteKey]\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    // A dynamic segment will be an array, and doesn't correspond with a page segment.\n    const isPageSegment = Array.isArray(newSegmentChild)\n      ? false\n      : // A page segment might contain search parameters, so we verify that it starts with the page segment key.\n        newSegmentChild.startsWith(PAGE_SEGMENT_KEY)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (onlyHashChange && oldRouterStateChild !== undefined) {\n      // If only the hash fragment changed, we can re-use the existing cache.\n      // We spawn a \"task\" just to keep track of the updated router state; unlike most, it's\n      // already fulfilled and won't be affected by the dynamic response.\n      taskChild = spawnReusedTask(oldRouterStateChild)\n    } else if (isPageSegment) {\n      // This is a leaf segment — a page, not a shared layout. We always apply\n      // its data.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead\n      )\n    } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead\n        )\n      }\n    } else if (\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees.\n        if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n          // Recursively update the children.\n          taskChild = updateCacheNodeOnNavigation(\n            oldCacheNodeChild,\n            oldRouterStateChild,\n            newRouterStateChild,\n            prefetchDataChild,\n            prefetchHead,\n            onlyHashChange\n          )\n        } else {\n          // The server didn't send any prefetch data for this segment. This\n          // shouldn't happen because the Route Tree and the Seed Data tree\n          // should always be the same shape, but until we unify those types\n          // it's still possible. For now we're going to deopt and trigger a\n          // lazy fetch during render.\n          taskChild = spawnTaskForMissingData(newRouterStateChild)\n        }\n      } else {\n        // Either there's no existing Cache Node for this segment, or this\n        // segment doesn't exist in the old Router State tree. Switch to the\n        // \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead\n      )\n    }\n\n    if (taskChild !== null) {\n      // Something changed in the child tree. Keep track of the child task.\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n        // a non-null taskChild.node means we're waiting for a dynamic request to\n        // fill in the missing data\n        needsDynamicRequest = true\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      patchedRouterStateChildren[parallelRouteKey] = taskChild.route\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    // Only return the new cache node if there are pending tasks that need to be resolved\n    // by the dynamic data from the server. If they don't, we don't need to trigger a dynamic request.\n    node: needsDynamicRequest ? newCacheNode : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode\n): Task {\n  // Create a task that will later be fulfilled by data from the server.\n  const pendingCacheNode = createPendingCacheNode(\n    routerState,\n    prefetchData,\n    prefetchHead\n  )\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    children: null,\n  }\n}\n\nfunction spawnTaskForMissingData(routerState: FlightRouterState): Task {\n  // Create a task for a new subtree that wasn't prefetched by the server.\n  // This shouldn't really ever happen but it's here just in case the Seed Data\n  // Tree and the Router State Tree disagree unexpectedly.\n  const pendingCacheNode = createPendingCacheNode(routerState, null, null)\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: Task,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    ({ flightData }: FetchServerResponseResult) => {\n      for (const normalizedFlightData of flightData) {\n        if (typeof normalizedFlightData === 'string') {\n          // Happens when navigating to page in `pages` from `app`. We shouldn't\n          // get here because should have already handled this during\n          // the prefetch.\n          continue\n        }\n\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: Task,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: Task,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Null this out to indicate that the task is complete.\n      task.node = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[2]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : null,\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[2]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[1]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: Task, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Null this out to indicate that the task is complete.\n  task.node = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n) {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch  data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","onlyHashChange","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","isPageSegment","Array","isArray","startsWith","oldCacheNodeChild","taskChild","spawnReusedTask","spawnPendingTask","spawnTaskForMissingData","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","children","baseRouterState","newChildren","clone","routerState","pendingCacheNode","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","flightData","normalizedFlightData","segmentPath","tree","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","length","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","isLeafSegment","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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"}