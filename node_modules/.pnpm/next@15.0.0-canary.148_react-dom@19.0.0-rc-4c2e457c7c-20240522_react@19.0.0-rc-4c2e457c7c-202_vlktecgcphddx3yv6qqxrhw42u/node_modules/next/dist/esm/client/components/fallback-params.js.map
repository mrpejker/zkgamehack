{"version":3,"sources":["../../../src/client/components/fallback-params.ts"],"sourcesContent":["import { trackFallbackParamAccessed } from '../../server/app-render/dynamic-rendering'\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher'\nimport { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport type { Params } from './params'\nimport { staticGenerationAsyncStorage } from './static-generation-async-storage.external'\n\nexport type FallbackRouteParams = ReadonlyMap<string, string>\n\nexport function getParamKeys(page: string) {\n  const pattern = getRouteRegex(page)\n  const matcher = getRouteMatcher(pattern)\n\n  // Get the default list of allowed params.\n  return Object.keys(matcher(page))\n}\n\nexport function getFallbackRouteParams(\n  pageOrKeys: string | readonly string[]\n): FallbackRouteParams | null {\n  let keys: readonly string[]\n  if (typeof pageOrKeys === 'string') {\n    keys = getParamKeys(pageOrKeys)\n  } else {\n    keys = pageOrKeys\n  }\n\n  // If there are no keys, we can return early.\n  if (keys.length === 0) return null\n\n  const params = new Map<string, string>()\n\n  // As we're creating unique keys for each of the dynamic route params, we only\n  // need to generate a unique ID once per request because each of the keys will\n  // be also be unique.\n  const uniqueID = Math.random().toString(16).slice(2)\n\n  for (const key of keys) {\n    params.set(key, `%%drp:${key}:${uniqueID}%%`)\n  }\n\n  return params\n}\n\nexport type CreateDynamicallyTrackedParams =\n  typeof createDynamicallyTrackedParams\n\nexport function createDynamicallyTrackedParams(params: Params): Params {\n  const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n  if (\n    !staticGenerationStore ||\n    !staticGenerationStore.isStaticGeneration ||\n    !staticGenerationStore.fallbackRouteParams ||\n    staticGenerationStore.fallbackRouteParams.size === 0\n  ) {\n    return params\n  }\n\n  // If there are no unknown route params, we can just return the params.\n  const { fallbackRouteParams } = staticGenerationStore\n\n  return new Proxy(params as Params, {\n    get(target, prop, receiver) {\n      // If the property is in the params object, we should track the access if\n      // it's an unknown dynamic param.\n      if (\n        typeof prop === 'string' &&\n        prop in params &&\n        fallbackRouteParams.has(prop)\n      ) {\n        trackFallbackParamAccessed(staticGenerationStore, `params.${prop}`)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (\n        typeof prop === 'string' &&\n        prop in params &&\n        fallbackRouteParams.has(prop)\n      ) {\n        trackFallbackParamAccessed(staticGenerationStore, `params.${prop}`)\n      }\n\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys(target) {\n      for (const key in params) {\n        if (fallbackRouteParams.has(key)) {\n          trackFallbackParamAccessed(staticGenerationStore, 'params')\n        }\n      }\n\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n"],"names":["trackFallbackParamAccessed","ReflectAdapter","getRouteMatcher","getRouteRegex","staticGenerationAsyncStorage","getParamKeys","page","pattern","matcher","Object","keys","getFallbackRouteParams","pageOrKeys","length","params","Map","uniqueID","Math","random","toString","slice","key","set","createDynamicallyTrackedParams","staticGenerationStore","getStore","isStaticGeneration","fallbackRouteParams","size","Proxy","get","target","prop","receiver","has","ownKeys","Reflect"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,4CAA2C;AACtF,SAASC,cAAc,QAAQ,mDAAkD;AACjF,SAASC,eAAe,QAAQ,8CAA6C;AAC7E,SAASC,aAAa,QAAQ,4CAA2C;AAEzE,SAASC,4BAA4B,QAAQ,6CAA4C;AAIzF,OAAO,SAASC,aAAaC,IAAY;IACvC,MAAMC,UAAUJ,cAAcG;IAC9B,MAAME,UAAUN,gBAAgBK;IAEhC,0CAA0C;IAC1C,OAAOE,OAAOC,IAAI,CAACF,QAAQF;AAC7B;AAEA,OAAO,SAASK,uBACdC,UAAsC;IAEtC,IAAIF;IACJ,IAAI,OAAOE,eAAe,UAAU;QAClCF,OAAOL,aAAaO;IACtB,OAAO;QACLF,OAAOE;IACT;IAEA,6CAA6C;IAC7C,IAAIF,KAAKG,MAAM,KAAK,GAAG,OAAO;IAE9B,MAAMC,SAAS,IAAIC;IAEnB,8EAA8E;IAC9E,8EAA8E;IAC9E,qBAAqB;IACrB,MAAMC,WAAWC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;IAElD,KAAK,MAAMC,OAAOX,KAAM;QACtBI,OAAOQ,GAAG,CAACD,KAAK,AAAC,WAAQA,MAAI,MAAGL,WAAS;IAC3C;IAEA,OAAOF;AACT;AAKA,OAAO,SAASS,+BAA+BT,MAAc;IAC3D,MAAMU,wBAAwBpB,6BAA6BqB,QAAQ;IACnE,IACE,CAACD,yBACD,CAACA,sBAAsBE,kBAAkB,IACzC,CAACF,sBAAsBG,mBAAmB,IAC1CH,sBAAsBG,mBAAmB,CAACC,IAAI,KAAK,GACnD;QACA,OAAOd;IACT;IAEA,uEAAuE;IACvE,MAAM,EAAEa,mBAAmB,EAAE,GAAGH;IAEhC,OAAO,IAAIK,MAAMf,QAAkB;QACjCgB,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,yEAAyE;YACzE,iCAAiC;YACjC,IACE,OAAOD,SAAS,YAChBA,QAAQlB,UACRa,oBAAoBO,GAAG,CAACF,OACxB;gBACAhC,2BAA2BwB,uBAAuB,AAAC,YAASQ;YAC9D;YAEA,OAAO/B,eAAe6B,GAAG,CAACC,QAAQC,MAAMC;QAC1C;QACAC,KAAIH,MAAM,EAAEC,IAAI;YACd,IACE,OAAOA,SAAS,YAChBA,QAAQlB,UACRa,oBAAoBO,GAAG,CAACF,OACxB;gBACAhC,2BAA2BwB,uBAAuB,AAAC,YAASQ;YAC9D;YAEA,OAAO/B,eAAeiC,GAAG,CAACH,QAAQC;QACpC;QACAG,SAAQJ,MAAM;YACZ,IAAK,MAAMV,OAAOP,OAAQ;gBACxB,IAAIa,oBAAoBO,GAAG,CAACb,MAAM;oBAChCrB,2BAA2BwB,uBAAuB;gBACpD;YACF;YAEA,OAAOY,QAAQD,OAAO,CAACJ;QACzB;IACF;AACF"}