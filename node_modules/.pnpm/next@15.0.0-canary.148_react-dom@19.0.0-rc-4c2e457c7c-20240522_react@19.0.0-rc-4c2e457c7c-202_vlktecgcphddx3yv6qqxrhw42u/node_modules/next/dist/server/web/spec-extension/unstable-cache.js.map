{"version":3,"sources":["../../../../src/server/web/spec-extension/unstable-cache.ts"],"sourcesContent":["import type { IncrementalCache } from '../../lib/incremental-cache'\n\nimport { CACHE_ONE_YEAR } from '../../../lib/constants'\nimport {\n  addImplicitTags,\n  validateRevalidate,\n  validateTags,\n} from '../../lib/patch-fetch'\nimport { staticGenerationAsyncStorage } from '../../../client/components/static-generation-async-storage.external'\nimport { requestAsyncStorage } from '../../../client/components/request-async-storage.external'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchData,\n} from '../../response-cache'\nimport { prerenderAsyncStorage } from '../../app-render/prerender-async-storage.external'\n\ntype Callback = (...args: any[]) => Promise<any>\n\nlet noStoreFetchIdx = 0\n\nasync function cacheNewResult<T>(\n  result: T,\n  incrementalCache: IncrementalCache,\n  cacheKey: string,\n  tags: string[],\n  revalidate: number | false | undefined,\n  fetchIdx: number,\n  fetchUrl: string\n): Promise<unknown> {\n  await incrementalCache.set(\n    cacheKey,\n    {\n      kind: CachedRouteKind.FETCH,\n      data: {\n        headers: {},\n        // TODO: handle non-JSON values?\n        body: JSON.stringify(result),\n        status: 200,\n        url: '',\n      } satisfies CachedFetchData,\n      revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,\n    },\n    {\n      revalidate,\n      fetchCache: true,\n      tags,\n      fetchIdx,\n      fetchUrl,\n    }\n  )\n  return\n}\n\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */\nexport function unstable_cache<T extends Callback>(\n  cb: T,\n  keyParts?: string[],\n  options: {\n    /**\n     * The revalidation interval in seconds.\n     */\n    revalidate?: number | false\n    tags?: string[]\n  } = {}\n): T {\n  if (options.revalidate === 0) {\n    throw new Error(\n      `Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`\n    )\n  }\n\n  // Validate the tags provided are valid\n  const tags = options.tags\n    ? validateTags(options.tags, `unstable_cache ${cb.toString()}`)\n    : []\n\n  // Validate the revalidate options\n  validateRevalidate(\n    options.revalidate,\n    `unstable_cache ${cb.name || cb.toString()}`\n  )\n\n  // Stash the fixed part of the key at construction time. The invocation key will combine\n  // the fixed key with the arguments when actually called\n  // @TODO if cb.toString() is long we should hash it\n  // @TODO come up with a collision-free way to combine keyParts\n  // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n  // and the error produced by accidentally using something that cannot be safely coerced is likely\n  // hard to debug\n  const fixedKey = `${cb.toString()}-${\n    Array.isArray(keyParts) && keyParts.join(',')\n  }`\n\n  const cachedCb = async (...args: any[]) => {\n    const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n    const requestStore = requestAsyncStorage.getStore()\n\n    // We must be able to find the incremental cache otherwise we throw\n    const maybeIncrementalCache:\n      | import('../../lib/incremental-cache').IncrementalCache\n      | undefined =\n      staticGenerationStore?.incrementalCache ||\n      (globalThis as any).__incrementalCache\n\n    if (!maybeIncrementalCache) {\n      throw new Error(\n        `Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`\n      )\n    }\n    const incrementalCache = maybeIncrementalCache\n\n    const prerenderStore = prerenderAsyncStorage.getStore()\n    const cacheSignal = prerenderStore?.cacheSignal\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    try {\n      // If there's no request store, we aren't in a request (or we're not in app\n      // router)  and if there's no static generation store, we aren't in app\n      // router. Default to an empty pathname and search params when there's no\n      // request store or static generation store available.\n      const pathname =\n        requestStore?.url.pathname ?? staticGenerationStore?.route ?? ''\n      const searchParams = new URLSearchParams(requestStore?.url.search ?? '')\n\n      const sortedSearchKeys = [...searchParams.keys()].sort((a, b) => {\n        return a.localeCompare(b)\n      })\n      const sortedSearch = sortedSearchKeys\n        .map((key) => `${key}=${searchParams.get(key)}`)\n        .join('&')\n\n      // Construct the complete cache key for this function invocation\n      // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n      // the keyspace smaller than the execution space\n      const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n      const cacheKey = await incrementalCache.generateCacheKey(invocationKey)\n      // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n      const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`\n      const fetchIdx =\n        (staticGenerationStore\n          ? staticGenerationStore.nextFetchId\n          : noStoreFetchIdx) ?? 1\n\n      if (staticGenerationStore) {\n        staticGenerationStore.nextFetchId = fetchIdx + 1\n\n        // We are in an App Router context. We try to return the cached entry if it exists and is valid\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        // We update the store's revalidate property if the option.revalidate is a higher precedence\n        if (typeof options.revalidate === 'number') {\n          if (\n            typeof staticGenerationStore.revalidate === 'number' &&\n            staticGenerationStore.revalidate < options.revalidate\n          ) {\n            // The store is already revalidating on a shorter time interval, leave it alone\n          } else {\n            staticGenerationStore.revalidate = options.revalidate\n          }\n        } else if (\n          options.revalidate === false &&\n          typeof staticGenerationStore.revalidate === 'undefined'\n        ) {\n          // The store has not defined revalidate type so we can use the false option\n          staticGenerationStore.revalidate = options.revalidate\n        }\n\n        // We need to accumulate the tags for this invocation within the store\n        if (!staticGenerationStore.tags) {\n          staticGenerationStore.tags = tags.slice()\n        } else {\n          for (const tag of tags) {\n            // @TODO refactor tags to be a set to avoid this O(n) lookup\n            if (!staticGenerationStore.tags.includes(tag)) {\n              staticGenerationStore.tags.push(tag)\n            }\n          }\n        }\n        // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n        // of this function is potentially a little confusing\n        const implicitTags = addImplicitTags(\n          staticGenerationStore,\n          requestStore\n        )\n\n        if (\n          // when we are nested inside of other unstable_cache's\n          // we should bypass cache similar to fetches\n          staticGenerationStore.fetchCache !== 'force-no-store' &&\n          !staticGenerationStore.isOnDemandRevalidate &&\n          !incrementalCache.isOnDemandRevalidate &&\n          !staticGenerationStore.isDraftMode\n        ) {\n          // We attempt to get the current cache entry from the incremental cache.\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            softTags: implicitTags,\n            fetchIdx,\n            fetchUrl,\n            isFallback: false,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else {\n              // We have a valid cache entry so we will be returning it. We also check to see if we need\n              // to background revalidate it by checking if it is stale.\n              const cachedResponse =\n                cacheEntry.value.data.body !== undefined\n                  ? JSON.parse(cacheEntry.value.data.body)\n                  : undefined\n              if (cacheEntry.isStale) {\n                // In App Router we return the stale result and revalidate in the background\n                if (!staticGenerationStore.pendingRevalidates) {\n                  staticGenerationStore.pendingRevalidates = {}\n                }\n                // We run the cache function asynchronously and save the result when it completes\n                staticGenerationStore.pendingRevalidates[invocationKey] =\n                  staticGenerationAsyncStorage\n                    .run(\n                      {\n                        ...staticGenerationStore,\n                        // force any nested fetches to bypass cache so they revalidate\n                        // when the unstable_cache call is revalidated\n                        fetchCache: 'force-no-store',\n                        isUnstableCacheCallback: true,\n                      },\n                      cb,\n                      ...args\n                    )\n                    .then((result) => {\n                      return cacheNewResult(\n                        result,\n                        incrementalCache,\n                        cacheKey,\n                        tags,\n                        options.revalidate,\n                        fetchIdx,\n                        fetchUrl\n                      )\n                    })\n                    // @TODO This error handling seems wrong. We swallow the error?\n                    .catch((err) =>\n                      console.error(\n                        `revalidating cache with key: ${invocationKey}`,\n                        err\n                      )\n                    )\n              }\n              // We had a valid cache entry so we return it here\n              return cachedResponse\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        const result = await staticGenerationAsyncStorage.run(\n          {\n            ...staticGenerationStore,\n            // force any nested fetches to bypass cache so they revalidate\n            // when the unstable_cache call is revalidated\n            fetchCache: 'force-no-store',\n            isUnstableCacheCallback: true,\n          },\n          cb,\n          ...args\n        )\n\n        if (!staticGenerationStore.isDraftMode) {\n          cacheNewResult(\n            result,\n            incrementalCache,\n            cacheKey,\n            tags,\n            options.revalidate,\n            fetchIdx,\n            fetchUrl\n          )\n        }\n\n        return result\n      } else {\n        noStoreFetchIdx += 1\n        // We are in Pages Router or were called outside of a render. We don't have a store\n        // so we just call the callback directly when it needs to run.\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        if (!incrementalCache.isOnDemandRevalidate) {\n          // We aren't doing an on demand revalidation so we check use the cache if valid\n\n          // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n          // of this function is potentially a little confusing\n          const implicitTags =\n            staticGenerationStore &&\n            addImplicitTags(staticGenerationStore, requestStore)\n\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            fetchIdx,\n            fetchUrl,\n            softTags: implicitTags,\n            isFallback: false,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else if (!cacheEntry.isStale) {\n              // We have a valid cache entry and it is fresh so we return it\n              return cacheEntry.value.data.body !== undefined\n                ? JSON.parse(cacheEntry.value.data.body)\n                : undefined\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        // @TODO this storage wrapper is included here because it existed prior to the latest refactor\n        // however it is incorrect logic because it causes any internal cache calls to follow the App Router\n        // path rather than Pages router path. This may mean there is existing buggy behavior however no specific\n        // issues are known at this time. The whole static generation storage pathways should be reworked\n        // to allow tracking which \"mode\" we are in without the presence of a store or not. For now I have\n        // maintained the existing behavior to limit the impact of the current refactor\n        const result = await staticGenerationAsyncStorage.run(\n          // We are making a fake store that is useful for scoping fetchCache: 'force-no-store' and isUnstableCacheCallback: true\n          // The fact that we need to construct this kind of fake store indicates the code is not factored correctly\n          // @TODO refactor to not require this fake store object\n          {\n            // force any nested fetches to bypass cache so they revalidate\n            // when the unstable_cache call is revalidated\n            fetchCache: 'force-no-store',\n            isUnstableCacheCallback: true,\n            route: '/',\n            page: '/',\n            isStaticGeneration: false,\n            fallbackRouteParams: null,\n          },\n          cb,\n          ...args\n        )\n        cacheNewResult(\n          result,\n          incrementalCache,\n          cacheKey,\n          tags,\n          options.revalidate,\n          fetchIdx,\n          fetchUrl\n        )\n        return result\n      }\n    } finally {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n    }\n  }\n  // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n  return cachedCb as unknown as T\n}\n"],"names":["unstable_cache","noStoreFetchIdx","cacheNewResult","result","incrementalCache","cacheKey","tags","revalidate","fetchIdx","fetchUrl","set","kind","CachedRouteKind","FETCH","data","headers","body","JSON","stringify","status","url","CACHE_ONE_YEAR","fetchCache","cb","keyParts","options","Error","toString","validateTags","validateRevalidate","name","fixedKey","Array","isArray","join","cachedCb","args","staticGenerationStore","staticGenerationAsyncStorage","getStore","requestStore","requestAsyncStorage","maybeIncrementalCache","globalThis","__incrementalCache","prerenderStore","prerenderAsyncStorage","cacheSignal","beginRead","pathname","route","searchParams","URLSearchParams","search","sortedSearchKeys","keys","sort","a","b","localeCompare","sortedSearch","map","key","get","invocationKey","generateCacheKey","length","nextFetchId","slice","tag","includes","push","implicitTags","addImplicitTags","isOnDemandRevalidate","isDraftMode","cacheEntry","IncrementalCacheKind","softTags","isFallback","value","console","error","cachedResponse","undefined","parse","isStale","pendingRevalidates","run","isUnstableCacheCallback","then","catch","err","page","isStaticGeneration","fallbackRouteParams","endRead"],"mappings":"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"}