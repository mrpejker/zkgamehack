{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  FlightSegmentPath,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n} from './types'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { RequestStore } from '../../client/components/request-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { Revalidate } from '../lib/revalidate'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  createMetadataComponents,\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata'\nimport { withRequestStore } from '../async-storage/with-request-store'\nimport { withStaticGenerationStore } from '../async-storage/with-static-generation-store'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport {\n  getURLFromRedirectError,\n  isRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { addImplicitTags } from '../lib/patch-fetch'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport {\n  getTracedMetadata,\n  makeGetServerInsertedHTML,\n} from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  isRenderInterruptedReason,\n  createDynamicTrackingState,\n  getFirstDynamicReason,\n  type DynamicTrackingState,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../shared/lib/router/action-queue'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../../client/components/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  type ReactServerPrerenderResolveToType,\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n} from '../app-render/app-render-prerender-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  prerenderAsyncStorage,\n  type PrerenderStore,\n} from './prerender-async-storage.external'\nimport { CacheSignal } from './cache-signal'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppRenderContext = {\n  staticGenerationStore: StaticGenerationStore\n  requestStore: RequestStore\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  defaultRevalidate: Revalidate\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isRoutePPREnabled: boolean\n}\n\nconst flightDataPathHeadKey = 'h'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isPrefetchRequest =\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  const isRSCRequest = headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    nonce,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\nexport type CreateSegmentPath = (child: FlightSegmentPath) => FlightSegmentPath\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({ ctx }: { ctx: AppRenderContext }) {\n  const is404Page = ctx.pagePath === '/404'\n  const isInvalidStatusCode =\n    typeof ctx.res.statusCode === 'number' && ctx.res.statusCode > 400\n\n  if (is404Page || isInvalidStatusCode) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    requestStore: { url },\n    query,\n    requestId,\n    flightRouterState,\n    staticGenerationStore,\n  } = ctx\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const [MetadataTree, getMetadataReady] = createMetadataComponents({\n      tree: loaderTree,\n      query,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        staticGenerationStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n    })\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        createSegmentPath: (child) => child,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        isFirst: true,\n        // For flight, render metadata inside leaf page\n        rscPayloadHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            <NonIndex ctx={ctx} />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <MetadataTree key={requestId} />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getMetadataReady,\n        preloadCallbacks,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.renderOpts.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.renderOpts.buildId,\n    f: flightData,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    routeType: ctx.isAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.staticGenerationStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const rscPayload = await generateDynamicRSCPayload(ctx, options)\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = ctx.componentMod.renderToReadableStream(\n    rscPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      nonce: ctx.nonce,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.staticGenerationStore.fetchMetrics,\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n    },\n    requestStore: { url },\n    staticGenerationStore,\n  } = ctx\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  const [MetadataTree, getMetadataReady] = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    query,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      staticGenerationStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n    createDynamicallyTrackedParams,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    createSegmentPath: (child) => child,\n    loaderTree: tree,\n    parentParams: {},\n    firstItem: true,\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={ctx.requestId} />\n    </React.Fragment>\n  )\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [[initialTree, seedData, initialHead]],\n    m: missingSlots,\n    G: GlobalError,\n    s: typeof ctx.renderOpts.postponed === 'string',\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  errorType: 'not-found' | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createDynamicallyTrackedSearchParams,\n      createDynamicallyTrackedParams,\n    },\n    requestStore: { url },\n    requestId,\n  } = ctx\n\n  const [MetadataTree] = createMetadataComponents({\n    tree,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    query,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n    createDynamicallyTrackedParams,\n  })\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={requestId} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const initialSeedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head></head>\n      <body></body>\n    </html>,\n    {},\n    null,\n  ]\n\n  return {\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [[initialTree, initialSeedData, initialHead]],\n    G: GlobalError,\n    s: typeof ctx.renderOpts.postponed === 'string',\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n  ServerInsertedHTMLProvider,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    buildId: response.b,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    // location and initialParallelRoutes are not initialized in the SSR render\n    // they are set to an empty map and window.location, respectively during hydration\n    initialParallelRoutes: null!,\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedHTMLProvider>\n        <AppRouter\n          actionQueue={actionQueue}\n          globalErrorComponent={response.G}\n          assetPrefix={response.p}\n        />\n      </ServerInsertedHTMLProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction AppWithoutContext<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    buildId: response.b,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    // location and initialParallelRoutes are not initialized in the SSR render\n    // they are set to an empty map and window.location, respectively during hydration\n    initialParallelRoutes: null!,\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  return (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorComponent={response.G}\n      assetPrefix={response.p}\n    />\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  requestStore: RequestStore,\n  staticGenerationStore: StaticGenerationStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    // @ts-ignore\n    globalThis.__next_chunk_load__ = (...args: Array<any>) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setAppIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      const staticGenStore =\n        ComponentMod.staticGenerationAsyncStorage.getStore()\n      const prerenderStore = prerenderAsyncStorage.getStore()\n      const isPPR = !!prerenderStore?.dynamicTracking?.dynamicAccesses?.length\n\n      if (\n        process.env.NODE_ENV === 'development' &&\n        staticGenStore &&\n        renderOpts.setAppIsrStatus &&\n        !isPPR\n      ) {\n        // only node can be ISR so we only need to update the status here\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        let { revalidate } = staticGenStore\n        if (typeof revalidate === 'undefined') {\n          revalidate = false\n        }\n        if (revalidate === false || revalidate > 0) {\n          renderOpts.setAppIsrStatus(pathname, revalidate)\n        }\n      }\n\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({\n    serverActionsManifest,\n    pageName: renderOpts.page,\n  })\n\n  setReferenceManifestsSingleton({\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  staticGenerationStore.fetchMetrics = []\n  metadata.fetchMetrics = staticGenerationStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const { flightRouterState, isPrefetchRequest, isRSCRequest, nonce } =\n    parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = staticGenerationStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isActionRequest = getServerActionRequestMetadata(req).isServerAction\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    renderOpts,\n    requestStore,\n    staticGenerationStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isAction: isActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    defaultRevalidate: false,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n  }\n\n  getTracer().getRootSpanAttributes()?.set('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    let response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      staticGenerationStore,\n      loaderTree\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicTracking &&\n      accessedDynamicData(response.dynamicTracking) &&\n      response.dynamicTracking.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicTracking)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (staticGenerationStore.pendingRevalidates) {\n      options.waitUntil = Promise.all([\n        staticGenerationStore.incrementalCache?.revalidateTag(\n          staticGenerationStore.revalidatedTags || []\n        ),\n        ...Object.values(staticGenerationStore.pendingRevalidates || {}),\n      ])\n    }\n\n    addImplicitTags(staticGenerationStore, requestStore)\n\n    if (staticGenerationStore.tags) {\n      metadata.fetchTags = staticGenerationStore.tags.join(',')\n    }\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (staticGenerationStore.forceStatic === false) {\n      staticGenerationStore.revalidate = 0\n    }\n\n    // Copy the revalidation value onto the render result metadata.\n    metadata.revalidate =\n      staticGenerationStore.revalidate ?? ctx.defaultRevalidate\n\n    // provide bailout info for debugging\n    if (metadata.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: staticGenerationStore.dynamicUsageDescription,\n        stack: staticGenerationStore.dynamicUsageStack,\n      }\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        staticGenerationStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            req,\n            res,\n            ctx,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (staticGenerationStore.pendingRevalidates) {\n      options.waitUntil = Promise.all([\n        staticGenerationStore.incrementalCache?.revalidateTag(\n          staticGenerationStore.revalidatedTags || []\n        ),\n        ...Object.values(staticGenerationStore.pendingRevalidates || {}),\n      ])\n    }\n\n    addImplicitTags(staticGenerationStore, requestStore)\n\n    if (staticGenerationStore.tags) {\n      metadata.fetchTags = staticGenerationStore.tags.join(',')\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n  })\n\n  const { isHmrRefresh } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n      throw new Error(\n        'Invariant: postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  return withRequestStore(\n    renderOpts.ComponentMod.requestAsyncStorage,\n    {\n      req,\n      url,\n      res,\n      renderOpts,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n    },\n    (requestStore) =>\n      withStaticGenerationStore(\n        renderOpts.ComponentMod.staticGenerationAsyncStorage,\n        {\n          page: renderOpts.routeModule.definition.page,\n          fallbackRouteParams,\n          renderOpts,\n          requestEndedState,\n        },\n        (staticGenerationStore) =>\n          renderToHTMLOrFlightImpl(\n            req,\n            res,\n            pagePath,\n            query,\n            renderOpts,\n            requestStore,\n            staticGenerationStore,\n            parsedRequestHeaders,\n            requestEndedState,\n            postponedState\n          )\n      )\n  )\n}\n\nasync function renderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n\n  try {\n    // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n    const RSCPayload = await getRSCPayload(tree, ctx, res.statusCode === 404)\n    reactServerResult = new ReactServerResult(\n      ComponentMod.renderToReadableStream(\n        RSCPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: serverComponentsErrorHandler,\n          nonce: ctx.nonce,\n        }\n      )\n    )\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await resume(\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={ctx.nonce}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await renderToReadableStream(\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            setHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        // When debugging the static shell, client-side rendering should be\n        // disabled to prevent blanking out the page.\n        bootstrapScripts: renderOpts.isDebugStaticShell\n          ? []\n          : [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML = renderOpts.supportsDynamicResponse !== true\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      serverInsertedHTMLToHead: true,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    if (isNotFoundError(err)) {\n      res.statusCode = 404\n    }\n    let hasRedirectError = false\n    if (isRedirectError(err)) {\n      hasRedirectError = true\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      if (err.mutableCookies) {\n        const headers = new Headers()\n\n        // If there were mutable cookies set, we need to set them on the\n        // response.\n        if (appendMutableCookies(headers, err.mutableCookies)) {\n          setHeader('set-cookie', Array.from(headers.values()))\n        }\n      }\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n      setHeader('Location', redirectUrl)\n    }\n\n    const is404 = res.statusCode === 404\n    if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const errorType = is404\n      ? 'not-found'\n      : hasRedirectError\n        ? 'redirect'\n        : undefined\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await getErrorRSCPayload(tree, ctx, errorType)\n\n    const errorServerStream = ComponentMod.renderToReadableStream(\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n        nonce: ctx.nonce,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <AppWithoutContext\n            reactServerStream={errorServerStream}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={ctx.nonce}\n          />\n        ),\n        streamOptions: {\n          nonce: ctx.nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML = renderOpts.supportsDynamicResponse !== true\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        serverInsertedHTMLToHead: true,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (process.env.NODE_ENV === 'development' && isNotFoundError(finalErr)) {\n        const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n          require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n        bailOnNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicTracking?: null | DynamicTrackingState\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(\n  staticGenerationStore: StaticGenerationStore\n): boolean {\n  const { fallbackRouteParams, isStaticGeneration } = staticGenerationStore\n  if (!isStaticGeneration) return false\n\n  if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n    return false\n  }\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  staticGenerationStore: StaticGenerationStore,\n  tree: LoaderTree\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = staticGenerationStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let dynamicTracking: null | DynamicTrackingState = null\n  let reactServerPrerenderResult: null | ReactServerPrerenderResult = null\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n\n    return res\n  }\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        const PRERENDER_COMPLETE = 'NEXT_PRERENDER_COMPLETE'\n        const abortReason = new Error(PRERENDER_COMPLETE)\n\n        const cacheSignal = new CacheSignal()\n        const prospectiveRenderPrerenderStore: PrerenderStore = {\n          cacheSignal,\n          // During the prospective render we don't want to synchronously abort on dynamic access\n          // because it could prevent us from discovering all caches in siblings. So we omit the controller\n          // from the prerender store this time.\n          controller: null,\n          // With PPR during Prerender we don't need to track individual dynamic reasons\n          // because we will always do a final render after caches have filled and we\n          // will track it again there\n          dynamicTracking: null,\n        }\n\n        let flightController = new AbortController()\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await getRSCPayload(\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        function voidOnError() {}\n        ;(\n          prerenderAsyncStorage.run(\n            // The store to scope\n            prospectiveRenderPrerenderStore,\n            // The function to run\n            ComponentMod.prerender,\n            // ... the arguments for the function to run\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              nonce: ctx.nonce,\n              // This render will be thrown away so we don't need to track errors or postpones\n              onError: voidOnError,\n              onPostpone: undefined,\n              // we don't care to track postpones during the prospective render because we need\n              // to always do a final render anyway\n              signal: flightController.signal,\n            }\n          ) as Promise<ReactServerPrerenderResolveToType>\n        ).catch(() => {})\n\n        // When this resolves the cache has no inflight reads and we can ascertain the dynamic outcome\n        await cacheSignal.cacheReady()\n        flightController.abort(abortReason)\n        // When PPR is enabled we don't synchronously abort the render when performing a prospective render\n        // because it might prevent us from discovering all caches during the render which is essential\n        // when we perform the second single-task render.\n\n        // Reset the dynamic IO state for the final render\n        flightController = new AbortController()\n        dynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = {\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          // During the final render we do want to abort synchronously on dynamic access so we\n          // include the flight controller in the store.\n          controller: flightController,\n          dynamicTracking,\n        }\n\n        let reactServerIsDynamic = false\n        function onError(err: unknown, errorInfo: ErrorInfo) {\n          if (err === abortReason || isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return\n          }\n\n          return serverComponentsErrorHandler(err, errorInfo)\n        }\n\n        function onPostpone(reason: string) {\n          if (\n            reason === PRERENDER_COMPLETE ||\n            isRenderInterruptedReason(reason)\n          ) {\n            reactServerIsDynamic = true\n          }\n        }\n        const finalAttemptRSCPayload = await getRSCPayload(\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              () =>\n                prerenderAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    nonce: ctx.nonce,\n                    onError,\n                    onPostpone,\n                    signal: flightController.signal,\n                  }\n                ),\n              () => {\n                flightController.abort(abortReason)\n              }\n            )\n          ))\n\n        await warmFlightResponse(\n          reactServerResult.asStream(),\n          clientReferenceManifest\n        )\n\n        const SSRController = new AbortController()\n        const ssrPrerenderStore: PrerenderStore = {\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          // We expect the SSR render to complete in a single Task and need to be able to synchronously abort\n          // When you use APIs that are considered dynamic or synchronous IO.\n          controller: SSRController,\n          // We do track dynamic access because searchParams and certain hooks can still be\n          // dynamic during SSR\n          dynamicTracking,\n        }\n        let SSRIsDynamic = false\n        function SSROnError(err: unknown, errorInfo: unknown) {\n          if (err === abortReason || isPrerenderInterruptedError(err)) {\n            SSRIsDynamic = true\n            return\n          }\n\n          return htmlRendererErrorHandler(err, errorInfo)\n        }\n\n        function SSROnPostpone(reason: string) {\n          if (\n            reason === PRERENDER_COMPLETE ||\n            isRenderInterruptedReason(reason)\n          ) {\n            SSRIsDynamic = true\n          }\n        }\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        const { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n          () =>\n            prerenderAsyncStorage.run(\n              ssrPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={ctx.nonce}\n              />,\n              {\n                signal: SSRController.signal,\n                onError: SSROnError,\n                onPostpone: SSROnPostpone,\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    setHeader(key, value)\n                  })\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                // When debugging the static shell, client-side rendering should be\n                // disabled to prevent blanking out the page.\n                bootstrapScripts: renderOpts.isDebugStaticShell\n                  ? []\n                  : [bootstrapScript],\n              }\n            ),\n          () => {\n            SSRController.abort(abortReason)\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n\n        if (SSRIsDynamic || reactServerIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = getDynamicDataPostponedState()\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n            }),\n            dynamicTracking,\n          }\n        } else {\n          // Static case\n          if (staticGenerationStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={ctx.nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce: ctx.nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                ctx.nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n            }),\n            dynamicTracking,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = staticGenerationStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        const PRERENDER_COMPLETE = 'NEXT_PRERENDER_COMPLETE'\n        const abortReason = new Error(PRERENDER_COMPLETE)\n\n        // We need to scope the dynamic IO state per render because we don't want to leak\n        // details between the prospective render and the final render\n        let flightController = new AbortController()\n\n        let reactServerIsDynamic = false\n        function onError(err: unknown, errorInfo: ErrorInfo) {\n          if (err === abortReason || isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return\n          }\n\n          return serverComponentsErrorHandler(err, errorInfo)\n        }\n\n        dynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const cacheSignal = new CacheSignal()\n        const prospectiveRenderPrerenderStore: PrerenderStore = {\n          cacheSignal,\n          // When PPR is off we can synchronously abort the prospective render because we will\n          // always hit this path on the final render and thus we can skip the final render and just\n          // consider the route dynamic.\n          controller: flightController,\n          dynamicTracking,\n        }\n\n        const firstAttemptRSCPayload = await getRSCPayload(\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        ;(\n          prerenderAsyncStorage.run(\n            // The store to scope\n            prospectiveRenderPrerenderStore,\n            // The function to run\n            ComponentMod.prerender,\n            // ... the arguments for the function to run\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              nonce: ctx.nonce,\n              onError,\n              signal: flightController.signal,\n            }\n          ) as Promise<ReactServerPrerenderResolveToType>\n        ).catch(() => {})\n\n        // When this resolves the cache has no inflight reads and we can ascertain the dynamic outcome\n        await cacheSignal.cacheReady()\n        if (reactServerIsDynamic) {\n          // During a prospective render the only dynamic thing that can happen is a synchronous dynamic\n          // API access. We expect to have a tracked expression to use for our dynamic error but we fall back\n          // to a generic error if we don't.\n          const dynamicReason = getFirstDynamicReason(dynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route ${staticGenerationStore.route} couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n            )\n          } else {\n            console.error(\n              'Expected Next.js to keep track of reason for opting out of static rendering but one was not found. This is a bug in Next.js'\n            )\n            throw new DynamicServerError(\n              `Route ${staticGenerationStore.route} couldn't be rendered statically because it used a dynamic API. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n            )\n          }\n        } else {\n          // The render didn't explicitly use any Dynamic APIs but it might have IO so we need to retry\n          // the render. We abort the current render here to avoid doing unecessary work.\n          // Keep in mind that while the render is aborted, inflight async ServerComponents can still continue\n          // and might call dynamic APIs.\n          flightController.abort(abortReason)\n        }\n\n        // Reset the prerenderState because we are going to retry the render\n        flightController = new AbortController()\n        dynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        reactServerIsDynamic = false\n\n        const finalRenderPrerenderStore: PrerenderStore = {\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          controller: flightController,\n          dynamicTracking,\n        }\n\n        const finalAttemptRSCPayload = await getRSCPayload(\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              () =>\n                prerenderAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    nonce: ctx.nonce,\n                    onError,\n                    signal: flightController.signal,\n                  }\n                ),\n              () => {\n                flightController.abort(abortReason)\n              }\n            )\n          ))\n\n        if (reactServerIsDynamic) {\n          // There was unfinished work after we aborted after the first render Task. This means there is some IO\n          // that is not covered by a cache and we need to bail out of static generation.\n          const err = new DynamicServerError(\n            `Route ${staticGenerationStore.route} couldn't be rendered statically because it used IO that was not cached in a Server Component. See more info here: https://nextjs.org/docs/messages/dynamic-io`\n          )\n          serverComponentsErrorHandler(err, {})\n          throw err\n        }\n\n        await warmFlightResponse(\n          reactServerResult.asStream(),\n          clientReferenceManifest\n        )\n\n        const SSRController = new AbortController()\n        const ssrPrerenderStore: PrerenderStore = {\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          // We expect the SSR render to complete in a single Task and need to be able to synchronously abort\n          // When you use APIs that are considered dynamic or synchronous IO.\n          controller: SSRController,\n          // We do track dynamic access because searchParams and certain hooks can still be\n          // dynamic during SSR\n          dynamicTracking,\n        }\n        let SSRIsDynamic = false\n        function SSROnError(err: unknown, errorInfo: unknown) {\n          if (err === abortReason || isPrerenderInterruptedError(err)) {\n            SSRIsDynamic = true\n            return\n          }\n\n          return htmlRendererErrorHandler(err, errorInfo)\n        }\n        function SSROnPostpone(_: string) {\n          // We don't really support postponing when PPR is off but since experimental react\n          // has this API enabled we need to account for it. For now we'll just treat any postpone\n          // as dynamic.\n          SSRIsDynamic = true\n          return\n        }\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        const { prelude: htmlStream } =\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              prerenderAsyncStorage.run(\n                ssrPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={reactServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: SSRController.signal,\n                  onError: SSROnError,\n                  onPostpone: SSROnPostpone,\n                  // When debugging the static shell, client-side rendering should be\n                  // disabled to prevent blanking out the page.\n                  bootstrapScripts: renderOpts.isDebugStaticShell\n                    ? []\n                    : [bootstrapScript],\n                }\n              ),\n            () => {\n              SSRController.abort(abortReason)\n            }\n          )\n\n        if (SSRIsDynamic) {\n          // Something dynamic happened in the SSR phase of the render. This could be IO or it could be\n          // a dynamic API like accessing searchParams in a client Page\n          const dynamicReason = getFirstDynamicReason(dynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route ${staticGenerationStore.route} couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route ${staticGenerationStore.route} couldn't be rendered statically because it used IO that was not cached in a Client Component. See more info here: https://nextjs.org/docs/messages/dynamic-io`\n            )\n          }\n        }\n\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            serverInsertedHTMLToHead: true,\n            validateRootLayout,\n          }),\n          dynamicTracking,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n      const reactServerPrerenderStore = {\n        cacheSignal: null,\n        controller: null,\n        dynamicTracking,\n      }\n      const RSCPayload = await getRSCPayload(tree, ctx, res.statusCode === 404)\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          prerenderAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        cacheSignal: null,\n        controller: null,\n        dynamicTracking,\n      }\n\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await prerenderAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              setHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          // When debugging the static shell, client-side rendering should be\n          // disabled to prevent blanking out the page.\n          bootstrapScripts: renderOpts.isDebugStaticShell\n            ? []\n            : [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(staticGenerationStore)) {\n        metadata.flightData = flightData\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = getDynamicDataPostponedState()\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n          }),\n          dynamicTracking,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = getDynamicDataPostponedState()\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n          }),\n          dynamicTracking,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (staticGenerationStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={ctx.nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n          }),\n          dynamicTracking,\n        }\n      }\n    } else {\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await getRSCPayload(tree, ctx, res.statusCode === 404)\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await renderToReadableStream(\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce: ctx.nonce,\n          // When debugging the static shell, client-side rendering should be\n          // disabled to prevent blanking out the page.\n          bootstrapScripts: renderOpts.isDebugStaticShell\n            ? []\n            : [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(staticGenerationStore)) {\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          serverInsertedHTMLToHead: true,\n        }),\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    if (isNotFoundError(err)) {\n      res.statusCode = 404\n    }\n    let hasRedirectError = false\n    if (isRedirectError(err)) {\n      hasRedirectError = true\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      if (err.mutableCookies) {\n        const headers = new Headers()\n\n        // If there were mutable cookies set, we need to set them on the\n        // response.\n        if (appendMutableCookies(headers, err.mutableCookies)) {\n          setHeader('set-cookie', Array.from(headers.values()))\n        }\n      }\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n      setHeader('Location', redirectUrl)\n    }\n\n    const is404 = res.statusCode === 404\n    if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    if (reactServerPrerenderResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    const errorType = is404\n      ? 'not-found'\n      : hasRedirectError\n        ? 'redirect'\n        : undefined\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await getErrorRSCPayload(tree, ctx, errorType)\n\n    const errorServerStream = ComponentMod.renderToReadableStream(\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n        nonce: ctx.nonce,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <AppWithoutContext\n            reactServerStream={errorServerStream}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={ctx.nonce}\n          />\n        ),\n        streamOptions: {\n          nonce: ctx.nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(staticGenerationStore)) {\n        metadata.flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            // This is intentionally using the readable datastream from the\n            // main render rather than the flight data from the error page\n            // render\n            reactServerPrerenderResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          serverInsertedHTMLToHead: true,\n          validateRootLayout,\n        }),\n        dynamicTracking,\n      }\n    } catch (finalErr: any) {\n      if (process.env.NODE_ENV === 'development' && isNotFoundError(finalErr)) {\n        const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n          require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n        bailOnNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: BinaryStreamOf<any>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  let createFromReadableStream\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  try {\n    createFromReadableStream(flightStream, {\n      ssrManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n"],"names":["renderToHTMLOrFlight","warmFlightResponse","flightDataPathHeadKey","parseRequestHeaders","headers","options","isPrefetchRequest","NEXT_ROUTER_PREFETCH_HEADER","toLowerCase","undefined","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","isRSCRequest","RSC_HEADER","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE_HEADER","csp","nonce","getScriptNonceFromHeader","createNotFoundLoaderTree","loaderTree","components","children","PAGE_SEGMENT_KEY","page","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","getSegmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","dynamicParamTypes","treeSegment","split","slice","flatMap","pathSegment","parseParameter","join","getShortDynamicParamType","NonIndex","ctx","is404Page","isInvalidStatusCode","res","statusCode","meta","name","content","generateDynamicRSCPayload","flightData","componentMod","tree","createDynamicallyTrackedSearchParams","createDynamicallyTrackedParams","appUsingSizeAdjustment","requestStore","url","query","requestId","staticGenerationStore","skipFlight","preloadCallbacks","MetadataTree","getMetadataReady","createMetadataComponents","metadataContext","createTrackedMetadataContext","pathname","renderOpts","walkTreeWithFlightRouterState","createSegmentPath","child","loaderTreeToFilter","parentParams","isFirst","rscPayloadHead","React","Fragment","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","buildId","createErrorContext","renderSource","routerKind","routePath","routeType","isAction","revalidateReason","getRevalidateReason","generateDynamicFlightRenderResult","req","onFlightDataRenderError","err","onInstrumentationRequestError","onError","createFlightReactServerErrorHandler","dev","rscPayload","flightReadableStream","renderToReadableStream","clientReferenceManifest","clientModules","FlightRenderResult","fetchMetrics","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","process","env","NODE_ENV","GlobalError","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","createComponentTree","firstItem","varyHeader","getHeader","couldBeIntercepted","includes","NEXT_URL","initialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","createMetadataContext","initialSeedData","html","id","head","body","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","response","use","useFlightStream","initialState","createInitialRouterState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","location","actionQueue","createMutableActionQueue","HeadManagerContext","require","Provider","appDir","AppRouter","globalErrorComponent","AppWithoutContext","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","getTracer","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","wrapClientComponentLoader","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setAppIsrStatus","NEXT_RUNTIME","isNodeNextRequest","originalRequest","on","prerenderStore","staticGenStore","staticGenerationAsyncStorage","getStore","prerenderAsyncStorage","isPPR","dynamicTracking","dynamicAccesses","length","revalidate","ended","metrics","getClientComponentLoaderMetrics","reset","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","createServerModuleMap","pageName","setReferenceManifestsSingleton","patchFetch","taintObjectReference","stripInternalQueries","crypto","randomUUID","nanoid","isStaticGeneration","isActionRequest","getServerActionRequestMetadata","isServerAction","isPrefetch","defaultRevalidate","getRootSpanAttributes","set","prerenderToStreamWithTracing","wrap","AppRenderSpan","getBodyResult","spanName","prerenderToStream","accessedDynamicData","isDebugDynamicAccesses","warn","access","formatDynamicAPIAccesses","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","find","isUserLandError","pendingRevalidates","waitUntil","Promise","all","incrementalCache","revalidateTag","revalidatedTags","Object","addImplicitTags","tags","fetchTags","forceStatic","staticBailoutInfo","description","dynamicUsageDescription","stack","dynamicUsageStack","RenderResult","streamToString","stream","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","handleAction","generateFlight","notFoundLoaderTree","result","assignMetadata","serverComponentsHmrCache","Error","parseRelativeUrl","experimental","parsePostponedState","withRequestStore","requestAsyncStorage","withStaticGenerationStore","routeModule","definition","renderServerInsertedHTML","createServerInsertedHTML","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","getRequiredScripts","reactServerErrorsByDigest","Map","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","createHTMLReactServerErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","createHTMLErrorHandler","reactServerResult","setHeader","bind","RSCPayload","ReactServerResult","waitAtLeastOneReactRenderTask","DynamicState","DATA","inlinedReactServerDataStream","createInlinedDataReadableStream","tee","chainStreams","createDocumentClosingStream","getPostponedFromState","resume","htmlStream","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","basePath","continueDynamicHTMLResume","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","isDebugStaticShell","generateStaticHTML","supportsDynamicResponse","validateRootLayout","continueFizzStream","serverInsertedHTMLToHead","isStaticGenBailoutError","message","shouldBailoutToCSR","isBailoutToCSRError","getStackWithoutErrorMessage","error","reason","isNotFoundError","hasRedirectError","isRedirectError","getRedirectStatusCodeFromError","mutableCookies","Headers","appendMutableCookies","from","redirectUrl","addPathPrefix","getURLFromRedirectError","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnNotFound","shouldGenerateStaticFlightData","reactServerPrerenderResult","dynamicIO","PRERENDER_COMPLETE","abortReason","cacheSignal","CacheSignal","prospectiveRenderPrerenderStore","controller","flightController","AbortController","firstAttemptRSCPayload","voidOnError","run","prerender","onPostpone","signal","catch","cacheReady","abort","createDynamicTrackingState","finalRenderPrerenderStore","reactServerIsDynamic","errorInfo","isPrerenderInterruptedError","isRenderInterruptedReason","finalAttemptRSCPayload","createReactServerPrerenderResult","prerenderAndAbortInSequentialTasks","asStream","SSRController","ssrPrerenderStore","SSRIsDynamic","SSROnError","SSROnPostpone","prelude","asUnclosingStream","streamToBuffer","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","forceDynamic","StaticGenBailoutError","foreverStream","ReadableStream","resumeStream","JSON","parse","stringify","createPostponedAbortSignal","continueStaticPrerender","consumeAsStream","cache","dynamicReason","getFirstDynamicReason","DynamicServerError","route","console","_","reactServerPrerenderStore","createReactServerPrerenderResultFromRender","isDynamicServerError","loadingChunks","chunkListeners","load","add","finally","delete","flightStream","createFromReadableStream","TURBOPACK","ssrManifest","moduleLoading","moduleMap","ssrModuleMapping","r","push"],"mappings":"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"}