{"version":3,"sources":["../../../src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import stringHash from 'next/dist/compiled/string-hash'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype ErrorHandler = (err: unknown, errorInfo: unknown) => string | undefined\n\nexport type DigestedError = Error & { digest: string }\n\nexport function createFlightReactServerErrorHandler(\n  dev: boolean,\n  onReactServerRenderError: (err: any) => void\n): ErrorHandler {\n  return (err: any, errorInfo: any) => {\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(\n        err.message + (errorInfo?.stack || err.stack || '')\n      ).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(err)) return\n\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(err)) return err.digest\n\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(err)) return err.digest\n\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(err)) return err.digest\n\n    // Format server errors in development to add more helpful error messages\n    if (dev) {\n      formatServerError(err)\n    }\n\n    // Record exception in an active span, if available.\n    const span = getTracer().getActiveScopeSpan()\n    if (span) {\n      span.recordException(err)\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      })\n    }\n\n    onReactServerRenderError(err)\n\n    return err.digest\n  }\n}\n\nexport function createHTMLReactServerErrorHandler(\n  dev: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  silenceLogger: boolean,\n  onReactServerRenderError: undefined | ((err: any) => void)\n): ErrorHandler {\n  return (err: any, errorInfo: any) => {\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(\n        err.message + (errorInfo?.stack || err.stack || '')\n      ).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(err)) return\n\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(err)) return err.digest\n\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(err)) return err.digest\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(err)) return err.digest\n\n    // Format server errors in development to add more helpful error messages\n    if (dev) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (!silenceLogger) {\n        onReactServerRenderError?.(err)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function createHTMLErrorHandler(\n  dev: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  silenceLogger: boolean,\n  onHTMLRenderSSRError: (err: any) => void\n): ErrorHandler {\n  return (err: any, errorInfo: any) => {\n    let isSSRError = true\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        err = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = stringHash(\n        err.message + (errorInfo?.stack || err.stack || '')\n      ).toString()\n    }\n\n    allCapturedErrors.push(err)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(err)) return\n\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(err)) return err.digest\n\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(err)) return err.digest\n\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(err)) return err.digest\n\n    // Format server errors in development to add more helpful error messages\n    if (dev) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (\n        !silenceLogger &&\n        // HTML errors contain RSC errors as well, filter them out before reporting\n        isSSRError\n      ) {\n        onHTMLRenderSSRError(err)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["createFlightReactServerErrorHandler","createHTMLErrorHandler","createHTMLReactServerErrorHandler","isUserLandError","dev","onReactServerRenderError","err","errorInfo","digest","stringHash","message","stack","toString","isAbortError","isBailoutToCSRError","isNextRouterError","isDynamicServerError","formatServerError","span","getTracer","getActiveScopeSpan","recordException","setStatus","code","SpanStatusCode","ERROR","isNextExport","reactServerErrors","silenceLogger","has","set","includes","allCapturedErrors","onHTMLRenderSSRError","isSSRError","get","push"],"mappings":"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"}