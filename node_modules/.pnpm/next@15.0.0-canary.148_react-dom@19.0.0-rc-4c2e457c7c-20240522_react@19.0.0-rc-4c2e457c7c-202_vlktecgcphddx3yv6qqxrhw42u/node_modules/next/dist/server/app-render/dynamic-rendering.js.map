{"version":3,"sources":["../../../src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { prerenderAsyncStorage } from './prerender-async-storage.external'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\ntype DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during a render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: StaticGenerationStore,\n  expression: string\n): void {\n  // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n  // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n  // forbidden inside a cache scope.\n  if (store.isUnstableCacheCallback) return\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  const prerenderStore = prerenderAsyncStorage.getStore()\n  if (prerenderStore) {\n    if (prerenderStore.controller) {\n      // We're prerendering the RSC stream with dynamicIO enabled and we need to abort the\n      // current render because something dynamic is being used.\n      // This won't throw so we still need to fall through to determine if/how we handle\n      // this specific dynamic request.\n      abortRSCRender(prerenderStore.controller, store.route, expression)\n      errorWithTracking(prerenderStore.dynamicTracking, store.route, expression)\n    } else if (prerenderStore.cacheSignal) {\n      // we're prerendering with dynamicIO but we don't want to eagerly abort this\n      // prospective render. We error here to avoid returning anything from whatever\n      // is trying to access dynamic data.\n      errorWithTracking(prerenderStore.dynamicTracking, store.route, expression)\n    } else {\n      postponeWithTracking(\n        prerenderStore.dynamicTracking,\n        store.route,\n        expression\n      )\n    }\n  } else {\n    store.revalidate = 0\n\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: StaticGenerationStore,\n  expression: string\n): void {\n  const prerenderStore = prerenderAsyncStorage.getStore()\n  if (!prerenderStore) return\n\n  postponeWithTracking(prerenderStore.dynamicTracking, store.route, expression)\n}\n\n/**\n * This function communicates that some dynamic data was read. This typically would refer to accessing\n * a Request specific data store such as cookies or headers. This function is not how end-users will\n * describe reading from dynamic data sources which are valid to cache and up to the author to make\n * a determination of when to do so.\n *\n * If we are inside a cache scope we error\n * Also during a PPR Prerender we postpone\n */\nexport function trackDynamicDataAccessed(\n  store: StaticGenerationStore,\n  expression: string\n): void {\n  if (store.isUnstableCacheCallback) {\n    throw new Error(\n      `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n    )\n  } else if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  const prerenderStore = prerenderAsyncStorage.getStore()\n  if (prerenderStore) {\n    if (prerenderStore.controller) {\n      // We're prerendering the RSC stream with dynamicIO enabled and we need to abort the\n      // current render because something dynamic is being used.\n      // This won't throw so we still need to fall through to determine if/how we handle\n      // this specific dynamic request.\n      abortRSCRender(prerenderStore.controller, store.route, expression)\n      errorWithTracking(prerenderStore.dynamicTracking, store.route, expression)\n    } else if (prerenderStore.cacheSignal) {\n      // we're prerendering with dynamicIO but we don't want to eagerly abort this\n      // prospective render. We error here to avoid returning anything from whatever\n      // is trying to access dynamic data.\n      errorWithTracking(prerenderStore.dynamicTracking, store.route, expression)\n    } else {\n      postponeWithTracking(\n        prerenderStore.dynamicTracking,\n        store.route,\n        expression\n      )\n    }\n  } else {\n    store.revalidate = 0\n\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    }\n  }\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = prerenderAsyncStorage.getStore()\n  const dynamicTracking = prerenderStore?.dynamicTracking || null\n  postponeWithTracking(dynamicTracking, route, reason)\n}\n\nfunction errorWithTracking(\n  dynamicTracking: null | DynamicTrackingState,\n  route: string,\n  expression: string\n): never {\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n  const reason =\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n\n  throw createPrerenderInterruptedError(reason)\n}\n\nfunction postponeWithTracking(\n  dynamicTracking: null | DynamicTrackingState,\n  route: string,\n  expression: string\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\nexport function isPrerenderInterruptedError(error: unknown) {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED\n  )\n}\n\nfunction abortRSCRender(\n  controller: AbortController,\n  route: string,\n  expression: string\n): void {\n  // TODO improve the error message to communicate what it means to have a complete\n  // prerender that was interrupted\n  const reason =\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n\n  controller.abort(createPrerenderInterruptedError(reason))\n}\n\nexport function isRenderInterruptedReason(reason: string) {\n  return reason === NEXT_PRERENDER_INTERRUPTED\n}\n\nexport function accessedDynamicData(\n  dynamicTracking: DynamicTrackingState\n): boolean {\n  return dynamicTracking.dynamicAccesses.length > 0\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicTracking: DynamicTrackingState\n): string[] {\n  return dynamicTracking.dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n"],"names":["Postpone","accessedDynamicData","createDynamicTrackingState","createPostponedAbortSignal","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","isRenderInterruptedReason","markCurrentScopeAsDynamic","trackDynamicDataAccessed","trackFallbackParamAccessed","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","trackingState","expression","store","isUnstableCacheCallback","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","prerenderStore","prerenderAsyncStorage","getStore","controller","abortRSCRender","errorWithTracking","dynamicTracking","cacheSignal","postponeWithTracking","revalidate","isStaticGeneration","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","Error","reason","push","undefined","createPrerenderInterruptedError","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","error","digest","abort","length","filter","access","map","split","slice","line","join","AbortController","x","signal"],"mappings":"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"}