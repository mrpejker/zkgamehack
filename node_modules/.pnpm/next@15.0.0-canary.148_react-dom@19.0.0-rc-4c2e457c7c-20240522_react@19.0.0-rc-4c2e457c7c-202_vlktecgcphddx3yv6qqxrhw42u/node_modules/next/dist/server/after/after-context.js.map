{"version":3,"sources":["../../../src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport {\n  requestAsyncStorage,\n  type RequestStore,\n} from '../../client/components/request-async-storage.external'\nimport { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n\n  private requestStore: RequestStore | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n\n  constructor({ waitUntil, onClose }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public run<T>(requestStore: RequestStore, callback: () => T): T {\n    this.requestStore = requestStore\n    return callback()\n  }\n\n  public after(task: AfterTask): void {\n    if (isPromise(task)) {\n      task.catch(() => {}) // avoid unhandled rejection crashes\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task)\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.requestStore) {\n      throw new InvariantError(\n        'unstable_after: Expected `AfterContext.requestStore` to be initialized'\n      )\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      // NOTE: We're creating a promise here, which means that\n      // we will propagate any AsyncLocalStorage contexts we're currently in\n      // to the callbacks that'll execute later.\n      // This includes e.g. `requestAsyncStorage` and React's `requestStorage` (which backs `React.cache()`).\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    const wrappedCallback = async () => {\n      try {\n        await callback()\n      } catch (err) {\n        // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n        console.error(\n          'An error occurred in a function passed to `unstable_after()`:',\n          err\n        )\n      }\n    }\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks(this.requestStore!)\n  }\n\n  private async runCallbacks(requestStore: RequestStore): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    const readonlyRequestStore: RequestStore =\n      wrapRequestStoreForAfterCallbacks(requestStore)\n\n    return requestAsyncStorage.run(readonlyRequestStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n\n/** Disable mutations of `requestStore` within `after()` and disallow nested after calls.  */\nfunction wrapRequestStoreForAfterCallbacks(\n  requestStore: RequestStore\n): RequestStore {\n  return {\n    url: requestStore.url,\n    get headers() {\n      return requestStore.headers\n    },\n    get cookies() {\n      return requestStore.cookies\n    },\n    get draftMode() {\n      return requestStore.draftMode\n    },\n    // TODO(after): calling a `cookies.set()` in an after() that's in an action doesn't currently error.\n    mutableCookies: new ResponseCookies(new Headers()),\n    assetPrefix: requestStore.assetPrefix,\n    reactLoadableManifest: requestStore.reactLoadableManifest,\n    afterContext: requestStore.afterContext,\n    isHmrRefresh: requestStore.isHmrRefresh,\n    serverComponentsHmrCache: requestStore.serverComponentsHmrCache,\n  }\n}\n\nfunction isPromise(p: unknown): p is Promise<unknown> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  )\n}\n"],"names":["AfterContext","constructor","waitUntil","onClose","callbackQueue","PromiseQueue","pause","run","requestStore","callback","after","task","isPromise","catch","errorWaitUntilNotAvailable","addCallback","Error","InvariantError","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","err","console","error","add","Promise","resolve","runCallbacks","size","readonlyRequestStore","wrapRequestStoreForAfterCallbacks","requestAsyncStorage","start","onIdle","url","headers","cookies","draftMode","mutableCookies","ResponseCookies","Headers","assetPrefix","reactLoadableManifest","afterContext","isHmrRefresh","serverComponentsHmrCache","p","then"],"mappings":"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"}