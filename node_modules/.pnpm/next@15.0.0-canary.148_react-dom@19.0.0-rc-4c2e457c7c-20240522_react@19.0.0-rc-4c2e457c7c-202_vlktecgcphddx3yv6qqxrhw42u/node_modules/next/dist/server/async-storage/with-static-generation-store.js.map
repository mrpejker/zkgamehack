{"version":3,"sources":["../../../src/server/async-storage/with-static-generation-store.ts"],"sourcesContent":["import type { WithStore } from './with-store'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOptsPartial } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../../client/components/fallback-params'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type StaticGenerationContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  renderOpts: {\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: StaticGenerationStore['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOptsPartial['experimental'],\n      'isRoutePPREnabled' | 'after' | 'dynamicIO'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: StaticGenerationStore\n  } & Pick<\n    // Pull some properties from RenderOptsPartial so that the docs are also\n    // mirrored.\n    RenderOptsPartial,\n    | 'supportsDynamicResponse'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n  > &\n    Partial<RequestLifecycleOpts>\n}\n\nexport const withStaticGenerationStore: WithStore<\n  StaticGenerationStore,\n  StaticGenerationContext\n> = <Result>(\n  storage: AsyncLocalStorage<StaticGenerationStore>,\n  {\n    page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n  }: StaticGenerationContext,\n  callback: (store: StaticGenerationStore) => Result\n): Result => {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: StaticGenerationStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return storage.run(store, callback, store)\n}\n"],"names":["withStaticGenerationStore","storage","page","fallbackRouteParams","renderOpts","requestEndedState","callback","isStaticGeneration","supportsDynamicResponse","isDraftMode","isServerAction","store","route","normalizeAppPath","incrementalCache","globalThis","__incrementalCache","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","run"],"mappings":";;;;+BA6DaA;;;eAAAA;;;0BApDoB;AAoD1B,MAAMA,4BAGT,CACFC,SACA,EACEC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACO,EAC1BC;IAEA;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACH,WAAWI,uBAAuB,IACnC,CAACJ,WAAWK,WAAW,IACvB,CAACL,WAAWM,cAAc;IAE5B,MAAMC,QAA+B;QACnCJ;QACAL;QACAC;QACAS,OAAOC,IAAAA,0BAAgB,EAACX;QACxBY,kBACE,qEAAqE;QACrE,mDAAmD;QACnDV,WAAWU,gBAAgB,IAAI,AAACC,WAAmBC,kBAAkB;QACvEC,cAAcb,WAAWa,YAAY;QACrCC,gBAAgBd,WAAWe,UAAU;QACrCC,YAAYhB,WAAWgB,UAAU;QACjCC,sBAAsBjB,WAAWiB,oBAAoB;QAErDZ,aAAaL,WAAWK,WAAW;QAEnCJ;IACF;IAEA,sFAAsF;IACtFD,WAAWO,KAAK,GAAGA;IAEnB,OAAOV,QAAQqB,GAAG,CAACX,OAAOL,UAAUK;AACtC"}