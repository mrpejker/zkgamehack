{"version":3,"sources":["../../../../src/server/lib/incremental-cache/file-system-cache.ts"],"sourcesContent":["import type { RouteMetadata } from '../../../export/routes/types'\nimport type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from './'\nimport type { CacheFs } from '../../../shared/lib/utils'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchValue,\n} from '../../response-cache'\n\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from '../../../shared/lib/isomorphic/path'\nimport {\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_DATA_SUFFIX,\n  NEXT_META_SUFFIX,\n  RSC_PREFETCH_SUFFIX,\n  RSC_SUFFIX,\n} from '../../../lib/constants'\n\ntype FileSystemCacheContext = Omit<\n  CacheHandlerContext,\n  'fs' | 'serverDistDir'\n> & {\n  fs: CacheFs\n  serverDistDir: string\n}\n\ntype TagsManifest = {\n  version: 1\n  items: { [tag: string]: { revalidatedAt: number } }\n}\nlet memoryCache: LRUCache<string, CacheHandlerValue> | undefined\nlet tagsManifest: TagsManifest | undefined\n\nexport default class FileSystemCache implements CacheHandler {\n  private fs: FileSystemCacheContext['fs']\n  private flushToDisk?: FileSystemCacheContext['flushToDisk']\n  private serverDistDir: FileSystemCacheContext['serverDistDir']\n  private tagsManifestPath?: string\n  private revalidatedTags: string[]\n  private debug: boolean\n\n  constructor(ctx: FileSystemCacheContext) {\n    this.fs = ctx.fs\n    this.flushToDisk = ctx.flushToDisk\n    this.serverDistDir = ctx.serverDistDir\n    this.revalidatedTags = ctx.revalidatedTags\n    this.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n\n    if (ctx.maxMemoryCacheSize) {\n      if (!memoryCache) {\n        if (this.debug) {\n          console.log('using memory store for fetch cache')\n        }\n\n        memoryCache = new LRUCache({\n          max: ctx.maxMemoryCacheSize,\n          length({ value }) {\n            if (!value) {\n              return 25\n            } else if (value.kind === CachedRouteKind.REDIRECT) {\n              return JSON.stringify(value.props).length\n            } else if (value.kind === CachedRouteKind.IMAGE) {\n              throw new Error('invariant image should not be incremental-cache')\n            } else if (value.kind === CachedRouteKind.FETCH) {\n              return JSON.stringify(value.data || '').length\n            } else if (value.kind === CachedRouteKind.APP_ROUTE) {\n              return value.body.length\n            }\n            // rough estimate of size of cache value\n            return (\n              value.html.length +\n              (JSON.stringify(\n                value.kind === CachedRouteKind.APP_PAGE\n                  ? value.rscData\n                  : value.pageData\n              )?.length || 0)\n            )\n          },\n        })\n      }\n    } else if (this.debug) {\n      console.log('not using memory store for fetch cache')\n    }\n\n    if (this.serverDistDir && this.fs) {\n      this.tagsManifestPath = path.join(\n        this.serverDistDir,\n        '..',\n        'cache',\n        'fetch-cache',\n        'tags-manifest.json'\n      )\n\n      this.loadTagsManifestSync()\n    }\n  }\n\n  public resetRequestCache(): void {}\n\n  /**\n   * Load the tags manifest from the file system\n   */\n  private async loadTagsManifest() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return\n    try {\n      tagsManifest = JSON.parse(\n        await this.fs.readFile(this.tagsManifestPath, 'utf8')\n      )\n    } catch (err: any) {\n      tagsManifest = { version: 1, items: {} }\n    }\n    if (this.debug) console.log('loadTagsManifest', tagsManifest)\n  }\n\n  /**\n   * As above, but synchronous for use in the constructor. This is to\n   * preserve the existing behaviour when instantiating the cache handler. Although it's\n   * not ideal to block the main thread it's only called once during startup.\n   */\n  private loadTagsManifestSync() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return\n    try {\n      tagsManifest = JSON.parse(\n        this.fs.readFileSync(this.tagsManifestPath, 'utf8')\n      )\n    } catch (err: any) {\n      tagsManifest = { version: 1, items: {} }\n    }\n    if (this.debug) console.log('loadTagsManifest', tagsManifest)\n  }\n\n  public async revalidateTag(\n    ...args: Parameters<CacheHandler['revalidateTag']>\n  ) {\n    let [tags] = args\n    tags = typeof tags === 'string' ? [tags] : tags\n\n    if (this.debug) {\n      console.log('revalidateTag', tags)\n    }\n\n    if (tags.length === 0) {\n      return\n    }\n\n    // we need to ensure the tagsManifest is refreshed\n    // since separate workers can be updating it at the same\n    // time and we can't flush out of sync data\n    await this.loadTagsManifest()\n    if (!tagsManifest || !this.tagsManifestPath) {\n      return\n    }\n\n    for (const tag of tags) {\n      const data = tagsManifest.items[tag] || {}\n      data.revalidatedAt = Date.now()\n      tagsManifest.items[tag] = data\n    }\n\n    try {\n      await this.fs.mkdir(path.dirname(this.tagsManifestPath))\n      await this.fs.writeFile(\n        this.tagsManifestPath,\n        JSON.stringify(tagsManifest || {})\n      )\n      if (this.debug) {\n        console.log('Updated tags manifest', tagsManifest)\n      }\n    } catch (err: any) {\n      console.warn('Failed to update tags manifest.', err)\n    }\n  }\n\n  public async get(...args: Parameters<CacheHandler['get']>) {\n    const [key, ctx] = args\n    const { tags, softTags, kind, isRoutePPREnabled, isFallback } = ctx\n\n    let data = memoryCache?.get(key)\n\n    if (this.debug) {\n      console.log('get', key, tags, kind, !!data)\n    }\n\n    // let's check the disk for seed data\n    if (!data && process.env.NEXT_RUNTIME !== 'edge') {\n      if (kind === IncrementalCacheKind.APP_ROUTE) {\n        try {\n          const filePath = this.getFilePath(\n            `${key}.body`,\n            IncrementalCacheKind.APP_ROUTE\n          )\n          const fileData = await this.fs.readFile(filePath)\n          const { mtime } = await this.fs.stat(filePath)\n\n          const meta = JSON.parse(\n            await this.fs.readFile(\n              filePath.replace(/\\.body$/, NEXT_META_SUFFIX),\n              'utf8'\n            )\n          )\n\n          const cacheEntry: CacheHandlerValue = {\n            lastModified: mtime.getTime(),\n            value: {\n              kind: CachedRouteKind.APP_ROUTE,\n              body: fileData,\n              headers: meta.headers,\n              status: meta.status,\n            },\n          }\n          return cacheEntry\n        } catch {\n          return null\n        }\n      }\n\n      try {\n        const filePath = this.getFilePath(\n          kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,\n          kind\n        )\n\n        const fileData = await this.fs.readFile(filePath, 'utf8')\n        const { mtime } = await this.fs.stat(filePath)\n\n        if (kind === IncrementalCacheKind.FETCH) {\n          if (!this.flushToDisk) return null\n\n          const lastModified = mtime.getTime()\n          const parsedData: CachedFetchValue = JSON.parse(fileData)\n          data = {\n            lastModified,\n            value: parsedData,\n          }\n\n          if (data.value?.kind === CachedRouteKind.FETCH) {\n            const storedTags = data.value?.tags\n\n            // update stored tags if a new one is being added\n            // TODO: remove this when we can send the tags\n            // via header on GET same as SET\n            if (!tags?.every((tag) => storedTags?.includes(tag))) {\n              if (this.debug) {\n                console.log('tags vs storedTags mismatch', tags, storedTags)\n              }\n              await this.set(key, data.value, {\n                tags,\n                isRoutePPREnabled,\n              })\n            }\n          }\n        } else if (kind === IncrementalCacheKind.APP_PAGE) {\n          // We try to load the metadata file, but if it fails, we don't\n          // error. We also don't load it if this is a fallback.\n          let meta: RouteMetadata | undefined\n          try {\n            meta = JSON.parse(\n              await this.fs.readFile(\n                filePath.replace(/\\.html$/, NEXT_META_SUFFIX),\n                'utf8'\n              )\n            )\n          } catch {}\n\n          let rscData: Buffer | undefined\n          if (!isFallback) {\n            rscData = await this.fs.readFile(\n              this.getFilePath(\n                `${key}${isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,\n                IncrementalCacheKind.APP_PAGE\n              )\n            )\n          }\n\n          data = {\n            lastModified: mtime.getTime(),\n            value: {\n              kind: CachedRouteKind.APP_PAGE,\n              html: fileData,\n              rscData,\n              postponed: meta?.postponed,\n              headers: meta?.headers,\n              status: meta?.status,\n            },\n          }\n        } else if (kind === IncrementalCacheKind.PAGES) {\n          let meta: RouteMetadata | undefined\n          let pageData: string | object = {}\n\n          if (!isFallback) {\n            pageData = JSON.parse(\n              await this.fs.readFile(\n                this.getFilePath(\n                  `${key}${NEXT_DATA_SUFFIX}`,\n                  IncrementalCacheKind.PAGES\n                ),\n                'utf8'\n              )\n            )\n          }\n\n          data = {\n            lastModified: mtime.getTime(),\n            value: {\n              kind: CachedRouteKind.PAGES,\n              html: fileData,\n              pageData,\n              headers: meta?.headers,\n              status: meta?.status,\n            },\n          }\n        } else {\n          throw new Error(\n            `Invariant: Unexpected route kind ${kind} in file system cache.`\n          )\n        }\n\n        if (data) {\n          memoryCache?.set(key, data)\n        }\n      } catch {\n        return null\n      }\n    }\n\n    if (\n      data?.value?.kind === CachedRouteKind.APP_PAGE ||\n      data?.value?.kind === CachedRouteKind.PAGES\n    ) {\n      let cacheTags: undefined | string[]\n      const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]\n\n      if (typeof tagsHeader === 'string') {\n        cacheTags = tagsHeader.split(',')\n      }\n\n      if (cacheTags?.length) {\n        await this.loadTagsManifest()\n\n        const isStale = cacheTags.some((tag) => {\n          return (\n            tagsManifest?.items[tag]?.revalidatedAt &&\n            tagsManifest?.items[tag].revalidatedAt >=\n              (data?.lastModified || Date.now())\n          )\n        })\n\n        // we trigger a blocking validation if an ISR page\n        // had a tag revalidated, if we want to be a background\n        // revalidation instead we return data.lastModified = -1\n        if (isStale) {\n          return null\n        }\n      }\n    } else if (data?.value?.kind === CachedRouteKind.FETCH) {\n      await this.loadTagsManifest()\n\n      const combinedTags = [...(tags || []), ...(softTags || [])]\n\n      const wasRevalidated = combinedTags.some((tag) => {\n        if (this.revalidatedTags.includes(tag)) {\n          return true\n        }\n\n        return (\n          tagsManifest?.items[tag]?.revalidatedAt &&\n          tagsManifest?.items[tag].revalidatedAt >=\n            (data?.lastModified || Date.now())\n        )\n      })\n      // When revalidate tag is called we don't return\n      // stale data so it's updated right away\n      if (wasRevalidated) {\n        data = undefined\n      }\n    }\n\n    return data ?? null\n  }\n\n  public async set(...args: Parameters<CacheHandler['set']>) {\n    const [key, data, ctx] = args\n    const { isFallback } = ctx\n    memoryCache?.set(key, {\n      value: data,\n      lastModified: Date.now(),\n    })\n\n    if (this.debug) {\n      console.log('set', key)\n    }\n\n    if (!this.flushToDisk || !data) return\n\n    if (data.kind === CachedRouteKind.APP_ROUTE) {\n      const filePath = this.getFilePath(\n        `${key}.body`,\n        IncrementalCacheKind.APP_ROUTE\n      )\n      await this.fs.mkdir(path.dirname(filePath))\n      await this.fs.writeFile(filePath, data.body)\n\n      const meta: RouteMetadata = {\n        headers: data.headers,\n        status: data.status,\n        postponed: undefined,\n      }\n\n      await this.fs.writeFile(\n        filePath.replace(/\\.body$/, NEXT_META_SUFFIX),\n        JSON.stringify(meta, null, 2)\n      )\n    } else if (\n      data.kind === CachedRouteKind.PAGES ||\n      data.kind === CachedRouteKind.APP_PAGE\n    ) {\n      const isAppPath = data.kind === CachedRouteKind.APP_PAGE\n      const htmlPath = this.getFilePath(\n        `${key}.html`,\n        isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES\n      )\n      await this.fs.mkdir(path.dirname(htmlPath))\n      await this.fs.writeFile(htmlPath, data.html)\n\n      // Fallbacks don't generate a data file.\n      if (!isFallback) {\n        await this.fs.writeFile(\n          this.getFilePath(\n            `${key}${\n              isAppPath\n                ? ctx.isRoutePPREnabled\n                  ? RSC_PREFETCH_SUFFIX\n                  : RSC_SUFFIX\n                : NEXT_DATA_SUFFIX\n            }`,\n            isAppPath\n              ? IncrementalCacheKind.APP_PAGE\n              : IncrementalCacheKind.PAGES\n          ),\n          isAppPath ? data.rscData : JSON.stringify(data.pageData)\n        )\n      }\n\n      if (data?.kind === CachedRouteKind.APP_PAGE) {\n        const meta: RouteMetadata = {\n          headers: data.headers,\n          status: data.status,\n          postponed: data.postponed,\n        }\n\n        await this.fs.writeFile(\n          htmlPath.replace(/\\.html$/, NEXT_META_SUFFIX),\n          JSON.stringify(meta)\n        )\n      }\n    } else if (data.kind === CachedRouteKind.FETCH) {\n      const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)\n      await this.fs.mkdir(path.dirname(filePath))\n      await this.fs.writeFile(\n        filePath,\n        JSON.stringify({\n          ...data,\n          tags: ctx.tags,\n        })\n      )\n    }\n  }\n\n  private getFilePath(pathname: string, kind: IncrementalCacheKind): string {\n    switch (kind) {\n      case IncrementalCacheKind.FETCH:\n        // we store in .next/cache/fetch-cache so it can be persisted\n        // across deploys\n        return path.join(\n          this.serverDistDir,\n          '..',\n          'cache',\n          'fetch-cache',\n          pathname\n        )\n      case IncrementalCacheKind.PAGES:\n        return path.join(this.serverDistDir, 'pages', pathname)\n      case IncrementalCacheKind.IMAGE:\n      case IncrementalCacheKind.APP_PAGE:\n      case IncrementalCacheKind.APP_ROUTE:\n        return path.join(this.serverDistDir, 'app', pathname)\n      default:\n        throw new Error(`Unexpected file path kind: ${kind}`)\n    }\n  }\n}\n"],"names":["FileSystemCache","memoryCache","tagsManifest","constructor","ctx","fs","flushToDisk","serverDistDir","revalidatedTags","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","maxMemoryCacheSize","console","log","LRUCache","max","length","value","JSON","kind","CachedRouteKind","REDIRECT","stringify","props","IMAGE","Error","FETCH","data","APP_ROUTE","body","html","APP_PAGE","rscData","pageData","tagsManifestPath","path","join","loadTagsManifestSync","resetRequestCache","loadTagsManifest","parse","readFile","err","version","items","readFileSync","revalidateTag","args","tags","tag","revalidatedAt","Date","now","mkdir","dirname","writeFile","warn","get","key","softTags","isRoutePPREnabled","isFallback","NEXT_RUNTIME","IncrementalCacheKind","filePath","getFilePath","fileData","mtime","stat","meta","replace","NEXT_META_SUFFIX","cacheEntry","lastModified","getTime","headers","status","parsedData","storedTags","every","includes","set","RSC_PREFETCH_SUFFIX","RSC_SUFFIX","postponed","PAGES","NEXT_DATA_SUFFIX","cacheTags","tagsHeader","NEXT_CACHE_TAGS_HEADER","split","isStale","some","combinedTags","wasRevalidated","undefined","isAppPath","htmlPath","pathname"],"mappings":"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"}