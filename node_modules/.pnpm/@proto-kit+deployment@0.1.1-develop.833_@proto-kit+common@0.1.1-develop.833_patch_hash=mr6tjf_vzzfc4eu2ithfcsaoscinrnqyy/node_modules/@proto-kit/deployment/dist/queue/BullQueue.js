import { MetricsTime, Queue, QueueEvents, Worker } from "bullmq";
import { log, noop } from "@proto-kit/common";
import { SequencerModule, } from "@proto-kit/sequencer";
/**
 * TaskQueue implementation for BullMQ
 */
export class BullQueue extends SequencerModule {
    createWorker(name, executor, options) {
        const worker = new Worker(name, async (job) => JSON.stringify(await executor(job.data)), {
            concurrency: options?.concurrency ?? 1,
            connection: this.config.redis,
            metrics: { maxDataPoints: MetricsTime.ONE_HOUR * 24 },
        });
        // We have to do this, because we want to prevent the worker from crashing
        worker.on("error", (error) => {
            log.error("Worker threw error:");
            log.error(error);
        });
        return {
            async close() {
                await worker.close();
            },
        };
    }
    async getQueue(queueName) {
        const { retryAttempts, redis } = this.config;
        const queue = new Queue(queueName, {
            connection: redis,
        });
        const events = new QueueEvents(queueName, { connection: redis });
        await queue.drain();
        return {
            name: queueName,
            async addTask(payload) {
                const job = await queue.add(queueName, payload, {
                    attempts: retryAttempts ?? 2,
                });
                return { taskId: job.id };
            },
            async onCompleted(listener) {
                events.on("completed", async (result) => {
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                    await listener(JSON.parse(result.returnvalue));
                });
                await events.waitUntilReady();
            },
            async close() {
                await events.close();
                await queue.close();
            },
        };
    }
    async start() {
        noop();
    }
}
