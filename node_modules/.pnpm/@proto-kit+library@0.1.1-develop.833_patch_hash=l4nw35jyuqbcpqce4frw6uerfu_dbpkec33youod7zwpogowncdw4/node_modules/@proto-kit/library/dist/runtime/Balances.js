var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { RuntimeModule, runtimeMethod, state, runtimeModule, } from "@proto-kit/module";
import { StateMap, assert } from "@proto-kit/protocol";
import { Field, PublicKey, Struct, Provable } from "o1js";
import { UInt64 } from "../math/UInt64";
export const errors = {
    senderNotFrom: () => "Sender does not match 'from'",
    fromBalanceInsufficient: () => "From balance is insufficient",
};
export class TokenId extends Field {
}
export class BalancesKey extends Struct({
    tokenId: TokenId,
    address: PublicKey,
}) {
    static from(tokenId, address) {
        return new BalancesKey({ tokenId, address });
    }
}
export class Balance extends UInt64 {
}
export let Balances = class Balances extends RuntimeModule {
    constructor() {
        super(...arguments);
        this.balances = StateMap.from(BalancesKey, Balance);
    }
    async getBalance(tokenId, address) {
        const key = new BalancesKey({ tokenId, address });
        const balanceOption = await this.balances.get(key);
        return Balance.Unsafe.fromField(balanceOption.value.value);
    }
    async setBalance(tokenId, address, amount) {
        const key = new BalancesKey({ tokenId, address });
        await this.balances.set(key, amount);
    }
    async transfer(tokenId, from, to, amount) {
        const fromBalance = await this.getBalance(tokenId, from);
        const fromBalanceIsSufficient = fromBalance.greaterThanOrEqual(amount);
        assert(fromBalanceIsSufficient, errors.fromBalanceInsufficient());
        const newFromBalance = fromBalance.sub(amount);
        await this.setBalance(tokenId, from, newFromBalance);
        const toBalance = await this.getBalance(tokenId, to);
        const newToBalance = toBalance.add(amount);
        await this.setBalance(tokenId, to, newToBalance);
    }
    async mint(tokenId, address, amount) {
        const balance = await this.getBalance(tokenId, address);
        const newBalance = balance.add(amount);
        await this.setBalance(tokenId, address, newBalance);
    }
    async burn(tokenId, address, amount) {
        const balance = await this.getBalance(tokenId, address);
        Provable.log("Balance", balance, amount);
        const newBalance = balance.sub(amount);
        await this.setBalance(tokenId, address, newBalance);
    }
    async transferSigned(tokenId, from, to, amount) {
        assert(this.transaction.sender.value.equals(from), errors.senderNotFrom());
        await this.transfer(tokenId, from, to, amount);
    }
};
__decorate([
    state(),
    __metadata("design:type", Object)
], Balances.prototype, "balances", void 0);
__decorate([
    runtimeMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TokenId,
        PublicKey,
        PublicKey,
        Balance]),
    __metadata("design:returntype", Promise)
], Balances.prototype, "transferSigned", null);
Balances = __decorate([
    runtimeModule()
], Balances);
