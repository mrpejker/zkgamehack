import { Bool, Field, UInt64 } from "o1js";
declare const UIntX_base: (new (value: {
    value: import("o1js/dist/node/lib/field").Field;
}) => {
    value: import("o1js/dist/node/lib/field").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    value: import("o1js/dist/node/lib/field").Field;
}> & {
    toInput: (x: {
        value: import("o1js/dist/node/lib/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        value: import("o1js/dist/node/lib/field").Field;
    }) => {
        value: string;
    };
    fromJSON: (x: {
        value: string;
    }) => {
        value: import("o1js/dist/node/lib/field").Field;
    };
};
export declare abstract class UIntX<This extends UIntX<any>> extends UIntX_base {
    private readonly impls;
    readonly NUM_BITS: number;
    protected static readonly assertionFunction: (bool: Bool, msg?: string) => void;
    static checkConstant(x: Field, numBits: number): import("o1js/dist/node/lib/field").Field;
    /**
     * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.
     */
    protected static maxIntField(numBits: number): Field;
    protected constructor(value: Field, bits: number, impls: {
        creator: (value: Field) => This;
        from: (value: Field | This | bigint | number | string) => This;
    });
    /**
     * Turns the {@link UIntX} into a string.
     * @returns
     */
    toString(): string;
    /**
     * Turns the {@link UInt64} into a {@link BigInt}.
     * @returns
     */
    toBigInt(): bigint;
    /**
     * Integer division with remainder.
     *
     * `x.divMod(y)` returns the quotient and the remainder.
     */
    divMod(y: This | bigint | number | string): {
        quotient: This;
        rest: This;
    };
    /**
     * Integer division.
     *
     * `x.div(y)` returns the floor of `x / y`, that is, the greatest
     * `z` such that `z * y <= x`.
     *
     */
    div(y: This | bigint | number): This;
    /**
     * Implements a non-overflowing square-root with rest.
     * Normal Field.sqrt() provides the sqrt as it is defined by the finite field operations.
     * This implementation however mimics the natural-numbers style of sqrt to be used
     * inside applications with the tradeoff that it also returns a "rest" that indicates
     * the amount the actual result is off (since we floor the result to stay inside the ff).
     *
     * Some assertions are hard-failing, because they represent malicious witness values
     *
     * @returns sqrt: The non-overflowing sqrt
     * @returns rest: The remainder indicating how far off the result is from the "real" sqrt
     */
    sqrtMod(): {
        sqrt: This;
        rest: This;
    };
    /**
     * Wraps sqrtMod() by only returning the sqrt and omitting the rest field.
     */
    sqrtFloor(): This;
    /**
     * Integer remainder.
     *
     * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
     * `x - z` is divisble by `y`.
     */
    mod(y: This | bigint | number): This;
    /**
     * Multiplication with overflow checking.
     */
    mul(y: This | bigint | number): This;
    /**
     * Addition with overflow checking.
     */
    add(y: This | bigint | number): This;
    /**
     * Subtraction with underflow checking.
     */
    sub(y: This | bigint | number): This;
    /**
     * Checks if a {@link UInt64} is less than or equal to another one.
     */
    lessThanOrEqual(y: This): import("o1js/dist/node/lib/bool").Bool;
    /**
     * Asserts that a {@link UInt64} is less than or equal to another one.
     */
    assertLessThanOrEqual(y: This, message?: string): void;
    /**
     *
     * Checks if a {@link UInt64} is less than another one.
     */
    lessThan(y: This): import("o1js/dist/node/lib/bool").Bool;
    /**
     * Asserts that a {@link UInt64} is less than another one.
     */
    assertLessThan(y: This, message?: string): void;
    /**
     * Checks if a {@link UInt64} is greater than another one.
     */
    greaterThan(y: This): import("o1js/dist/node/lib/bool").Bool;
    /**
     * Asserts that a {@link UInt64} is greater than another one.
     */
    assertGreaterThan(y: This, message?: string): void;
    /**
     * Checks if a {@link UInt64} is greater than or equal to another one.
     */
    greaterThanOrEqual(y: This): import("o1js/dist/node/lib/bool").Bool;
    /**
     * Asserts that a {@link UInt64} is greater than or equal to another one.
     */
    assertGreaterThanOrEqual(y: This, message?: string): void;
    /**
     * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.
     */
    toUInt64(): UInt64;
    /**
     * Turns the {@link UIntX} into a {@link UInt64}, clamping to the 64 bits range if it's too large.
     * ```ts
     * UInt64.from(4294967296).toUInt32Clamped().toString(); // "4294967295"
     * ```
     */
    toUInt64Clamped(): UInt64;
}
export {};
//# sourceMappingURL=UInt.d.ts.map