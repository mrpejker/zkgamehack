// eslint-disable-next-line max-len
/* eslint-disable @typescript-eslint/no-magic-numbers,prefer-const,id-length,no-underscore-dangle,putout/putout */
import { Bool, Field, Provable, Struct, UInt64 } from "o1js";
import { assert } from "@proto-kit/protocol";
import bigintSqrt from "bigint-isqrt";
export class UIntX extends Struct({
    value: Field,
}) {
    // private readonly assertion_fn: (bool: Bool, msg?: string) => void = (bool, msg) => { bool.assertTrue(msg) }
    static checkConstant(x, numBits) {
        if (!x.isConstant()) {
            return x;
        }
        let xBig = x.toBigInt();
        if (xBig < 0n || xBig >= 1n << BigInt(numBits)) {
            throw new Error(`UIntX: Expected number between 0 and 2^${numBits} - 1, got ${xBig}`);
        }
        return x;
    }
    /**
     * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.
     */
    static maxIntField(numBits) {
        return Field((1n << BigInt(numBits)) - 1n);
    }
    constructor(value, bits, impls) {
        super({ value });
        this.impls = impls;
        if (bits % 16 !== 0) {
            throw new Error("Can only create rangechecks for multiples of 16 bits");
        }
        if (bits <= 64) {
            throw new Error("For numBits 32 and 64 use UInt32 and UInt64 respectively");
        }
        this.NUM_BITS = bits;
    }
    /**
     * Turns the {@link UIntX} into a string.
     * @returns
     */
    toString() {
        return this.value.toString();
    }
    /**
     * Turns the {@link UInt64} into a {@link BigInt}.
     * @returns
     */
    toBigInt() {
        return this.value.toBigInt();
    }
    /**
     * Integer division with remainder.
     *
     * `x.divMod(y)` returns the quotient and the remainder.
     */
    divMod(y) {
        let x = this.value;
        let y_ = this.impls.from(y).value;
        if (this.value.isConstant() && y_.isConstant()) {
            let xn = x.toBigInt();
            let yn = y_.toBigInt();
            let q = xn / yn;
            let r = xn - q * yn;
            return {
                quotient: this.impls.creator(Field(q)),
                rest: this.impls.creator(Field(r)),
            };
        }
        y_ = y_.seal();
        let q = Provable.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));
        UIntX.assertionFunction(q.rangeCheckHelper(this.NUM_BITS).equals(q), "Divison overflowing");
        // eslint-disable-next-line no-warning-comments
        // TODO: Could be a bit more efficient
        let r = x.sub(q.mul(y_)).seal();
        UIntX.assertionFunction(r.rangeCheckHelper(this.NUM_BITS).equals(r), "Divison overflowing, remainder");
        let r_ = this.impls.creator(r);
        let q_ = this.impls.creator(q);
        UIntX.assertionFunction(r_.lessThan(this.impls.creator(y_)), "Divison failure, remainder larger than divisor");
        return { quotient: q_, rest: r_ };
    }
    /**
     * Integer division.
     *
     * `x.div(y)` returns the floor of `x / y`, that is, the greatest
     * `z` such that `z * y <= x`.
     *
     */
    div(y) {
        return this.divMod(y).quotient;
    }
    /**
     * Implements a non-overflowing square-root with rest.
     * Normal Field.sqrt() provides the sqrt as it is defined by the finite field operations.
     * This implementation however mimics the natural-numbers style of sqrt to be used
     * inside applications with the tradeoff that it also returns a "rest" that indicates
     * the amount the actual result is off (since we floor the result to stay inside the ff).
     *
     * Some assertions are hard-failing, because they represent malicious witness values
     *
     * @returns sqrt: The non-overflowing sqrt
     * @returns rest: The remainder indicating how far off the result is from the "real" sqrt
     */
    sqrtMod() {
        let x = this.value;
        if (x.isConstant()) {
            const xn = x.toBigInt();
            const sqrt = bigintSqrt(xn);
            const rest = xn - sqrt * sqrt;
            return {
                sqrt: this.impls.creator(Field(sqrt)),
                rest: this.impls.creator(Field(rest)),
            };
        }
        const sqrtField = Provable.witness(Field, () => {
            const sqrtn = bigintSqrt(x.toBigInt());
            return Field(sqrtn);
        });
        sqrtField
            .rangeCheckHelper(this.NUM_BITS)
            .assertEquals(sqrtField, "Sqrt output overflowing");
        // Range check included here?
        const sqrt = this.impls.creator(sqrtField);
        const rest = Provable.witness(Field, () => {
            const sqrtn = sqrtField.toBigInt();
            return Field(x.toBigInt() - sqrtn * sqrtn);
        });
        rest
            .rangeCheckHelper(this.NUM_BITS)
            .assertEquals(rest, "Sqrt rest output overflowing");
        const square = sqrtField.mul(sqrtField);
        const nextSqrt = sqrtField.add(1);
        const nextLargerSquare = nextSqrt.mul(nextSqrt);
        // We assert that the rest is not larger than the minimum it needs to be
        // Therefore we assert that the sqrt is the highest possible candidate
        rest.assertLessThan(nextLargerSquare.sub(square), "There exists a larger sqrt solution than provided witness");
        // Assert that sqrt*sqrt+rest == x
        x.assertEquals(square.add(rest), "Square evaluation failed");
        return {
            sqrt,
            rest: this.impls.creator(rest),
        };
    }
    /**
     * Wraps sqrtMod() by only returning the sqrt and omitting the rest field.
     */
    sqrtFloor() {
        return this.sqrtMod().sqrt;
    }
    /**
     * Integer remainder.
     *
     * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
     * `x - z` is divisble by `y`.
     */
    mod(y) {
        return this.divMod(y).rest;
    }
    /**
     * Multiplication with overflow checking.
     */
    mul(y) {
        let z = this.value.mul(this.impls.from(y).value);
        UIntX.assertionFunction(z.rangeCheckHelper(this.NUM_BITS).equals(z), "Multiplication overflowing");
        return this.impls.creator(z);
    }
    /**
     * Addition with overflow checking.
     */
    add(y) {
        let z = this.value.add(this.impls.from(y).value);
        UIntX.assertionFunction(z.rangeCheckHelper(this.NUM_BITS).equals(z), "Addition overflowing");
        return this.impls.creator(z);
    }
    /**
     * Subtraction with underflow checking.
     */
    sub(y) {
        let z = this.value.sub(this.impls.from(y).value);
        UIntX.assertionFunction(z.rangeCheckHelper(this.NUM_BITS).equals(z), "Subtraction overflow");
        return this.impls.creator(z);
    }
    /**
     * Checks if a {@link UInt64} is less than or equal to another one.
     */
    lessThanOrEqual(y) {
        if (this.value.isConstant() && y.value.isConstant()) {
            return Bool(this.value.toBigInt() <= y.value.toBigInt());
        }
        let xMinusY = this.value.sub(y.value).seal();
        let yMinusX = xMinusY.neg();
        let xMinusYFits = xMinusY.rangeCheckHelper(UInt64.NUM_BITS).equals(xMinusY);
        let yMinusXFits = yMinusX.rangeCheckHelper(UInt64.NUM_BITS).equals(yMinusX);
        UIntX.assertionFunction(xMinusYFits.or(yMinusXFits));
        // x <= y if y - x fits in 64 bits
        return yMinusXFits;
    }
    /**
     * Asserts that a {@link UInt64} is less than or equal to another one.
     */
    assertLessThanOrEqual(y, message) {
        if (this.value.isConstant() && y.value.isConstant()) {
            let x0 = this.value.toBigInt();
            let y0 = y.value.toBigInt();
            if (x0 > y0) {
                if (message !== undefined) {
                    throw new Error(message);
                }
                throw new Error(`UInt64.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
            }
            return;
        }
        let yMinusX = y.value.sub(this.value).seal();
        UIntX.assertionFunction(yMinusX.rangeCheckHelper(UInt64.NUM_BITS).equals(yMinusX), message);
    }
    /**
     *
     * Checks if a {@link UInt64} is less than another one.
     */
    lessThan(y) {
        return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
    }
    /**
     * Asserts that a {@link UInt64} is less than another one.
     */
    assertLessThan(y, message) {
        UIntX.assertionFunction(this.lessThan(y), message);
    }
    /**
     * Checks if a {@link UInt64} is greater than another one.
     */
    greaterThan(y) {
        return y.lessThan(this);
    }
    /**
     * Asserts that a {@link UInt64} is greater than another one.
     */
    assertGreaterThan(y, message) {
        y.assertLessThan(this, message);
    }
    /**
     * Checks if a {@link UInt64} is greater than or equal to another one.
     */
    greaterThanOrEqual(y) {
        return this.lessThan(y).not();
    }
    /**
     * Asserts that a {@link UInt64} is greater than or equal to another one.
     */
    assertGreaterThanOrEqual(y, message) {
        y.assertLessThanOrEqual(this, message);
    }
    /**
     * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.
     */
    toUInt64() {
        let uint64 = new UInt64(this.value);
        UInt64.check(uint64);
        return uint64;
    }
    /**
     * Turns the {@link UIntX} into a {@link UInt64}, clamping to the 64 bits range if it's too large.
     * ```ts
     * UInt64.from(4294967296).toUInt32Clamped().toString(); // "4294967295"
     * ```
     */
    toUInt64Clamped() {
        let max = (1n << 64n) - 1n;
        return Provable.if(this.greaterThan(this.impls.from(max)), UInt64.from(max), new UInt64(this.value));
    }
}
UIntX.assertionFunction = assert;
