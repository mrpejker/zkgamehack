var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { ConfigurableModule, createMerkleTree, InMemoryMerkleTreeStorage, } from "@proto-kit/common";
import { Runtime } from "@proto-kit/module";
import { container, inject } from "tsyringe";
import { RuntimeMethodExecutionContext, RuntimeTransaction, NetworkState, } from "@proto-kit/protocol";
import { Field, Poseidon, Struct } from "o1js";
import { UInt64 } from "../math/UInt64";
export class MethodFeeConfigData extends Struct({
    methodId: Field,
    baseFee: UInt64,
    perWeightUnitFee: UInt64,
    weight: UInt64,
}) {
    hash() {
        return Poseidon.hash(MethodFeeConfigData.toFields(this));
    }
}
export const treeFeeHeight = 10;
export class FeeTree extends createMerkleTree(treeFeeHeight) {
}
export let RuntimeFeeAnalyzerService = class RuntimeFeeAnalyzerService extends ConfigurableModule {
    static getWitnessType() {
        return FeeTree.WITNESS;
    }
    constructor(runtime) {
        super();
        this.runtime = runtime;
    }
    async initializeFeeTree() {
        const context = container.resolve(RuntimeMethodExecutionContext);
        context.setup({
            transaction: RuntimeTransaction.dummyTransaction(),
            networkState: NetworkState.empty(),
        });
        const analyzedMethods = await this.runtime.zkProgrammable.zkProgram.analyzeMethods();
        container.resolve(RuntimeMethodExecutionContext).clear();
        const [values, indexes] = Object.keys(this.runtime.zkProgrammable.zkProgram.methods).reduce(
        // eslint-disable-next-line @typescript-eslint/no-shadow
        ([values, indexes], combinedMethodName, index) => {
            const { rows } = analyzedMethods[combinedMethodName];
            // const rows = 1000;
            const [moduleName, methodName] = combinedMethodName.split(".");
            const methodId = this.runtime.methodIdResolver.getMethodId(moduleName, methodName);
            /**
             * Determine the fee config for the given method id, and merge it with
             * the default fee config.
             */
            return [
                {
                    ...values,
                    [methodId.toString()]: {
                        methodId,
                        baseFee: this.config.methods[combinedMethodName]?.baseFee ??
                            this.config.baseFee,
                        perWeightUnitFee: this.config.methods[combinedMethodName]?.perWeightUnitFee ??
                            this.config.perWeightUnitFee,
                        weight: this.config.methods[combinedMethodName]?.weight ?? BigInt(rows),
                    },
                },
                {
                    ...indexes,
                    [methodId.toString()]: BigInt(index),
                },
            ];
        }, [{}, {}]);
        const tree = new FeeTree(new InMemoryMerkleTreeStorage());
        Object.values(values).forEach((value, index) => {
            const feeConfig = new MethodFeeConfigData({
                methodId: Field(value.methodId),
                baseFee: UInt64.from(value.baseFee),
                weight: UInt64.from(value.weight),
                perWeightUnitFee: UInt64.from(value.perWeightUnitFee),
            });
            tree.setLeaf(BigInt(index), feeConfig.hash());
        });
        this.persistedFeeTree = { tree, values, indexes };
    }
    getFeeTree() {
        if (this.persistedFeeTree === undefined) {
            throw new Error("Fee Tree not intialized");
        }
        return this.persistedFeeTree;
    }
    getFeeConfig(methodId) {
        const feeConfig = this.getFeeTree().values[methodId.toString()];
        return new MethodFeeConfigData({
            methodId: Field(feeConfig.methodId),
            baseFee: UInt64.from(feeConfig.baseFee),
            weight: UInt64.from(feeConfig.weight),
            perWeightUnitFee: UInt64.from(feeConfig.perWeightUnitFee),
        });
    }
    getWitness(methodId) {
        const feeTree = this.getFeeTree();
        return feeTree.tree.getWitness(feeTree.indexes[methodId.toString()]);
    }
    getRoot() {
        const { tree } = this.getFeeTree();
        return tree.getRoot().toBigInt();
    }
};
RuntimeFeeAnalyzerService = __decorate([
    __param(0, inject("Runtime")),
    __metadata("design:paramtypes", [Runtime])
], RuntimeFeeAnalyzerService);
