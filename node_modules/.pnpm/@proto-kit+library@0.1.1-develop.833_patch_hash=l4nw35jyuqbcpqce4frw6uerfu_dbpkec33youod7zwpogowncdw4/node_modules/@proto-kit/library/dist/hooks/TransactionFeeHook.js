var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { getAllPropertyNames, isRuntimeMethod, Runtime, } from "@proto-kit/module";
import { inject, injectable } from "tsyringe";
import { ProvableTransactionHook, } from "@proto-kit/protocol";
import { Field, Provable, PublicKey } from "o1js";
import { UInt64 } from "../math/UInt64";
import { Balance, TokenId } from "../runtime/Balances";
import { MethodFeeConfigData, RuntimeFeeAnalyzerService, } from "./RuntimeFeeAnalyzerService";
const errors = {
    invalidFeeTreeRoot: () => "Root hash of the provided fee config witness is invalid",
    invalidFeeConfigMethodId: () => "Method id of the provided fee config does not match the executed transaction method id",
    invalidMethod: (method) => new Error(`${method} does not exist in the current runtime.`),
};
/**
 * Transaction hook for deducting transaction fees from the sender's balance.
 */
export let TransactionFeeHook = class TransactionFeeHook extends ProvableTransactionHook {
    constructor(runtime) {
        super();
        this.runtime = runtime;
        this.persistedFeeAnalyzer = undefined;
    }
    // check if the fee config is compatible with the current runtime
    // we couldn't resolve this purely on the type level, so we have to do it here
    verifyConfig() {
        Object.keys(super.config.methods).forEach((combinedMethodName) => {
            const [runtimeModule, runtimeMethod] = combinedMethodName.split(".");
            const resolvedRuntimeModule = this.runtime.resolve(runtimeModule);
            const runtimeMethodExists = getAllPropertyNames(resolvedRuntimeModule).includes(runtimeMethod) &&
                isRuntimeMethod(resolvedRuntimeModule, runtimeMethod);
            if (!runtimeMethodExists) {
                throw errors.invalidMethod(combinedMethodName);
            }
        });
    }
    async start() {
        this.persistedFeeAnalyzer = new RuntimeFeeAnalyzerService(this.runtime);
        this.persistedFeeAnalyzer.config = this.config;
        await this.persistedFeeAnalyzer.initializeFeeTree();
    }
    get config() {
        this.verifyConfig();
        return super.config;
    }
    set config(value) {
        super.config = value;
    }
    get balances() {
        return this.runtime.dependencyContainer.resolve("Balances");
    }
    get feeAnalyzer() {
        if (this.persistedFeeAnalyzer === undefined) {
            throw new Error("TransactionFeeHook.start not called by protocol");
        }
        return this.persistedFeeAnalyzer;
    }
    async transferFee(from, fee) {
        await this.balances.transfer(new TokenId(this.config.tokenId), from.value, PublicKey.fromBase58(this.config.feeRecipient), Balance.Unsafe.fromField(fee.value));
    }
    getFee(feeConfig) {
        return UInt64.Unsafe.fromField(feeConfig.baseFee.value).add(UInt64.Unsafe.fromField(feeConfig.weight.value).mul(UInt64.Unsafe.fromField(feeConfig.perWeightUnitFee.value)));
    }
    /**
     * Determine the transaction fee for the given transaction, and transfer it
     * from the transaction sender to the fee recipient.
     *
     * @param executionData
     */
    async onTransaction(executionData) {
        const feeConfig = Provable.witness(MethodFeeConfigData, () => this.feeAnalyzer.getFeeConfig(executionData.transaction.methodId.toBigInt()));
        const witness = Provable.witness(RuntimeFeeAnalyzerService.getWitnessType(), () => this.feeAnalyzer.getWitness(executionData.transaction.methodId.toBigInt()));
        const root = Field(this.feeAnalyzer.getRoot());
        const calculatedRoot = witness.calculateRoot(feeConfig.hash());
        root.assertEquals(calculatedRoot, errors.invalidFeeTreeRoot());
        feeConfig.methodId.assertEquals(executionData.transaction.methodId, errors.invalidFeeConfigMethodId());
        const fee = this.getFee(feeConfig);
        await this.transferFee(executionData.transaction.sender, UInt64.Unsafe.fromField(fee.value));
    }
};
TransactionFeeHook = __decorate([
    injectable(),
    __param(0, inject("Runtime")),
    __metadata("design:paramtypes", [Runtime])
], TransactionFeeHook);
