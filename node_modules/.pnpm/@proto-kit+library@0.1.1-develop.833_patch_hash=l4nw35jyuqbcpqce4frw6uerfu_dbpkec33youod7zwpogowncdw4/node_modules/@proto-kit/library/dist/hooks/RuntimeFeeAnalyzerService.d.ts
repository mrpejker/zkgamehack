import { ConfigurableModule } from "@proto-kit/common";
import { Runtime, RuntimeModulesRecord } from "@proto-kit/module";
import { UInt64 } from "../math/UInt64";
export interface MethodFeeConfig {
    methodId: bigint;
    baseFee: bigint;
    perWeightUnitFee: bigint;
    weight: bigint;
}
export interface FeeTreeValues {
    [methodId: string]: MethodFeeConfig;
}
export interface FeeIndexes {
    [methodId: string]: bigint;
}
declare const MethodFeeConfigData_base: (new (value: {
    methodId: import("o1js/dist/node/lib/provable/field").Field;
    baseFee: UInt64;
    perWeightUnitFee: UInt64;
    weight: UInt64;
}) => {
    methodId: import("o1js/dist/node/lib/provable/field").Field;
    baseFee: UInt64;
    perWeightUnitFee: UInt64;
    weight: UInt64;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    methodId: import("o1js/dist/node/lib/provable/field").Field;
    baseFee: UInt64;
    perWeightUnitFee: UInt64;
    weight: UInt64;
}, {
    methodId: bigint;
    baseFee: {
        value: bigint;
    };
    perWeightUnitFee: {
        value: bigint;
    };
    weight: {
        value: bigint;
    };
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    };
} & {
    fromValue: (value: {
        methodId: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        baseFee: {
            value: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        } | UInt64;
        perWeightUnitFee: {
            value: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        } | UInt64;
        weight: {
            value: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        } | UInt64;
    }) => {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    };
    toInput: (x: {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    }) => {
        methodId: string;
        baseFee: {
            value: string;
        };
        perWeightUnitFee: {
            value: string;
        };
        weight: {
            value: string;
        };
    };
    fromJSON: (x: {
        methodId: string;
        baseFee: {
            value: string;
        };
        perWeightUnitFee: {
            value: string;
        };
        weight: {
            value: string;
        };
    }) => {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    };
    empty: () => {
        methodId: import("o1js/dist/node/lib/provable/field").Field;
        baseFee: UInt64;
        perWeightUnitFee: UInt64;
        weight: UInt64;
    };
};
export declare class MethodFeeConfigData extends MethodFeeConfigData_base {
    hash(): import("o1js/dist/node/lib/provable/field").Field;
}
export declare const treeFeeHeight = 10;
declare const FeeTree_base: import("@proto-kit/common").AbstractMerkleTreeClass;
export declare class FeeTree extends FeeTree_base {
}
export interface RuntimeFeeAnalyzerServiceConfig {
    tokenId: bigint;
    feeRecipient: string;
    baseFee: bigint;
    perWeightUnitFee: bigint;
    methods: {
        [methodId: string]: Partial<MethodFeeConfig>;
    };
}
export declare class RuntimeFeeAnalyzerService extends ConfigurableModule<RuntimeFeeAnalyzerServiceConfig> {
    runtime: Runtime<RuntimeModulesRecord>;
    static getWitnessType(): import("@proto-kit/common").TypedClass<import("@proto-kit/common").AbstractMerkleWitness> & {
        new (value: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }): {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        };
        _isStruct: true;
        toFields: (value: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) => import("o1js/dist/node/lib/provable/field").Field[];
        toAuxiliary: (value?: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        } | undefined) => any[];
        sizeInFields: () => number;
        check: (value: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) => void;
        toValue: (x: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) => {
            path: bigint[];
            isLeft: boolean[];
        };
        fromValue: ((x: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        } | {
            path: bigint[];
            isLeft: boolean[];
        }) => {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) & ((value: {
            path: import("o1js/dist/node/lib/provable/field").Field[] | bigint[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[] | boolean[];
        }) => {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        });
        fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        };
        toInput: (x: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) => {
            fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
            packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
        };
        toJSON: (x: {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        }) => {
            path: string[];
            isLeft: boolean[];
        };
        fromJSON: (x: {
            path: string[];
            isLeft: boolean[];
        }) => {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        };
        empty: () => {
            path: import("o1js/dist/node/lib/provable/field").Field[];
            isLeft: import("o1js/dist/node/lib/provable/bool").Bool[];
        };
    } & {
        dummy: () => import("@proto-kit/common").AbstractMerkleWitness;
    };
    private persistedFeeTree?;
    constructor(runtime: Runtime<RuntimeModulesRecord>);
    initializeFeeTree(): Promise<void>;
    getFeeTree(): {
        tree: FeeTree;
        values: FeeTreeValues;
        indexes: FeeIndexes;
    };
    getFeeConfig(methodId: bigint): MethodFeeConfigData;
    getWitness(methodId: bigint): import("@proto-kit/common").AbstractMerkleWitness;
    getRoot(): bigint;
}
export {};
//# sourceMappingURL=RuntimeFeeAnalyzerService.d.ts.map