import { Bool, Field, UInt64 as O1UInt64 } from "o1js";
export type UIntConstructor<BITS extends number> = {
    from(x: UInt<BITS> | bigint | number | string): UInt<BITS>;
    check(x: {
        value: Field;
    }): void;
    get zero(): UInt<BITS>;
    get max(): UInt<BITS>;
    Unsafe: {
        fromField(x: Field): UInt<BITS>;
    };
    Safe: {
        fromField(x: Field): UInt<BITS>;
    };
};
declare const UInt_base: (new (value: {
    value: import("o1js/dist/node/lib/provable/field").Field;
}) => {
    value: import("o1js/dist/node/lib/provable/field").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    value: import("o1js/dist/node/lib/provable/field").Field;
}, {
    value: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
} & {
    fromValue: (value: {
        value: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        value: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        value: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        value: string;
    };
    fromJSON: (x: {
        value: string;
    }) => {
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
};
/**
 * UInt is a base class for all soft-failing UInt* implementations.
 * It has to be overridden for every bitlength that should be available.
 *
 * For this, the developer has to create a subclass of UInt implementing the
 * static methods from interface UIntConstructor
 */
export declare abstract class UInt<BITS extends number> extends UInt_base {
    static readonly assertionFunction: (bool: Bool, msg?: string) => void;
    static checkConstant(x: Field, numBits: number): import("o1js/dist/node/lib/provable/field").Field;
    /**
     * Creates a {@link UInt} with a value of 18,446,744,073,709,551,615.
     */
    static maxIntField(numBits: number): Field;
    constructor(value: {
        value: Field;
    });
    abstract numBits(): BITS;
    abstract constructorReference(): UIntConstructor<BITS>;
    private fromField;
    private from;
    /**
     * Turns the {@link UInt} into a string.
     * @returns
     */
    toString(): string;
    /**
     * Turns the {@link UInt} into a {@link BigInt}.
     * @returns
     */
    toBigInt(): bigint;
    /**
     * Integer division with remainder.
     *
     * `x.divMod(y)` returns the quotient and the remainder.
     */
    divMod(divisor: UInt<BITS> | bigint | number | string): {
        quotient: UInt<BITS>;
        rest: UInt<BITS>;
    };
    /**
     * Integer division.
     *
     * `x.div(y)` returns the floor of `x / y`, that is, the greatest
     * `z` such that `z * y <= x`.
     *
     */
    div(y: UInt<BITS> | bigint | number): UInt<BITS>;
    /**
     * Implements a non-overflowing square-root with rest.
     * Normal Field.sqrt() provides the sqrt as it is defined by the finite
     * field operations. This implementation however mimics the natural-numbers
     * style of sqrt to be used inside applications with the tradeoff that it
     * also returns a "rest" that indicates the amount the actual result is off
     * (since we floor the result to stay inside the ff).
     *
     * Some assertions are hard-failing, because they represent malicious
     * witness values
     *
     * @returns sqrt: The non-overflowing sqrt
     * @returns rest: The remainder indicating how far off the result
     * is from the "real" sqrt
     */
    sqrtMod(): {
        sqrt: UInt<BITS>;
        rest: UInt<BITS>;
    };
    /**
     * Wraps sqrtMod() by only returning the sqrt and omitting the rest field.
     */
    sqrtFloor(): UInt<BITS>;
    /**
     * Integer remainder.
     *
     * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
     * `x - z` is divisble by `y`.
     */
    mod(y: UInt<BITS> | bigint | number): UInt<BITS>;
    /**
     * Multiplication with overflow checking.
     */
    mul(y: UInt<BITS> | bigint | number): UInt<BITS>;
    /**
     * Addition with overflow checking.
     */
    add(y: UInt<BITS> | bigint | number): UInt<BITS>;
    /**
     * Subtraction with underflow checking.
     */
    sub(y: UInt<BITS> | bigint | number): UInt<BITS>;
    /**
     * Checks if a {@link UInt} is less than or equal to another one.
     */
    lessThanOrEqual(y: UInt<BITS>): import("o1js/dist/node/lib/provable/bool").Bool;
    /**
     * Asserts that a {@link UInt} is less than or equal to another one.
     */
    assertLessThanOrEqual(y: UInt<BITS>, message?: string): void;
    /**
     *
     * Checks if a {@link UInt} is less than another one.
     */
    lessThan(y: UInt<BITS>): import("o1js/dist/node/lib/provable/bool").Bool;
    /**
     * Asserts that a {@link UInt} is less than another one.
     */
    assertLessThan(y: UInt<BITS>, message?: string): void;
    /**
     * Checks if a {@link UInt} is greater than another one.
     */
    greaterThan(y: UInt<BITS>): import("o1js/dist/node/lib/provable/bool").Bool;
    /**
     * Asserts that a {@link UInt} is greater than another one.
     */
    assertGreaterThan(y: UInt<BITS>, message?: string): void;
    /**
     * Checks if a {@link UInt} is greater than or equal to another one.
     */
    greaterThanOrEqual(y: UInt<BITS>): import("o1js/dist/node/lib/provable/bool").Bool;
    /**
     * Asserts that a {@link UInt} is greater than or equal to another one.
     */
    assertGreaterThanOrEqual(y: UInt<BITS>, message?: string): void;
    /**
     * Checks if a {@link UInt} is equal to another one.
     */
    equals(y: UInt<BITS> | bigint | number): Bool;
    /**
     * Asserts that a {@link UInt} is equal to another one.
     */
    assertEquals(y: UInt<BITS> | bigint | number, message?: string): void;
    /**
     * Turns the {@link UInt} into a o1js {@link UInt64}, asserting that it fits in 32 bits.
     */
    toO1UInt64(): O1UInt64;
    /**
     * Turns the {@link UInt} into a o1js {@link UInt64},
     * clamping to the 64 bits range if it's too large.
     */
    toO1UInt64Clamped(): O1UInt64;
}
export {};
//# sourceMappingURL=UInt.d.ts.map