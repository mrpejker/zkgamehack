import { createTRPCClientProxy } from '@trpc/client';
import { createFlatProxy, createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';
import { contextProps } from '../../internals/context.mjs';
import { getQueryKeyInternal } from '../../internals/getQueryKey.mjs';

const getQueryType = (utilName)=>{
    switch(utilName){
        case 'fetch':
        case 'ensureData':
        case 'prefetch':
        case 'getData':
        case 'setData':
            return 'query';
        case 'fetchInfinite':
        case 'prefetchInfinite':
        case 'getInfiniteData':
        case 'setInfiniteData':
            return 'infinite';
        case 'cancel':
        case 'invalidate':
        case 'refetch':
        case 'reset':
            return 'any';
    }
};
/**
 * @internal
 */ function createRecursiveUtilsProxy(context, key) {
    return createRecursiveProxy((opts)=>{
        const path = [
            key,
            ...opts.path
        ];
        const utilName = path.pop();
        const args = [
            ...opts.args
        ];
        const input = args.shift(); // args can now be spread when input removed
        const queryType = getQueryType(utilName);
        const queryKey = getQueryKeyInternal(path, input, queryType);
        const contextMap = {
            fetch: ()=>context.fetchQuery(queryKey, ...args),
            fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, args[0]),
            prefetch: ()=>context.prefetchQuery(queryKey, ...args),
            prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, args[0]),
            ensureData: ()=>context.ensureQueryData(queryKey, ...args),
            invalidate: ()=>context.invalidateQueries(queryKey, ...args),
            reset: ()=>context.resetQueries(queryKey, ...args),
            refetch: ()=>context.refetchQueries(queryKey, ...args),
            cancel: ()=>context.cancelQuery(queryKey, ...args),
            setData: ()=>{
                context.setQueryData(queryKey, args[0], args[1]);
            },
            setInfiniteData: ()=>{
                context.setInfiniteQueryData(queryKey, args[0], args[1]);
            },
            getData: ()=>context.getQueryData(queryKey),
            getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)
        };
        return contextMap[utilName]();
    });
}
/**
 * @internal
 */ function createReactQueryUtils(context) {
    return createFlatProxy((key)=>{
        const contextName = key;
        if (contextName === 'client') {
            return createTRPCClientProxy(context.client);
        }
        if (contextProps.includes(contextName)) {
            return context[contextName];
        }
        return createRecursiveUtilsProxy(context, key);
    });
}
/**
 * @internal
 */ function createQueryUtilsProxy(context) {
    return createFlatProxy((key)=>{
        return createRecursiveUtilsProxy(context, key);
    });
}

export { createQueryUtilsProxy, createReactQueryUtils, getQueryType };
