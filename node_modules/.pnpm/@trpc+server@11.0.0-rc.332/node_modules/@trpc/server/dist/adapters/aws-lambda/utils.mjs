import { TRPCError } from '../../unstable-core-do-not-import/error/TRPCError.mjs';
import '../../unstable-core-do-not-import/rootConfig.mjs';

/**
 * If you're making an adapter for tRPC and looking at this file for reference, you should import types and functions from `@trpc/server` and `@trpc/server/http`
 *
 * @example
 * ```ts
 * import type { AnyTRPCRouter } from '@trpc/server'
 * import type { HTTPBaseHandlerOptions } from '@trpc/server/http'
 * ```
 */ // @trpc/server
function isPayloadV1(event) {
    return determinePayloadFormat(event) == '1.0';
}
function isPayloadV2(event) {
    return determinePayloadFormat(event) == '2.0';
}
function determinePayloadFormat(event) {
    // https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
    // According to AWS support, version is is extracted from the version property in the event.
    // If there is no version property, then the version is implied as 1.0
    const unknownEvent = event;
    if (typeof unknownEvent.version === 'undefined') {
        return '1.0';
    } else {
        if ([
            '1.0',
            '2.0'
        ].includes(unknownEvent.version)) {
            return unknownEvent.version;
        } else {
            return 'custom';
        }
    }
}
function getHTTPMethod(event) {
    if (isPayloadV1(event)) {
        return event.httpMethod;
    }
    if (isPayloadV2(event)) {
        return event.requestContext.http.method;
    }
    throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE
    });
}
function getPath(event) {
    if (isPayloadV1(event)) {
        if (!event.pathParameters) {
            // Then this event was not triggered by a resource denoted with {proxy+}
            return event.path.split('/').pop() ?? '';
        }
        const matches = event.resource.matchAll(/\{(.*?)\}/g);
        for (const match of matches){
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const group = match[1];
            if (group.includes('+') && event.pathParameters) {
                return event.pathParameters[group.replace('+', '')] ?? '';
            }
        }
        return event.path.slice(1);
    }
    if (isPayloadV2(event)) {
        const matches1 = event.routeKey.matchAll(/\{(.*?)\}/g);
        for (const match1 of matches1){
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const group1 = match1[1];
            if (group1.includes('+') && event.pathParameters) {
                return event.pathParameters[group1.replace('+', '')] ?? '';
            }
        }
        return event.rawPath.slice(1);
    }
    throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE
    });
}
function transformHeaders(headers) {
    const obj = {};
    for (const [key, value] of Object.entries(headers)){
        if (typeof value === 'undefined') {
            continue;
        }
        obj[key] = Array.isArray(value) ? value.join(',') : value;
    }
    return obj;
}
const UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE = 'Custom payload format version not handled by this adapter. Please use either 1.0 or 2.0. More information here' + 'https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html';

export { UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE, getHTTPMethod, getPath, isPayloadV1, isPayloadV2, transformHeaders };
