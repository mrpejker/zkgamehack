import { randomBytes } from 'node:crypto';
import { createWriteStream, statSync, createReadStream } from 'node:fs';
import { mkdir, rm, unlink, stat } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { resolve, dirname, basename, extname } from 'node:path';
import { finished, Readable } from 'node:stream';
import { promisify } from 'node:util';
import { streamSlice } from './streamSlice.mjs';
import { MaxPartSizeExceededError } from './uploadHandler.mjs';

async function readableStreamToString(stream, encoding) {
    const reader = stream.getReader();
    const chunks = [];
    async function read() {
        const { done , value  } = await reader.read();
        if (done) {
            return;
        } else if (value) {
            chunks.push(value);
        }
        await read();
    }
    await read();
    return Buffer.concat(chunks).toString(encoding);
}
const defaultFilePathResolver = ({ filename ,  })=>{
    const ext = filename ? extname(filename) : '';
    return 'upload_' + randomBytes(4).readUInt32LE(0) + ext;
};
async function uniqueFile(filepath) {
    const ext = extname(filepath);
    let uniqueFilepath = filepath;
    for(let i = 1; await stat(uniqueFilepath).then(()=>true).catch(()=>false); i++){
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${new Date().getTime()}${ext}`;
    }
    return uniqueFilepath;
}
function createFileUploadHandler({ directory =tmpdir() , avoidFileConflicts =true , file =defaultFilePathResolver , filter , maxPartSize =3000000  } = {}) {
    return async ({ name , filename , contentType , data  })=>{
        if (!filename || filter && !await filter({
            name,
            filename,
            contentType
        })) {
            return undefined;
        }
        const dir = typeof directory === 'string' ? directory : directory({
            name,
            filename,
            contentType
        });
        if (!dir) {
            return undefined;
        }
        const filedir = resolve(dir);
        const path = typeof file === 'string' ? file : file({
            name,
            filename,
            contentType
        });
        if (!path) {
            return undefined;
        }
        let filepath = resolve(filedir, path);
        if (avoidFileConflicts) {
            filepath = await uniqueFile(filepath);
        }
        await mkdir(dirname(filepath), {
            recursive: true
        }).catch(()=>{});
        const writeFileStream = createWriteStream(filepath);
        let size = 0;
        let deleteFile = false;
        try {
            for await (const chunk of data){
                size += chunk.byteLength;
                if (size > maxPartSize) {
                    deleteFile = true;
                    throw new MaxPartSizeExceededError(name, maxPartSize);
                }
                writeFileStream.write(chunk);
            }
        } finally{
            writeFileStream.end();
            await promisify(finished)(writeFileStream);
            if (deleteFile) {
                await rm(filepath).catch(()=>{});
            }
        }
        return new NodeOnDiskFile(filepath, contentType);
    };
}
let _toStringTag = Symbol.toStringTag;
class NodeOnDiskFile {
    get size() {
        const stats = statSync(this.filepath);
        if (this.slicer) {
            const slice = this.slicer.end - this.slicer.start;
            return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
    }
    slice(start, end, type) {
        if (typeof start === 'number' && start < 0) start = this.size + start;
        if (typeof end === 'number' && end < 0) end = this.size + end;
        const startOffset = this.slicer?.start ?? 0;
        start = startOffset + (start ?? 0);
        end = startOffset + (end ?? this.size);
        return new NodeOnDiskFile(this.filepath, typeof type === 'string' ? type : this.type, {
            start,
            end
        });
    }
    async arrayBuffer() {
        let stream = createReadStream(this.filepath);
        if (this.slicer) {
            stream = stream.pipe(streamSlice(this.slicer.start, this.slicer.end));
        }
        return new Promise((resolve, reject)=>{
            const buf = [];
            stream.on('data', (chunk)=>buf.push(chunk));
            stream.on('end', ()=>{
                resolve(Buffer.concat(buf));
            });
            stream.on('error', (err)=>{
                reject(err);
            });
        });
    }
    stream() {
        let stream = createReadStream(this.filepath);
        if (this.slicer) {
            stream = stream.pipe(streamSlice(this.slicer.start, this.slicer.end));
        }
        return Readable.toWeb(stream);
    }
    async text() {
        return readableStreamToString(this.stream());
    }
    remove() {
        return unlink(this.filepath);
    }
    getFilePath() {
        return this.filepath;
    }
    constructor(filepath, type, slicer){
        this.filepath = filepath;
        this.type = type;
        this.slicer = slicer;
        this.lastModified = 0;
        this.webkitRelativePath = '';
        this[_toStringTag] = 'File';
        this.name = basename(filepath);
    }
}

export { NodeOnDiskFile, createFileUploadHandler, readableStreamToString };
