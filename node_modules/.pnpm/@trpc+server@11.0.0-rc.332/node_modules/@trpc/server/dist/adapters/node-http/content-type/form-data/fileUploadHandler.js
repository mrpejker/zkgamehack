'use strict';

var node_crypto = require('node:crypto');
var node_fs = require('node:fs');
var fs = require('node:fs/promises');
var node_os = require('node:os');
var node_path = require('node:path');
var node_stream = require('node:stream');
var node_util = require('node:util');
var streamSlice = require('./streamSlice.js');
var uploadHandler = require('./uploadHandler.js');

async function readableStreamToString(stream, encoding) {
    const reader = stream.getReader();
    const chunks = [];
    async function read() {
        const { done , value  } = await reader.read();
        if (done) {
            return;
        } else if (value) {
            chunks.push(value);
        }
        await read();
    }
    await read();
    return Buffer.concat(chunks).toString(encoding);
}
const defaultFilePathResolver = ({ filename ,  })=>{
    const ext = filename ? node_path.extname(filename) : '';
    return 'upload_' + node_crypto.randomBytes(4).readUInt32LE(0) + ext;
};
async function uniqueFile(filepath) {
    const ext = node_path.extname(filepath);
    let uniqueFilepath = filepath;
    for(let i = 1; await fs.stat(uniqueFilepath).then(()=>true).catch(()=>false); i++){
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${new Date().getTime()}${ext}`;
    }
    return uniqueFilepath;
}
function createFileUploadHandler({ directory =node_os.tmpdir() , avoidFileConflicts =true , file =defaultFilePathResolver , filter , maxPartSize =3000000  } = {}) {
    return async ({ name , filename , contentType , data  })=>{
        if (!filename || filter && !await filter({
            name,
            filename,
            contentType
        })) {
            return undefined;
        }
        const dir = typeof directory === 'string' ? directory : directory({
            name,
            filename,
            contentType
        });
        if (!dir) {
            return undefined;
        }
        const filedir = node_path.resolve(dir);
        const path = typeof file === 'string' ? file : file({
            name,
            filename,
            contentType
        });
        if (!path) {
            return undefined;
        }
        let filepath = node_path.resolve(filedir, path);
        if (avoidFileConflicts) {
            filepath = await uniqueFile(filepath);
        }
        await fs.mkdir(node_path.dirname(filepath), {
            recursive: true
        }).catch(()=>{});
        const writeFileStream = node_fs.createWriteStream(filepath);
        let size = 0;
        let deleteFile = false;
        try {
            for await (const chunk of data){
                size += chunk.byteLength;
                if (size > maxPartSize) {
                    deleteFile = true;
                    throw new uploadHandler.MaxPartSizeExceededError(name, maxPartSize);
                }
                writeFileStream.write(chunk);
            }
        } finally{
            writeFileStream.end();
            await node_util.promisify(node_stream.finished)(writeFileStream);
            if (deleteFile) {
                await fs.rm(filepath).catch(()=>{});
            }
        }
        return new NodeOnDiskFile(filepath, contentType);
    };
}
let _toStringTag = Symbol.toStringTag;
class NodeOnDiskFile {
    get size() {
        const stats = node_fs.statSync(this.filepath);
        if (this.slicer) {
            const slice = this.slicer.end - this.slicer.start;
            return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
    }
    slice(start, end, type) {
        if (typeof start === 'number' && start < 0) start = this.size + start;
        if (typeof end === 'number' && end < 0) end = this.size + end;
        const startOffset = this.slicer?.start ?? 0;
        start = startOffset + (start ?? 0);
        end = startOffset + (end ?? this.size);
        return new NodeOnDiskFile(this.filepath, typeof type === 'string' ? type : this.type, {
            start,
            end
        });
    }
    async arrayBuffer() {
        let stream = node_fs.createReadStream(this.filepath);
        if (this.slicer) {
            stream = stream.pipe(streamSlice.streamSlice(this.slicer.start, this.slicer.end));
        }
        return new Promise((resolve, reject)=>{
            const buf = [];
            stream.on('data', (chunk)=>buf.push(chunk));
            stream.on('end', ()=>{
                resolve(Buffer.concat(buf));
            });
            stream.on('error', (err)=>{
                reject(err);
            });
        });
    }
    stream() {
        let stream = node_fs.createReadStream(this.filepath);
        if (this.slicer) {
            stream = stream.pipe(streamSlice.streamSlice(this.slicer.start, this.slicer.end));
        }
        return node_stream.Readable.toWeb(stream);
    }
    async text() {
        return readableStreamToString(this.stream());
    }
    remove() {
        return fs.unlink(this.filepath);
    }
    getFilePath() {
        return this.filepath;
    }
    constructor(filepath, type, slicer){
        this.filepath = filepath;
        this.type = type;
        this.slicer = slicer;
        this.lastModified = 0;
        this.webkitRelativePath = '';
        this[_toStringTag] = 'File';
        this.name = node_path.basename(filepath);
    }
}

exports.NodeOnDiskFile = NodeOnDiskFile;
exports.createFileUploadHandler = createFileUploadHandler;
exports.readableStreamToString = readableStreamToString;
