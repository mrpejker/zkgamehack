import * as fs from 'node:fs/promises';
import { Readable } from 'node:stream';
import { streamMultipart } from '@web3-storage/multipart-parser';
import { createNodeHTTPContentTypeHandler } from '../../internals/contentType.mjs';
import { NodeOnDiskFile } from './fileUploadHandler.mjs';
export { createFileUploadHandler as experimental_createFileUploadHandler } from './fileUploadHandler.mjs';
import { MaxBodySizeExceededError } from './uploadHandler.mjs';
export { MaxPartSizeExceededError, composeUploadHandlers as experimental_composeUploadHandlers } from './uploadHandler.mjs';
export { createMemoryUploadHandler as experimental_createMemoryUploadHandler } from './memoryUploadHandler.mjs';

const utfTextDecoder = new TextDecoder('utf-8');
/**
 * Allows you to handle multipart forms (file uploads) for your app.
 * Request body parts with a 'filename' property will be treated as files.
 * The rest will be treated as text.
 * @param request The incoming Node HTTP request
 * @param uploadHandler A function that handles file uploads and returns a value to be used in the request body. If uploaded to disk, the returned value is a NodeOnDiskFile. If uploaded to memory, the returned value is a File.
 * @param maxBodySize The maximum size of the request body in bytes. Defaults to Infinity.
 *
 * @link https://remix.run/utils/parse-multipart-form-data
 */ async function parseMultipartFormData(request, uploadHandler, maxBodySize = Infinity) {
    const contentType = request.headers['content-type'] ?? '';
    const [type, boundary] = contentType.split(/\s*;\s*boundary=/);
    if (!boundary || type !== 'multipart/form-data') {
        throw new TypeError('Could not parse content as FormData.');
    }
    const formData = new FormData();
    const parts = streamMultipart(Readable.toWeb(request), boundary);
    let currentBodySize = 0;
    const nodeOnDiskFiles = [];
    try {
        for await (const part of parts){
            if (part.done) break;
            if (typeof part.filename === 'string') {
                // This is a file, so the uploadHandler function will be called
                // only pass basename as the multipart/form-data spec recommends
                // https://datatracker.ietf.org/doc/html/rfc7578#section-4.2
                part.filename = part.filename.split(/[/\\]/).pop();
                const value = await uploadHandler(part);
                if (typeof value === 'undefined' || value === null) {
                    continue;
                }
                // add to cleanup array in case of error
                if (value instanceof NodeOnDiskFile) {
                    nodeOnDiskFiles.push(value);
                }
                // if the combined size of the body exceeds the max size, throw an error
                currentBodySize += value.size;
                if (currentBodySize > maxBodySize) {
                    throw new MaxBodySizeExceededError(maxBodySize);
                }
                // add the file to the form data
                formData.append(part.name, value);
            } else {
                // This is text, so we'll decode it and add it to the form data
                let textualPart = '';
                for await (const chunk of part.data){
                    // if the combined size of the body exceeds the max size, throw an error
                    currentBodySize += chunk.length;
                    if (currentBodySize > maxBodySize) {
                        throw new MaxBodySizeExceededError(maxBodySize);
                    }
                    textualPart += utfTextDecoder.decode(chunk);
                }
                // add the text to the form data
                formData.append(part.name, textualPart);
            }
        }
        return formData;
    } catch (e) {
        // clean up any files that were uploaded to disk if an error occurs
        await Promise.all(nodeOnDiskFiles.map((file)=>fs.unlink(file.getFilePath())));
        throw e;
    }
}
function isMultipartFormDataRequest(req) {
    const contentTypeHeader = req.headers['content-type'];
    return contentTypeHeader?.startsWith('multipart/form-data') ?? contentTypeHeader === 'application/x-www-form-urlencoded';
}
const nodeHTTPFormDataContentTypeHandler = createNodeHTTPContentTypeHandler({
    isMatch (opts) {
        return isMultipartFormDataRequest(opts.req);
    },
    async getBody (opts) {
        const fields = Object.fromEntries(opts.query);
        return {
            ok: true,
            data: fields,
            preprocessed: false
        };
    },
    getInputs (opts) {
        const req = opts.req;
        const unparsedInput = req.query.get('input');
        if (!unparsedInput) {
            return {
                0: undefined
            };
        }
        const transformer = opts.router._def._config.transformer;
        const deserializedInput = transformer.input.deserialize(JSON.parse(unparsedInput));
        return {
            0: deserializedInput
        };
    }
});

export { MaxBodySizeExceededError, NodeOnDiskFile as experimental_NodeOnDiskFile, isMultipartFormDataRequest as experimental_isMultipartFormDataRequest, parseMultipartFormData as experimental_parseMultipartFormData, nodeHTTPFormDataContentTypeHandler };
