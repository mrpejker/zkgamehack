'use strict';

var TRPCError = require('../../unstable-core-do-not-import/error/TRPCError.js');
var resolveHTTPResponse = require('../../unstable-core-do-not-import/http/resolveHTTPResponse.js');
require('../../unstable-core-do-not-import/rootConfig.js');
var utils = require('./utils.js');

/**
 * If you're making an adapter for tRPC and looking at this file for reference, you should import types and functions from `@trpc/server` and `@trpc/server/http`
 *
 * @example
 * ```ts
 * import type { AnyTRPCRouter } from '@trpc/server'
 * import type { HTTPBaseHandlerOptions } from '@trpc/server/http'
 * ```
 */ // @trpc/server
function lambdaEventToHTTPRequest(event) {
    const query = new URLSearchParams();
    for (const [key, value] of Object.entries(event.queryStringParameters ?? {})){
        if (typeof value !== 'undefined') {
            query.append(key, value);
        }
    }
    let body;
    if (event.body && event.isBase64Encoded) {
        body = Buffer.from(event.body, 'base64').toString('utf8');
    } else {
        body = event.body;
    }
    return {
        method: utils.getHTTPMethod(event),
        query: query,
        headers: event.headers,
        body: body
    };
}
function tRPCOutputToAPIGatewayOutput(event, response) {
    if (utils.isPayloadV1(event)) {
        const resp = {
            statusCode: response.status,
            body: response.body ?? '',
            headers: utils.transformHeaders(response.headers ?? {})
        };
        return resp;
    } else if (utils.isPayloadV2(event)) {
        const resp1 = {
            statusCode: response.status,
            body: response.body ?? undefined,
            headers: utils.transformHeaders(response.headers ?? {})
        };
        return resp1;
    } else {
        throw new TRPCError.TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: utils.UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE
        });
    }
}
function awsLambdaRequestHandler(opts) {
    return async (event, context)=>{
        const req = lambdaEventToHTTPRequest(event);
        const path = utils.getPath(event);
        const createContext = async (innerOpts)=>{
            return await opts.createContext?.({
                event,
                context,
                ...innerOpts
            });
        };
        const response = await resolveHTTPResponse.resolveHTTPResponse({
            ...opts,
            createContext,
            req,
            path,
            error: null,
            onError (o) {
                opts?.onError?.({
                    ...o,
                    req: event
                });
            }
        });
        return tRPCOutputToAPIGatewayOutput(event, response);
    };
}

exports.UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE = utils.UNKNOWN_PAYLOAD_FORMAT_VERSION_ERROR_MESSAGE;
exports.getHTTPMethod = utils.getHTTPMethod;
exports.getPath = utils.getPath;
exports.isPayloadV1 = utils.isPayloadV1;
exports.isPayloadV2 = utils.isPayloadV2;
exports.transformHeaders = utils.transformHeaders;
exports.awsLambdaRequestHandler = awsLambdaRequestHandler;
