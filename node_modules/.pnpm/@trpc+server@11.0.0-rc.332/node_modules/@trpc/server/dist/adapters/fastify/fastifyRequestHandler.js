'use strict';

var node_stream = require('node:stream');
var resolveHTTPResponse = require('../../unstable-core-do-not-import/http/resolveHTTPResponse.js');
var batchStreamFormatter = require('../../unstable-core-do-not-import/http/batchStreamFormatter.js');
require('../../unstable-core-do-not-import/rootConfig.js');

async function fastifyRequestHandler(opts) {
    const createContext = async (innerOpts)=>{
        return await opts.createContext?.({
            ...opts,
            ...innerOpts
        });
    };
    const query = opts.req.query ? new URLSearchParams(opts.req.query) : new URLSearchParams(opts.req.url.split('?')[1]);
    const req = {
        query,
        method: opts.req.method,
        headers: opts.req.headers,
        body: opts.req.body ?? 'null'
    };
    let resolve;
    const promise = new Promise((r)=>resolve = r);
    let isStream = false;
    let stream;
    let formatter;
    const unstable_onHead = (head, isStreaming)=>{
        if (!opts.res.statusCode || opts.res.statusCode === 200) {
            opts.res.statusCode = head.status;
        }
        for (const [key, value] of Object.entries(head.headers ?? {})){
            /* istanbul ignore if -- @preserve */ if (typeof value === 'undefined') {
                continue;
            }
            void opts.res.header(key, value);
        }
        if (isStreaming) {
            void opts.res.header('Transfer-Encoding', 'chunked');
            void opts.res.header('Vary', opts.res.hasHeader('Vary') ? 'trpc-batch-mode, ' + opts.res.getHeader('Vary') : 'trpc-batch-mode');
            stream = new node_stream.Readable();
            stream._read = ()=>{}; // eslint-disable-line @typescript-eslint/no-empty-function -- https://github.com/fastify/fastify/issues/805#issuecomment-369172154
            resolve(opts.res.send(stream));
            isStream = true;
            formatter = batchStreamFormatter.getBatchStreamFormatter();
        }
    };
    const unstable_onChunk = ([index, string])=>{
        if (index === -1) {
            // full response, no streaming
            resolve(opts.res.send(string));
        } else {
            stream.push(formatter(index, string));
        }
    };
    resolveHTTPResponse.resolveHTTPResponse({
        ...opts,
        req,
        createContext,
        onError (o) {
            opts?.onError?.({
                ...o,
                req: opts.req
            });
        },
        unstable_onHead,
        unstable_onChunk
    }).then(()=>{
        if (isStream) {
            stream.push(formatter.end());
            stream.push(null); // https://github.com/fastify/fastify/issues/805#issuecomment-369172154
        }
    }).catch(()=>{
        if (isStream) {
            stream.push(null);
        }
    });
    return promise;
}

exports.fastifyRequestHandler = fastifyRequestHandler;
