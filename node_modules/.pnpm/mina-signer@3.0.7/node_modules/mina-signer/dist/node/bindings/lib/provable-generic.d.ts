import { GenericHashInput, GenericProvable, GenericProvablePure, GenericProvableExtended, GenericProvableExtendedPure, GenericSignable } from './generic.js';
export { createDerivers, createHashInput, ProvableConstructor, SignableConstructor, NonMethods, InferProvable, InferJson, InferValue, InferredProvable, IsPure, From, Constructor, };
type ProvableConstructor<Field> = <A>(typeObj: A, options?: {
    isPure?: boolean;
}) => InferredProvable<A, Field>;
type SignableConstructor<Field> = <A>(typeObj: A) => InferredSignable<A, Field>;
declare function createDerivers<Field>(): {
    provable: ProvableConstructor<Field>;
    signable: SignableConstructor<Field>;
};
declare function createHashInput<Field>(): {
    readonly empty: {};
    append(input1: GenericHashInput<Field>, input2: GenericHashInput<Field>): GenericHashInput<Field>;
};
type JSONValue = number | string | boolean | null | Array<JSONValue> | {
    [key: string]: JSONValue;
};
type Struct<T, Field> = GenericProvableExtended<NonMethods<T>, any, any, Field> & Constructor<T> & {
    _isStruct: true;
};
type NonMethodKeys<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonMethods<T> = Pick<T, NonMethodKeys<T>>;
type Constructor<T> = new (...args: any) => T;
type Tuple<T> = [T, ...T[]] | [];
type Primitive = typeof String | typeof Number | typeof Boolean | typeof BigInt | null | undefined;
type InferPrimitive<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? bigint : P extends null ? null : P extends undefined ? undefined : any;
type InferPrimitiveValue<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? bigint : P extends null ? null : P extends undefined ? undefined : any;
type InferPrimitiveJson<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? string : P extends null ? null : P extends undefined ? null : JSONValue;
type InferProvable<A, Field> = A extends Constructor<infer U> ? A extends GenericProvable<U, any, Field> ? U : A extends Struct<U, Field> ? U : InferProvableBase<A, Field> : InferProvableBase<A, Field>;
type InferProvableBase<A, Field> = A extends GenericProvable<infer U, any, Field> ? U : A extends Primitive ? InferPrimitive<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferProvable<A[I], Field>;
} : A extends (infer U)[] ? InferProvable<U, Field>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferProvable<A[K], Field>;
} : never;
type InferValue<A> = A extends GenericProvable<any, infer U, any> ? U : A extends Primitive ? InferPrimitiveValue<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferValue<A[I]>;
} : A extends (infer U)[] ? InferValue<U>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferValue<A[K]>;
} : never;
type WithJson<J> = {
    toJSON: (x: any) => J;
};
type InferJson<A> = A extends WithJson<infer J> ? J : A extends Primitive ? InferPrimitiveJson<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferJson<A[I]>;
} : A extends WithJson<infer U>[] ? U[] : A extends Record<any, any> ? {
    [K in keyof A]: InferJson<A[K]>;
} : JSONValue;
type IsPure<A, Field> = IsPureBase<A, Field> extends true ? true : false;
type IsPureBase<A, Field> = A extends GenericProvablePure<any, any, Field> ? true : A extends GenericProvable<any, any, Field> ? false : A extends Primitive ? false : A extends (infer U)[] ? IsPure<U, Field> : A extends Record<any, any> ? {
    [K in keyof A]: IsPure<A[K], Field>;
}[keyof A] : false;
type InferredProvable<A, Field> = IsPure<A, Field> extends true ? GenericProvableExtendedPure<InferProvable<A, Field>, InferValue<A>, InferJson<A>, Field> : GenericProvableExtended<InferProvable<A, Field>, InferValue<A>, InferJson<A>, Field>;
type InferSignable<A, Field> = A extends GenericSignable<infer U, any, Field> ? U : A extends Primitive ? InferPrimitive<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferSignable<A[I], Field>;
} : A extends (infer U)[] ? InferSignable<U, Field>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferSignable<A[K], Field>;
} : never;
type InferredSignable<A, Field> = GenericSignable<InferSignable<A, Field>, InferJson<A>, Field>;
type From<A> = A extends {
    fromValue: (x: infer U) => any;
} & GenericProvable<any, any, any> ? U | InferProvable<A, any> : A extends GenericProvable<any, any, any> ? InferProvable<A, any> | InferValue<A> : A extends Primitive ? InferPrimitiveValue<A> : A extends Tuple<any> ? {
    [I in keyof A]: From<A[I]>;
} : A extends (infer U)[] ? From<U>[] : A extends Record<any, any> ? {
    [K in keyof A]: From<A[K]>;
} : never;
