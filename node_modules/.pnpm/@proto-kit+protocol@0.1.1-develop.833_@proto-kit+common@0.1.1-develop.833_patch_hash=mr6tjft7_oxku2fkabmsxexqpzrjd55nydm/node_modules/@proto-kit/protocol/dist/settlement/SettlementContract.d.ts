import { AccountUpdate, Field, Proof, PublicKey, Signature, SmartContract, State, UInt32, UInt64 } from "o1js";
import { RollupMerkleTreeWitness } from "@proto-kit/common";
import { ProtocolModule } from "../protocol/ProtocolModule";
import { BlockProvable, BlockProverPublicInput, BlockProverPublicOutput } from "../prover/block/BlockProvable";
import { NetworkState } from "../model/network/NetworkState";
import { ProvableSettlementHook } from "./ProvableSettlementHook";
declare class LazyBlockProof extends Proof<BlockProverPublicInput, BlockProverPublicOutput> {
    static publicInputType: typeof BlockProverPublicInput;
    static publicOutputType: typeof BlockProverPublicOutput;
    static tag: () => {
        name: string;
    };
}
export type SettlementMethodIdMapping = Record<`${string}.${string}`, bigint>;
declare const Deposit_base: (new (value: {
    address: PublicKey;
    amount: UInt64;
}) => {
    address: PublicKey;
    amount: UInt64;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    address: PublicKey;
    amount: UInt64;
}> & {
    toInput: (x: {
        address: PublicKey;
        amount: UInt64;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        address: PublicKey;
        amount: UInt64;
    }) => {
        address: string;
        amount: string;
    };
    fromJSON: (x: {
        address: string;
        amount: string;
    }) => {
        address: PublicKey;
        amount: UInt64;
    };
};
export declare class Deposit extends Deposit_base {
}
declare const Withdrawal_base: (new (value: {
    address: PublicKey;
    amount: UInt64;
}) => {
    address: PublicKey;
    amount: UInt64;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    address: PublicKey;
    amount: UInt64;
}> & {
    toInput: (x: {
        address: PublicKey;
        amount: UInt64;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        address: PublicKey;
        amount: UInt64;
    }) => {
        address: string;
        amount: string;
    };
    fromJSON: (x: {
        address: string;
        amount: string;
    }) => {
        address: PublicKey;
        amount: UInt64;
    };
};
export declare class Withdrawal extends Withdrawal_base {
    static dummy(): Withdrawal;
}
export declare const OUTGOING_MESSAGE_BATCH_SIZE = 1;
declare const OutgoingMessageArgument_base: (new (value: {
    witness: RollupMerkleTreeWitness;
    value: Withdrawal;
}) => {
    witness: RollupMerkleTreeWitness;
    value: Withdrawal;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    witness: RollupMerkleTreeWitness;
    value: Withdrawal;
}> & {
    toInput: (x: {
        witness: RollupMerkleTreeWitness;
        value: Withdrawal;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        witness: RollupMerkleTreeWitness;
        value: Withdrawal;
    }) => {
        witness: {
            path: string[];
            isLeft: boolean[];
        };
        value: {
            address: string;
            amount: string;
        };
    };
    fromJSON: (x: {
        witness: {
            path: string[];
            isLeft: boolean[];
        };
        value: {
            address: string;
            amount: string;
        };
    }) => {
        witness: RollupMerkleTreeWitness;
        value: Withdrawal;
    };
};
export declare class OutgoingMessageArgument extends OutgoingMessageArgument_base {
    static dummy(): OutgoingMessageArgument;
}
declare const OutgoingMessageArgumentBatch_base: (new (value: {
    arguments: OutgoingMessageArgument[];
    isDummys: import("o1js/dist/node/lib/bool").Bool[];
}) => {
    arguments: OutgoingMessageArgument[];
    isDummys: import("o1js/dist/node/lib/bool").Bool[];
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    arguments: OutgoingMessageArgument[];
    isDummys: import("o1js/dist/node/lib/bool").Bool[];
}> & {
    toInput: (x: {
        arguments: OutgoingMessageArgument[];
        isDummys: import("o1js/dist/node/lib/bool").Bool[];
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        arguments: OutgoingMessageArgument[];
        isDummys: import("o1js/dist/node/lib/bool").Bool[];
    }) => {
        arguments: {
            witness: {
                path: string[];
                isLeft: boolean[];
            };
            value: {
                address: string;
                amount: string;
            };
        }[];
        isDummys: boolean[];
    };
    fromJSON: (x: {
        arguments: {
            witness: {
                path: string[];
                isLeft: boolean[];
            };
            value: {
                address: string;
                amount: string;
            };
        }[];
        isDummys: boolean[];
    }) => {
        arguments: OutgoingMessageArgument[];
        isDummys: import("o1js/dist/node/lib/bool").Bool[];
    };
};
export declare class OutgoingMessageArgumentBatch extends OutgoingMessageArgumentBatch_base {
    static fromMessages(providedArguments: OutgoingMessageArgument[]): OutgoingMessageArgumentBatch;
}
export declare const BATCH_SIGNATURE_PREFIX: import("o1js/dist/node/lib/field").Field;
export declare const ACTIONS_EMPTY_HASH: import("o1js/dist/node/lib/field").Field;
export declare class SettlementContract extends SmartContract {
    private readonly methodIdMappings;
    private readonly hooks;
    private readonly withdrawalStatePath;
    private readonly incomingMessagesPaths;
    private readonly escapeHatchSlotsInterval;
    sequencerKey: State<import("o1js/dist/node/lib/field").Field>;
    lastSettlementL1Block: State<UInt32>;
    stateRoot: State<import("o1js/dist/node/lib/field").Field>;
    networkStateHash: State<import("o1js/dist/node/lib/field").Field>;
    blockHashRoot: State<import("o1js/dist/node/lib/field").Field>;
    promisedMessagesHash: State<import("o1js/dist/node/lib/field").Field>;
    honoredMessagesHash: State<import("o1js/dist/node/lib/field").Field>;
    outgoingMessageCursor: State<import("o1js/dist/node/lib/field").Field>;
    constructor(address: PublicKey, methodIdMappings: Record<string, bigint>, hooks: ProvableSettlementHook<unknown>[], withdrawalStatePath: [string, string], incomingMessagesPaths: Record<string, `${string}.${string}`>, escapeHatchSlotsInterval?: number);
    initialize(sequencer: PublicKey): void;
    settle(blockProof: LazyBlockProof, signature: Signature, publicKey: PublicKey, inputNetworkState: NetworkState, outputNetworkState: NetworkState, newPromisedMessagesHash: Field): void;
    private dispatchMessage;
    deposit(amount: UInt64): void;
    rollupOutgoingMessages(batch: OutgoingMessageArgumentBatch): void;
    redeem(additionUpdate: AccountUpdate): void;
}
export interface SettlementContractModuleConfig {
    withdrawalStatePath: `${string}.${string}`;
    withdrawalMethodPath: `${string}.${string}`;
    incomingMessagesMethods: Record<string, `${string}.${string}`>;
}
export declare class SettlementContractModule extends ProtocolModule<SettlementContractModuleConfig> {
    private readonly hooks;
    private readonly blockProver;
    constructor(hooks: ProvableSettlementHook<unknown>[], blockProver: BlockProvable);
    getContractClass(): typeof SettlementContract;
    createContract(address: PublicKey, methodIdMappings: SettlementMethodIdMapping): SettlementContract;
}
export {};
//# sourceMappingURL=SettlementContract.d.ts.map