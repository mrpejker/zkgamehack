var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { prefixToField, RollupMerkleTree, mapSequential, } from "@proto-kit/common";
import { AccountUpdate, Bool, Field, method, Mina, Poseidon, Proof, Provable, PublicKey, Signature, State, state, TokenId, UInt32, UInt64, TokenContract, AccountUpdateForest, } from "o1js";
import { NetworkState } from "../../model/network/NetworkState";
import { Path } from "../../model/Path";
import { BlockHashMerkleTree } from "../../prover/block/accummulators/BlockHashMerkleTree";
import { BlockProverPublicInput, BlockProverPublicOutput, } from "../../prover/block/BlockProvable";
import { OUTGOING_MESSAGE_BATCH_SIZE, OutgoingMessageArgumentBatch, } from "../messages/OutgoingMessageArgument";
import { Withdrawal } from "../messages/Withdrawal";
/* eslint-disable @typescript-eslint/lines-between-class-members */
export class LazyBlockProof extends Proof {
}
LazyBlockProof.publicInputType = BlockProverPublicInput;
LazyBlockProof.publicOutputType = BlockProverPublicOutput;
LazyBlockProof.tag = () => {
    throw new Error("Tag not initialized yet");
};
// Some random prefix for the sequencer signature
export const BATCH_SIGNATURE_PREFIX = prefixToField("pk-batchSignature");
export class SettlementSmartContract extends TokenContract {
    constructor() {
        super(...arguments);
        this.sequencerKey = State();
        this.lastSettlementL1Block = State();
        this.stateRoot = State();
        this.networkStateHash = State();
        this.blockHashRoot = State();
        this.dispatchContractAddressX = State();
        this.outgoingMessageCursor = State();
    }
    async approveBase(forest) {
        this.checkZeroBalanceChange(forest);
    }
    async initialize(sequencer, dispatchContract) {
        this.sequencerKey.getAndRequireEquals().assertEquals(Field(0));
        this.stateRoot.getAndRequireEquals().assertEquals(Field(0));
        this.blockHashRoot.getAndRequireEquals().assertEquals(Field(0));
        this.networkStateHash.getAndRequireEquals().assertEquals(Field(0));
        this.dispatchContractAddressX.getAndRequireEquals().assertEquals(Field(0));
        this.sequencerKey.set(sequencer.x);
        this.stateRoot.set(Field(RollupMerkleTree.EMPTY_ROOT));
        this.blockHashRoot.set(Field(BlockHashMerkleTree.EMPTY_ROOT));
        this.networkStateHash.set(NetworkState.empty().hash());
        this.dispatchContractAddressX.set(dispatchContract.x);
        const { DispatchContract } = SettlementSmartContract.args;
        await new DispatchContract(dispatchContract).initialize(this.address);
    }
    async settle(blockProof, signature, dispatchContractAddress, publicKey, inputNetworkState, outputNetworkState, newPromisedMessagesHash) {
        // Verify the blockproof
        blockProof.verify();
        // Get and assert on-chain values
        const stateRoot = this.stateRoot.getAndRequireEquals();
        const networkStateHash = this.networkStateHash.getAndRequireEquals();
        const blockHashRoot = this.blockHashRoot.getAndRequireEquals();
        const sequencerKey = this.sequencerKey.getAndRequireEquals();
        const lastSettlementL1Block = this.lastSettlementL1Block.getAndRequireEquals();
        const onChainDispatchContractAddressX = this.dispatchContractAddressX.getAndRequireEquals();
        onChainDispatchContractAddressX.assertEquals(dispatchContractAddress.x, "DispatchContract address not provided correctly");
        const { DispatchContract, escapeHatchSlotsInterval, hooks } = SettlementSmartContract.args;
        // Get dispatch contract values
        // These values are witnesses but will be checked later on the AU
        // call to the dispatch contract via .updateMessagesHash()
        const dispatchContract = new DispatchContract(dispatchContractAddress);
        const promisedMessagesHash = dispatchContract.promisedMessagesHash.get();
        // Get block height and use the lower bound for all ops
        const minBlockIncluded = this.network.globalSlotSinceGenesis.get();
        this.network.globalSlotSinceGenesis.requireBetween(minBlockIncluded, 
        // 5 because that is the length the newPromisedMessagesHash will be valid
        minBlockIncluded.add(4));
        // Check signature/escape catch
        publicKey.x.assertEquals(sequencerKey, "Sequencer public key witness not matching");
        const signatureValid = signature.verify(publicKey, [
            BATCH_SIGNATURE_PREFIX,
            lastSettlementL1Block.value,
        ]);
        const escapeHatchActivated = lastSettlementL1Block
            .add(UInt32.from(escapeHatchSlotsInterval))
            .lessThan(minBlockIncluded);
        signatureValid
            .or(escapeHatchActivated)
            .assertTrue("Sequencer signature not valid and escape hatch not activated");
        // Assert correctness of networkState witness
        Provable.log("Network State Hash ", networkStateHash);
        Provable.log("input Hash ", inputNetworkState.hash());
        Provable.log("equals ", inputNetworkState.hash().equals(networkStateHash));
        inputNetworkState
            .hash()
            .assertEquals(networkStateHash, "InputNetworkState witness not valid");
        outputNetworkState
            .hash()
            .assertEquals(blockProof.publicOutput.networkStateHash, "OutputNetworkState witness not valid");
        blockProof.publicOutput.closed.assertEquals(Bool(true), "Supplied proof is not a closed BlockProof");
        // Execute onSettlementHooks for additional checks
        const stateRecord = {
            blockHashRoot,
            stateRoot,
            networkStateHash,
            lastSettlementL1Block,
            sequencerKey: publicKey,
        };
        const inputs = {
            blockProof,
            contractState: stateRecord,
            newPromisedMessagesHash,
            fromNetworkState: inputNetworkState,
            toNetworkState: outputNetworkState,
            currentL1Block: minBlockIncluded,
        };
        await mapSequential(hooks, async (hook) => {
            await hook.beforeSettlement(this, inputs);
        });
        // Apply blockProof
        stateRoot.assertEquals(blockProof.publicInput.stateRoot, "Input state root not matching");
        Provable.log("Network State Hash ", networkStateHash);
        Provable.log("input Hash ", inputNetworkState.hash());
        Provable.log("Proof Hash ", blockProof.publicInput.networkStateHash);
        networkStateHash.assertEquals(blockProof.publicInput.networkStateHash, "Input networkStateHash not matching");
        blockHashRoot.assertEquals(blockProof.publicInput.blockHashRoot, "Input blockHashRoot not matching");
        this.stateRoot.set(blockProof.publicOutput.stateRoot);
        this.networkStateHash.set(blockProof.publicOutput.networkStateHash);
        this.blockHashRoot.set(blockProof.publicOutput.blockHashRoot);
        // Assert and apply deposit commitments
        promisedMessagesHash.assertEquals(blockProof.publicOutput.incomingMessagesHash, "Promised messages not honored");
        // Call DispatchContract
        // This call checks that the promisedMessagesHash, which is already proven
        // to be the blockProofs publicoutput, is actually the current on-chain
        // promisedMessageHash. It also checks the newPromisedMessagesHash to be
        // a current sequencestate value
        await dispatchContract.updateMessagesHash(promisedMessagesHash, newPromisedMessagesHash);
        this.lastSettlementL1Block.set(minBlockIncluded);
    }
    async rollupOutgoingMessages(batch) {
        let counter = this.outgoingMessageCursor.getAndRequireEquals();
        const stateRoot = this.stateRoot.getAndRequireEquals();
        const [withdrawalModule, withdrawalStateName] = SettlementSmartContract.args.withdrawalStatePath;
        const mapPath = Path.fromProperty(withdrawalModule, withdrawalStateName);
        let accountCreationFeePaid = Field(0);
        for (let i = 0; i < OUTGOING_MESSAGE_BATCH_SIZE; i++) {
            const args = batch.arguments[i];
            // Check witness
            const path = Path.fromKey(mapPath, Field, counter);
            args.witness
                .checkMembership(stateRoot, path, Poseidon.hash(Withdrawal.toFields(args.value)))
                .assertTrue("Provided Withdrawal witness not valid");
            // Process message
            const { address, amount } = args.value;
            const isDummy = address.equals(this.address);
            const tokenAu = this.internal.mint({ address, amount });
            const isNewAccount = tokenAu.account.isNew.getAndRequireEquals();
            tokenAu.body.balanceChange.magnitude =
                tokenAu.body.balanceChange.magnitude.sub(Provable.if(isNewAccount, Mina.getNetworkConstants().accountCreationFee.toConstant(), UInt64.zero));
            accountCreationFeePaid = accountCreationFeePaid.add(Provable.if(isNewAccount, Field(1e9), Field(0)));
            counter = counter.add(Provable.if(isDummy, Field(0), Field(1)));
        }
        this.balance.subInPlace(UInt64.Unsafe.fromField(accountCreationFeePaid));
        this.outgoingMessageCursor.set(counter);
    }
    async redeem(additionUpdate) {
        additionUpdate.body.tokenId.assertEquals(TokenId.default, "Tokenid not default token");
        additionUpdate.body.balanceChange.sgn
            .isPositive()
            .assertTrue("Sign not correct");
        const amount = additionUpdate.body.balanceChange.magnitude;
        // Burn tokens
        this.internal.burn({
            address: additionUpdate.publicKey,
            amount,
        });
        // Send mina
        this.approve(additionUpdate);
        this.balance.subInPlace(amount);
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "sequencerKey", void 0);
__decorate([
    state(UInt32),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "lastSettlementL1Block", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "stateRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "networkStateHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "blockHashRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "dispatchContractAddressX", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementSmartContract.prototype, "outgoingMessageCursor", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AccountUpdateForest]),
    __metadata("design:returntype", Promise)
], SettlementSmartContract.prototype, "approveBase", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey, PublicKey]),
    __metadata("design:returntype", Promise)
], SettlementSmartContract.prototype, "initialize", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [LazyBlockProof,
        Signature,
        PublicKey,
        PublicKey,
        NetworkState,
        NetworkState,
        Field]),
    __metadata("design:returntype", Promise)
], SettlementSmartContract.prototype, "settle", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [OutgoingMessageArgumentBatch]),
    __metadata("design:returntype", Promise)
], SettlementSmartContract.prototype, "rollupOutgoingMessages", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AccountUpdate]),
    __metadata("design:returntype", Promise)
], SettlementSmartContract.prototype, "redeem", null);
/* eslint-enable @typescript-eslint/lines-between-class-members */
