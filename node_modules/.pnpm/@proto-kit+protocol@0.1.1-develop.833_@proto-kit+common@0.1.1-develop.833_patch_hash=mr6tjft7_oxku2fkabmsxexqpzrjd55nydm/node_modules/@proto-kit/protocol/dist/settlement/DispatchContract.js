var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { AccountUpdate, Field, method, Poseidon, PublicKey, Reducer, SmartContract, State, state, UInt64, } from "o1js";
import { RuntimeTransaction } from "../model/transaction/RuntimeTransaction";
import { MinaActions, MinaEvents } from "../utils/MinaPrefixedProvableHashList";
import { Deposit } from "./messages/Deposit";
export const ACTIONS_EMPTY_HASH = Reducer.initialActionState;
export class DispatchContract extends SmartContract {
    constructor(address, methodIdMappings, incomingMessagesPaths) {
        super(address);
        this.methodIdMappings = methodIdMappings;
        this.incomingMessagesPaths = incomingMessagesPaths;
        this.promisedMessagesHash = State();
        this.honoredMessagesHash = State();
        this.settlementContract = State();
    }
    updateMessagesHash(executedMessagesHash, newPromisedMessagesHash) {
        const promisedMessagesHash = this.promisedMessagesHash.getAndAssertEquals();
        this.honoredMessagesHash.getAndAssertEquals();
        executedMessagesHash.assertEquals(promisedMessagesHash);
        this.honoredMessagesHash.set(executedMessagesHash);
        this.self.account.isNew;
        // Assert and apply new promisedMessagesHash
        this.self.account.actionState.assertEquals(newPromisedMessagesHash);
        this.promisedMessagesHash.set(newPromisedMessagesHash);
    }
    initialize(settlementContract) {
        this.promisedMessagesHash.getAndAssertEquals().assertEquals(Field(0));
        this.honoredMessagesHash.getAndAssertEquals().assertEquals(Field(0));
        this.settlementContract
            .getAndAssertEquals()
            .assertEquals(PublicKey.empty());
        this.promisedMessagesHash.set(ACTIONS_EMPTY_HASH);
        this.honoredMessagesHash.set(ACTIONS_EMPTY_HASH);
        this.settlementContract.set(settlementContract);
    }
    dispatchMessage(methodId, value, valueType) {
        const args = valueType.toFields(value);
        // Should be the same as RuntimeTransaction.hash
        const argsHash = Poseidon.hash(args);
        const runtimeTransaction = RuntimeTransaction.fromMessage({
            methodId,
            argsHash,
        });
        // Append tx to incomingMessagesHash
        const actionData = runtimeTransaction.hashData();
        const actionHash = MinaActions.actionHash(actionData);
        this.self.body.actions = {
            hash: actionHash,
            data: [actionData],
        };
        const eventHash = MinaEvents.eventHash(args);
        this.self.body.events = {
            hash: eventHash,
            data: [args],
        };
    }
    deposit(amount) {
        // Save this, since otherwise it would be a second witness later,
        // which could be a different values than the first
        const { sender } = this;
        const settlementContract = this.settlementContract.getAndAssertEquals();
        // Credit the amount to the settlement contract
        const balanceAU = AccountUpdate.create(settlementContract);
        balanceAU.balance.addInPlace(amount);
        this.self.approve(balanceAU);
        const action = new Deposit({
            address: sender,
            amount,
        });
        const methodId = Field(this.methodIdMappings[this.incomingMessagesPaths.deposit]);
        this.dispatchMessage(methodId.toConstant(), action, Deposit);
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], DispatchContract.prototype, "promisedMessagesHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], DispatchContract.prototype, "honoredMessagesHash", void 0);
__decorate([
    state(PublicKey),
    __metadata("design:type", Object)
], DispatchContract.prototype, "settlementContract", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Field,
        Field]),
    __metadata("design:returntype", void 0)
], DispatchContract.prototype, "updateMessagesHash", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey]),
    __metadata("design:returntype", void 0)
], DispatchContract.prototype, "initialize", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UInt64]),
    __metadata("design:returntype", void 0)
], DispatchContract.prototype, "deposit", null);
