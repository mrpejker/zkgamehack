var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { AccountUpdate, Field, method, Poseidon, PublicKey, Reducer, SmartContract, State, state, UInt64, } from "o1js";
import { RuntimeTransaction } from "../../model/transaction/RuntimeTransaction";
import { MinaActions, MinaEvents, } from "../../utils/MinaPrefixedProvableHashList";
import { Deposit } from "../messages/Deposit";
export const ACTIONS_EMPTY_HASH = Reducer.initialActionState;
export class DispatchSmartContract extends SmartContract {
    constructor() {
        super(...arguments);
        this.promisedMessagesHash = State();
        this.honoredMessagesHash = State();
        this.settlementContract = State();
    }
    async updateMessagesHash(executedMessagesHash, newPromisedMessagesHash) {
        const promisedMessagesHash = this.promisedMessagesHash.getAndRequireEquals();
        this.honoredMessagesHash.getAndRequireEquals();
        executedMessagesHash.assertEquals(promisedMessagesHash);
        this.honoredMessagesHash.set(executedMessagesHash);
        // Assert and apply new promisedMessagesHash
        this.self.account.actionState.requireEquals(newPromisedMessagesHash);
        this.promisedMessagesHash.set(newPromisedMessagesHash);
    }
    async initialize(settlementContract) {
        this.promisedMessagesHash.getAndRequireEquals().assertEquals(Field(0));
        this.honoredMessagesHash.getAndRequireEquals().assertEquals(Field(0));
        this.settlementContract
            .getAndRequireEquals()
            .assertEquals(PublicKey.empty());
        this.promisedMessagesHash.set(ACTIONS_EMPTY_HASH);
        this.honoredMessagesHash.set(ACTIONS_EMPTY_HASH);
        this.settlementContract.set(settlementContract);
    }
    dispatchMessage(methodId, value, valueType) {
        const args = valueType.toFields(value);
        // Should be the same as RuntimeTransaction.hash
        const argsHash = Poseidon.hash(args);
        const runtimeTransaction = RuntimeTransaction.fromMessage({
            methodId,
            argsHash,
        });
        // Append tx to incomingMessagesHash
        const actionData = runtimeTransaction.hashData();
        const actionHash = MinaActions.actionHash(actionData);
        this.self.body.actions = {
            hash: actionHash,
            data: [actionData],
        };
        const eventHash = MinaEvents.eventHash(args);
        this.self.body.events = {
            hash: eventHash,
            data: [args],
        };
    }
    async deposit(amount) {
        // Save this, since otherwise it would be a second witness later,
        // which could be a different values than the first
        const sender = this.sender.getUnconstrained();
        const settlementContract = this.settlementContract.getAndRequireEquals();
        // Credit the amount to the settlement contract
        const balanceAU = AccountUpdate.create(settlementContract);
        balanceAU.balance.addInPlace(amount);
        this.self.approve(balanceAU);
        const action = new Deposit({
            address: sender,
            amount,
        });
        const { methodIdMappings, incomingMessagesPaths } = DispatchSmartContract.args;
        const methodId = Field(methodIdMappings[incomingMessagesPaths.deposit].methodId).toConstant();
        this.dispatchMessage(methodId.toConstant(), action, Deposit);
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], DispatchSmartContract.prototype, "promisedMessagesHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], DispatchSmartContract.prototype, "honoredMessagesHash", void 0);
__decorate([
    state(PublicKey),
    __metadata("design:type", Object)
], DispatchSmartContract.prototype, "settlementContract", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Field,
        Field]),
    __metadata("design:returntype", Promise)
], DispatchSmartContract.prototype, "updateMessagesHash", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey]),
    __metadata("design:returntype", Promise)
], DispatchSmartContract.prototype, "initialize", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UInt64]),
    __metadata("design:returntype", Promise)
], DispatchSmartContract.prototype, "deposit", null);
