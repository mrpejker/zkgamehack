var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { AccountUpdate, Bool, Field, method, Mina, Poseidon, Proof, Provable, PublicKey, Reducer, Signature, SmartContract, State, state, Struct, TokenId, UInt32, UInt64, } from "o1js";
import { EMPTY_PUBLICKEY, prefixToField, RollupMerkleTree, RollupMerkleTreeWitness, } from "@proto-kit/common";
import { inject, injectable, injectAll } from "tsyringe";
import { ProtocolModule } from "../protocol/ProtocolModule";
import { BlockProverPublicInput, BlockProverPublicOutput, } from "../prover/block/BlockProvable";
import { NetworkState } from "../model/network/NetworkState";
import { BlockHashMerkleTree } from "../prover/block/accummulators/BlockHashMerkleTree";
import { RuntimeTransaction } from "../model/transaction/RuntimeTransaction";
import { Path } from "../model/Path";
import { MinaActions, MinaEvents } from "../utils/MinaPrefixedProvableHashList";
class LazyBlockProof extends Proof {
}
LazyBlockProof.publicInputType = BlockProverPublicInput;
LazyBlockProof.publicOutputType = BlockProverPublicOutput;
LazyBlockProof.tag = () => {
    throw new Error("Tag not initialized yet");
};
export class Deposit extends Struct({
    address: PublicKey,
    amount: UInt64,
}) {
}
export class Withdrawal extends Struct({
    address: PublicKey,
    amount: UInt64,
}) {
    static dummy() {
        return new Withdrawal({
            address: EMPTY_PUBLICKEY,
            amount: UInt64.from(0),
        });
    }
}
export const OUTGOING_MESSAGE_BATCH_SIZE = 1;
export class OutgoingMessageArgument extends Struct({
    witness: RollupMerkleTreeWitness,
    value: Withdrawal,
}) {
    static dummy() {
        return new OutgoingMessageArgument({
            witness: RollupMerkleTreeWitness.dummy(),
            value: Withdrawal.dummy(),
        });
    }
}
export class OutgoingMessageArgumentBatch extends Struct({
    arguments: Provable.Array(OutgoingMessageArgument, OUTGOING_MESSAGE_BATCH_SIZE),
    isDummys: Provable.Array(Bool, OUTGOING_MESSAGE_BATCH_SIZE),
}) {
    static fromMessages(providedArguments) {
        const batch = providedArguments.slice();
        const isDummys = batch.map(() => Bool(false));
        while (batch.length < OUTGOING_MESSAGE_BATCH_SIZE) {
            batch.push(OutgoingMessageArgument.dummy());
            isDummys.push(Bool(true));
        }
        return new OutgoingMessageArgumentBatch({
            arguments: batch,
            isDummys,
        });
    }
}
// Some random prefix for the sequencer signature
export const BATCH_SIGNATURE_PREFIX = prefixToField("pk-batchSignature");
export const ACTIONS_EMPTY_HASH = Reducer.initialActionState;
export class SettlementContract extends SmartContract {
    constructor(address, methodIdMappings, hooks, withdrawalStatePath, incomingMessagesPaths, 
    // 24 hours
    escapeHatchSlotsInterval = (60 / 3) * 24) {
        super(address);
        this.methodIdMappings = methodIdMappings;
        this.hooks = hooks;
        this.withdrawalStatePath = withdrawalStatePath;
        this.incomingMessagesPaths = incomingMessagesPaths;
        this.escapeHatchSlotsInterval = escapeHatchSlotsInterval;
        this.sequencerKey = State();
        this.lastSettlementL1Block = State();
        this.stateRoot = State();
        this.networkStateHash = State();
        this.blockHashRoot = State();
        this.promisedMessagesHash = State();
        this.honoredMessagesHash = State();
        this.outgoingMessageCursor = State();
    }
    initialize(sequencer) {
        this.sequencerKey.getAndAssertEquals().assertEquals(Field(0));
        this.stateRoot.getAndAssertEquals().assertEquals(Field(0));
        this.blockHashRoot.getAndAssertEquals().assertEquals(Field(0));
        this.networkStateHash.getAndAssertEquals().assertEquals(Field(0));
        this.promisedMessagesHash.getAndAssertEquals().assertEquals(Field(0));
        this.honoredMessagesHash.getAndAssertEquals().assertEquals(Field(0));
        this.sequencerKey.set(sequencer.x);
        this.stateRoot.set(Field(RollupMerkleTree.EMPTY_ROOT));
        this.blockHashRoot.set(Field(BlockHashMerkleTree.EMPTY_ROOT));
        this.networkStateHash.set(NetworkState.empty().hash());
        this.promisedMessagesHash.set(ACTIONS_EMPTY_HASH);
        this.honoredMessagesHash.set(ACTIONS_EMPTY_HASH);
    }
    settle(blockProof, signature, publicKey, inputNetworkState, outputNetworkState, newPromisedMessagesHash) {
        // Verify the blockproof
        blockProof.verify();
        // Get and assert on-chain values
        const stateRoot = this.stateRoot.getAndAssertEquals();
        const networkStateHash = this.networkStateHash.getAndAssertEquals();
        const blockHashRoot = this.blockHashRoot.getAndAssertEquals();
        const sequencerKey = this.sequencerKey.getAndAssertEquals();
        const promisedMessagesHash = this.promisedMessagesHash.getAndAssertEquals();
        const honoredMessagesHash = this.honoredMessagesHash.getAndAssertEquals();
        const lastSettlementL1Block = this.lastSettlementL1Block.getAndAssertEquals();
        // Get block height and use the lower bound for all ops
        const minBlockIncluded = this.network.globalSlotSinceGenesis.get();
        this.network.globalSlotSinceGenesis.assertBetween(minBlockIncluded, minBlockIncluded.add(20));
        // Check signature/escape catch
        publicKey.x.assertEquals(sequencerKey, "Sequencer public key witness not matching");
        const signatureValid = signature.verify(publicKey, [
            BATCH_SIGNATURE_PREFIX,
            lastSettlementL1Block.value,
        ]);
        const escapeHatchActivated = lastSettlementL1Block
            .add(UInt32.from(this.escapeHatchSlotsInterval))
            .lessThan(minBlockIncluded);
        signatureValid
            .or(escapeHatchActivated)
            .assertTrue("Sequencer signature not valid and escape hatch not activated");
        // Assert correctness of networkState witness
        inputNetworkState
            .hash()
            .assertEquals(networkStateHash, "InputNetworkState witness not valid");
        outputNetworkState
            .hash()
            .assertEquals(blockProof.publicOutput.networkStateHash, "OutputNetworkState witness not valid");
        blockProof.publicOutput.closed.assertEquals(Bool(true), "Supplied proof is not a closed BlockProof");
        // Execute onSettlementHooks for additional checks
        const stateRecord = {
            blockHashRoot,
            stateRoot,
            networkStateHash,
            honoredMessagesHash,
            lastSettlementL1Block,
            promisedMessagesHash,
            sequencerKey,
        };
        const inputs = {
            blockProof,
            contractState: stateRecord,
            newPromisedMessagesHash,
            fromNetworkState: inputNetworkState,
            toNetworkState: outputNetworkState,
            currentL1Block: minBlockIncluded,
        };
        this.hooks.forEach((hook) => {
            hook.beforeSettlement(this, inputs);
        });
        // Apply blockProof
        stateRoot.assertEquals(blockProof.publicInput.stateRoot, "Input state root not matching");
        networkStateHash.assertEquals(blockProof.publicInput.networkStateHash, "Input networkStateHash not matching");
        blockHashRoot.assertEquals(blockProof.publicInput.blockHashRoot, "Input blockHashRoot not matching");
        this.stateRoot.set(blockProof.publicOutput.stateRoot);
        this.networkStateHash.set(blockProof.publicOutput.networkStateHash);
        this.blockHashRoot.set(blockProof.publicOutput.blockHashRoot);
        // Assert and apply deposit commitments
        promisedMessagesHash.assertEquals(blockProof.publicOutput.incomingMessagesHash, "Promised messages not honored");
        this.honoredMessagesHash.set(promisedMessagesHash);
        // Assert and apply new promisedMessagesHash
        this.self.account.actionState.assertEquals(newPromisedMessagesHash);
        this.promisedMessagesHash.set(newPromisedMessagesHash);
        this.lastSettlementL1Block.set(minBlockIncluded);
    }
    dispatchMessage(methodId, value, valueType) {
        const args = valueType.toFields(value);
        // Should be the same as RuntimeTransaction.hash
        const argsHash = Poseidon.hash(args);
        const runtimeTransaction = RuntimeTransaction.fromMessage({
            methodId,
            argsHash,
        });
        // Append tx to incomingMessagesHash
        const actionData = runtimeTransaction.hashData();
        const actionHash = MinaActions.actionHash(actionData);
        this.self.body.actions = {
            hash: actionHash,
            data: [actionData],
        };
        const eventHash = MinaEvents.eventHash(args);
        this.self.body.events = {
            hash: eventHash,
            data: [args],
        };
    }
    deposit(amount) {
        // Save this, since otherwise it would be a second witness later,
        // which could be a different values than the first
        const sender = this.sender;
        // Credit the amount to the bridge contract
        this.self.balance.addInPlace(amount);
        const action = new Deposit({
            address: sender,
            amount,
        });
        const methodId = Field(this.methodIdMappings[this.incomingMessagesPaths["deposit"]]);
        this.dispatchMessage(methodId.toConstant(), action, Deposit);
    }
    rollupOutgoingMessages(batch) {
        let counter = this.outgoingMessageCursor.getAndAssertEquals();
        const stateRoot = this.stateRoot.getAndAssertEquals();
        const [withdrawalModule, withdrawalStateName] = this.withdrawalStatePath;
        const mapPath = Path.fromProperty(withdrawalModule, withdrawalStateName);
        let accountCreationFeePaid = Field(0);
        for (let i = 0; i < OUTGOING_MESSAGE_BATCH_SIZE; i++) {
            const args = batch.arguments[i];
            // Check witness
            const path = Path.fromKey(mapPath, Field, counter);
            args.witness
                .checkMembership(stateRoot, path, Poseidon.hash(Withdrawal.toFields(args.value)))
                .assertTrue("Provided Withdrawal witness not valid");
            // Process message
            const { address, amount } = args.value;
            const isDummy = address.equals(this.address);
            const tokenAu = this.token.mint({ address, amount });
            const isNewAccount = tokenAu.account.isNew.getAndAssertEquals();
            tokenAu.body.balanceChange.magnitude =
                tokenAu.body.balanceChange.magnitude.sub(Provable.if(isNewAccount, Mina.accountCreationFee().toConstant(), UInt64.zero));
            accountCreationFeePaid = accountCreationFeePaid.add(Provable.if(isNewAccount, Field(1e9), Field(0)));
            counter = counter.add(Provable.if(isDummy, Field(0), Field(1)));
        }
        this.balance.subInPlace(UInt64.from(accountCreationFeePaid));
        this.outgoingMessageCursor.set(counter);
    }
    redeem(additionUpdate) {
        additionUpdate.body.tokenId.assertEquals(TokenId.default, "Tokenid not default token");
        additionUpdate.body.balanceChange.sgn
            .isPositive()
            .assertTrue("Sign not correct");
        const amount = additionUpdate.body.balanceChange.magnitude;
        // Burn tokens
        this.token.burn({
            address: additionUpdate.publicKey,
            amount,
        });
        // Send mina
        this.approve(additionUpdate);
        this.balance.subInPlace(amount);
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "sequencerKey", void 0);
__decorate([
    state(UInt32),
    __metadata("design:type", Object)
], SettlementContract.prototype, "lastSettlementL1Block", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "stateRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "networkStateHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "blockHashRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "promisedMessagesHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "honoredMessagesHash", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], SettlementContract.prototype, "outgoingMessageCursor", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey]),
    __metadata("design:returntype", void 0)
], SettlementContract.prototype, "initialize", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [LazyBlockProof,
        Signature,
        PublicKey,
        NetworkState,
        NetworkState,
        Field]),
    __metadata("design:returntype", void 0)
], SettlementContract.prototype, "settle", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UInt64]),
    __metadata("design:returntype", void 0)
], SettlementContract.prototype, "deposit", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [OutgoingMessageArgumentBatch]),
    __metadata("design:returntype", void 0)
], SettlementContract.prototype, "rollupOutgoingMessages", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AccountUpdate]),
    __metadata("design:returntype", void 0)
], SettlementContract.prototype, "redeem", null);
let SettlementContractModule = class SettlementContractModule extends ProtocolModule {
    constructor(hooks, blockProver) {
        super();
        this.hooks = hooks;
        this.blockProver = blockProver;
        LazyBlockProof.tag = blockProver.zkProgrammable.zkProgram.Proof.tag;
    }
    getContractClass() {
        return SettlementContract;
    }
    createContract(address, methodIdMappings) {
        // We know that this returns [string, string], but TS can't infer that
        const withdrawalPath = this.config.withdrawalStatePath.split(".");
        return new SettlementContract(address, methodIdMappings, this.hooks, [withdrawalPath[0], withdrawalPath[1]], this.config.incomingMessagesMethods);
    }
};
SettlementContractModule = __decorate([
    injectable(),
    __param(0, injectAll("ProvableSettlementHook")),
    __param(1, inject("BlockProver")),
    __metadata("design:paramtypes", [Array, Object])
], SettlementContractModule);
export { SettlementContractModule };
