import { Bool, Provable, Struct } from "o1js";
import { range } from "@proto-kit/common";
import { constants } from "../Constants";
import { ProvableStateTransition } from "./StateTransition.js";
export class StateTransitionType {
    static isNormal(type) {
        return type === StateTransitionType.normal;
    }
    static isProtocol(type) {
        return type === StateTransitionType.protocol;
    }
}
StateTransitionType.normal = true;
StateTransitionType.protocol = false;
export class ProvableStateTransitionType extends Struct({
    type: Bool,
}) {
    static get normal() {
        return new ProvableStateTransitionType({
            type: Bool(StateTransitionType.normal),
        });
    }
    static get protocol() {
        return new ProvableStateTransitionType({
            type: Bool(StateTransitionType.protocol),
        });
    }
    isNormal() {
        return this.type;
    }
    isProtocol() {
        return this.type.not();
    }
}
/**
 * A Batch of StateTransitions to be consumed by the StateTransitionProver
 * to prove multiple STs at once
 *
 * transitionType:
 * true == normal ST, false == protocol ST
 */
export class StateTransitionProvableBatch extends Struct({
    batch: Provable.Array(ProvableStateTransition, constants.stateTransitionProverBatchSize),
    transitionTypes: Provable.Array(ProvableStateTransitionType, constants.stateTransitionProverBatchSize),
}) {
    static fromMappings(transitions) {
        const batch = transitions.map((entry) => entry.transition);
        const transitionTypes = transitions.map((entry) => entry.type);
        // Check that order is correct
        let normalSTsStarted = false;
        transitionTypes.forEach((x) => {
            if (!normalSTsStarted && x.isNormal().toBoolean()) {
                normalSTsStarted = true;
            }
            if (normalSTsStarted && x.isProtocol().toBoolean()) {
                throw new Error("Order in initializing STBatch not correct");
            }
        });
        while (batch.length < constants.stateTransitionProverBatchSize) {
            batch.push(ProvableStateTransition.dummy());
            transitionTypes.push(ProvableStateTransitionType.normal);
        }
        return new StateTransitionProvableBatch({
            batch,
            transitionTypes,
        });
    }
    static fromTransitions(transitions, protocolTransitions) {
        const array = transitions.slice().concat(protocolTransitions);
        const transitionTypes = range(0, transitions.length)
            .map(() => ProvableStateTransitionType.normal)
            .concat(range(0, protocolTransitions.length).map(() => ProvableStateTransitionType.protocol));
        while (array.length < constants.stateTransitionProverBatchSize) {
            array.push(ProvableStateTransition.dummy());
            transitionTypes.push(ProvableStateTransitionType.normal);
        }
        return new StateTransitionProvableBatch({
            batch: array,
            transitionTypes,
        });
    }
    constructor(object) {
        super(object);
    }
}
