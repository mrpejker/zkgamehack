import { Bool, Field, Poseidon, Provable, Struct, } from "o1js";
export class ProvableOption extends Struct({
    isSome: Bool,
    value: Field,
}) {
    toSome() {
        this.isSome = Bool(true);
        return this;
    }
}
export class OptionBase {
    constructor(isSome, isForcedSome) {
        this.isSome = isSome;
        this.isForcedSome = isForcedSome;
    }
    /**
     * @returns Tree representation of the current value
     */
    get treeValue() {
        const treeValue = Poseidon.hash(this.encodeValueToFields());
        return Provable.if(this.isSome.and(this.isForcedSome.not()), treeValue, Field(0));
    }
    forceSome() {
        this.isForcedSome = Provable.if(this.isSome, Bool(false), Bool(true));
        this.isSome = Bool(true);
    }
    /**
     * Returns the `to`-value as decoded as a list of fields
     * Not in circuit
     */
    toFields() {
        if (this.isSome.toBoolean()) {
            return this.encodeValueToFields();
        }
        return [Field(0)];
    }
    /**
     * @returns Provable representation of the current option.
     */
    toProvable() {
        return new ProvableOption({
            isSome: this.isSome,
            value: this.treeValue,
        });
    }
    toJSON() {
        const value = this.encodeValueToFields().map((field) => field.toString());
        return {
            isSome: this.isSome.toBoolean(),
            isForcedSome: this.isForcedSome.toBoolean(),
            value,
        };
    }
}
/**
 * Option facilitating in-circuit values that may or may not exist.
 */
export class Option extends OptionBase {
    /**
     * Creates a new Option from the provided parameters
     *
     * @param isSome
     * @param value
     * @param valueType
     * @returns New option from the provided parameters.
     */
    static from(isSome, value, valueType) {
        return new Option(isSome, value, valueType);
    }
    /**
     * Creates a new Option from the provided parameters
     *
     * @param value
     * @param valueType
     * @returns New option from the provided parameters.
     */
    static fromValue(value, valueType) {
        return this.from(Bool(true), value, valueType);
    }
    /**
     * @returns Empty / none option
     */
    static none() {
        return new Option(Bool(false), Field(0), Field);
    }
    constructor(isSome, value, valueType, isForcedSome = Bool(false)) {
        super(isSome, isForcedSome);
        this.value = value;
        this.valueType = valueType;
    }
    encodeValueToFields() {
        return this.valueType.toFields(this.value);
    }
    clone() {
        return new Option(this.isSome, this.value, this.valueType, this.isForcedSome);
    }
    /**
     * @returns Returns the value of this option if it isSome,
     * otherwise returns the given defaultValue
     */
    orElse(defaultValue) {
        return Provable.if(this.isSome, this.valueType, this.value, defaultValue);
    }
    toConstant() {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        const valueConstant = this.valueType.fromFields(this.valueType.toFields(this.value).map((field) => field.toConstant()));
        const boolConstant = (bool) => Bool.fromFields([bool.toField().toConstant()]);
        return new Option(boolConstant(this.isSome), valueConstant, this.valueType, boolConstant(this.isForcedSome));
    }
}
