import { Bool, Field, type FlexibleProvablePure } from "o1js";
declare const ProvableOption_base: (new (value: {
    isSome: import("o1js/dist/node/lib/provable/bool").Bool;
    value: import("o1js/dist/node/lib/provable/field").Field;
}) => {
    isSome: import("o1js/dist/node/lib/provable/bool").Bool;
    value: import("o1js/dist/node/lib/provable/field").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    isSome: import("o1js/dist/node/lib/provable/bool").Bool;
    value: import("o1js/dist/node/lib/provable/field").Field;
}, {
    isSome: boolean;
    value: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
} & {
    fromValue: (value: {
        isSome: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
        value: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        isSome: boolean;
        value: string;
    };
    fromJSON: (x: {
        isSome: boolean;
        value: string;
    }) => {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        isSome: import("o1js/dist/node/lib/provable/bool").Bool;
        value: import("o1js/dist/node/lib/provable/field").Field;
    };
};
export declare class ProvableOption extends ProvableOption_base {
    toSome(): this;
}
export declare abstract class OptionBase {
    isSome: Bool;
    isForcedSome: Bool;
    protected constructor(isSome: Bool, isForcedSome: Bool);
    protected abstract encodeValueToFields(): Field[];
    protected abstract clone(): OptionBase;
    /**
     * @returns Tree representation of the current value
     */
    get treeValue(): import("o1js/dist/node/lib/provable/field").Field;
    forceSome(): void;
    /**
     * Returns the `to`-value as decoded as a list of fields
     * Not in circuit
     */
    toFields(): Field[];
    /**
     * @returns Provable representation of the current option.
     */
    toProvable(): ProvableOption;
    toJSON(): {
        isSome: boolean;
        isForcedSome: boolean;
        value: string[];
    };
}
/**
 * Option facilitating in-circuit values that may or may not exist.
 */
export declare class Option<Value> extends OptionBase {
    value: Value;
    valueType: FlexibleProvablePure<Value>;
    /**
     * Creates a new Option from the provided parameters
     *
     * @param isSome
     * @param value
     * @param valueType
     * @returns New option from the provided parameters.
     */
    static from<Value>(isSome: Bool, value: Value, valueType: FlexibleProvablePure<Value>): Option<Value>;
    /**
     * Creates a new Option from the provided parameters
     *
     * @param value
     * @param valueType
     * @returns New option from the provided parameters.
     */
    static fromValue<Value>(value: Value, valueType: FlexibleProvablePure<Value>): Option<Value>;
    /**
     * @returns Empty / none option
     */
    static none(): Option<import("o1js/dist/node/lib/provable/field").Field>;
    constructor(isSome: Bool, value: Value, valueType: FlexibleProvablePure<Value>, isForcedSome?: import("o1js/dist/node/lib/provable/bool").Bool);
    encodeValueToFields(): Field[];
    clone(): Option<Value>;
    /**
     * @returns Returns the value of this option if it isSome,
     * otherwise returns the given defaultValue
     */
    orElse(defaultValue: Value): Value;
    toConstant(): Option<Value>;
}
export {};
//# sourceMappingURL=Option.d.ts.map