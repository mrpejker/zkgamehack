import { Field, type FlexibleProvablePure } from "o1js";
import { Path } from "../model/Path";
import { Option } from "../model/Option";
import { StateServiceProvider } from "./StateServiceProvider";
export declare class WithPath {
    path?: Field;
    hasPathOrFail(): asserts this is {
        path: Path;
    };
}
export declare class WithStateServiceProvider {
    stateServiceProvider?: StateServiceProvider;
    hasStateServiceOrFail(): asserts this is {
        stateServiceProvider: StateServiceProvider;
    };
}
declare const State_base: import("ts-mixer/dist/types/types").Class<any[], WithPath & WithStateServiceProvider, typeof WithPath & typeof WithStateServiceProvider>;
/**
 * Utilities for runtime module state, such as get/set
 */
export declare class State<Value> extends State_base {
    valueType: FlexibleProvablePure<Value>;
    /**
     * Creates a new state wrapper for the provided value type.
     *
     * @param valueType - Type of value to be stored (e.g. UInt64, Struct, ...)
     * @returns New state for the given value type.
     */
    static from<Value>(valueType: FlexibleProvablePure<Value>): State<Value>;
    constructor(valueType: FlexibleProvablePure<Value>);
    private stateType;
    /**
     * Returns the state that is currently the current state tree
     * value: The value-fields, or if not state was found, dummy values
     * isSome: Whether the values where found in the state or not
     * (Basically, whether the value-fields are dummy values or actual values
     * @private
     */
    private getState;
    /**
     * Provides an in-circuit witness for the current state representation,
     * and constructs an Option out of it.
     *
     * @returns Optional value of the current state
     */
    private witnessFromState;
    /**
     * Retrieves the current state and creates a state transition
     * anchoring the use of the current state value in the circuit.
     *
     * @returns Option representation of the current state.
     */
    get(): Promise<Option<Value>>;
    /**
     * Sets a new state value by creating a state transition from
     * the current value to the newly set value.
     *
     * The newly set value isn't available via state.get(), since the
     * state transitions are not applied within the same circuit.
     * You can however store and access your new value in
     * a separate circuit variable.
     *
     * @param value - Value to be set as the current state
     */
    set(value: Value): Promise<void>;
}
export {};
//# sourceMappingURL=State.d.ts.map