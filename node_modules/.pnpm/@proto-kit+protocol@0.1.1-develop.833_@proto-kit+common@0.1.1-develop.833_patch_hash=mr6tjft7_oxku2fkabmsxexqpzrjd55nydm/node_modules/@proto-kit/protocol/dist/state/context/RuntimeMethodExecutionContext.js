var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Bool, Provable, Struct } from "o1js";
import { singleton } from "tsyringe";
import { ProvableMethodExecutionContext, ProvableMethodExecutionResult, } from "@proto-kit/common";
import { RuntimeTransaction } from "../../model/transaction/RuntimeTransaction";
import { NetworkState } from "../../model/network/NetworkState";
const errors = {
    setupNotCalled: () => new Error("Setup has not been called prior to executing a runtime method. Be sure to do that so that the Runtime is setup property for execution"),
};
export class RuntimeProvableMethodExecutionResult extends ProvableMethodExecutionResult {
    constructor() {
        super(...arguments);
        this.stateTransitions = [];
        this.status = Bool(true);
    }
}
export class RuntimeMethodExecutionDataStruct extends Struct({
    transaction: RuntimeTransaction,
    networkState: NetworkState,
}) {
}
/**
 * Execution context used to wrap runtime module methods,
 * allowing them to post relevant information (such as execution status)
 * into the context without any unnecessary 'prop drilling'.
 */
export let RuntimeMethodExecutionContext = class RuntimeMethodExecutionContext extends ProvableMethodExecutionContext {
    constructor() {
        super(...arguments);
        this.methods = [];
        this.result = new RuntimeProvableMethodExecutionResult();
        this.isSimulated = false;
    }
    assertSetupCalled() {
        if (this.input === undefined) {
            throw errors.setupNotCalled();
        }
    }
    /**
     * Adds an in-method generated state transition to the current context
     * @param stateTransition - State transition to add to the context
     */
    addStateTransition(stateTransition) {
        this.assertSetupCalled();
        this.result.stateTransitions.push(stateTransition);
    }
    /**
     * @param message - Status message to acompany the current status
     */
    setStatusMessage(message, stackTrace) {
        var _a, _b;
        this.assertSetupCalled();
        if (this.isSimulated) {
            return;
        }
        (_a = this.result).statusMessage ?? (_a.statusMessage = message);
        (_b = this.result).stackTrace ?? (_b.stackTrace = stackTrace);
    }
    /**
     * @param status - Execution status of the current method
     */
    setStatus(status) {
        this.assertSetupCalled();
        if (this.isSimulated) {
            return;
        }
        this.result.status = status;
    }
    /**
     * @param input Input witness data required for a runtime execution
     */
    setup(input) {
        this.input = input;
    }
    witnessInput() {
        this.assertSetupCalled();
        return Provable.witness(RuntimeMethodExecutionDataStruct, () => {
            // TODO Is that right? Or this.current().input
            const { transaction, networkState } = this.input;
            return new RuntimeMethodExecutionDataStruct({
                networkState,
                transaction,
            });
        });
    }
    setSimulated(simulated) {
        this.isSimulated = simulated;
    }
    /**
     * Manually clears/resets the execution context
     */
    clear() {
        this.result = new RuntimeProvableMethodExecutionResult();
    }
    afterMethod() {
        super.afterMethod();
        if (this.isFinished) {
            this.lastInput = this.input;
            // TODO: find out why input isnt set in TransactionFeeHook during assert
            // this.input = undefined;
            this.isSimulated = false;
        }
    }
    /**
     * Had to override current() otherwise it would not infer
     * the type of result correctly (parent type would be reused)
     */
    current() {
        return {
            isFinished: this.isFinished,
            result: this.result,
            input: this.lastInput,
            isSimulated: this.isSimulated,
        };
    }
};
RuntimeMethodExecutionContext = __decorate([
    singleton()
], RuntimeMethodExecutionContext);
