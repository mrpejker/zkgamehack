import { container } from "tsyringe";
import { RuntimeMethodExecutionContext, } from "./RuntimeMethodExecutionContext";
/**
 * Executed a given function f inside a RuntimeMethodExecutionContext
 * and retrieves the result along with the return value of f
 * @param f
 * @param inputs
 * @param isAnnotated Whether the execution f is annotated with @runtimeMethod or similar
 * @param isSimulated
 */
export function executeWithContext(f, inputs, isAnnotated, isSimulated) {
    const executionContext = container.resolve(RuntimeMethodExecutionContext);
    if (!isAnnotated) {
        executionContext.beforeMethod("", "", []);
    }
    // Setup context for potential calls to runtime methods.
    // With the special case that we set the new networkstate for every hook
    // We also have to put in a dummy transaction for network.transaction
    executionContext.setup(inputs);
    executionContext.setSimulated(isSimulated);
    const functionResult = f();
    if (!isAnnotated) {
        executionContext.afterMethod();
    }
    const result = executionContext.current().result;
    return {
        result,
        functionResult,
    };
}
