import { Bool, Provable } from "o1js";
import { ProvableMethodExecutionContext, ProvableMethodExecutionResult } from "@proto-kit/common";
import { StateTransition } from "../../model/StateTransition";
import { RuntimeTransaction } from "../../model/transaction/RuntimeTransaction";
import { NetworkState } from "../../model/network/NetworkState";
export declare class RuntimeProvableMethodExecutionResult extends ProvableMethodExecutionResult {
    stateTransitions: StateTransition<any>[];
    status: Bool;
    statusMessage?: string;
    stackTrace?: string;
}
export interface RuntimeMethodExecutionData {
    transaction: RuntimeTransaction;
    networkState: NetworkState;
}
declare const RuntimeMethodExecutionDataStruct_base: (new (value: {
    transaction: RuntimeTransaction;
    networkState: NetworkState;
}) => {
    transaction: RuntimeTransaction;
    networkState: NetworkState;
}) & {
    _isStruct: true;
} & Provable<{
    transaction: RuntimeTransaction;
    networkState: NetworkState;
}, {
    transaction: {
        methodId: bigint;
        argsHash: bigint;
        nonce: {
            isSome: boolean;
            value: any;
        };
        sender: {
            isSome: boolean;
            value: any;
        };
    };
    networkState: {
        block: {
            height: bigint;
        };
        previous: {
            rootHash: bigint;
        };
    };
}> & {
    fromValue: (value: {
        transaction: RuntimeTransaction | {
            methodId: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            argsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            nonce: import("../..").UInt64Option | {
                isSome: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
                value: any;
            };
            sender: import("../..").PublicKeyOption | {
                isSome: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
                value: any;
            };
        };
        networkState: NetworkState | {
            block: import("../../model/network/NetworkState").CurrentBlock | {
                height: bigint | import("o1js/dist/node/lib/provable/int").UInt64;
            };
            previous: import("../../model/network/NetworkState").PreviousBlock | {
                rootHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            };
        };
    }) => {
        transaction: RuntimeTransaction;
        networkState: NetworkState;
    };
    toInput: (x: {
        transaction: RuntimeTransaction;
        networkState: NetworkState;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        transaction: RuntimeTransaction;
        networkState: NetworkState;
    }) => {
        transaction: {
            methodId: string;
            argsHash: string;
            nonce: {
                isSome: boolean;
                value: any;
            };
            sender: {
                isSome: boolean;
                value: any;
            };
        };
        networkState: {
            block: {
                height: string;
            };
            previous: {
                rootHash: string;
            };
        };
    };
    fromJSON: (x: {
        transaction: {
            methodId: string;
            argsHash: string;
            nonce: {
                isSome: boolean;
                value: any;
            };
            sender: {
                isSome: boolean;
                value: any;
            };
        };
        networkState: {
            block: {
                height: string;
            };
            previous: {
                rootHash: string;
            };
        };
    }) => {
        transaction: RuntimeTransaction;
        networkState: NetworkState;
    };
    empty: () => {
        transaction: RuntimeTransaction;
        networkState: NetworkState;
    };
};
export declare class RuntimeMethodExecutionDataStruct extends RuntimeMethodExecutionDataStruct_base implements RuntimeMethodExecutionData {
}
/**
 * Execution context used to wrap runtime module methods,
 * allowing them to post relevant information (such as execution status)
 * into the context without any unnecessary 'prop drilling'.
 */
export declare class RuntimeMethodExecutionContext extends ProvableMethodExecutionContext {
    methods: string[];
    input: RuntimeMethodExecutionData | undefined;
    private lastInput;
    result: RuntimeProvableMethodExecutionResult;
    private isSimulated;
    private assertSetupCalled;
    /**
     * Adds an in-method generated state transition to the current context
     * @param stateTransition - State transition to add to the context
     */
    addStateTransition<Value>(stateTransition: StateTransition<Value>): void;
    /**
     * @param message - Status message to acompany the current status
     */
    setStatusMessage(message?: string, stackTrace?: string): void;
    /**
     * @param status - Execution status of the current method
     */
    setStatus(status: Bool): void;
    /**
     * @param input Input witness data required for a runtime execution
     */
    setup(input: RuntimeMethodExecutionData): void;
    witnessInput(): RuntimeMethodExecutionDataStruct;
    setSimulated(simulated: boolean): void;
    /**
     * Manually clears/resets the execution context
     */
    clear(): void;
    afterMethod(): void;
    /**
     * Had to override current() otherwise it would not infer
     * the type of result correctly (parent type would be reused)
     */
    current(): {
        isFinished: boolean;
        result: RuntimeProvableMethodExecutionResult;
        input: RuntimeMethodExecutionData | undefined;
        isSimulated: boolean;
    };
}
export {};
//# sourceMappingURL=RuntimeMethodExecutionContext.d.ts.map