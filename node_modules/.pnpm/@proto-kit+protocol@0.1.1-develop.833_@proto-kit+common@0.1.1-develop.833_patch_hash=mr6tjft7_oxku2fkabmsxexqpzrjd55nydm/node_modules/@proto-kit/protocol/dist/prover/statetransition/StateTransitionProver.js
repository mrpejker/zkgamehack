var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { provableMethod, RollupMerkleTreeWitness, ZkProgrammable, } from "@proto-kit/common";
import { Field, Provable, SelfProof, ZkProgram } from "o1js";
import { injectable } from "tsyringe";
import { constants } from "../../Constants";
import { ProvableStateTransition } from "../../model/StateTransition";
import { StateTransitionProvableBatch, } from "../../model/StateTransitionProvableBatch";
import { ProtocolModule } from "../../protocol/ProtocolModule";
import { DefaultProvableHashList, } from "../../utils/ProvableHashList";
import { StateTransitionProverPublicInput, StateTransitionProverPublicOutput, } from "./StateTransitionProvable";
import { StateTransitionWitnessProviderReference } from "./StateTransitionWitnessProviderReference";
const errors = {
    propertyNotMatching: (property, step) => `${property} not matching ${step}`,
    merkleWitnessNotCorrect: (index, type) => `MerkleWitness not valid for StateTransition (${index}, type ${type})`,
    noWitnessProviderSet: () => new Error("WitnessProvider not set, set it before you use StateTransitionProvider"),
};
const StateTransitionSelfProofClass = (SelfProof);
/**
 * StateTransitionProver is the prover that proves the application of some state
 * transitions and checks and updates their merkle-tree entries
 */
export class StateTransitionProverProgrammable extends ZkProgrammable {
    constructor(stateTransitionProver, witnessProviderReference) {
        super();
        this.stateTransitionProver = stateTransitionProver;
        this.witnessProviderReference = witnessProviderReference;
    }
    get appChain() {
        return this.stateTransitionProver.appChain;
    }
    zkProgramFactory() {
        const instance = this;
        const program = ZkProgram({
            name: "StateTransitionProver",
            publicInput: StateTransitionProverPublicInput,
            publicOutput: StateTransitionProverPublicOutput,
            methods: {
                proveBatch: {
                    privateInputs: [StateTransitionProvableBatch],
                    async method(publicInput, batch) {
                        return await instance.runBatch(publicInput, batch);
                    },
                },
                merge: {
                    privateInputs: [
                        StateTransitionSelfProofClass,
                        StateTransitionSelfProofClass,
                    ],
                    async method(publicInput, proof1, proof2) {
                        return await instance.merge(publicInput, proof1, proof2);
                    },
                },
            },
        });
        const methods = {
            proveBatch: program.proveBatch.bind(program),
            merge: program.merge.bind(program),
        };
        const SelfProofClass = ZkProgram.Proof(program);
        return {
            compile: program.compile.bind(program),
            verify: program.verify.bind(program),
            analyzeMethods: program.analyzeMethods.bind(program),
            Proof: SelfProofClass,
            methods,
        };
    }
    get witnessProvider() {
        const provider = this.witnessProviderReference.getWitnessProvider();
        if (provider === undefined) {
            throw errors.noWitnessProviderSet();
        }
        return provider;
    }
    /**
     * Applies the state transitions to the current stateRoot
     * and returns the new prover state
     */
    applyTransitions(stateRoot, protocolStateRoot, stateTransitionCommitmentFrom, protocolTransitionCommitmentFrom, transitionBatch) {
        const state = {
            stateRoot,
            protocolStateRoot,
            stateTransitionList: new DefaultProvableHashList(ProvableStateTransition, stateTransitionCommitmentFrom),
            protocolTransitionList: new DefaultProvableHashList(ProvableStateTransition, protocolTransitionCommitmentFrom),
        };
        const transitions = transitionBatch.batch;
        const types = transitionBatch.transitionTypes;
        for (let index = 0; index < constants.stateTransitionProverBatchSize; index++) {
            this.applyTransition(state, transitions[index], types[index], index);
        }
        return state;
    }
    /**
     * Applies a single state transition to the given state
     * and mutates it in place
     */
    applyTransition(state, transition, type, index = 0) {
        const witness = Provable.witness(RollupMerkleTreeWitness, () => this.witnessProvider.getWitness(transition.path));
        const membershipValid = witness.checkMembership(state.stateRoot, transition.path, transition.from.value);
        membershipValid
            .or(transition.from.isSome.not())
            .assertTrue(errors.merkleWitnessNotCorrect(index, type.isNormal().toBoolean() ? "normal" : "protocol"));
        const newRoot = witness.calculateRoot(transition.to.value);
        state.stateRoot = Provable.if(transition.to.isSome, newRoot, state.stateRoot);
        // Only update protocol state root if ST is also of type protocol
        // Since protocol STs are all at the start of the batch, this works
        state.protocolStateRoot = Provable.if(transition.to.isSome.and(type.isProtocol()), newRoot, state.protocolStateRoot);
        const isNotDummy = transition.path.equals(Field(0)).not();
        state.stateTransitionList.pushIf(transition, isNotDummy.and(type.isNormal()));
        state.protocolTransitionList.pushIf(transition, isNotDummy.and(type.isProtocol()));
    }
    /**
     * Applies a whole batch of StateTransitions at once
     */
    async runBatch(publicInput, batch) {
        const result = this.applyTransitions(publicInput.stateRoot, publicInput.protocolStateRoot, publicInput.stateTransitionsHash, publicInput.protocolTransitionsHash, batch);
        return new StateTransitionProverPublicOutput({
            stateRoot: result.stateRoot,
            stateTransitionsHash: result.stateTransitionList.commitment,
            protocolTransitionsHash: result.protocolTransitionList.commitment,
            protocolStateRoot: result.protocolStateRoot,
        });
    }
    async merge(publicInput, proof1, proof2) {
        proof1.verify();
        proof2.verify();
        // Check state
        publicInput.stateRoot.assertEquals(proof1.publicInput.stateRoot, errors.propertyNotMatching("stateRoot", "publicInput.from -> proof1.from"));
        proof1.publicOutput.stateRoot.assertEquals(proof2.publicInput.stateRoot, errors.propertyNotMatching("stateRoot", "proof1.to -> proof2.from"));
        // Check ST list
        publicInput.stateTransitionsHash.assertEquals(proof1.publicInput.stateTransitionsHash, errors.propertyNotMatching("stateTransitionsHash", "publicInput.from -> proof1.from"));
        proof1.publicOutput.stateTransitionsHash.assertEquals(proof2.publicInput.stateTransitionsHash, errors.propertyNotMatching("stateTransitionsHash", "proof1.to -> proof2.from"));
        // Check Protocol ST list
        publicInput.protocolTransitionsHash.assertEquals(proof1.publicInput.protocolTransitionsHash, errors.propertyNotMatching("protocolTransitionsHash", "publicInput.from -> proof1.from"));
        proof1.publicOutput.protocolTransitionsHash.assertEquals(proof2.publicInput.protocolTransitionsHash, errors.propertyNotMatching("protocolTransitionsHash", "proof1.to -> proof2.from"));
        // Check protocol state root
        publicInput.protocolStateRoot.assertEquals(proof1.publicInput.protocolStateRoot, errors.propertyNotMatching("protocolStateRoot", "publicInput.from -> proof1.from"));
        proof1.publicOutput.protocolStateRoot.assertEquals(proof2.publicInput.protocolStateRoot, errors.propertyNotMatching("protocolStateRoot", "proof1.to -> proof2.from"));
        return new StateTransitionProverPublicInput({
            stateRoot: proof2.publicOutput.stateRoot,
            stateTransitionsHash: proof2.publicOutput.stateTransitionsHash,
            protocolTransitionsHash: proof2.publicOutput.protocolTransitionsHash,
            protocolStateRoot: proof2.publicOutput.protocolStateRoot,
        });
    }
}
__decorate([
    provableMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [StateTransitionProverPublicInput,
        StateTransitionProvableBatch]),
    __metadata("design:returntype", Promise)
], StateTransitionProverProgrammable.prototype, "runBatch", null);
__decorate([
    provableMethod(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [StateTransitionProverPublicInput, Object, Object]),
    __metadata("design:returntype", Promise)
], StateTransitionProverProgrammable.prototype, "merge", null);
export let StateTransitionProver = class StateTransitionProver extends ProtocolModule {
    constructor(
    // Injected
    witnessProviderReference) {
        super();
        this.witnessProviderReference = witnessProviderReference;
        this.zkProgrammable = new StateTransitionProverProgrammable(this, witnessProviderReference);
    }
    runBatch(publicInput, batch) {
        return this.zkProgrammable.runBatch(publicInput, batch);
    }
    merge(publicInput, proof1, proof2) {
        return this.zkProgrammable.merge(publicInput, proof1, proof2);
    }
};
StateTransitionProver = __decorate([
    injectable(),
    __metadata("design:paramtypes", [StateTransitionWitnessProviderReference])
], StateTransitionProver);
