import { AreProofsEnabled, PlainZkProgram, ZkProgrammable } from "@proto-kit/common";
import { Field } from "o1js";
import { ProvableStateTransition } from "../../model/StateTransition";
import { ProvableStateTransitionType, StateTransitionProvableBatch } from "../../model/StateTransitionProvableBatch";
import { StateTransitionProverType } from "../../protocol/Protocol";
import { ProtocolModule } from "../../protocol/ProtocolModule";
import { ProvableHashList } from "../../utils/ProvableHashList";
import { StateTransitionProof, StateTransitionProvable, StateTransitionProverPublicInput, StateTransitionProverPublicOutput } from "./StateTransitionProvable";
import { StateTransitionWitnessProviderReference } from "./StateTransitionWitnessProviderReference";
interface StateTransitionProverExecutionState {
    stateRoot: Field;
    protocolStateRoot: Field;
    stateTransitionList: ProvableHashList<ProvableStateTransition>;
    protocolTransitionList: ProvableHashList<ProvableStateTransition>;
}
/**
 * StateTransitionProver is the prover that proves the application of some state
 * transitions and checks and updates their merkle-tree entries
 */
export declare class StateTransitionProverProgrammable extends ZkProgrammable<StateTransitionProverPublicInput, StateTransitionProverPublicOutput> {
    private readonly stateTransitionProver;
    readonly witnessProviderReference: StateTransitionWitnessProviderReference;
    constructor(stateTransitionProver: StateTransitionProver, witnessProviderReference: StateTransitionWitnessProviderReference);
    get appChain(): AreProofsEnabled | undefined;
    zkProgramFactory(): PlainZkProgram<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>;
    private get witnessProvider();
    /**
     * Applies the state transitions to the current stateRoot
     * and returns the new prover state
     */
    applyTransitions(stateRoot: Field, protocolStateRoot: Field, stateTransitionCommitmentFrom: Field, protocolTransitionCommitmentFrom: Field, transitionBatch: StateTransitionProvableBatch): StateTransitionProverExecutionState;
    /**
     * Applies a single state transition to the given state
     * and mutates it in place
     */
    applyTransition(state: StateTransitionProverExecutionState, transition: ProvableStateTransition, type: ProvableStateTransitionType, index?: number): void;
    /**
     * Applies a whole batch of StateTransitions at once
     */
    runBatch(publicInput: StateTransitionProverPublicInput, batch: StateTransitionProvableBatch): Promise<StateTransitionProverPublicOutput>;
    merge(publicInput: StateTransitionProverPublicInput, proof1: StateTransitionProof, proof2: StateTransitionProof): Promise<StateTransitionProverPublicOutput>;
}
export declare class StateTransitionProver extends ProtocolModule implements StateTransitionProvable, StateTransitionProverType {
    readonly witnessProviderReference: StateTransitionWitnessProviderReference;
    zkProgrammable: StateTransitionProverProgrammable;
    constructor(witnessProviderReference: StateTransitionWitnessProviderReference);
    runBatch(publicInput: StateTransitionProverPublicInput, batch: StateTransitionProvableBatch): Promise<StateTransitionProverPublicOutput>;
    merge(publicInput: StateTransitionProverPublicInput, proof1: StateTransitionProof, proof2: StateTransitionProof): Promise<StateTransitionProverPublicOutput>;
}
export {};
//# sourceMappingURL=StateTransitionProver.d.ts.map