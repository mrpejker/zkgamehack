import { Field, type Proof } from "o1js";
import { AreProofsEnabled, PlainZkProgram, WithZkProgrammable, ZkProgrammable } from "@proto-kit/common";
import { MethodPublicOutput } from "../../model/MethodPublicOutput";
import { ProtocolModule } from "../../protocol/ProtocolModule";
import { StateTransitionProof, StateTransitionProverPublicInput, StateTransitionProverPublicOutput } from "../statetransition/StateTransitionProvable";
import { ProvableTransactionHook } from "../../protocol/ProvableTransactionHook";
import { ProvableBlockHook } from "../../protocol/ProvableBlockHook";
import { NetworkState } from "../../model/network/NetworkState";
import { BlockProvable, BlockProverExecutionData, BlockProverProof, BlockProverPublicInput, BlockProverPublicOutput } from "./BlockProvable";
import { BlockHashMerkleTreeWitness } from "./accummulators/BlockHashMerkleTree";
export interface BlockProverState {
    /**
     * The current state root of the block prover
     */
    stateRoot: Field;
    /**
     * The current commitment of the transaction-list which
     * will at the end equal the bundle hash
     */
    transactionsHash: Field;
    /**
     * The network state which gives access to values such as blockHeight
     * This value is the same for the whole batch (L2 block)
     */
    networkStateHash: Field;
    /**
     * The root of the merkle tree encoding all block hashes,
     * see `BlockHashMerkleTree`
     */
    blockHashRoot: Field;
    /**
     * A variant of the transactionsHash that is never reset.
     * Thought for usage in the sequence state mempool.
     * In comparison, transactionsHash restarts at 0 for every new block
     */
    eternalTransactionsHash: Field;
    incomingMessagesHash: Field;
}
export type BlockProof = Proof<BlockProverPublicInput, BlockProverPublicOutput>;
export type RuntimeProof = Proof<void, MethodPublicOutput>;
export declare class BlockProverProgrammable extends ZkProgrammable<BlockProverPublicInput, BlockProverPublicOutput> {
    private readonly prover;
    readonly stateTransitionProver: ZkProgrammable<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>;
    readonly runtime: ZkProgrammable<undefined, MethodPublicOutput>;
    private readonly transactionHooks;
    private readonly blockHooks;
    constructor(prover: BlockProver, stateTransitionProver: ZkProgrammable<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>, runtime: ZkProgrammable<undefined, MethodPublicOutput>, transactionHooks: ProvableTransactionHook<unknown>[], blockHooks: ProvableBlockHook<unknown>[]);
    get appChain(): AreProofsEnabled | undefined;
    /**
     * Applies and checks the two proofs and applies the corresponding state
     * changes to the given state
     *
     * @param state The from-state of the BlockProver
     * @param stateTransitionProof
     * @param runtimeProof
     * @param executionData
     * @returns The new BlockProver-state to be used as public output
     */
    applyTransaction(state: BlockProverState, stateTransitionProof: Proof<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>, runtimeProof: RuntimeProof, executionData: BlockProverExecutionData): Promise<BlockProverState>;
    assertProtocolTransitions(stateTransitionProof: Proof<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>, executionData: BlockProverExecutionData, runtimeProof: Proof<void, MethodPublicOutput>): Promise<void>;
    private executeBlockHooks;
    private addTransactionToBundle;
    proveTransaction(publicInput: BlockProverPublicInput, stateProof: StateTransitionProof, runtimeProof: RuntimeProof, executionData: BlockProverExecutionData): Promise<BlockProverPublicOutput>;
    private assertSTProofInput;
    proveBlock(publicInput: BlockProverPublicInput, networkState: NetworkState, blockWitness: BlockHashMerkleTreeWitness, stateTransitionProof: StateTransitionProof, transactionProof: BlockProverProof): Promise<BlockProverPublicOutput>;
    merge(publicInput: BlockProverPublicInput, proof1: BlockProverProof, proof2: BlockProverProof): Promise<BlockProverPublicOutput>;
    /**
     * Creates the BlockProver ZkProgram.
     * Recursive linking of proofs is done via the previously
     * injected StateTransitionProver and the required AppChainProof class
     */
    zkProgramFactory(): PlainZkProgram<BlockProverPublicInput, BlockProverPublicOutput>;
}
/**
 * BlockProver class, which aggregates a AppChainProof and
 * a StateTransitionProof into a single BlockProof, that can
 * then be merged to be committed to the base-layer contract
 */
export declare class BlockProver extends ProtocolModule implements BlockProvable {
    readonly stateTransitionProver: WithZkProgrammable<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>;
    readonly runtime: WithZkProgrammable<undefined, MethodPublicOutput>;
    zkProgrammable: BlockProverProgrammable;
    constructor(stateTransitionProver: WithZkProgrammable<StateTransitionProverPublicInput, StateTransitionProverPublicOutput>, runtime: WithZkProgrammable<undefined, MethodPublicOutput>, transactionHooks: ProvableTransactionHook<unknown>[], blockHooks: ProvableBlockHook<unknown>[]);
    proveTransaction(publicInput: BlockProverPublicInput, stateProof: StateTransitionProof, appProof: Proof<void, MethodPublicOutput>, executionData: BlockProverExecutionData): Promise<BlockProverPublicOutput>;
    proveBlock(publicInput: BlockProverPublicInput, networkState: NetworkState, blockWitness: BlockHashMerkleTreeWitness, stateTransitionProof: StateTransitionProof, transactionProof: BlockProverProof): Promise<BlockProverPublicOutput>;
    merge(publicInput: BlockProverPublicInput, proof1: BlockProverProof, proof2: BlockProverProof): Promise<BlockProverPublicOutput>;
}
//# sourceMappingURL=BlockProver.d.ts.map