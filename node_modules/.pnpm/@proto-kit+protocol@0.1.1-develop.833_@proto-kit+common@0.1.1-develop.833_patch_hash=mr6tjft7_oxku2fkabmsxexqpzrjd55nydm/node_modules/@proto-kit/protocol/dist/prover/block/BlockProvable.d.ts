import { Bool, Field, Proof, Signature } from "o1js";
import { WithZkProgrammable } from "@proto-kit/common";
import { StateTransitionProof } from "../statetransition/StateTransitionProvable";
import { MethodPublicOutput } from "../../model/MethodPublicOutput";
import { RuntimeTransaction } from "../../model/transaction/RuntimeTransaction";
import { NetworkState } from "../../model/network/NetworkState";
import { BlockHashMerkleTreeWitness } from "./accummulators/BlockHashMerkleTree";
declare const BlockProverPublicInput_base: (new (value: {
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
}) => {
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
}, {
    transactionsHash: bigint;
    stateRoot: bigint;
    networkStateHash: bigint;
    blockHashRoot: bigint;
    eternalTransactionsHash: bigint;
    incomingMessagesHash: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    };
} & {
    fromValue: (value: {
        transactionsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        transactionsHash: string;
        stateRoot: string;
        networkStateHash: string;
        blockHashRoot: string;
        eternalTransactionsHash: string;
        incomingMessagesHash: string;
    };
    fromJSON: (x: {
        transactionsHash: string;
        stateRoot: string;
        networkStateHash: string;
        blockHashRoot: string;
        eternalTransactionsHash: string;
        incomingMessagesHash: string;
    }) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    };
};
export declare class BlockProverPublicInput extends BlockProverPublicInput_base {
}
declare const BlockProverPublicOutput_base: (new (value: {
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    closed: import("o1js/dist/node/lib/provable/bool").Bool;
    blockNumber: import("o1js/dist/node/lib/provable/field").Field;
}) => {
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    closed: import("o1js/dist/node/lib/provable/bool").Bool;
    blockNumber: import("o1js/dist/node/lib/provable/field").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    stateRoot: import("o1js/dist/node/lib/provable/field").Field;
    networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
    blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
    eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
    incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
    closed: import("o1js/dist/node/lib/provable/bool").Bool;
    blockNumber: import("o1js/dist/node/lib/provable/field").Field;
}, {
    transactionsHash: bigint;
    stateRoot: bigint;
    networkStateHash: bigint;
    blockHashRoot: bigint;
    eternalTransactionsHash: bigint;
    incomingMessagesHash: bigint;
    closed: boolean;
    blockNumber: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    };
} & {
    fromValue: (value: {
        transactionsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
        closed: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        transactionsHash: string;
        stateRoot: string;
        networkStateHash: string;
        blockHashRoot: string;
        eternalTransactionsHash: string;
        incomingMessagesHash: string;
        closed: boolean;
        blockNumber: string;
    };
    fromJSON: (x: {
        transactionsHash: string;
        stateRoot: string;
        networkStateHash: string;
        blockHashRoot: string;
        eternalTransactionsHash: string;
        incomingMessagesHash: string;
        closed: boolean;
        blockNumber: string;
    }) => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        transactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        stateRoot: import("o1js/dist/node/lib/provable/field").Field;
        networkStateHash: import("o1js/dist/node/lib/provable/field").Field;
        blockHashRoot: import("o1js/dist/node/lib/provable/field").Field;
        eternalTransactionsHash: import("o1js/dist/node/lib/provable/field").Field;
        incomingMessagesHash: import("o1js/dist/node/lib/provable/field").Field;
        closed: import("o1js/dist/node/lib/provable/bool").Bool;
        blockNumber: import("o1js/dist/node/lib/provable/field").Field;
    };
};
export declare class BlockProverPublicOutput extends BlockProverPublicOutput_base {
    equals(input: BlockProverPublicInput, closed: Bool, blockNumber: Field): Bool;
}
export type BlockProverProof = Proof<BlockProverPublicInput, BlockProverPublicOutput>;
declare const BlockProverExecutionData_base: (new (value: {
    transaction: RuntimeTransaction;
    signature: Signature;
    networkState: NetworkState;
}) => {
    transaction: RuntimeTransaction;
    signature: Signature;
    networkState: NetworkState;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/lib/provable/provable").Provable<{
    transaction: RuntimeTransaction;
    signature: Signature;
    networkState: NetworkState;
}, {
    transaction: {
        methodId: bigint;
        argsHash: bigint;
        nonce: {
            isSome: boolean;
            value: any;
        };
        sender: {
            isSome: boolean;
            value: any;
        };
    };
    signature: any;
    networkState: {
        block: {
            height: bigint;
        };
        previous: {
            rootHash: bigint;
        };
    };
}> & {
    fromValue: (value: {
        transaction: RuntimeTransaction | {
            methodId: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            argsHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            nonce: import("../..").UInt64Option | {
                isSome: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
                value: any;
            };
            sender: import("../..").PublicKeyOption | {
                isSome: boolean | import("o1js/dist/node/lib/provable/bool").Bool;
                value: any;
            };
        };
        signature: any;
        networkState: NetworkState | {
            block: import("../../model/network/NetworkState").CurrentBlock | {
                height: bigint | import("o1js/dist/node/lib/provable/int").UInt64;
            };
            previous: import("../../model/network/NetworkState").PreviousBlock | {
                rootHash: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
            };
        };
    }) => {
        transaction: RuntimeTransaction;
        signature: Signature;
        networkState: NetworkState;
    };
    toInput: (x: {
        transaction: RuntimeTransaction;
        signature: Signature;
        networkState: NetworkState;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        transaction: RuntimeTransaction;
        signature: Signature;
        networkState: NetworkState;
    }) => {
        transaction: {
            methodId: string;
            argsHash: string;
            nonce: {
                isSome: boolean;
                value: any;
            };
            sender: {
                isSome: boolean;
                value: any;
            };
        };
        signature: any;
        networkState: {
            block: {
                height: string;
            };
            previous: {
                rootHash: string;
            };
        };
    };
    fromJSON: (x: {
        transaction: {
            methodId: string;
            argsHash: string;
            nonce: {
                isSome: boolean;
                value: any;
            };
            sender: {
                isSome: boolean;
                value: any;
            };
        };
        signature: any;
        networkState: {
            block: {
                height: string;
            };
            previous: {
                rootHash: string;
            };
        };
    }) => {
        transaction: RuntimeTransaction;
        signature: Signature;
        networkState: NetworkState;
    };
    empty: () => {
        transaction: RuntimeTransaction;
        signature: Signature;
        networkState: NetworkState;
    };
};
export declare class BlockProverExecutionData extends BlockProverExecutionData_base {
}
export interface BlockProvable extends WithZkProgrammable<BlockProverPublicInput, BlockProverPublicOutput> {
    proveTransaction: (publicInput: BlockProverPublicInput, stateProof: StateTransitionProof, appProof: Proof<void, MethodPublicOutput>, executionData: BlockProverExecutionData) => Promise<BlockProverPublicOutput>;
    proveBlock: (publicInput: BlockProverPublicInput, networkState: NetworkState, blockWitness: BlockHashMerkleTreeWitness, stateTransitionProof: StateTransitionProof, transactionProof: BlockProverProof) => Promise<BlockProverPublicOutput>;
    merge: (publicInput: BlockProverPublicInput, proof1: BlockProverProof, proof2: BlockProverProof) => Promise<BlockProverPublicOutput>;
}
export {};
//# sourceMappingURL=BlockProvable.d.ts.map