import { log, ModuleContainer, } from "@proto-kit/common";
import { Lifecycle } from "tsyringe";
import { NoopBlockHook } from "../hooks/NoopBlockHook";
import { ProvableSettlementHook } from "../settlement/modularity/ProvableSettlementHook";
import { NoopSettlementHook } from "../hooks/NoopSettlementHook";
import { NoopTransactionHook } from "../hooks/NoopTransactionHook";
import { ProvableTransactionHook } from "./ProvableTransactionHook";
import { ProvableBlockHook } from "./ProvableBlockHook";
const PROTOCOL_INJECTION_TOKENS = {
    ProvableTransactionHook: "ProvableTransactionHook",
    ProvableBlockHook: "ProvableBlockHook",
    ProvableSettlementHook: "ProvableSettlementHook",
};
export class Protocol extends ModuleContainer {
    static from(modules) {
        return class ScopedProtocol extends Protocol {
            constructor() {
                super(modules);
            }
        };
    }
    constructor(definition) {
        super(definition);
        this.definition = definition;
    }
    get stateService() {
        return this.stateServiceProvider.stateService;
    }
    get stateServiceProvider() {
        return this.container.resolve("StateServiceProvider");
    }
    decorateModule(moduleName, containedModule) {
        log.debug(`Decorated ${moduleName}`);
        containedModule.protocol = this;
        if (containedModule instanceof ProvableTransactionHook) {
            containedModule.name = moduleName;
        }
        super.decorateModule(moduleName, containedModule);
    }
    get dependencyContainer() {
        return this.container;
    }
    isModule(moduleName) {
        return this.definition.modules[moduleName] !== undefined;
    }
    get blockProver() {
        // Why do I resolve directly here?
        // I don't know exactly but generics don't let me use .resolve()
        return this.container.resolve("BlockProver");
    }
    get stateTransitionProver() {
        return this.container.resolve("StateTransitionProver");
    }
    getAreProofsEnabled() {
        return this.container.resolve("AreProofsEnabled");
    }
    create(childContainerProvider) {
        super.create(childContainerProvider);
        // Register the BlockModules seperately since we need to
        // inject them differently later
        const ABSTRACT_MODULE_TYPES = [
            { type: ProvableTransactionHook, defaultType: NoopTransactionHook },
            { type: ProvableBlockHook, defaultType: NoopBlockHook },
            { type: ProvableSettlementHook, defaultType: NoopSettlementHook },
        ];
        ABSTRACT_MODULE_TYPES.forEach((moduleTypeRegistration) => {
            const abstractType = moduleTypeRegistration.type;
            const implementingModules = Object.entries(this.definition.modules).filter(([, value]) => Object.prototype.isPrototypeOf.call(abstractType, value));
            const newInjectionToken = PROTOCOL_INJECTION_TOKENS[abstractType.name];
            if (newInjectionToken === undefined) {
                log.error("Can't inject hook under the underlying hook token: Alias not found in mapping");
                return;
            }
            implementingModules.forEach(([key]) => {
                this.container.register(abstractType.name, { useToken: key }, { lifecycle: Lifecycle.ContainerScoped });
            });
            if (implementingModules.length === 0) {
                // This type annotation shouldn't change anything but is necessary
                // bcs tsyringe complains
                const { defaultType } = moduleTypeRegistration;
                // Register default (noop) version
                this.container.register(abstractType.name, { useClass: defaultType }, { lifecycle: Lifecycle.ContainerScoped });
            }
        });
    }
    async start() {
        // eslint-disable-next-line guard-for-in
        for (const moduleName in this.definition.modules) {
            const protocolModule = this.resolve(moduleName);
            log.info(`Starting protocol module ${moduleName} (${protocolModule.constructor.name})`);
            // eslint-disable-next-line no-await-in-loop
            await protocolModule.start();
        }
    }
}
