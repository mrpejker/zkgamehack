import { Field, Poseidon, Provable } from "o1js";
import floor from "lodash/floor";
export function notInCircuit() {
    return function ReplacedFunction(target, propertyKey, descriptor) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const childFunction = descriptor.value;
        descriptor.value = function value(...args) {
            if (Provable.inCheckedComputation() || Provable.inProver()) {
                throw new Error(`Method ${propertyKey.toString()} is supposed to be only called outside of the circuit`);
            }
            return childFunction.apply(this, args);
        };
        return descriptor;
    };
}
export function stringToField(value) {
    const fieldSize = Field.sizeInBytes - 1;
    // Encode string as byte[]
    const encoder = new TextEncoder();
    const stringBytes = Array.from(encoder.encode(value));
    // Add padding in case the string is not a multiple of Field.sizeInBytes
    const padding = Array.from({
        length: fieldSize - (stringBytes.length % fieldSize),
    }).fill(0);
    const data = stringBytes.concat(padding).reverse();
    // Hash the result Field[] to reduce it to
    const chunks = data.reduce((a, b, index) => {
        const arrayIndex = floor(index / fieldSize);
        a[arrayIndex].push(b);
        return a;
    }, Array.from({ length: floor(data.length / fieldSize) }).map(() => []));
    const fields = chunks.map((x) => 
    // We have to add a zero at the highest byte here, because a Field is
    // a bit smaller than 2^256
    Field.fromBytes(x.concat([0])));
    return Poseidon.hash(fields);
}
export function singleFieldToString(value) {
    let fieldValue = value;
    if (typeof value === "bigint") {
        fieldValue = Field(value);
    }
    return fieldValue.toString();
}
