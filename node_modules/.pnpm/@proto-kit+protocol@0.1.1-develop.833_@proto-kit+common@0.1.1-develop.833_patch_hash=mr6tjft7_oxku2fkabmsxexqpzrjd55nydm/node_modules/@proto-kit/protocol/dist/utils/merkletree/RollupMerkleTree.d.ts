import { Bool, Field } from "o1js";
import { MerkleTreeStore } from "./MerkleTreeStore";
export { RollupMerkleTree, RollupMerkleWitness };
export { maybeSwap };
declare const RollupMerkleWitness_base: (new (value: {
    path: import("o1js/dist/node/lib/field").Field[];
    isLeft: import("o1js/dist/node/lib/bool").Bool[];
}) => {
    path: import("o1js/dist/node/lib/field").Field[];
    isLeft: import("o1js/dist/node/lib/bool").Bool[];
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    path: import("o1js/dist/node/lib/field").Field[];
    isLeft: import("o1js/dist/node/lib/bool").Bool[];
}> & {
    toInput: (x: {
        path: import("o1js/dist/node/lib/field").Field[];
        isLeft: import("o1js/dist/node/lib/bool").Bool[];
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        path: import("o1js/dist/node/lib/field").Field[];
        isLeft: import("o1js/dist/node/lib/bool").Bool[];
    }) => {
        path: string[];
        isLeft: boolean[];
    };
    fromJSON: (x: {
        path: string[];
        isLeft: boolean[];
    }) => {
        path: import("o1js/dist/node/lib/field").Field[];
        isLeft: import("o1js/dist/node/lib/bool").Bool[];
    };
};
/**
 * The {@link BaseMerkleWitness} class defines a circuit-compatible base class
 * for [Merkle Witness'](https://computersciencewiki.org/index.php/Merkle_proof).
 */
declare class RollupMerkleWitness extends RollupMerkleWitness_base {
    static height: number;
    height(): number;
    /**
     * Calculates a root depending on the leaf value.
     * @param leaf Value of the leaf node that belongs to this Witness.
     * @returns The calculated root.
     */
    calculateRoot(hash: Field): Field;
    /**
     * Calculates the index of the leaf node that belongs to this Witness.
     * @returns Index of the leaf.
     */
    calculateIndex(): Field;
    toShortenedEntries(): string[];
}
/**
 * A [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) is a binary tree in
 * which every leaf is the cryptography hash of a piece of data,
 * and every node is the hash of the concatenation of its two child nodes.
 *
 * A Merkle Tree allows developers to easily and securely verify
 * the integrity of large amounts of data.
 *
 * Take a look at our [documentation](https://docs.minaprotocol.com/en/zkapps)
 * on how to use Merkle Trees in combination with zkApps and
 * zero knowledge programming!
 *
 * Levels are indexed from leaves (level 0) to root (level N - 1).
 */
declare class RollupMerkleTree {
    static height: number;
    static EMPTY_ROOT: bigint;
    static get leafCount(): bigint;
    private readonly zeroes;
    readonly store: MerkleTreeStore;
    constructor(store: MerkleTreeStore);
    /**
     * Returns a node which lives at a given index and level.
     * @param level Level of the node.
     * @param index Index of the node.
     * @returns The data of the node.
     */
    getNode(level: number, index: bigint): Field;
    /**
     * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
     * @returns The root of the Merkle Tree.
     */
    getRoot(): Field;
    private setNode;
    /**
     * TODO: if this is passed an index bigger than the max, it will set a couple
     * of out-of-bounds nodes but not affect the real Merkle root. OK?
     */
    /**
     * Sets the value of a leaf node at a given index to a given value.
     * @param index Position of the leaf node.
     * @param leaf New value.
     */
    setLeaf(index: bigint, leaf: Field): void;
    /**
     * Returns the witness (also known as
     * [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof))
     * for the leaf at the given index.
     * @param index Position of the leaf node.
     * @returns The witness that belongs to the leaf.
     */
    getWitness(index: bigint): RollupMerkleWitness;
    /**
     * Fills all leaves of the tree.
     * @param leaves Values to fill the leaves with.
     */
    fill(leaves: Field[]): void;
    /**
     * Returns the amount of leaf nodes.
     * @returns Amount of leaf nodes.
     */
    get leafCount(): bigint;
}
export declare namespace MerkleTreeUtils {
    function normalizeKey(key: Field): Field;
    function checkMembership(witness: RollupMerkleWitness, root: Field, key: Field, value: Field): Bool;
    function checkMembershipGetRoots(witness: RollupMerkleWitness, root: Field, key: Field, value: Field): [Bool, Field, Field];
    function computeRoot(witness: RollupMerkleWitness, value: Field): Field;
}
/**
 * More efficient version of `maybeSwapBad` which
 * reuses an intermediate variable
 */
declare function maybeSwap(b: Bool, x: Field, y: Field): [Field, Field];
//# sourceMappingURL=RollupMerkleTree.d.ts.map