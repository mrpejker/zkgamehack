var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PrismaClient } from "@prisma/client";
import { sequencerModule, SequencerModule, } from "@proto-kit/sequencer";
import { PrismaStateService } from "./services/prisma/PrismaStateService";
import { PrismaBatchStore } from "./services/prisma/PrismaBatchStore";
import { PrismaBlockStorage } from "./services/prisma/PrismaBlockStorage";
import { PrismaSettlementStorage } from "./services/prisma/PrismaSettlementStorage";
import { PrismaMessageStorage } from "./services/prisma/PrismaMessageStorage";
import { PrismaTransactionStorage } from "./services/prisma/PrismaTransactionStorage";
export let PrismaDatabaseConnection = class PrismaDatabaseConnection extends SequencerModule {
    constructor() {
        super(...arguments);
        this.initializedClient = undefined;
    }
    get prismaClient() {
        if (this.initializedClient === undefined) {
            throw new Error("Client not initialized yet, wait for after the startup");
        }
        return this.initializedClient;
    }
    dependencies() {
        return {
            asyncStateService: {
                useFactory: () => new PrismaStateService(this, "batch"),
            },
            batchStorage: {
                useClass: PrismaBatchStore,
            },
            blockQueue: {
                useClass: PrismaBlockStorage,
            },
            blockStorage: {
                useClass: PrismaBlockStorage,
            },
            unprovenStateService: {
                useFactory: () => new PrismaStateService(this, "block"),
            },
            settlementStorage: {
                useClass: PrismaSettlementStorage,
            },
            messageStorage: {
                useClass: PrismaMessageStorage,
            },
            transactionStorage: {
                useClass: PrismaTransactionStorage,
            },
        };
    }
    async pruneDatabase() {
        const tables = [
            "TransactionExecutionResult",
            "Transaction",
            "Block",
            "Batch",
            "BlockResult",
            "State",
            "Settlement",
            "IncomingMessageBatch",
            "IncomingMessageBatchTransaction",
        ];
        await this.prismaClient.$transaction(tables.map((table) => this.prismaClient.$executeRawUnsafe(`TRUNCATE TABLE "${table}" CASCADE`)));
    }
    buildConnectionString(connection) {
        const { host, port, username, password, db } = connection;
        const dbString = db !== undefined
            ? `${db.name}?schema=${db.schema ?? "public"}`
            : "protokit?schema=public";
        return `postgresql://${username}:${password}@${host}:${port ?? 5432}/${dbString}`;
    }
    async start() {
        const { connection } = this.config;
        if (connection !== undefined) {
            const url = typeof connection === "string"
                ? connection
                : this.buildConnectionString(connection);
            this.initializedClient = new PrismaClient({
                datasources: {
                    db: {
                        url,
                    },
                },
            });
        }
        else {
            this.initializedClient = new PrismaClient();
        }
    }
    async close() {
        await this.prismaClient.$disconnect();
    }
};
PrismaDatabaseConnection = __decorate([
    sequencerModule()
], PrismaDatabaseConnection);
