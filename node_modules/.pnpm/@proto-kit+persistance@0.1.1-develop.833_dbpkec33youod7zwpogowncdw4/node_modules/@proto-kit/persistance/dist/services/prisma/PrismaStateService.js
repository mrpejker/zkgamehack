var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Field } from "o1js";
import { Prisma } from "@prisma/client";
import { noop } from "@proto-kit/common";
import { injectable } from "tsyringe";
// We need to create a correctly configured Decimal constructor
// with our parameters
const Decimal = Prisma.Decimal.clone({
    precision: 78,
});
export let PrismaStateService = class PrismaStateService {
    /**
     * @param connection
     * @param mask A indicator to which masking level the values belong
     */
    constructor(connection, mask) {
        this.connection = connection;
        this.mask = mask;
        this.cache = [];
    }
    async commit() {
        const { prismaClient } = this.connection;
        const data = this.cache
            .filter((entry) => entry.value !== undefined)
            .map((entry) => ({
            path: new Decimal(entry.key.toString()),
            values: entry.value.map((field) => new Decimal(field.toString())),
            mask: this.mask,
        }));
        await prismaClient.$transaction([
            prismaClient.state.deleteMany({
                where: {
                    path: {
                        in: this.cache.map((x) => new Decimal(x.key.toString())),
                    },
                    mask: this.mask,
                },
            }),
            prismaClient.state.createMany({
                data,
            }),
        ]);
        this.cache = [];
    }
    async getMany(keys) {
        const records = await this.connection.prismaClient.state.findMany({
            where: {
                AND: [
                    {
                        path: {
                            in: keys.map((key) => new Decimal(key.toString())),
                        },
                    },
                    {
                        mask: this.mask,
                    },
                ],
            },
        });
        return records.map((record) => ({
            key: Field(record.path.toFixed()),
            value: record.values.map((x) => Field(x.toFixed())),
        }));
    }
    async openTransaction() {
        noop();
    }
    async get(key) {
        const state = await this.getMany([key]);
        return state.at(-1)?.value;
    }
    writeStates(entries) {
        this.cache.push(...entries);
    }
};
PrismaStateService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Object, String])
], PrismaStateService);
