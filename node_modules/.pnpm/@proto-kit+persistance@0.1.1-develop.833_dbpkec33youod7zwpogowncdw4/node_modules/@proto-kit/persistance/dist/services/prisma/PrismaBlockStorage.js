var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { distinctByString, } from "@proto-kit/sequencer";
import { filterNonNull, log } from "@proto-kit/common";
import { Prisma, } from "@prisma/client";
import { inject, injectable } from "tsyringe";
import { TransactionExecutionResultMapper, TransactionMapper, } from "./mappers/TransactionMapper";
import { BlockResultMapper } from "./mappers/BlockResultMapper";
import { BlockMapper } from "./mappers/BlockMapper";
export let PrismaBlockStorage = class PrismaBlockStorage {
    constructor(connection, transactionResultMapper, transactionMapper, blockResultMapper, blockMapper) {
        this.connection = connection;
        this.transactionResultMapper = transactionResultMapper;
        this.transactionMapper = transactionMapper;
        this.blockResultMapper = blockResultMapper;
        this.blockMapper = blockMapper;
    }
    async getBlockByQuery(where) {
        const dbResult = await this.connection.prismaClient.block.findFirst({
            where,
            include: {
                transactions: {
                    include: {
                        tx: true,
                    },
                },
                result: true,
            },
        });
        if (dbResult === null) {
            return undefined;
        }
        const transactions = dbResult.transactions.map((txresult) => this.transactionResultMapper.mapIn([txresult, txresult.tx]));
        if (dbResult.result === undefined || dbResult.result === null) {
            throw new Error(`No Metadata has been set for block ${JSON.stringify(where)} yet`);
        }
        return {
            block: {
                ...this.blockMapper.mapIn(dbResult),
                transactions,
            },
            result: this.blockResultMapper.mapIn(dbResult.result),
        };
    }
    async getBlockAt(height) {
        return (await this.getBlockByQuery({ height }))?.block;
    }
    async getBlock(hash) {
        return (await this.getBlockByQuery({ hash }))?.block;
    }
    async pushBlock(block) {
        log.trace("Pushing block to DB. Txs:", block.transactions.map((x) => x.tx.hash().toString()));
        const transactions = block.transactions.map((tx) => {
            const encoded = this.transactionResultMapper.mapOut(tx);
            return {
                ...encoded[0],
                blockHash: block.hash.toString(),
            };
        });
        const encodedBlock = this.blockMapper.mapOut(block);
        const { prismaClient } = this.connection;
        await prismaClient.$transaction([
            prismaClient.transaction.createMany({
                data: block.transactions.map((txr) => this.transactionMapper.mapOut(txr.tx)),
                skipDuplicates: true,
            }),
            prismaClient.block.create({
                data: {
                    ...encodedBlock,
                    beforeNetworkState: encodedBlock.beforeNetworkState,
                    duringNetworkState: encodedBlock.duringNetworkState,
                    transactions: {
                        createMany: {
                            data: transactions.map((tx) => {
                                return {
                                    status: tx.status,
                                    statusMessage: tx.statusMessage,
                                    txHash: tx.txHash,
                                    stateTransitions: tx.stateTransitions,
                                    protocolTransitions: tx.protocolTransitions,
                                };
                            }),
                            skipDuplicates: true,
                        },
                    },
                    batchHeight: undefined,
                },
            }),
        ]);
    }
    async pushMetadata(metadata) {
        const encoded = this.blockResultMapper.mapOut(metadata);
        await this.connection.prismaClient.blockResult.create({
            data: {
                afterNetworkState: encoded.afterNetworkState,
                blockHashWitness: encoded.blockHashWitness,
                blockStateTransitions: encoded.blockStateTransitions,
                stateRoot: encoded.stateRoot,
                blockHash: encoded.blockHash,
                blockHashRoot: encoded.blockHashRoot,
            },
        });
    }
    // TODO Phase out and replace with getLatestBlock().network.height
    async getCurrentBlockHeight() {
        const result = await this.connection.prismaClient.block.aggregate({
            _max: {
                height: true,
            },
        });
        // TODO I have no idea what this should give in case no blocks are in the DB. Document properly
        return (result?._max.height ?? -1) + 1;
    }
    async getLatestBlock() {
        const latestBlock = await this.connection.prismaClient.$queryRaw `SELECT b1."hash" FROM "Block" b1 
        LEFT JOIN "Block" child ON child."parentHash" = b1."hash"
        WHERE child IS NULL LIMIT 1`;
        if (latestBlock.length === 0) {
            return undefined;
        }
        return await this.getBlockByQuery({
            hash: latestBlock[0].hash,
        });
    }
    async getNewBlocks() {
        const blocks = await this.connection.prismaClient.block.findMany({
            where: {
                batch: null,
            },
            include: {
                transactions: {
                    include: {
                        tx: true,
                    },
                },
            },
            orderBy: {
                height: Prisma.SortOrder.asc,
            },
        });
        const blockHashes = blocks
            .flatMap((block) => [block.parentHash, block.hash])
            .filter(filterNonNull)
            .filter(distinctByString);
        const result = await this.connection.prismaClient.blockResult.findMany({
            where: {
                blockHash: {
                    in: blockHashes,
                },
            },
        });
        return blocks.map((block, index) => {
            const transactions = block.transactions.map((txresult) => {
                return this.transactionResultMapper.mapIn([txresult, txresult.tx]);
            });
            const decodedBlock = this.blockMapper.mapIn(block);
            decodedBlock.transactions = transactions;
            const correspondingResult = result.find((candidate) => candidate.blockHash === block.hash);
            if (correspondingResult === undefined) {
                throw new Error(`No BlockResult has been set for block ${block.hash} yet`);
            }
            const parentResult = result.find((candidate) => candidate.blockHash === block.parentHash);
            return {
                block: {
                    block: decodedBlock,
                    result: this.blockResultMapper.mapIn(correspondingResult),
                },
                lastBlockResult: parentResult !== undefined
                    ? this.blockResultMapper.mapIn(parentResult)
                    : undefined,
            };
        });
    }
};
PrismaBlockStorage = __decorate([
    injectable(),
    __param(0, inject("Database")),
    __metadata("design:paramtypes", [Object, TransactionExecutionResultMapper,
        TransactionMapper,
        BlockResultMapper,
        BlockMapper])
], PrismaBlockStorage);
