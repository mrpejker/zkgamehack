import { observable } from '@trpc/server/observable';
import { transformResult } from '@trpc/server/unstable-core-do-not-import';
import { dataLoader } from '../../internals/dataLoader.mjs';
import { TRPCClientError } from '../../TRPCClientError.mjs';
import { resolveHTTPLinkOptions, getUrl } from './httpUtils.mjs';

/**
 * @internal
 */ function createHTTPBatchLink(requester) {
    return function httpBatchLink(opts) {
        const resolvedOpts = resolveHTTPLinkOptions(opts);
        const maxURLLength = opts.maxURLLength ?? Infinity;
        // initialized config
        return (runtime)=>{
            const batchLoader = (type)=>{
                const validate = (batchOps)=>{
                    if (maxURLLength === Infinity) {
                        // escape hatch for quick calcs
                        return true;
                    }
                    const path = batchOps.map((op)=>op.path).join(',');
                    const inputs = batchOps.map((op)=>op.input);
                    const url = getUrl({
                        ...resolvedOpts,
                        type,
                        path,
                        inputs
                    });
                    return url.length <= maxURLLength;
                };
                const fetch = requester({
                    ...resolvedOpts,
                    runtime,
                    type,
                    opts
                });
                return {
                    validate,
                    fetch
                };
            };
            const query = dataLoader(batchLoader('query'));
            const mutation = dataLoader(batchLoader('mutation'));
            const subscription = dataLoader(batchLoader('subscription'));
            const loaders = {
                query,
                subscription,
                mutation
            };
            return ({ op  })=>{
                return observable((observer)=>{
                    const loader = loaders[op.type];
                    const { promise , cancel  } = loader.load(op);
                    let _res = undefined;
                    promise.then((res)=>{
                        _res = res;
                        const transformed = transformResult(res.json, resolvedOpts.transformer.output);
                        if (!transformed.ok) {
                            observer.error(TRPCClientError.from(transformed.error, {
                                meta: res.meta
                            }));
                            return;
                        }
                        observer.next({
                            context: res.meta,
                            result: transformed.result
                        });
                        observer.complete();
                    }).catch((err)=>{
                        observer.error(TRPCClientError.from(err, {
                            meta: _res?.meta
                        }));
                    });
                    return ()=>{
                        cancel();
                    };
                });
            };
        };
    };
}

export { createHTTPBatchLink };
