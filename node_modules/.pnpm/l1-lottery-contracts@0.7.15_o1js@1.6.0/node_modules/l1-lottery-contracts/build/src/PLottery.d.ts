import { Field, SmartContract, State, UInt32, MerkleMapWitness, UInt64, PublicKey, Provable } from 'o1js';
import { Ticket } from './Ticket.js';
import { DistributionProof } from './DistributionProof.js';
import { MerkleMap20Witness } from './CustomMerkleMap.js';
import { LotteryAction, TicketReduceProof } from './TicketReduceProof.js';
export interface MerkleCheckResult {
    key: Field;
}
export declare const mockResult: import("o1js/dist/node/lib/provable/field.js").Field;
declare const BuyTicketEvent_base: (new (value: {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    ticket: {
        numbers: bigint[];
        owner: {
            x: bigint;
            isOdd: boolean;
        };
        amount: bigint;
    };
    round: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        ticket: Ticket | {
            numbers: UInt32[] | bigint[];
            owner: PublicKey | {
                x: bigint | import("o1js/dist/node/lib/provable/field.js").Field;
                isOdd: boolean | import("o1js/dist/node/lib/provable/bool.js").Bool;
            };
            amount: bigint | UInt64;
        };
        round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    };
    fromJSON: (x: {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class BuyTicketEvent extends BuyTicketEvent_base {
}
declare const ProduceResultEvent_base: (new (value: {
    result: import("o1js/dist/node/lib/provable/field.js").Field;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    result: import("o1js/dist/node/lib/provable/field.js").Field;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    result: import("o1js/dist/node/lib/provable/field.js").Field;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    result: bigint;
    round: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        result: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        result: string;
        round: string;
    };
    fromJSON: (x: {
        result: string;
        round: string;
    }) => {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        result: import("o1js/dist/node/lib/provable/field.js").Field;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class ProduceResultEvent extends ProduceResultEvent_base {
}
declare const GetRewardEvent_base: (new (value: {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    ticket: {
        numbers: bigint[];
        owner: {
            x: bigint;
            isOdd: boolean;
        };
        amount: bigint;
    };
    round: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        ticket: Ticket | {
            numbers: UInt32[] | bigint[];
            owner: PublicKey | {
                x: bigint | import("o1js/dist/node/lib/provable/field.js").Field;
                isOdd: boolean | import("o1js/dist/node/lib/provable/bool.js").Bool;
            };
            amount: bigint | UInt64;
        };
        round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    };
    fromJSON: (x: {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class GetRewardEvent extends GetRewardEvent_base {
}
declare const RefundEvent_base: (new (value: {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    ticket: {
        numbers: bigint[];
        owner: {
            x: bigint;
            isOdd: boolean;
        };
        amount: bigint;
    };
    round: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        ticket: Ticket | {
            numbers: UInt32[] | bigint[];
            owner: PublicKey | {
                x: bigint | import("o1js/dist/node/lib/provable/field.js").Field;
                isOdd: boolean | import("o1js/dist/node/lib/provable/bool.js").Bool;
            };
            amount: bigint | UInt64;
        };
        round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    };
    fromJSON: (x: {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class RefundEvent extends RefundEvent_base {
}
declare const ReduceEvent_base: (new (value: {
    startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    startActionState: bigint;
    endActionState: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        startActionState: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        startActionState: string;
        endActionState: string;
    };
    fromJSON: (x: {
        startActionState: string;
        endActionState: string;
    }) => {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        startActionState: import("o1js/dist/node/lib/provable/field.js").Field;
        endActionState: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class ReduceEvent extends ReduceEvent_base {
}
export declare class PLottery extends SmartContract {
    reducer: {
        dispatch(action: LotteryAction): void;
        reduce<State>(actions: import("o1js").MerkleList<import("o1js").MerkleList<LotteryAction>>, stateType: Provable<State>, reduce: (state: State, action: LotteryAction) => State, initial: State, options?: {
            maxUpdatesWithActions?: number | undefined;
            maxActionsPerUpdate?: number | undefined;
            skipActionStatePrecondition?: boolean | undefined;
        } | undefined): State;
        forEach(actions: import("o1js").MerkleList<import("o1js").MerkleList<LotteryAction>>, reduce: (action: LotteryAction) => void, options?: {
            maxUpdatesWithActions?: number | undefined;
            maxActionsPerUpdate?: number | undefined;
            skipActionStatePrecondition?: boolean | undefined;
        } | undefined): void;
        getActions({ fromActionState, endActionState, }?: {
            fromActionState?: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
            endActionState?: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
        } | undefined): import("o1js").MerkleList<import("o1js").MerkleList<LotteryAction>>;
        fetchActions({ fromActionState, endActionState, }?: {
            fromActionState?: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
            endActionState?: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
        } | undefined): Promise<LotteryAction[][]>;
    };
    events: {
        'buy-ticket': typeof BuyTicketEvent;
        'produce-result': typeof ProduceResultEvent;
        'get-reward': typeof GetRewardEvent;
        'get-refund': typeof RefundEvent;
        reduce: typeof ReduceEvent;
    };
    ticketRoot: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    ticketNullifier: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    bankRoot: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    roundResultRoot: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    startBlock: State<UInt32>;
    lastProcessedState: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    lastReduceInRound: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    lastProcessedTicketId: State<import("o1js/dist/node/lib/provable/field.js").Field>;
    init(): void;
    buyTicket(ticket: Ticket, round: Field): Promise<void>;
    reduceTickets(reduceProof: TicketReduceProof): Promise<void>;
    produceResult(resultWiness: MerkleMap20Witness, result: Field, bankValue: Field, bankWitness: MerkleMap20Witness): Promise<void>;
    refund(ticket: Ticket, roundWitness: MerkleMap20Witness, roundTicketWitness: MerkleMap20Witness, resultWitness: MerkleMap20Witness, nullifierWitness: MerkleMapWitness): Promise<void>;
    getReward(ticket: Ticket, roundWitness: MerkleMap20Witness, roundTicketWitness: MerkleMap20Witness, dp: DistributionProof, winningNumbers: Field, resutWitness: MerkleMap20Witness, bankValue: Field, bankWitness: MerkleMap20Witness, nullifierWitness: MerkleMapWitness): Promise<void>;
    checkCurrentRound(round: UInt32): void;
    checkRoundPass(round: UInt32): void;
    getWiningNumbersForRound(): UInt32[];
    private checkResult;
    private checkBank;
    private checkAndUpdateBank;
    private checkAndUpdateNullifier;
    private checkAndUpdateMap;
    private checkMap;
    private checkTicket;
}
export {};
