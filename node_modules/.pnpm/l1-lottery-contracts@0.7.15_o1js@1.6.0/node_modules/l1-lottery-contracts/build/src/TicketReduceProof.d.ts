import { Field, MerkleList, SelfProof, UInt64 } from 'o1js';
import { Ticket } from './Ticket.js';
import { MerkleMap20Witness } from './CustomMerkleMap.js';
declare const LotteryAction_base: (new (value: {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    ticket: Ticket;
    round: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    ticket: {
        numbers: bigint[];
        owner: {
            x: bigint;
            isOdd: boolean;
        };
        amount: bigint;
    };
    round: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        ticket: Ticket | {
            numbers: import("o1js").UInt32[] | bigint[];
            owner: import("o1js").PublicKey | {
                x: bigint | import("o1js/dist/node/lib/provable/field.js").Field;
                isOdd: boolean | import("o1js/dist/node/lib/provable/bool.js").Bool;
            };
            amount: bigint | UInt64;
        };
        round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    };
    fromJSON: (x: {
        ticket: {
            numbers: string[];
            owner: string;
            amount: string;
        };
        round: string;
    }) => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class LotteryAction extends LotteryAction_base {
}
export declare const actionListAdd: (hash: Field, action: LotteryAction) => Field;
declare const ActionList_base: {
    new ({ hash, data }: import("o1js/dist/node/lib/provable/merkle-list.js").MerkleListBase<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>): MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>;
    create<T>(type: import("o1js").ProvableHashable<T>, nextHash?: ((hash: import("o1js/dist/node/lib/provable/field.js").Field, value: T) => import("o1js/dist/node/lib/provable/field.js").Field) | undefined, emptyHash_?: import("o1js/dist/node/lib/provable/field.js").Field | undefined): typeof MerkleList<T> & {
        empty: () => MerkleList<T>;
        from: (array: T[]) => MerkleList<T>;
        fromReverse: (array: T[]) => MerkleList<T>;
        provable: import("o1js").ProvableHashable<MerkleList<T>>;
    };
    _nextHash: ((hash: import("o1js/dist/node/lib/provable/field.js").Field, t: any) => import("o1js/dist/node/lib/provable/field.js").Field) | undefined;
    _emptyHash: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
    _provable: import("o1js").ProvableHashable<MerkleList<any>> | undefined;
    _innerProvable: import("o1js").ProvableHashable<any> | undefined;
    readonly emptyHash: import("o1js/dist/node/lib/provable/field.js").Field;
} & {
    empty: () => MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>;
    from: (array: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }[]) => MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>;
    fromReverse: (array: {
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }[]) => MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>;
    provable: import("o1js").ProvableHashable<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>;
};
export declare class ActionList extends ActionList_base {
}
export declare const merkleActionsAdd: (hash: Field, actionsHash: Field) => Field;
declare const MerkleActions_base: {
    new ({ hash, data }: import("o1js/dist/node/lib/provable/merkle-list.js").MerkleListBase<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>): MerkleList<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>;
    create<T>(type: import("o1js").ProvableHashable<T>, nextHash?: ((hash: import("o1js/dist/node/lib/provable/field.js").Field, value: T) => import("o1js/dist/node/lib/provable/field.js").Field) | undefined, emptyHash_?: import("o1js/dist/node/lib/provable/field.js").Field | undefined): typeof MerkleList<T> & {
        empty: () => MerkleList<T>;
        from: (array: T[]) => MerkleList<T>;
        fromReverse: (array: T[]) => MerkleList<T>;
        provable: import("o1js").ProvableHashable<MerkleList<T>>;
    };
    _nextHash: ((hash: import("o1js/dist/node/lib/provable/field.js").Field, t: any) => import("o1js/dist/node/lib/provable/field.js").Field) | undefined;
    _emptyHash: import("o1js/dist/node/lib/provable/field.js").Field | undefined;
    _provable: import("o1js").ProvableHashable<MerkleList<any>> | undefined;
    _innerProvable: import("o1js").ProvableHashable<any> | undefined;
    readonly emptyHash: import("o1js/dist/node/lib/provable/field.js").Field;
} & {
    empty: () => MerkleList<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>;
    from: (array: MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>[]) => MerkleList<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>;
    fromReverse: (array: MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>[]) => MerkleList<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>;
    provable: import("o1js").ProvableHashable<MerkleList<MerkleList<{
        ticket: Ticket;
        round: import("o1js/dist/node/lib/provable/field.js").Field;
    }>>>;
};
export declare class MerkleActions extends MerkleActions_base {
}
declare const TicketReduceProofPublicInput_base: (new (value: {
    action: LotteryAction;
    roundWitness: MerkleMap20Witness;
    roundTicketWitness: MerkleMap20Witness;
    bankWitness: MerkleMap20Witness;
    bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    action: LotteryAction;
    roundWitness: MerkleMap20Witness;
    roundTicketWitness: MerkleMap20Witness;
    bankWitness: MerkleMap20Witness;
    bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    action: LotteryAction;
    roundWitness: MerkleMap20Witness;
    roundTicketWitness: MerkleMap20Witness;
    bankWitness: MerkleMap20Witness;
    bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    action: {
        ticket: {
            numbers: bigint[];
            owner: {
                x: bigint;
                isOdd: boolean;
            };
            amount: bigint;
        };
        round: bigint;
    };
    roundWitness: {
        isLefts: boolean[];
        siblings: bigint[];
    };
    roundTicketWitness: {
        isLefts: boolean[];
        siblings: bigint[];
    };
    bankWitness: {
        isLefts: boolean[];
        siblings: bigint[];
    };
    bankValue: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        action: LotteryAction | {
            ticket: Ticket | {
                numbers: import("o1js").UInt32[] | bigint[];
                owner: import("o1js").PublicKey | {
                    x: bigint | import("o1js/dist/node/lib/provable/field.js").Field;
                    isOdd: boolean | import("o1js/dist/node/lib/provable/bool.js").Bool;
                };
                amount: bigint | UInt64;
            };
            round: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        };
        roundWitness: MerkleMap20Witness | {
            isLefts: import("o1js/dist/node/lib/provable/bool.js").Bool[] | boolean[];
            siblings: import("o1js/dist/node/lib/provable/field.js").Field[] | bigint[];
        };
        roundTicketWitness: MerkleMap20Witness | {
            isLefts: import("o1js/dist/node/lib/provable/bool.js").Bool[] | boolean[];
            siblings: import("o1js/dist/node/lib/provable/field.js").Field[] | bigint[];
        };
        bankWitness: MerkleMap20Witness | {
            isLefts: import("o1js/dist/node/lib/provable/bool.js").Bool[] | boolean[];
            siblings: import("o1js/dist/node/lib/provable/field.js").Field[] | bigint[];
        };
        bankValue: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        action: {
            ticket: {
                numbers: string[];
                owner: string;
                amount: string;
            };
            round: string;
        };
        roundWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        roundTicketWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        bankWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        bankValue: string;
    };
    fromJSON: (x: {
        action: {
            ticket: {
                numbers: string[];
                owner: string;
                amount: string;
            };
            round: string;
        };
        roundWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        roundTicketWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        bankWitness: {
            isLefts: boolean[];
            siblings: string[];
        };
        bankValue: string;
    }) => {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        action: LotteryAction;
        roundWitness: MerkleMap20Witness;
        roundTicketWitness: MerkleMap20Witness;
        bankWitness: MerkleMap20Witness;
        bankValue: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class TicketReduceProofPublicInput extends TicketReduceProofPublicInput_base {
}
declare const TicketReduceProofPublicOutput_base: (new (value: {
    initialState: import("o1js/dist/node/lib/provable/field.js").Field;
    finalState: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
}) => {
    initialState: import("o1js/dist/node/lib/provable/field.js").Field;
    finalState: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf.js").Provable<{
    initialState: import("o1js/dist/node/lib/provable/field.js").Field;
    finalState: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
    processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
    lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
}, {
    initialState: bigint;
    finalState: bigint;
    initialTicketRoot: bigint;
    initialBankRoot: bigint;
    initialTicketId: bigint;
    newTicketRoot: bigint;
    newBankRoot: bigint;
    processedActionList: bigint;
    lastProcessedRound: bigint;
    lastProcessedTicketId: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field.js").Field[]) => {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        initialState: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    toInput: (x: {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    }) => {
        initialState: string;
        finalState: string;
        initialTicketRoot: string;
        initialBankRoot: string;
        initialTicketId: string;
        newTicketRoot: string;
        newBankRoot: string;
        processedActionList: string;
        lastProcessedRound: string;
        lastProcessedTicketId: string;
    };
    fromJSON: (x: {
        initialState: string;
        finalState: string;
        initialTicketRoot: string;
        initialBankRoot: string;
        initialTicketId: string;
        newTicketRoot: string;
        newBankRoot: string;
        processedActionList: string;
        lastProcessedRound: string;
        lastProcessedTicketId: string;
    }) => {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    };
    empty: () => {
        initialState: import("o1js/dist/node/lib/provable/field.js").Field;
        finalState: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        initialTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
        newTicketRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        newBankRoot: import("o1js/dist/node/lib/provable/field.js").Field;
        processedActionList: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedRound: import("o1js/dist/node/lib/provable/field.js").Field;
        lastProcessedTicketId: import("o1js/dist/node/lib/provable/field.js").Field;
    };
};
export declare class TicketReduceProofPublicOutput extends TicketReduceProofPublicOutput_base {
}
export declare const init: (input: TicketReduceProofPublicInput, initialState: Field, initialTicketRoot: Field, initialBankRoot: Field, initialRound: Field, initialTicketId: Field) => Promise<TicketReduceProofPublicOutput>;
export declare const addTicket: (input: TicketReduceProofPublicInput, prevProof: SelfProof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>) => Promise<TicketReduceProofPublicOutput>;
export declare const cutActions: (input: TicketReduceProofPublicInput, prevProof: SelfProof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>) => Promise<TicketReduceProofPublicOutput>;
export declare const TicketReduceProgram: {
    name: string;
    compile: (options?: {
        cache?: import("o1js").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/provable/field.js").Field;
        };
    }>;
    verify: (proof: import("o1js").Proof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>) => Promise<boolean>;
    digest: () => Promise<string>;
    analyzeMethods: () => Promise<{
        init: {
            rows: number;
            digest: string;
            gates: import("o1js/dist/node/snarky.js").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky.js").GateType | "Total rows", number>>;
        };
        addTicket: {
            rows: number;
            digest: string;
            gates: import("o1js/dist/node/snarky.js").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky.js").GateType | "Total rows", number>>;
        };
        cutActions: {
            rows: number;
            digest: string;
            gates: import("o1js/dist/node/snarky.js").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky.js").GateType | "Total rows", number>>;
        };
    }>;
    publicInputType: typeof TicketReduceProofPublicInput;
    publicOutputType: typeof TicketReduceProofPublicOutput;
    privateInputTypes: {
        init: [typeof import("o1js/dist/node/lib/provable/field.js").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldVar | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldConst) => import("o1js/dist/node/lib/provable/field.js").Field), typeof import("o1js/dist/node/lib/provable/field.js").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldVar | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldConst) => import("o1js/dist/node/lib/provable/field.js").Field), typeof import("o1js/dist/node/lib/provable/field.js").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldVar | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldConst) => import("o1js/dist/node/lib/provable/field.js").Field), typeof import("o1js/dist/node/lib/provable/field.js").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldVar | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldConst) => import("o1js/dist/node/lib/provable/field.js").Field), typeof import("o1js/dist/node/lib/provable/field.js").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/field.js").Field | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldVar | import("o1js/dist/node/lib/provable/core/fieldvar.js").FieldConst) => import("o1js/dist/node/lib/provable/field.js").Field)];
        addTicket: [typeof SelfProof];
        cutActions: [typeof SelfProof];
    };
    rawMethods: {
        init: (publicInput: TicketReduceProofPublicInput, ...args: [import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field] & any[]) => Promise<TicketReduceProofPublicOutput>;
        addTicket: (publicInput: TicketReduceProofPublicInput, ...args: [SelfProof<unknown, unknown>] & any[]) => Promise<TicketReduceProofPublicOutput>;
        cutActions: (publicInput: TicketReduceProofPublicInput, ...args: [SelfProof<unknown, unknown>] & any[]) => Promise<TicketReduceProofPublicOutput>;
    };
} & {
    init: (publicInput: TicketReduceProofPublicInput, ...args: [import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field, import("o1js/dist/node/lib/provable/field.js").Field] & any[]) => Promise<import("o1js").Proof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>>;
    addTicket: (publicInput: TicketReduceProofPublicInput, ...args: [SelfProof<unknown, unknown>] & any[]) => Promise<import("o1js").Proof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>>;
    cutActions: (publicInput: TicketReduceProofPublicInput, ...args: [SelfProof<unknown, unknown>] & any[]) => Promise<import("o1js").Proof<TicketReduceProofPublicInput, TicketReduceProofPublicOutput>>;
};
declare const TicketReduceProof_base: {
    new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
        proof: unknown;
        publicInput: TicketReduceProofPublicInput;
        publicOutput: TicketReduceProofPublicOutput;
        maxProofsVerified: 0 | 1 | 2;
    }): {
        verify(): void;
        verifyIf(condition: import("o1js/dist/node/lib/provable/bool.js").Bool): void;
        publicInput: TicketReduceProofPublicInput;
        publicOutput: TicketReduceProofPublicOutput;
        proof: unknown;
        maxProofsVerified: 0 | 1 | 2;
        shouldVerify: import("o1js/dist/node/lib/provable/bool.js").Bool;
        toJSON(): import("o1js").JsonProof;
    };
    publicInputType: typeof TicketReduceProofPublicInput;
    publicOutputType: typeof TicketReduceProofPublicOutput;
    tag: () => {
        name: string;
        publicInputType: typeof TicketReduceProofPublicInput;
        publicOutputType: typeof TicketReduceProofPublicOutput;
    };
    fromJSON<S extends (new (...args: any) => import("o1js").Proof<unknown, unknown>) & {
        prototype: import("o1js").Proof<any, any>;
        fromJSON: typeof import("o1js").Proof.fromJSON;
        dummy: typeof import("o1js").Proof.dummy;
        publicInputType: import("o1js").FlexibleProvablePure<any>;
        publicOutputType: import("o1js").FlexibleProvablePure<any>;
        tag: () => {
            name: string;
        };
    } & {
        prototype: import("o1js").Proof<unknown, unknown>;
    }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js").JsonProof): Promise<import("o1js").Proof<import("o1js").InferProvable<S["publicInputType"]>, import("o1js").InferProvable<S["publicOutputType"]>>>;
    dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js").Proof<Input, OutPut>>;
};
export declare class TicketReduceProof extends TicketReduceProof_base {
}
export {};
