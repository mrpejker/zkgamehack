var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Field, MerkleMap, MerkleMapWitness, Poseidon, SmartContract, State, UInt32, method, state, } from 'o1js';
import { treasury } from '../private_constants';
import { BLOCK_PER_ROUND } from '../constants';
const emptyMapRoot = new MerkleMap().getRoot();
export class RandomManager extends SmartContract {
    constructor() {
        super(...arguments);
        this.commitRoot = State();
        this.hashCommitRoot = State();
        this.resultRoot = State();
        this.startSlot = State();
    }
    init() {
        super.init();
        this.commitRoot.set(emptyMapRoot);
        this.hashCommitRoot.set(emptyMapRoot);
        this.resultRoot.set(emptyMapRoot);
        this.startSlot.set(this.network.globalSlotSinceGenesis.getAndRequireEquals());
    }
    /*
     * Can we update value
     * What we will do if value is wrong?
     */
    async commitValue(witness, value) {
        this.permissionCheck();
        const [prevCommitRoot, round] = witness.computeRootAndKey(Field(0));
        prevCommitRoot.assertEquals(this.commitRoot.getAndRequireEquals(), 'Wrong commit witness');
        this.checkRoundDoNotEnd(UInt32.fromFields([round]));
        const [newCommitRoot] = witness.computeRootAndKey(value);
        this.commitRoot.set(newCommitRoot);
    }
    async commitBlockHash(witness) {
        const [prevBlockCommitRoot, key] = witness.computeRootAndKey(Field(0));
        prevBlockCommitRoot.assertEquals(this.hashCommitRoot.getAndRequireEquals(), 'Wrong witness for hashCommits');
        this.checkRoundPass(UInt32.fromFields([key]));
        const newValue = Poseidon.hash([
            this.network.snarkedLedgerHash.get(),
            this.network.globalSlotSinceGenesis.getAndRequireEquals().value,
        ]);
        const [newBlockCommitRoot] = witness.computeRootAndKey(newValue);
        this.hashCommitRoot.set(newBlockCommitRoot);
    }
    /*
    @method async produceValue(
      commitWitness: MerkleMapWitness,
      commitValue: Field,
      revealValue: Field,
      salt: Field,
      blockHashCommitWitness: MerkleMapWitness,
      blockHashValue: Field,
      blockHashProof: BlockHashProof
    ) {
      const [commitRoot, commitKey] =
        commitWitness.computeRootAndKey(commitValue);
  
      commitRoot.assertEquals(
        this.commitRoot.getAndRequireEquals(),
        'Wrong commit witness'
      );
  
      Poseidon.hash([revealValue, salt]).assertEquals(
        commitValue,
        'Wrong reveal'
      );
  
      const [blockHashCommitRoot, blockHashCommitKey] =
        blockHashCommitWitness.computeRootAndKey(blockHashValue);
  
      blockHashCommitRoot.assertEquals(
        this.hashCommitRoot.getAndRequireEquals(),
        'Wrong hash commit witness'
      );
  
      commitKey.assertEquals(
        blockHashCommitKey,
        'Different rounds for commit and hash commit'
      );
  
      blockHashProof.verify();
  
      // Check blockHashProof initialHash to equal blockHashValue
  
      // Check that blockHashProof final block is right slot
  
      // Call lottery contract
    }
  
    */
    permissionCheck() {
        this.sender.getAndRequireSignature().assertEquals(treasury);
    }
    checkRoundPass(round) {
        const startBlock = this.startSlot.getAndRequireEquals();
        this.network.globalSlotSinceGenesis.requireBetween(startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)), UInt32.MAXINT());
    }
    checkRoundDoNotEnd(round) {
        const startBlock = this.startSlot.getAndRequireEquals();
        this.network.globalSlotSinceGenesis.requireBetween(UInt32.from(0), startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)));
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], RandomManager.prototype, "commitRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], RandomManager.prototype, "hashCommitRoot", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], RandomManager.prototype, "resultRoot", void 0);
__decorate([
    state(UInt32),
    __metadata("design:type", Object)
], RandomManager.prototype, "startSlot", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MerkleMapWitness, Field]),
    __metadata("design:returntype", Promise)
], RandomManager.prototype, "commitValue", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MerkleMapWitness]),
    __metadata("design:returntype", Promise)
], RandomManager.prototype, "commitBlockHash", null);
//# sourceMappingURL=RandomManager.js.map