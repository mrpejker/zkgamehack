'use strict';

var o1js = require('o1js');

const NUMBERS_IN_TICKET = 6;
const TICKET_PRICE = o1js.UInt64.from(10 * 10 ** 9); // #TODO change to field in smartcontract
const BLOCK_PER_ROUND = 480; // Aproximate blocks per 24 hours
const SCORE_COEFFICIENTS = [0, 90, 324, 2187, 26244, 590490, 31886460]; // Should be updated with apropriate probaility
const PRESICION = 1000;
const COMMISION = 30; // 3% comission
const mockWinningCombination = [1, 1, 1, 1, 1, 1];

function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}
// #TODO add user address to ticket
// technically we can remove round from ticket
class Ticket extends o1js.Struct({
    numbers: o1js.Provable.Array(o1js.UInt32, NUMBERS_IN_TICKET),
    owner: o1js.PublicKey,
    amount: o1js.UInt64,
}) {
    static from(numbers, owner, amount) {
        if (numbers.length != NUMBERS_IN_TICKET) {
            throw new Error(`Wrong amount of numbers. Got: ${numbers.length}, expect: ${NUMBERS_IN_TICKET}`);
        }
        return new Ticket({
            numbers: numbers.map((number) => o1js.UInt32.from(number)),
            owner,
            amount: o1js.UInt64.from(amount),
        });
    }
    static random(owner) {
        return new Ticket({
            numbers: [...Array(NUMBERS_IN_TICKET)].map(() => o1js.UInt32.from(getRandomInt(10))),
            owner,
            amount: o1js.UInt64.from(1),
        });
    }
    // static generateFromSeed(seed: Field, round: UInt32): Ticket {
    //   const initMask = 0b1111;
    //   const masks = [...Array(NUMBERS_IN_TICKET)].map(
    //     (val, i) => initMask << (i * 4)
    //   );
    //   const numbers = masks
    //     .map((mask, i) => {
    //       const masked = Gadgets.and(seed, Field.from(mask), (i + 1) * 4);
    //       return Gadgets.rightShift64(masked, i * 4);
    //     })
    //     .map((val) => UInt8.from(val));
    //   return new Ticket({
    //     numbers,
    //     round,
    //   });
    // }
    check() {
        return this.numbers.reduce((acc, val) => acc.and(val.lessThan(o1js.UInt32.from(10))), o1js.Bool(true));
    }
    hash() {
        return o1js.Poseidon.hash(this.numbers
            .map((number) => number.value)
            .concat(this.owner.toFields())
            .concat(this.amount.value));
    }
    // nullifierHash(round: Field): Field {
    //   return Poseidon.hash(
    //     this.numbers
    //       .map((number) => number.value)
    //       .concat(this.owner.toFields())
    //       .concat(this.amount.value)
    //       .concat(round)
    //   );
    // }
    getScore(winningCombination) {
        let result = o1js.UInt64.from(0);
        for (let i = 0; i < NUMBERS_IN_TICKET; i++) {
            result = result.add(o1js.Provable.if(winningCombination[i].equals(this.numbers[i]), o1js.UInt64.from(1), o1js.UInt64.from(0)));
        }
        const conditions = [...Array(NUMBERS_IN_TICKET + 1)].map((val, index) => result.equals(o1js.UInt64.from(index)));
        const values = SCORE_COEFFICIENTS.map((val) => o1js.UInt64.from(val).mul(this.amount));
        return o1js.Provable.switch(conditions, o1js.UInt64, values);
    }
}

// https://github.com/45930/o1js-pack
const MAX_BITS_PER_FIELD = 254n;
function PackingPlant(elementType, l, bitSize) {
    if (bitSize * BigInt(l) > MAX_BITS_PER_FIELD) {
        throw new Error(`The Packing Plant is only accepting orders that can fit into one Field, try using MultiPackingPlant`);
    }
    class Packed_ extends o1js.Struct({
        packed: o1js.Field,
    }) {
        constructor(packed) {
            super({ packed });
        }
        // Must implement these in type-specific implementation
        static extractField(input) {
            throw new Error('Must implement extractField');
        }
        static sizeInBits() {
            throw new Error('Must implement sizeInBits');
        }
        static unpack(f) {
            throw new Error('Must implement unpack');
        }
        // End
        /**
         *
         * @param unpacked Array of the implemented packed type
         * @throws if the length of the array is longer than the length of the implementing factory config
         */
        static checkPack(unpacked) {
            if (unpacked.length > l) {
                throw new Error(`Input of size ${unpacked.length} is larger than expected size of ${l}`);
            }
        }
        /**
         *
         * @param unpacked Array of the implemented packed type, must be shorter than the max allowed, which varies by type, will throw if the input is too long
         * @returns Field, packed with the information from the unpacked input
         */
        static pack(unpacked) {
            this.checkPack(unpacked);
            let f = this.extractField(unpacked[0]);
            const n = Math.min(unpacked.length, l);
            for (let i = 1; i < n; i++) {
                const c = o1js.Field((2n ** this.sizeInBits()) ** BigInt(i));
                f = f.add(this.extractField(unpacked[i]).mul(c));
            }
            return f;
        }
        /**
         *
         * @param f Field, packed with the information, as returned by #pack
         * @returns Array of bigints, which can be decoded by the implementing class into the final type
         */
        static unpackToBigints(f) {
            let unpacked = new Array(l);
            unpacked.fill(0n);
            let packedN;
            if (f) {
                packedN = f.toBigInt();
            }
            else {
                throw new Error('No Packed Value Provided');
            }
            for (let i = 0; i < l; i++) {
                unpacked[i] = packedN & ((1n << this.sizeInBits()) - 1n);
                packedN >>= this.sizeInBits();
            }
            return unpacked;
        }
        // NOTE: adding to fields here breaks the proof generation.  Probably not overriding it correctly
        /**
         * @returns array of single Field element which constitute the packed object
         */
        toFields() {
            return [this.packed];
        }
        assertEquals(other) {
            this.packed.assertEquals(other.packed);
        }
    }
    Packed_.type = o1js.provable({ packed: o1js.Field }, {});
    Packed_.l = l;
    Packed_.bitSize = bitSize;
    return Packed_;
}
const L = 7; // 7 32-bit uints fit in one Field
const SIZE_IN_BITS = 32n;
function PackedUInt32Factory(l = L) {
    class PackedUInt32_ extends PackingPlant(o1js.UInt32, l, SIZE_IN_BITS) {
        static extractField(input) {
            return input.value;
        }
        static sizeInBits() {
            return SIZE_IN_BITS;
        }
        /**
         *
         * @param f Field, packed with the information, as returned by #pack
         * @returns Array of UInt32
         */
        static unpack(f) {
            const unpacked = o1js.Provable.witness(o1js.Provable.Array(o1js.UInt32, l), () => {
                const unpacked = this.unpackToBigints(f);
                return unpacked.map((x) => o1js.UInt32.from(x));
            });
            f.assertEquals(PackedUInt32_.pack(unpacked));
            return unpacked;
        }
        /**
         *
         * @param uint32s Array of UInt32s to be packed
         * @returns Instance of the implementing class
         */
        static fromUInt32s(uint32s) {
            const packed = PackedUInt32_.pack(uint32s);
            return new PackedUInt32_(packed);
        }
        /**
         *
         * @param bigints Array of bigints to be packed
         * @returns Instance of the implementing class
         */
        static fromBigInts(bigints) {
            const uint32s = bigints.map((x) => o1js.UInt32.from(x));
            return PackedUInt32_.fromUInt32s(uint32s);
        }
        toBigInts() {
            return PackedUInt32_.unpack(this.packed).map((x) => x.toBigint());
        }
    }
    return PackedUInt32_;
}

const LENGTH20 = 20;
class MerkleMap20Witness extends o1js.Struct({
    isLefts: o1js.Provable.Array(o1js.Bool, LENGTH20 - 1),
    siblings: o1js.Provable.Array(o1js.Field, LENGTH20 - 1),
}) {
    /**
     * computes the merkle tree root for a given value and the key for this witness
     * @param value The value to compute the root for.
     * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.
     */
    computeRootAndKey(value) {
        let hash = value;
        const isLeft = this.isLefts;
        const siblings = this.siblings;
        let key = o1js.Field(0);
        for (let i = 0; i < LENGTH20 - 1; i++) {
            const left = o1js.Provable.if(isLeft[i], hash, siblings[i]);
            const right = o1js.Provable.if(isLeft[i], siblings[i], hash);
            hash = o1js.Poseidon.hash([left, right]);
            const bit = o1js.Provable.if(isLeft[i], o1js.Field(0), o1js.Field(1));
            key = key.mul(2).add(bit);
        }
        return [hash, key];
    }
}
class MerkleMap20 {
    /**
     * Creates a new, empty Merkle Map.
     * @returns A new MerkleMap
     */
    constructor() {
        this.tree = new o1js.MerkleTree(LENGTH20);
    }
    _keyToIndex(key) {
        // console.log('Key: ', key.toString());
        // the bit map is reversed to make reconstructing the key during proving more convenient
        // let bits = BinableFp.toBits(key.toBigInt()).reverse(); // original version
        let bits = key.toBits(LENGTH20 - 1).reverse(); // Can we just use BinableFP? It is used for constants anyway
        // console.log(bits.map((bit) => bit.toString()));
        // console.log(bits.map((bit) => bit.toField().toString()));
        let n = 0n;
        for (let i = bits.length - 1; i >= 0; i--) {
            n = (n << 1n) | BigInt(bits[i].toField().toString());
        }
        return n;
    }
    /**
     * Sets a key of the merkle map to a given value.
     * @param key The key to set in the map.
     * @param value The value to set.
     */
    set(key, value) {
        const index = this._keyToIndex(key);
        this.tree.setLeaf(index, value);
    }
    /**
     * Returns a value given a key. Values are by default Field(0).
     * @param key The key to get the value from.
     * @returns The value stored at the key.
     */
    get(key) {
        const index = this._keyToIndex(key);
        return this.tree.getNode(0, index);
    }
    /**
     * Returns the root of the Merkle Map.
     * @returns The root of the Merkle Map.
     */
    getRoot() {
        return this.tree.getRoot();
    }
    /**
     * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.
     * @param key The key to make a witness for.
     * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.
     */
    getWitness(key) {
        const index = this._keyToIndex(key);
        class MyMerkleWitness extends o1js.MerkleWitness(LENGTH20) {
        }
        const witness = new MyMerkleWitness(this.tree.getWitness(index));
        // console.log('Witness in getWitness: ');
        // console.log(witness);
        return new MerkleMap20Witness({
            isLefts: witness.isLeft,
            siblings: witness.path,
        });
    }
}

const getEmpty2dMerkleMap = (height) => {
    let emptyMapRoot;
    let empty2dMap;
    if (height) {
        if (height != 20) {
            throw Error('Custom size merkle map is not supported yet. Only 20');
        }
        emptyMapRoot = new MerkleMap20().getRoot();
        empty2dMap = new MerkleMap20();
    }
    else {
        emptyMapRoot = new o1js.MerkleMap().getRoot();
        empty2dMap = new o1js.MerkleMap();
    }
    empty2dMap.tree.zeroes[0] = emptyMapRoot;
    for (let i = 1; i < empty2dMap.tree.height; i++) {
        empty2dMap.tree.zeroes[i] = o1js.Poseidon.hash([
            empty2dMap.tree.zeroes[i - 1],
            empty2dMap.tree.zeroes[i - 1],
        ]);
    }
    return empty2dMap;
};
class NumberPacked extends PackedUInt32Factory() {
}
const comisionTicket = Ticket.from(Array(6).fill(0), o1js.PublicKey.empty(), 1);
function getNullifierId(round, ticketId) {
    o1js.Gadgets.rangeCheck64(round);
    o1js.Gadgets.rangeCheck64(ticketId);
    return o1js.Field.fromBits([...round.toBits(64), ...ticketId.toBits(64)]);
}
function convertToUInt64(value) {
    let val = o1js.UInt64.Unsafe.fromField(value);
    o1js.UInt64.check(val);
    return val;
}
function convertToUInt32(value) {
    let val = o1js.UInt32.Unsafe.fromField(value);
    o1js.UInt32.check(val);
    return val;
}

class DistributionProofPublicInput extends o1js.Struct({
    winningCombination: o1js.Field,
    ticket: Ticket,
    valueWitness: MerkleMap20Witness,
}) {
}
class DistributionProofPublicOutput extends o1js.Struct({
    root: o1js.Field,
    total: o1js.UInt64,
}) {
}
const emptyMap = new MerkleMap20();
const emptyMapRoot$1 = emptyMap.getRoot();
const init$1 = async (input) => {
    return new DistributionProofPublicOutput({
        root: emptyMapRoot$1,
        total: o1js.UInt64.from(0),
    });
};
const addTicket$1 = async (input, prevProof) => {
    prevProof.verify();
    const [initialRoot, key] = input.valueWitness.computeRootAndKey(o1js.Field(0));
    // key.assertEquals(input.ticket.hash(), 'Wrong key for that ticket');
    initialRoot.assertEquals(prevProof.publicOutput.root);
    const newValue = input.ticket.hash();
    const [newRoot] = input.valueWitness.computeRootAndKey(newValue);
    const ticketScore = input.ticket.getScore(NumberPacked.unpack(input.winningCombination));
    return new DistributionProofPublicOutput({
        root: newRoot,
        total: prevProof.publicOutput.total.add(ticketScore),
    });
};
const DistibutionProgram = o1js.ZkProgram({
    name: 'distribution-program',
    publicInput: DistributionProofPublicInput,
    publicOutput: DistributionProofPublicOutput,
    methods: {
        init: {
            privateInputs: [],
            async method(input) {
                return init$1();
            },
        },
        addTicket: {
            privateInputs: [o1js.SelfProof],
            async method(input, prevProof) {
                return addTicket$1(input, prevProof);
            },
        },
    },
});
class DistributionProof extends o1js.ZkProgram.Proof(DistibutionProgram) {
}

function prefixToField(prefix) {
    if (prefix.length * 8 >= 255)
        throw Error('prefix too long');
    let bits = [...prefix]
        .map((char) => {
        // convert char to 8 bits
        let bits = [];
        for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {
            bits.push(!!(c & 1));
        }
        return bits;
    })
        .flat();
    return o1js.Field.fromBits(bits);
}
// hashing helpers
function initialState() {
    return [o1js.Field(0), o1js.Field(0), o1js.Field(0)];
}
function salt(prefix) {
    return o1js.Poseidon.update(initialState(), [prefixToField(prefix)]);
}
function emptyHashWithPrefix(prefix) {
    return salt(prefix)[0];
}
class LotteryAction extends o1js.Struct({
    ticket: Ticket,
    round: o1js.Field,
}) {
}
const actionListAdd = (hash, action) => {
    return o1js.Poseidon.hashWithPrefix('MinaZkappSeqEvents**', [
        hash,
        o1js.Poseidon.hashWithPrefix('MinaZkappEvent******', LotteryAction.toFields(action)),
    ]);
};
class ActionList extends o1js.MerkleList.create(LotteryAction, actionListAdd, emptyHashWithPrefix('MinaZkappActionsEmpty')) {
}
const merkleActionsAdd = (hash, actionsHash) => {
    return o1js.Poseidon.hashWithPrefix('MinaZkappSeqEvents**', [hash, actionsHash]);
};
class MerkleActions extends o1js.MerkleList.create(ActionList.provable, (hash, x) => merkleActionsAdd(hash, x.hash), emptyHashWithPrefix('MinaZkappActionStateEmptyElt')) {
}
class TicketReduceProofPublicInput extends o1js.Struct({
    action: LotteryAction,
    roundWitness: MerkleMap20Witness,
    roundTicketWitness: MerkleMap20Witness,
    bankWitness: MerkleMap20Witness,
    bankValue: o1js.Field,
}) {
}
class TicketReduceProofPublicOutput extends o1js.Struct({
    initialState: o1js.Field,
    finalState: o1js.Field,
    initialTicketRoot: o1js.Field,
    initialBankRoot: o1js.Field,
    initialTicketId: o1js.Field,
    newTicketRoot: o1js.Field,
    newBankRoot: o1js.Field,
    processedActionList: o1js.Field,
    lastProcessedRound: o1js.Field,
    lastProcessedTicketId: o1js.Field,
}) {
}
const init = async (input, initialState, initialTicketRoot, initialBankRoot, initialRound, initialTicketId) => {
    return new TicketReduceProofPublicOutput({
        initialState,
        finalState: initialState,
        initialTicketRoot,
        initialBankRoot,
        initialTicketId,
        newTicketRoot: initialTicketRoot,
        newBankRoot: initialBankRoot,
        processedActionList: ActionList.emptyHash,
        lastProcessedRound: initialRound,
        lastProcessedTicketId: initialTicketId,
    });
};
const addTicket = async (input, prevProof) => {
    prevProof.verify();
    let [prevRoundRoot, ticketId] = input.roundTicketWitness.computeRootAndKey(o1js.Field(0));
    let [prevTicketRoot, round] = input.roundWitness.computeRootAndKey(prevRoundRoot);
    let expectedTicketId = o1js.Provable.if(round.greaterThan(prevProof.publicOutput.lastProcessedRound), o1js.Field(0), prevProof.publicOutput.lastProcessedTicketId.add(1));
    ticketId.assertEquals(expectedTicketId, 'Wrong id for ticket');
    prevTicketRoot.assertEquals(prevProof.publicOutput.newTicketRoot, 'Wrong ticket root');
    round.assertEquals(input.action.round, 'Wrong round in witness');
    // Update root
    let [newTicketRoundRoot] = input.roundTicketWitness.computeRootAndKey(input.action.ticket.hash());
    let [newTicketRoot] = input.roundWitness.computeRootAndKey(newTicketRoundRoot);
    let [prevBankRoot, bankKey] = input.bankWitness.computeRootAndKey(input.bankValue);
    bankKey.assertEquals(round, 'Wrong bankKey');
    prevBankRoot.assertEquals(prevProof.publicOutput.newBankRoot, 'Wrong bank root');
    let [newBankRoot] = input.bankWitness.computeRootAndKey(input.bankValue.add(TICKET_PRICE.mul(input.action.ticket.amount).value));
    let processedActionList = actionListAdd(prevProof.publicOutput.processedActionList, input.action);
    return new TicketReduceProofPublicOutput({
        initialState: prevProof.publicOutput.initialState,
        finalState: prevProof.publicOutput.finalState,
        initialTicketRoot: prevProof.publicOutput.initialTicketRoot,
        initialBankRoot: prevProof.publicOutput.initialBankRoot,
        initialTicketId: prevProof.publicOutput.initialTicketId,
        newTicketRoot,
        newBankRoot,
        processedActionList,
        lastProcessedRound: round,
        lastProcessedTicketId: expectedTicketId,
    });
};
const cutActions = async (input, prevProof) => {
    prevProof.verify();
    let finalState = merkleActionsAdd(prevProof.publicOutput.finalState, prevProof.publicOutput.processedActionList);
    let processedActionList = ActionList.emptyHash;
    return new TicketReduceProofPublicOutput({
        initialState: prevProof.publicOutput.initialState,
        finalState,
        initialTicketRoot: prevProof.publicOutput.initialTicketRoot,
        initialBankRoot: prevProof.publicOutput.initialBankRoot,
        initialTicketId: prevProof.publicOutput.initialTicketId,
        newTicketRoot: prevProof.publicOutput.newTicketRoot,
        newBankRoot: prevProof.publicOutput.newBankRoot,
        processedActionList,
        lastProcessedRound: prevProof.publicOutput.lastProcessedRound,
        lastProcessedTicketId: prevProof.publicOutput.lastProcessedTicketId,
    });
};
/*
  init: simple initializer, create empty proof
  addTicket: process next ticket, updates roots of merkle tries. Add actions to processedActionList merkleList
  cutActions: updates finalState by adding processedActionList to finalState merkle list
*/
const TicketReduceProgram = o1js.ZkProgram({
    name: 'ticket-reduce-program',
    publicInput: TicketReduceProofPublicInput,
    publicOutput: TicketReduceProofPublicOutput,
    methods: {
        init: {
            privateInputs: [o1js.Field, o1js.Field, o1js.Field, o1js.Field, o1js.Field],
            async method(input, initialState, initialTicketRoot, initialBankRoot, initialRound, initialTicketId) {
                return init(input, initialState, initialTicketRoot, initialBankRoot, initialRound, initialTicketId);
            },
        },
        addTicket: {
            privateInputs: [o1js.SelfProof],
            async method(input, prevProof) {
                return addTicket(input, prevProof);
            },
        },
        cutActions: {
            privateInputs: [o1js.SelfProof],
            async method(input, prevProof) {
                return cutActions(input, prevProof);
            },
        },
    },
});
class TicketReduceProof extends o1js.ZkProgram.Proof(TicketReduceProgram) {
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
NumberPacked.pack(mockWinningCombination.map((v) => o1js.UInt32.from(v)));
const treasury = o1js.PublicKey.fromBase58('B62qj3DYVUCaTrDnFXkJW34xHUBr9zUorg72pYN3BJTGB4KFdpYjxxQ');
const emptyMapRoot = new o1js.MerkleMap().getRoot();
const emptyMap20Root = new MerkleMap20().getRoot();
const empty2dMap = getEmpty2dMerkleMap(20);
const empty2dMapRoot = empty2dMap.getRoot();
// !!!!!!!!!!!!!!!!!!!1 Shoud be upadted with valid address before deploying
// export const { publicKey: treasury, privateKey: treasuryKey } =
//   PrivateKey.randomKeypair();
// #TODO constrain round to current
// #TODO add events
class BuyTicketEvent extends o1js.Struct({
    ticket: Ticket,
    round: o1js.Field,
}) {
}
class ProduceResultEvent extends o1js.Struct({
    result: o1js.Field,
    round: o1js.Field,
}) {
}
class GetRewardEvent extends o1js.Struct({
    ticket: Ticket,
    round: o1js.Field,
}) {
}
class RefundEvent extends o1js.Struct({
    ticket: Ticket,
    round: o1js.Field,
}) {
}
class ReduceEvent extends o1js.Struct({
    startActionState: o1js.Field,
    endActionState: o1js.Field,
}) {
}
// Parallel lottery
class PLottery extends o1js.SmartContract {
    constructor() {
        super(...arguments);
        this.reducer = o1js.Reducer({ actionType: LotteryAction });
        this.events = {
            'buy-ticket': BuyTicketEvent,
            'produce-result': ProduceResultEvent,
            'get-reward': GetRewardEvent,
            'get-refund': RefundEvent,
            reduce: ReduceEvent,
        };
        // Stores merkle map with all tickets, that user have bought. Each leaf of this tree is a root of tree for corresponding round
        this.ticketRoot = o1js.State();
        // #TODO rework nullifier. For now you can create ticket, that will fail nullifier check. Also it is too heavy
        this.ticketNullifier = o1js.State();
        // Stores merkle map with total bank for each round.
        this.bankRoot = o1js.State();
        // Stores merkle map with wining combination for each rounds
        this.roundResultRoot = o1js.State();
        // Stores block of deploy
        this.startBlock = o1js.State();
        this.lastProcessedState = o1js.State();
        this.lastReduceInRound = o1js.State();
        this.lastProcessedTicketId = o1js.State();
    }
    init() {
        this.network.stakingEpochData.ledger.hash.getAndRequireEquals();
        super.init();
        this.ticketRoot.set(empty2dMapRoot); // Redoo, becase leafs is not 0, but empty map root
        this.ticketNullifier.set(emptyMapRoot);
        this.bankRoot.set(emptyMap20Root);
        this.roundResultRoot.set(emptyMap20Root);
        this.startBlock.set(this.network.globalSlotSinceGenesis.getAndRequireEquals());
        this.lastProcessedState.set(o1js.Reducer.initialActionState);
        this.lastProcessedTicketId.set(o1js.Field(-1));
        // #TODO Permisions
    }
    async buyTicket(ticket, round) {
        ticket.owner.equals(this.sender.getAndRequireSignature()); // Do we need this check?
        // Ticket validity check
        ticket.check().assertTrue();
        this.checkCurrentRound(convertToUInt32(round));
        // Get ticket price from user
        let senderUpdate = o1js.AccountUpdate.createSigned(this.sender.getAndRequireSignature());
        senderUpdate.send({ to: this, amount: TICKET_PRICE.mul(ticket.amount) });
        this.reducer.dispatch(new LotteryAction({
            ticket,
            round,
        }));
        this.emitEvent('buy-ticket', new BuyTicketEvent({
            ticket,
            round: round,
        }));
    }
    async reduceTickets(reduceProof) {
        reduceProof.verify();
        let lastProcessedState = this.lastProcessedState.getAndRequireEquals();
        let lastProcessedTicketId = this.lastProcessedTicketId.getAndRequireEquals();
        reduceProof.publicOutput.processedActionList.assertEquals(ActionList.emptyHash, 'Proof is not complete. Call cutActions first');
        // Check that state on contract is equal to state on proof
        lastProcessedState.assertEquals(reduceProof.publicOutput.initialState, 'Initial state is not match contract last processed state');
        // Check that actionState is equal to actionState on proof
        this.account.actionState.requireEquals(reduceProof.publicOutput.finalState);
        // Check inital ticket id
        lastProcessedTicketId.assertEquals(reduceProof.publicOutput.initialTicketId, 'Initial ticket id don not match contract last processed ticket id');
        this.lastProcessedState.set(reduceProof.publicOutput.finalState);
        this.ticketRoot.set(reduceProof.publicOutput.newTicketRoot);
        this.bankRoot.set(reduceProof.publicOutput.newBankRoot);
        this.lastReduceInRound.set(reduceProof.publicOutput.lastProcessedRound);
        this.lastProcessedTicketId.set(reduceProof.publicOutput.lastProcessedTicketId);
        this.emitEvent('reduce', new ReduceEvent({
            startActionState: reduceProof.publicOutput.initialState,
            endActionState: reduceProof.publicOutput.finalState,
        }));
    }
    async produceResult(resultWiness, result, bankValue, bankWitness) {
        // Check that result for this round is not computed yet, and that witness it is valid
        const [initialResultRoot, round] = resultWiness.computeRootAndKey(o1js.Field.from(0));
        this.roundResultRoot
            .getAndRequireEquals()
            .assertEquals(initialResultRoot, 'Wrong resultWitness or value');
        this.lastReduceInRound
            .getAndRequireEquals()
            .assertGreaterThan(round, 'Call reduce for this round first');
        // Generate new ticket using value from blockchain
        this.getWiningNumbersForRound();
        // let newLeafValue = NumberPacked.pack(winningNumbers);
        let newLeafValue = result; // For test purpose
        // Update result tree
        const [newResultRoot] = resultWiness.computeRootAndKey(newLeafValue);
        this.roundResultRoot.set(newResultRoot);
        // Update bank and pay fee
        this.checkAndUpdateBank(bankWitness, round, bankValue, bankValue.mul(PRESICION - COMMISION).div(PRESICION));
        this.send({
            to: treasury,
            amount: convertToUInt64(bankValue.mul(COMMISION).div(PRESICION)),
        });
        this.emitEvent('produce-result', new ProduceResultEvent({
            result: newLeafValue,
            round,
        }));
    }
    async refund(ticket, roundWitness, roundTicketWitness, resultWitness, nullifierWitness) {
        // Check taht owner trying to claim
        ticket.owner.assertEquals(this.sender.getAndRequireSignature());
        // Check ticket in merkle map
        const { ticketId, round } = this.checkTicket(roundWitness, null, roundTicketWitness, ticket.hash());
        // Check that result is zero for this round
        this.checkResult(resultWitness, round, o1js.Field(0));
        // Can call refund after ~ 2 days after round finished
        this.checkRoundPass(convertToUInt32(round.add(2)));
        // Check and update bank witness
        const totalTicketPrice = ticket.amount.mul(TICKET_PRICE);
        const priceWithoutCommision = totalTicketPrice
            .mul(PRESICION - COMMISION)
            .div(PRESICION);
        // const newBankValue = bankValue.sub(totalTicketPrice.value);
        // this.checkAndUpdateBank(bankWitness, round, bankValue, newBankValue);
        // Check and update nullifier
        this.checkAndUpdateNullifier(nullifierWitness, getNullifierId(round, ticketId), o1js.Field(0), o1js.Field.from(1));
        // Send ticket price back to user
        this.send({
            to: ticket.owner,
            amount: priceWithoutCommision,
        });
        this.emitEvent('get-refund', new RefundEvent({
            ticket,
            round,
        }));
    }
    async getReward(ticket, roundWitness, roundTicketWitness, dp, winningNumbers, resutWitness, bankValue, bankWitness, nullifierWitness) {
        // Check taht owner trying to claim
        ticket.owner.assertEquals(this.sender.getAndRequireSignature());
        // Verify distibution proof
        dp.verify();
        // Check ticket in tree
        const { ticketId, roundRoot: roundTicketRoot, round, } = this.checkTicket(roundWitness, null, roundTicketWitness, ticket.hash());
        dp.publicOutput.root.assertEquals(roundTicketRoot, 'Wrong distribution proof');
        dp.publicInput.winningCombination.assertEquals(winningNumbers, 'Wrong winning numbers in dp');
        round.assertLessThan(this.lastReduceInRound.getAndRequireEquals(), 'Actions was not reduced for this round yet. Call reduceTickets first');
        // Check result root info
        this.checkResult(resutWitness, round, winningNumbers);
        // Compute score using winnging ticket
        const score = ticket.getScore(NumberPacked.unpack(winningNumbers));
        const totalScore = dp.publicOutput.total;
        // Pay user
        this.checkBank(bankWitness, round, bankValue);
        this.send({
            to: ticket.owner,
            amount: convertToUInt64(bankValue).mul(score).div(totalScore),
        });
        // Add ticket to nullifier
        this.checkAndUpdateNullifier(nullifierWitness, getNullifierId(round, ticketId), o1js.Field(0), o1js.Field.from(1));
        this.emitEvent('get-reward', new GetRewardEvent({
            ticket,
            round,
        }));
    }
    // @method async getCommisionForRound(
    //   ticketWitness: MerkleMap20Witness,
    //   result: Field,
    //   resultWitness: MerkleMap20Witness,
    //   dp: DistributionProof,
    //   bankValue: Field,
    //   bankWitness: MerkleMap20Witness,
    //   nullifierWitness: MerkleMapWitness
    // ): Promise<void> {
    //   dp.verify();
    //   // Only treasury account can claim commision
    //   this.sender.getAndRequireSignature().assertEquals(treasury);
    //   dp.publicInput.winningCombination.assertEquals(
    //     result,
    //     'Wrong winning numbers in dp'
    //   );
    //   // Check result for round is right
    //   const { key: round } = this.checkResult(resultWitness, null, result);
    //   round.assertLessThan(
    //     this.lastReduceInRound.getAndRequireEquals(),
    //     'Actions was not reduced for this round yet. Call reduceTickets first'
    //   );
    //   // Check bank value for round
    //   this.checkBank(bankWitness, round, bankValue);
    //   // Update nullifier for ticket
    //   this.checkAndUpdateNullifier(
    //     nullifierWitness,
    //     getNullifierId(round, Field(0)),
    //     Field(0),
    //     Field.from(1)
    //   );
    //   // Check ticket
    //   const [ticketRoot, ticketKey] = ticketWitness.computeRootAndKey(
    //     dp.publicOutput.root
    //   );
    //   this.ticketRoot
    //     .getAndRequireEquals()
    //     .assertEquals(ticketRoot, 'Wrong ticket root');
    //   ticketKey.assertEquals(round, 'Wrong ticket round');
    //   // Send commision to treasury
    //   const totalScore = getTotalScoreAndCommision(dp.publicOutput.total);
    //   this.send({
    //     to: treasury,
    //     amount: totalScore.sub(dp.publicOutput.total),
    //   });
    // }
    // public getCurrentRound(): UInt32 {
    //   const startBlock = this.startBlock.getAndRequireEquals();
    //   const blockNum = this.network.globalSlotSinceGenesis.getAndRequireEquals();
    //   return blockNum.sub(startBlock).div(BLOCK_PER_ROUND);
    // }
    checkCurrentRound(round) {
        const startBlock = this.startBlock.getAndRequireEquals();
        this.network.globalSlotSinceGenesis.requireBetween(startBlock.add(round.mul(BLOCK_PER_ROUND)), startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)));
    }
    checkRoundPass(round) {
        const startBlock = this.startBlock.getAndRequireEquals();
        this.network.globalSlotSinceGenesis.requireBetween(startBlock.add(round.add(1).mul(BLOCK_PER_ROUND)), o1js.UInt32.MAXINT());
    }
    getWiningNumbersForRound() {
        return mockWinningCombination.map((val) => o1js.UInt32.from(val));
        // // Temporary function implementation. Later will be switch with oracle call.
        // return generateNumbersSeed(Field(12345));
    }
    checkResult(witness, round, curValue) {
        return this.checkMap(this.roundResultRoot, witness, round, curValue);
    }
    // private checkAndUpdateResult(
    //   witness: MerkleMap20Witness,
    //   round: Field,
    //   curValue: Field,
    //   newValue: Field
    // ): MerkleCheckResult {
    //   return this.checkAndUpdateMap(
    //     this.roundResultRoot,
    //     witness,
    //     round,
    //     curValue,
    //     newValue
    //   );
    // }
    checkBank(witness, round, curValue) {
        return this.checkMap(this.bankRoot, witness, round, curValue);
    }
    checkAndUpdateBank(witness, round, curValue, newValue) {
        return this.checkAndUpdateMap(this.bankRoot, witness, round, curValue, newValue);
    }
    checkAndUpdateNullifier(witness, key, curValue, newValue) {
        return this.checkAndUpdateMap(this.ticketNullifier, witness, key, curValue, newValue);
    }
    checkAndUpdateMap(state, witness, key, curValue, newValue) {
        let checkRes = this.checkMap(state, witness, key, curValue);
        const [newRoot] = witness.computeRootAndKey(newValue);
        state.set(newRoot);
        return checkRes;
    }
    checkMap(state, witness, key, curValue) {
        const curRoot = state.getAndRequireEquals();
        const [prevRoot, witnessKey] = witness.computeRootAndKey(curValue);
        curRoot.assertEquals(prevRoot, 'Wrong witness');
        if (key) {
            witnessKey.assertEquals(key, 'Wrong key');
        }
        return {
            key: witnessKey,
        };
    }
    // private checkAndUpdateTicketMap(
    //   firstWitness: MerkleMap20Witness | MerkleMapWitness,
    //   key1: Field | null,
    //   secondWitness: MerkleMap20Witness | MerkleMapWitness,
    //   // key2: Field, For know second level key is not checked as later it would transform to merkle map
    //   prevValue: Field,
    //   newValue: Field
    // ): { ticketId: Field; round: Field } {
    //   const res = this.checkTicket(firstWitness, key1, secondWitness, prevValue);
    //   const [newRoot2] = secondWitness.computeRootAndKey(newValue);
    //   const [newRoot1] = firstWitness.computeRootAndKey(newRoot2);
    //   this.ticketRoot.set(newRoot1);
    //   return res;
    // }
    checkTicket(firstWitness, key1, secondWitness, 
    // key2: Field, For know second level key is not checked as later it would transform to merkle map
    value) {
        const [secondLevelRoot, ticketId] = secondWitness.computeRootAndKey(value);
        const [firstLevelRoot, round] = firstWitness.computeRootAndKey(secondLevelRoot);
        if (key1) {
            round.assertEquals(key1, 'Wrong round');
        }
        this.ticketRoot
            .getAndRequireEquals()
            .assertEquals(firstLevelRoot, 'Wrong 2d witness');
        return { ticketId, round, roundRoot: secondLevelRoot };
    }
}
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "ticketRoot", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "ticketNullifier", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "bankRoot", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "roundResultRoot", void 0);
__decorate([
    o1js.state(o1js.UInt32),
    __metadata("design:type", Object)
], PLottery.prototype, "startBlock", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "lastProcessedState", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "lastReduceInRound", void 0);
__decorate([
    o1js.state(o1js.Field),
    __metadata("design:type", Object)
], PLottery.prototype, "lastProcessedTicketId", void 0);
__decorate([
    o1js.method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Ticket, o1js.Field]),
    __metadata("design:returntype", Promise)
], PLottery.prototype, "buyTicket", null);
__decorate([
    o1js.method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TicketReduceProof]),
    __metadata("design:returntype", Promise)
], PLottery.prototype, "reduceTickets", null);
__decorate([
    o1js.method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MerkleMap20Witness,
        o1js.Field,
        o1js.Field,
        MerkleMap20Witness]),
    __metadata("design:returntype", Promise)
], PLottery.prototype, "produceResult", null);
__decorate([
    o1js.method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Ticket,
        MerkleMap20Witness,
        MerkleMap20Witness,
        MerkleMap20Witness,
        o1js.MerkleMapWitness]),
    __metadata("design:returntype", Promise)
], PLottery.prototype, "refund", null);
__decorate([
    o1js.method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Ticket,
        MerkleMap20Witness,
        MerkleMap20Witness,
        DistributionProof,
        o1js.Field,
        MerkleMap20Witness,
        o1js.Field,
        MerkleMap20Witness,
        o1js.MerkleMapWitness]),
    __metadata("design:returntype", Promise)
], PLottery.prototype, "getReward", null);

async function mockProof$1(publicOutput, ProofType, publicInput) {
    // const [, proof] = Pickles.proofOfBase64(await dummyBase64Proof(), 2);
    return new ProofType({
        proof: null,
        maxProofsVerified: 2,
        publicInput,
        publicOutput,
    });
}
class BaseStateManager {
    constructor(startBlock, isMock = true, shouldUpdateState = false) {
        this.ticketMap = getEmpty2dMerkleMap(20);
        this.roundTicketMap = [new MerkleMap20()];
        this.lastTicketInRound = [0];
        this.roundTickets = [[]];
        this.ticketNullifierMap = new o1js.MerkleMap();
        this.bankMap = new MerkleMap20();
        this.roundResultMap = new MerkleMap20();
        this.dpProofs = {};
        this.startBlock = startBlock;
        this.isMock = isMock;
        this.shouldUpdateState = shouldUpdateState;
    }
    syncWithCurBlock(curBlock) {
        let localRound = this.roundTicketMap.length - 1;
        let curRound = Math.ceil((curBlock - +this.startBlock) / BLOCK_PER_ROUND);
        this.startNextRound(curRound - localRound);
    }
    startNextRound(amount = 1) {
        for (let i = 0; i < amount; i++) {
            this.roundTicketMap.push(new MerkleMap20());
            this.lastTicketInRound.push(0);
            this.roundTickets.push([]);
        }
    }
    getNextTicketWitenss(round) {
        const roundWitness = this.ticketMap.getWitness(o1js.Field.from(round));
        const ticketRoundWitness = this.roundTicketMap[round].getWitness(o1js.Field.from(this.lastTicketInRound[round]));
        return [roundWitness, ticketRoundWitness];
    }
    addTicket(ticket, round) {
        throw Error('Add ticket is not implemented');
    }
    // Returns witness and value
    getBankWitness(round) {
        const bankWitness = this.bankMap.getWitness(o1js.Field.from(round));
        const value = this.bankMap.get(o1js.Field.from(round));
        return [bankWitness, value];
    }
    updateResult(round) {
        round = o1js.Field(round);
        const resultWitness = this.roundResultMap.getWitness(round);
        const packedNumbers = NumberPacked.pack(mockWinningCombination.map((val) => o1js.UInt32.from(val)));
        const bankValue = this.bankMap.get(round);
        const bankWitness = this.bankMap.getWitness(round);
        if (this.shouldUpdateState) {
            this.roundResultMap.set(round, packedNumbers);
            this.bankMap.set(round, bankValue.mul(PRESICION - COMMISION).div(PRESICION));
        }
        return {
            resultWitness,
            bankValue,
            bankWitness,
        };
    }
    async getDP(round) {
        if (this.dpProofs[round]) {
            return this.dpProofs[round];
        }
        const winningCombination = this.roundResultMap.get(o1js.Field.from(round));
        let ticketsInRound = this.lastTicketInRound[round];
        let curMap = new MerkleMap20();
        let input = new DistributionProofPublicInput({
            winningCombination,
            ticket: Ticket.random(o1js.PublicKey.empty()),
            valueWitness: this.roundTicketMap[round].getWitness(o1js.Field(0)),
        });
        let curProof = this.isMock
            ? await mockProof$1(await init$1(), DistributionProof, input)
            : await DistibutionProgram.init(input);
        for (let i = 0; i < ticketsInRound; i++) {
            const ticket = this.roundTickets[round][i];
            const input = new DistributionProofPublicInput({
                winningCombination,
                ticket: ticket,
                valueWitness: curMap.getWitness(o1js.Field(i)),
            });
            curMap.set(o1js.Field(i), ticket.hash());
            if (this.isMock) {
                curProof = await mockProof$1(await addTicket$1(input, curProof), DistributionProof, input);
            }
            else {
                curProof = await DistibutionProgram.addTicket(input, curProof);
            }
            // curProof = await DistibutionProgram.addTicket(input, curProof);
        }
        this.dpProofs[round] = curProof;
        return curProof;
    }
    // Changes value of nullifier!
    async getReward(round, ticket, roundDP = undefined, ticketIndex = 1 // If two or more same tickets presented
    ) {
        const roundWitness = this.ticketMap.getWitness(o1js.Field.from(round));
        const ticketHash = ticket.hash();
        let roundTicketWitness;
        // Find ticket in tree
        let ticketId = 0;
        for (; ticketId < this.lastTicketInRound[round]; ticketId++) {
            if (this.roundTicketMap[round]
                .get(o1js.Field(ticketId))
                .equals(ticketHash)
                .toBoolean()) {
                ticketIndex--;
                if (ticketIndex == 0) {
                    roundTicketWitness = this.roundTicketMap[round].getWitness(o1js.Field.from(ticketId));
                    break;
                }
            }
        }
        if (!roundTicketWitness) {
            throw Error(`No such ticket in round ${round}`);
        }
        const dp = !roundDP
            ? await this.getDP(round)
            : await DistributionProof.fromJSON(roundDP);
        const winningNumbers = this.roundResultMap.get(o1js.Field.from(round));
        if (winningNumbers.equals(o1js.Field(0)).toBoolean()) {
            throw Error('Do not have a result for this round');
        }
        const resultWitness = this.roundResultMap.getWitness(o1js.Field.from(round));
        const bankValue = this.bankMap.get(o1js.Field.from(round));
        const bankWitness = this.bankMap.getWitness(o1js.Field.from(round));
        const nullifierWitness = this.ticketNullifierMap.getWitness(getNullifierId(o1js.Field.from(round), o1js.Field.from(ticketId)));
        if (this.shouldUpdateState) {
            this.ticketNullifierMap.set(getNullifierId(o1js.Field.from(round), o1js.Field.from(ticketId)), o1js.Field(1));
        }
        return {
            roundWitness,
            roundTicketWitness,
            dp,
            winningNumbers,
            resultWitness,
            bankValue,
            bankWitness,
            nullifierWitness,
        };
    }
    async getRefund(round, ticket) {
        const roundWitness = this.ticketMap.getWitness(o1js.Field.from(round));
        const ticketHash = ticket.hash();
        let roundTicketWitness;
        // Find ticket in tree
        let ticketId = 0;
        for (; ticketId < this.lastTicketInRound[round]; ticketId++) {
            if (this.roundTicketMap[round]
                .get(o1js.Field(ticketId))
                .equals(ticketHash)
                .toBoolean()) {
                roundTicketWitness = this.roundTicketMap[round].getWitness(o1js.Field.from(ticketId));
                break;
            }
        }
        if (!roundTicketWitness) {
            throw Error(`No such ticket in round ${round}`);
        }
        const resultWitness = this.roundResultMap.getWitness(o1js.Field.from(round));
        // const bankValue = this.bankMap.get(Field.from(round));
        // const bankWitness = this.bankMap.getWitness(Field.from(round));
        const nullifierWitness = this.ticketNullifierMap.getWitness(getNullifierId(o1js.Field.from(round), o1js.Field.from(ticketId)));
        if (this.shouldUpdateState) {
            this.ticketNullifierMap.set(getNullifierId(o1js.Field.from(round), o1js.Field.from(ticketId)), o1js.Field(1));
            // this.bankMap.set(
            //   Field.from(round),
            //   bankValue.sub(ticket.amount.mul(TICKET_PRICE).value)
            // );
        }
        return {
            roundWitness,
            roundTicketWitness,
            resultWitness,
            // bankValue,
            // bankWitness,
            nullifierWitness,
        };
    }
}

async function mockProof(publicOutput, ProofType, publicInput) {
    // const [, proof] = Pickles.proofOfBase64(await dummyBase64Proof(), 2);
    return new ProofType({
        proof: null,
        maxProofsVerified: 2,
        publicInput,
        publicOutput,
    });
}
class PStateManager extends BaseStateManager {
    constructor(plottery, startBlock, isMock = true, shouldUpadteState = false) {
        super(startBlock, isMock, shouldUpadteState);
        this.contract = plottery;
        this.processedTicketData = {
            ticketId: -1,
            round: 0,
        };
    }
    addTicket(ticket, round, forceUpdate = false) {
        const [roundWitness, ticketRoundWitness] = this.getNextTicketWitenss(round);
        const [bankWitness, bankValue] = this.getBankWitness(round);
        if (this.shouldUpdateState || forceUpdate) {
            this.roundTicketMap[round].set(o1js.Field.from(this.lastTicketInRound[round]), ticket.hash());
            this.ticketMap.set(o1js.Field.from(round), this.roundTicketMap[round].getRoot());
            this.bankMap.set(o1js.Field.from(round), bankValue.add(TICKET_PRICE.mul(ticket.amount).value));
        }
        this.roundTickets[round].push(ticket);
        this.lastTicketInRound[round]++;
        return [roundWitness, ticketRoundWitness, bankWitness, bankValue];
    }
    async removeLastTicket(round) {
        const ticket = this.roundTickets[round].pop();
        this.lastTicketInRound[round]--;
        const bankValue = this.bankMap.get(o1js.Field.from(round));
        this.roundTicketMap[round].set(o1js.Field.from(this.lastTicketInRound[round] - 1), o1js.Field(0));
        this.ticketMap.set(o1js.Field.from(round), this.roundTicketMap[round].getRoot());
        this.bankMap.set(o1js.Field.from(round), bankValue.sub(TICKET_PRICE.mul(ticket.amount).value));
    }
    async reduceTickets() {
        const initialState = this.contract.lastProcessedState.get();
        const actionLists = await this.contract.reducer.fetchActions({
            fromActionState: initialState,
        });
        // All this params can be random for init function, because init do not use them
        let input = new TicketReduceProofPublicInput({
            action: new LotteryAction({
                ticket: Ticket.random(this.contract.address),
                round: o1js.Field(0),
            }),
            roundWitness: this.ticketMap.getWitness(o1js.Field(0)),
            roundTicketWitness: this.roundTicketMap[0].getWitness(o1js.Field(0)),
            bankWitness: this.bankMap.getWitness(o1js.Field(0)),
            bankValue: o1js.Field(0),
        });
        let initialTicketRoot = this.ticketMap.getRoot();
        let initialBankRoot = this.bankMap.getRoot();
        let curProof = this.isMock
            ? await mockProof(await init(input, initialState, initialTicketRoot, initialBankRoot, o1js.Field.from(this.processedTicketData.round), o1js.Field.from(this.processedTicketData.ticketId)), TicketReduceProof, input)
            : await TicketReduceProgram.init(input, initialState, initialTicketRoot, initialBankRoot, o1js.Field.from(this.processedTicketData.round), o1js.Field.from(this.processedTicketData.ticketId));
        for (let actionList of actionLists) {
            for (let action of actionList) {
                if (+action.round != this.processedTicketData.round) {
                    this.processedTicketData.round = +action.round;
                    this.processedTicketData.ticketId = 0;
                }
                else {
                    this.processedTicketData.ticketId++;
                }
                console.log(`Process ticket: <${+action.round}> <${this.processedTicketData.ticketId}>`);
                input = new TicketReduceProofPublicInput({
                    action: action,
                    roundWitness: this.ticketMap.getWitness(action.round),
                    roundTicketWitness: this.roundTicketMap[+action.round].getWitness(o1js.Field(this.processedTicketData.ticketId)),
                    bankWitness: this.bankMap.getWitness(action.round),
                    bankValue: this.bankMap.get(action.round),
                });
                curProof = this.isMock
                    ? await mockProof(await addTicket(input, curProof), TicketReduceProof, input)
                    : await TicketReduceProgram.addTicket(input, curProof);
                this.addTicket(action.ticket, +action.round, true);
            }
            // Again here we do not need specific input, as it is not using here
            curProof = this.isMock
                ? await mockProof(await cutActions(input, curProof), TicketReduceProof, input)
                : await TicketReduceProgram.cutActions(input, curProof);
        }
        return curProof;
    }
}

exports.BLOCK_PER_ROUND = BLOCK_PER_ROUND;
exports.BuyTicketEvent = BuyTicketEvent;
exports.COMMISION = COMMISION;
exports.DistibutionProgram = DistibutionProgram;
exports.DistributionProof = DistributionProof;
exports.DistributionProofPublicInput = DistributionProofPublicInput;
exports.GetRewardEvent = GetRewardEvent;
exports.MerkleMap20 = MerkleMap20;
exports.MerkleMap20Witness = MerkleMap20Witness;
exports.NumberPacked = NumberPacked;
exports.PLottery = PLottery;
exports.PRESICION = PRESICION;
exports.PStateManager = PStateManager;
exports.ProduceResultEvent = ProduceResultEvent;
exports.ReduceEvent = ReduceEvent;
exports.RefundEvent = RefundEvent;
exports.TICKET_PRICE = TICKET_PRICE;
exports.Ticket = Ticket;
exports.TicketReduceProgram = TicketReduceProgram;
exports.comisionTicket = comisionTicket;
exports.getEmpty2dMerkleMap = getEmpty2dMerkleMap;
exports.getNullifierId = getNullifierId;
