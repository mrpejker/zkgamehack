import { Field, InferProvable, UInt32 } from 'o1js';
export declare function PackingPlant<A, T extends InferProvable<A> = InferProvable<A>>(elementType: A, l: number, bitSize: bigint): (abstract new (packed: Field) => {
    /**
     * @returns array of single Field element which constitute the packed object
     */
    toFields(): Array<Field>;
    assertEquals(other: any): void;
    packed: import("o1js/dist/node/lib/provable/field").Field;
}) & {
    type: import("o1js/dist/node/bindings/lib/generic").GenericProvableExtendedPure<{
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }, {
        packed: bigint;
    }, {
        packed: string;
    }, import("o1js/dist/node/lib/provable/field").Field>;
    l: number;
    bitSize: bigint;
    extractField(input: T): Field;
    sizeInBits(): bigint;
    unpack(f: Field): Array<T>;
    /**
     *
     * @param unpacked Array of the implemented packed type
     * @throws if the length of the array is longer than the length of the implementing factory config
     */
    checkPack(unpacked: Array<T>): void;
    /**
     *
     * @param unpacked Array of the implemented packed type, must be shorter than the max allowed, which varies by type, will throw if the input is too long
     * @returns Field, packed with the information from the unpacked input
     */
    pack(unpacked: Array<T>): Field;
    /**
     *
     * @param f Field, packed with the information, as returned by #pack
     * @returns Array of bigints, which can be decoded by the implementing class into the final type
     */
    unpackToBigints(f: Field): Array<bigint>;
    _isStruct: true;
    toFields: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => import("o1js/dist/node/lib/provable/field").Field[];
    toAuxiliary: (value?: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    } | undefined) => any[];
    sizeInFields: () => number;
    check: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => void;
    toValue: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: bigint;
    };
    fromValue: ((x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    } | {
        packed: bigint;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) & ((value: {
        packed: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    });
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: string;
    };
    fromJSON: (x: {
        packed: string;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
};
export declare function MultiPackingPlant<A, T extends InferProvable<A> = InferProvable<A>>(elementType: A, l: number, bitSize: bigint): (abstract new (packed: Array<Field>) => {
    /**
     * @returns array of Field elements which constitute the multi-packed object
     */
    toFields(): Array<Field>;
    assertEquals(other: any): void;
    packed: import("o1js/dist/node/lib/provable/field").Field[];
}) & {
    type: import("o1js/dist/node/bindings/lib/generic").GenericProvableExtendedPure<{
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }, {
        packed: bigint[];
    }, {
        packed: string[];
    }, import("o1js/dist/node/lib/provable/field").Field>;
    l: number;
    n: number;
    bitSize: bigint;
    extractField(input: T | undefined): Field;
    sizeInBits(): bigint;
    elementsPerField(): number;
    unpack(fields: Array<Field>): Array<T>;
    /**
     *
     * @param unpacked Array of the implemented packed type
     * @throws if the length of the array is longer than the length of the implementing factory config
     */
    checkPack(unpacked: Array<T>): void;
    /**
     *
     * @param unpacked Array of the implemented packed type, must be shorter than the max allowed, which varies by type, will throw if the input is too long
     * @returns Array of Fields, packed such that each Field has as much information as possible
     *
     * e.g. 15 Characters pack into 1 Field.  15 or fewer Characters will return an array of 1 Field
     *      30 of fewer Characters will return an aray of 2 Fields
     */
    pack(unpacked: Array<T>): Array<Field>;
    /**
     *
     * @param fields Array of Fields, packed such that each Field has as much information as possible, as returned in #pack
     * @returns Array of bigints, which can be decoded by the implementing class into the final type
     */
    unpackToBigints(fields: Array<Field>): Array<bigint>;
    _isStruct: true;
    toFields: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) => import("o1js/dist/node/lib/provable/field").Field[];
    toAuxiliary: (value?: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    } | undefined) => any[];
    sizeInFields: () => number;
    check: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) => void;
    toValue: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) => {
        packed: bigint[];
    };
    fromValue: ((x: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    } | {
        packed: bigint[];
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) & ((value: {
        packed: import("o1js/dist/node/lib/provable/field").Field[] | bigint[];
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    });
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    };
    toInput: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    }) => {
        packed: string[];
    };
    fromJSON: (x: {
        packed: string[];
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    };
    empty: () => {
        packed: import("o1js/dist/node/lib/provable/field").Field[];
    };
};
export declare function PackedUInt32Factory(l?: number): {
    new (packed: import("o1js/dist/node/lib/provable/field").Field): {
        toBigInts(): Array<bigint>;
        /**
         * @returns array of single Field element which constitute the packed object
         */
        toFields(): import("o1js/dist/node/lib/provable/field").Field[];
        assertEquals(other: {
            /**
             * @returns array of single Field element which constitute the packed object
             */
            toFields(): import("o1js/dist/node/lib/provable/field").Field[];
            assertEquals(other: any): void;
            packed: import("o1js/dist/node/lib/provable/field").Field;
        }): void;
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    extractField(input: UInt32): Field;
    sizeInBits(): bigint;
    /**
     *
     * @param f Field, packed with the information, as returned by #pack
     * @returns Array of UInt32
     */
    unpack(f: Field): UInt32[];
    /**
     *
     * @param uint32s Array of UInt32s to be packed
     * @returns Instance of the implementing class
     */
    fromUInt32s(uint32s: Array<UInt32>): {
        toBigInts(): Array<bigint>;
        /**
         * @returns array of single Field element which constitute the packed object
         */
        toFields(): import("o1js/dist/node/lib/provable/field").Field[];
        assertEquals(other: {
            /**
             * @returns array of single Field element which constitute the packed object
             */
            toFields(): import("o1js/dist/node/lib/provable/field").Field[];
            assertEquals(other: any): void;
            packed: import("o1js/dist/node/lib/provable/field").Field;
        }): void;
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    /**
     *
     * @param bigints Array of bigints to be packed
     * @returns Instance of the implementing class
     */
    fromBigInts(bigints: Array<bigint>): {
        toBigInts(): Array<bigint>;
        /**
         * @returns array of single Field element which constitute the packed object
         */
        toFields(): import("o1js/dist/node/lib/provable/field").Field[];
        assertEquals(other: {
            /**
             * @returns array of single Field element which constitute the packed object
             */
            toFields(): import("o1js/dist/node/lib/provable/field").Field[];
            assertEquals(other: any): void;
            packed: import("o1js/dist/node/lib/provable/field").Field;
        }): void;
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    type: import("o1js/dist/node/bindings/lib/generic").GenericProvableExtendedPure<{
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }, {
        packed: bigint;
    }, {
        packed: string;
    }, import("o1js/dist/node/lib/provable/field").Field>;
    l: number;
    bitSize: bigint;
    /**
     *
     * @param unpacked Array of the implemented packed type
     * @throws if the length of the array is longer than the length of the implementing factory config
     */
    checkPack(unpacked: UInt32[]): void;
    /**
     *
     * @param unpacked Array of the implemented packed type, must be shorter than the max allowed, which varies by type, will throw if the input is too long
     * @returns Field, packed with the information from the unpacked input
     */
    pack(unpacked: UInt32[]): import("o1js/dist/node/lib/provable/field").Field;
    /**
     *
     * @param f Field, packed with the information, as returned by #pack
     * @returns Array of bigints, which can be decoded by the implementing class into the final type
     */
    unpackToBigints(f: import("o1js/dist/node/lib/provable/field").Field): bigint[];
    _isStruct: true;
    toFields: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => import("o1js/dist/node/lib/provable/field").Field[];
    toAuxiliary: (value?: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    } | undefined) => any[];
    sizeInFields: () => number;
    check: (value: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => void;
    toValue: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: bigint;
    };
    fromValue: ((x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    } | {
        packed: bigint;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) & ((value: {
        packed: string | number | bigint | import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    });
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    toInput: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    }) => {
        packed: string;
    };
    fromJSON: (x: {
        packed: string;
    }) => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
    empty: () => {
        packed: import("o1js/dist/node/lib/provable/field").Field;
    };
};
