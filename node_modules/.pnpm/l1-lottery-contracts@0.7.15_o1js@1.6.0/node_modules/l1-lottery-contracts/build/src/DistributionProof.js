import { Field, Struct, ZkProgram, SelfProof, } from 'o1js';
import { Ticket } from './Ticket.js';
import { UInt64 } from 'o1js';
import { NumberPacked } from './util.js';
import { MerkleMap20, MerkleMap20Witness } from './CustomMerkleMap.js';
export class DistributionProofPublicInput extends Struct({
    winningCombination: Field,
    ticket: Ticket,
    valueWitness: MerkleMap20Witness,
}) {
}
export class DistributionProofPublicOutput extends Struct({
    root: Field,
    total: UInt64,
}) {
}
const emptyMap = new MerkleMap20();
const emptyMapRoot = emptyMap.getRoot();
export const init = async (input) => {
    return new DistributionProofPublicOutput({
        root: emptyMapRoot,
        total: UInt64.from(0),
    });
};
export const addTicket = async (input, prevProof) => {
    prevProof.verify();
    const [initialRoot, key] = input.valueWitness.computeRootAndKey(Field(0));
    // key.assertEquals(input.ticket.hash(), 'Wrong key for that ticket');
    initialRoot.assertEquals(prevProof.publicOutput.root);
    const newValue = input.ticket.hash();
    const [newRoot] = input.valueWitness.computeRootAndKey(newValue);
    const ticketScore = input.ticket.getScore(NumberPacked.unpack(input.winningCombination));
    return new DistributionProofPublicOutput({
        root: newRoot,
        total: prevProof.publicOutput.total.add(ticketScore),
    });
};
export const DistibutionProgram = ZkProgram({
    name: 'distribution-program',
    publicInput: DistributionProofPublicInput,
    publicOutput: DistributionProofPublicOutput,
    methods: {
        init: {
            privateInputs: [],
            async method(input) {
                return init(input);
            },
        },
        addTicket: {
            privateInputs: [SelfProof],
            async method(input, prevProof) {
                return addTicket(input, prevProof);
            },
        },
    },
});
export class DistributionProof extends ZkProgram.Proof(DistibutionProgram) {
}
//# sourceMappingURL=DistributionProof.js.map