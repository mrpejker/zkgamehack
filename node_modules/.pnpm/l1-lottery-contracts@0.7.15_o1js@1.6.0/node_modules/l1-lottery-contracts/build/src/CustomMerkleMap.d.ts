import { Field, MerkleTree } from 'o1js';
declare const MerkleMap20Witness_base: (new (value: {
    isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
    siblings: import("o1js/dist/node/lib/provable/field").Field[];
}) => {
    isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
    siblings: import("o1js/dist/node/lib/provable/field").Field[];
}) & {
    _isStruct: true;
} & Omit<import("o1js/dist/node/lib/provable/types/provable-intf").Provable<{
    isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
    siblings: import("o1js/dist/node/lib/provable/field").Field[];
}, {
    isLefts: boolean[];
    siblings: bigint[];
}>, "fromFields"> & {
    fromFields: (fields: import("o1js/dist/node/lib/provable/field").Field[]) => {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    };
} & {
    fromValue: (value: {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[] | boolean[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[] | bigint[];
    }) => {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    };
    toInput: (x: {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    }) => {
        fields?: import("o1js/dist/node/lib/provable/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/provable/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    }) => {
        isLefts: boolean[];
        siblings: string[];
    };
    fromJSON: (x: {
        isLefts: boolean[];
        siblings: string[];
    }) => {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    };
    empty: () => {
        isLefts: import("o1js/dist/node/lib/provable/bool").Bool[];
        siblings: import("o1js/dist/node/lib/provable/field").Field[];
    };
};
export declare class MerkleMap20Witness extends MerkleMap20Witness_base {
    /**
     * computes the merkle tree root for a given value and the key for this witness
     * @param value The value to compute the root for.
     * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.
     */
    computeRootAndKey(value: Field): import("o1js/dist/node/lib/provable/field").Field[];
}
export declare class MerkleMap20 {
    tree: MerkleTree;
    /**
     * Creates a new, empty Merkle Map.
     * @returns A new MerkleMap
     */
    constructor();
    _keyToIndex(key: Field): bigint;
    /**
     * Sets a key of the merkle map to a given value.
     * @param key The key to set in the map.
     * @param value The value to set.
     */
    set(key: Field, value: Field): void;
    /**
     * Returns a value given a key. Values are by default Field(0).
     * @param key The key to get the value from.
     * @returns The value stored at the key.
     */
    get(key: Field): import("o1js/dist/node/lib/provable/field").Field;
    /**
     * Returns the root of the Merkle Map.
     * @returns The root of the Merkle Map.
     */
    getRoot(): import("o1js/dist/node/lib/provable/field").Field;
    /**
     * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.
     * @param key The key to make a witness for.
     * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.
     */
    getWitness(key: Field): MerkleMap20Witness;
}
export {};
